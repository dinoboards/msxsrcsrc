; SERIAL.MAC
;
; MSX-SERIAL second generation (multi channel), (as used in the Sony HBI-232 serial interface)
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders
;


        .Z80
        ASEG

        org	04000H

RDSLT	equ	000CH
WRSLT	equ	0014H
CALSLT	equ	001CH
ENASLT	equ	0024H
CHSNS	equ	009CH
CHGET	equ	009FH
CHPUT	equ	00A2H
LPTOUT	equ	00A5H
BREAKX	equ	00B7H

FNDLIN  EQU     4295H                   ; search linenumber from start of program
CHRGTR  EQU     4666H                   ; get next BASIC character
LINGET  EQU     4769H                   ; collect linenumber
FRMEVL	equ	4C64H
FRMQNT	equ	542FH
GETBYT	equ	521CH
FRESTR	equ	67D0H
PTRGET	equ	5EA4H
DOCNVF  EQU     517AH
SNERR   EQU     4055H                   ; syntax error
FCERR   EQU     475AH                   ; illegal function call error
USERR   EQU     481CH                   ; undefined line number error
TMERR   EQU     406DH                   ; type mismatch error
DIOERR  EQU     73B2H                   ; device I/O error
TRPENA  EQU     631BH                   ; enable trap
TRPDIS  EQU     632BH                   ; disable trap
TRPSTP  EQU     6331H                   ; stop trap
DERFAO  EQU     6E6EH                   ; file already open error
DERFNO  EQU     6E77H                   ; file not open error
DERIER  EQU     6E80H                   ; internal error
DERSOO  EQU     6E86H                   ; sequential I/O only error
DERBFN  EQU     6E6BH                   ; bad filename error

; RS232 RAM base

Y6000	equ	06000H		        ; rs232 receive buffers, 4 buffers
YA000	equ	Y6000+04000H
Y6400	equ	06400H		        ; rs232 flags
YA400	equ	Y6400+04000H
                                        ; +0
                                        ; +1 backup byte
                                        ; +2 backup byte error status
                                        ; +3
                                        ; +4 timeout
                                        ; +5 bytes in receiverbuffer
                                        ; +6 get offset
                                        ; +7 put offset
                                        ; +8 receive status
                                        ; +9 flags
                                        ; +10 mode flags
                                        ; +11 bitmask
                                        ; +12 command byte
                                        ; +13 mode byte


Y6600	equ	06600H		        ; MSX serial version 2.0 table, 15 entries
                                        ; +0 slotid
                                        ; +1 # of channels
Y661E	equ	0661EH		        ; channel slotmask table (entries are 3 bytes), 15 entries
                                        ; +0 primairy slot OR mask
                                        ; +1 secundairy slot OR mask
                                        ; +2 channel offset
Y664B	equ	0664BH		        ; channel mode table, 15 entries
Y665A	equ	0665AH		        ; channel file control block pointer table, 15 entries
Y6676	equ	06676H		        ; version 1.0 interface between version 2.0 interface flag
Y6678	equ	06678H		        ; temporary save (stackpointer)
Y667A	equ	0667AH		        ; temporary save (HL)
Y667C	equ	0667CH		        ; temporary save
Y667E	equ	0667EH		        ; temporary save (return address)
Y6680	equ	06680H		        ; end of channel slotmask table
Y6682	equ	06682H		        ; STATEMENT/DEVICE handler enabled
Y6683	equ	06683H		        ; slotid of this interface
Y6684	equ	06684H		        ; saved last i8251 command byte
Y6685	equ	06685H		        ; saved BASIC pointer
Y6687	equ	06687H		        ; current selected channel
Y6688	equ	06688H		        ; current selected channel of interface
Y6689	equ	06689H		        ; pointer to current channel flags
Y668B	equ	0668BH		        ; memorymapped address of current channel
Y668D	equ	0668DH		        ; receivebuffer current selected channel
Y668F	equ	0668FH		        ; number of channels in this interface
Y6690	equ	06690H		        ; total number of channels
Y6691	equ	06691H		        ; channel number first version 2.0 rs232
Y6692	equ	06692H		        ; first trap number version 2.0 rs232
Y6693	equ	06693H		        ; current channel enable Rx interrupt mask
Y6694	equ	06694H		        ; current channel disable Rx interrupt mask
Y6695	equ	06695H		        ; first channel interrupt masks
Y6697	equ	06697H		        ; next channel interrupt masks
Y6699	equ	06699H		        ; saved EXTBIO
Y669E	equ	0669EH		        ; saved H.NEWS
Y66A3	equ	066A3H		        ; saved H.KEYI
Y66A8	equ	066A8H		        ; COMTERM, received ESC byte
Y66A9	equ	066A9H		        ; COMTERM, show progress char
Y66AA	equ	066AAH		        ; COMTERM, literal mode
Y66AB	equ	066ABH		        ; COMTERM, duplex mode
Y66AC	equ	066ACH		        ; COMTERM, printer echo
Y66AD	equ	066ADH		        ; COMTERM, cursor display status
Y66AE	equ	066AEH		        ; COMINI, specified settings
Y66BB	equ	066BBH		        ; COMTERM, saved F5,F6 and F7
Y66EB	equ	066EBH		        ; version 1.0 interface channel between version 2.0 interfaces channels
Y6700	equ	06700H		        ; build table all interfaces before this interface

Y67FC	equ	Y6700+15*4+192          ; temporary stack

YBFF8	equ	0BFF8H		        ; rs232 hardware (memory mapped)

VALTYP	equ	0F663H
DAC	equ	0F7F6H
PTRFIL	equ	0F864H
FNKSTR  EQU     0F87FH

OLDINT	equ	0FB11H                  ; Save for H.KEYI (MSX-serial v1.0)

HOKVLD	equ	0FB20H
ONGSBF	equ	0FBD8H
TRPTBL	equ	0FC4CH
INTFLG	equ	0FC9BH
CSRSR	equ	0FCA9H
EXPTBL	equ	0FCC1H
SLTTBL	equ	0FCC5H
PROCNM	equ	0FD89H
H.KEYI	equ	0FD9AH
H.NEWS	equ	0FF3EH
EXTBIO	equ	0FFCAH
DISINT	equ	0FFCFH
ENAINT	equ	0FFD4H

YFFFF	equ	0FFFFH

        db	"A","B"
        dw	A40B2		; INIT
        dw	A435A		; STATEMENT
        dw	A440C		; DEVICE
        dw	0
        ds	6

;     Device information byte indicates following options are installed or not:
;	bits #  76543210
;		||||||||
;		|||||||+----- reserved
;		|||||||
;		||||||+------ TXREADY interrupt
;		||||||
;		|||||+------- sync/break character detected
;		|||||
;		||||+-------- timer interrupt
;		||||
;		|||+--------- carrier detect
;		|||
;		||+---------- ring indicator
;		||
;		|+----------- reserved
;		|
;		+------------ reserved

A4010:	db	0		        ; +00 MSX serial features (no TxReady INT, No Sync detect, No Timer INT, No CD, No RI)
        db	1		        ; +01 MSX serial version (version 2.0)
        db	0		        ; +02 reserved
        jp	A4040		        ; +03 RS232.INIT
        jp	A44B9		        ; +06 RS232.OPEN
        jp	A59CA		        ; +09 RS232.STAT
        jp	A4585		        ; +0C RS232.GETCHR
        jp	A56E5		        ; +0F RS232.SNDCHR
        jp	A4525		        ; +12 RS232.CLOSE
        jp	A408B		        ; +15 RS232.EOF
        jp	A4622		        ; +18 RS232.LOC
        jp	A4675		        ; +1B RS232.LOF
        jp	A46B7		        ; +1E RS232.BACKUP
        jp	A590C		        ; +21 RS232.SNDBRK
        jp	A5986		        ; +24 RS232.DTR
        jp	A51C7		        ; +27 RS232.SETCHN
        ret			        ; +2A future
        ret
        ret
        ret			        ; +2D future
        ret
        ret

;         Subroutine RS232.INIT
;            Inputs  ________________________
;            Outputs ________________________

A4040:	ei
        push	bc
        push	de
        push	hl
        push	bc
        call	A53C7		        ; buid slotinfo per channel table
        pop	bc
        ld	iy,-13
        add	iy,sp
        ld	sp,iy
        push	iy
        pop	de
        ld	c,13
A4056:	call	A488E		        ; read byte from slot
        ld	(de),a
        inc	de
        dec	c
        jr	nz,A4056	        ; the complete parameterblock
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A5232		        ; initialize rs232 channel
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ex	af,af'
        ld	iy,13
        add	iy,sp
        ld	sp,iy		        ; dispose parameterblock on stack
        ex	af,af'
        pop	hl
        pop	de
        pop	bc
        ret

;         Subroutine RS232.EOF
;            Inputs  ________________________
;            Outputs ________________________

A408B:	ld	hl,0
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A5518		        ; get number of bytes in receive buffer (include backup byte)
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ret	z		        ; no bytes, quit
        call	A4694
        ret

;         Subroutine extension init
;            Inputs  ________________________
;            Outputs ________________________

A40B2:	xor	a
        ld	(Y6676),a	        ; no version 1.0 interface between version 2.0 interface
        dec	a
        ld	(Y66EB),a	        ; no version 1.0 interface channel between version 2.0 interfaces channels
        di
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5389		        ; get slotid on page 1
        ld	(Y6683),a               ; store slotid
        ld	h,HIGH 8000H
        call	ENASLT		        ; put in also in page 2
        xor	a
        ld	b,a		        ; channel 0
        ld	iy,T431B	        ; default settings for rs232
A40D0:	push	bc
        call	A42BF		        ; set channelinfo
        pop	bc
        call	A4342		        ; test if i8251 on memory mapped address
        jr	nz,A40E8	        ; nope, quit
        push	bc
        call	A5232		        ; initialize rs232 channel
        call	A42F6		        ; clear flags and receive buffer
        pop	bc
        inc	b
        ld	a,b
        cp	4		        ; 4 channels is max.
        jr	nz,A40D0	        ; not yet, try next channel
A40E8:	ld	a,b
        ld	(Y668F),a	        ; # of channels my rs232
        pop	af                      ; restore slotid
        ld	h,HIGH 8000H
        call	ENASLT		        ; restore orginal slot in page 2
        ld	hl,HOKVLD
        bit	0,(hl)		        ; EXTBIO initialized ?
        jr	nz,A4105	        ; yes, skip init
        set	0,(hl)
        ld	hl,EXTBIO
        ld	b,5
A4100:	ld	(hl),0C9H
        inc	hl
        djnz	A4100		        ; initialize EXTBIO hook
A4105:	xor	a
        ld	de,0*256+1              ; broadcast: get number of trap entries
        call	EXTBIO
        ld	(Y6692),a		; store my trap entry
        xor	a
        ld	de,8*256+1              ; MSX-serial: get number of channels
        call	EXTBIO
        ld	(Y6691),a		; store rs232 channelnumber for my first channel
        or	a		        ; any other rs232 ?
        jp	z,A41C1		        ; no, take control (with I/O address enable)
        ld	hl,Y6700
        ld	a,(Y6683)
        ld	b,a		        ; my slotid
        ld	de,8*256+0              ; MSX-serial: build table
        call	EXTBIO
        ld	de,Y6700
        or	a
        sbc	hl,de		        ; table filled ?
        jp	z,A41C1		        ; no, take control (with I/O address enable)
        ld	a,l
        rrca
        rrca
        and	03FH			; entries are 4 bytes, number of entries
        ld	b,a		        ; number of rs232 interfaces before my
        ld	h,d
        ld	l,e		        ; table of rs232 interfaces
A413B:	ld	a,(hl)		        ; slotid of interface
        inc	hl
        ld	e,(hl)
        inc	hl
        ld	d,(hl)		        ; jumptable of rs232 interface
        inc	de
        ex	de,hl
        push	bc
        push	de
        call	RDSLT		        ; read rs232 version
        pop	de
        pop	bc
        ex	de,hl
        or	a		        ; version 2.0 or above ?
        jr	nz,A4154	        ; yes, leave control of rs232 where it is (version 2.0 ROM handles all version 2.0 interfaces)
        inc	hl
        inc	hl
        djnz	A413B		        ; next interface
        jp	A41E3		        ; all interfaces before are version 1.0, take control

; other version 2.0 ROM has control

A4154:	ld	a,0FFH
        ld	(Y6682),a	        ; disable my STATEMENT/DEVICE handler
        dec	hl
        dec	hl
        ld	a,(OLDINT+0)
        or	a		        ; has a version 1.0 ROM hooked H.KEYI ?
        jr	z,A4187		        ; nope, update MSX serial version 2.0 table of master ROM and quit
        ld	a,(hl)		        ; slotid of last version 2.0 rs232 interface before me
        push	hl
        ld	hl,Y6676
        call	RDSLT
        pop	hl
        or	a		        ; interface version 1.0 between interface version 2.0 ?
        jr	nz,A4187	        ; yes, update MSX serial version 2.0 table of master ROM and quit
        ld	a,(hl)		        ; slotid of last version 2.0 rs232 interface before me
        push	hl
        ld	hl,Y6691
        call	RDSLT		        ; read first channelnumber of interface
        pop	hl
        or	a		        ; has this interface channel 0 (first rs232) ?
        jr	nz,A4187	        ; no, update MSX serial version 2.0 table of master ROM and quit
        ld	a,(Y6683)
        ld	e,a		        ; my slotid
        ld	a,(hl)
        push	hl
        ld	hl,Y6676
        ld	(hl),e		        ; slotid interface version 2.0 interface after version 1.0 interface
        call	WRSLT
        pop	hl

; update MSX serial version 2.0 table of master ROM and quit

A4187:	ld	b,(hl)		        ; slotid of interface
        ld	hl,Y6600-2	        ; MSX serial version 2.0 table
A418B:	inc	hl
        inc	hl
        push	bc
        ld	a,b
        call	RDSLT
        pop	bc
        or	a		        ; free entry ?
        jr	nz,A418B	        ; nop, next
        ld	a,(Y6676)
        or	a		        ; version 1.0 interface between version 2.0 interfaces ?
        jr	z,A41AE		        ; nope,

        push	bc
        ld	a,b
        ld	e,0FFH                  ; slotid = special marker
        call	WRSLT
        pop	bc
        inc	hl
        push	bc
        ld	a,b
        ld	e,0FFH                  ; # number of channels
        call	WRSLT
        pop	bc
        inc	hl

A41AE:	ld	a,(Y6683)
        ld	e,a		        ; my slotid
        push	bc
        ld	a,b
        call	WRSLT
        pop	bc
        inc	hl
        ld	a,(Y668F)	        ; # of channels of my rs232
        ld	e,a
        ld	a,b
        jp	WRSLT		        ; and quit

; take control (with I/O address enable)

A41C1:	call	A4328		        ; test if i8251 on I/O address
        jr	z,A41E3		        ; yep, take control
        di
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        ld	a,(Y6683)
        ld	h,HIGH 8000H
        call	ENASLT		        ; my slotid on page 2
        ld	a,0FFH
        ld	(YBFF8+2),a	        ; enable serial on I/O space
        pop	af                      ; restore slotid
        ld	h,HIGH 8000H
        call	ENASLT		        ; restore page 2
        ld	hl,0FFFEH	        ; enable i/o space with enable/disable Rx interrupt
        jr	A41E6

A41E3:	ld	hl,0EFEEH	        ; disable i/o space with enable/disable Rx interrupt
A41E6:	ld	(Y6695),hl              ; set first channel interrupt masks
        ld	hl,0EFEEH	        ; enable/disable Rx interrupt
        ld	(Y6697),hl              ; set next channel interrupt masks
        xor	a
        ld	(Y6682),a	        ; enable my STATEMENT/DEVICE handler
        ld	(Y6687),a	        ; current selected channel = 0
        ld	(Y66A3),a	        ; H.KEYI not saved by this interface
        ld	(Y669E),a	        ; H.NEWS not saved by this interface
        ld	hl,Y6600
        ld	b,15*2		        ; max. 15 slots, 2 bytes per slot
A4201:	ld	(hl),a
        inc	hl
        djnz	A4201		        ; clear MSX serial version 2.0 table
        ld	hl,Y664B
        ld	b,15*1+15*2	        ; max. 15 slots, 1 byte for mode, 2 bytes for control block pointer
A420A:	ld	(hl),a
        inc	hl
        djnz	A420A		        ; clear mode and file control block pointer table
        dec	a
        ld	hl,Y661E
        ld	b,15*3		        ; max. 15 slots, 3 bytes for slotmasks
A4214:	ld	(hl),a
        inc	hl
        djnz	A4214		        ; clear channel slotmask table
        ld	a,(Y6683)	        ; my slotid
        ld	(Y6600+0),a             ; first entry MSX serial version 2.0 table, slotid
        ld	a,(Y668F)	        ; number of channels my rs232
        ld	(Y6600+1),a             ; first entry MSX serial version 2.0 table, # of channels
        ld	de,Y6699
        di
        ld	hl,EXTBIO
        ld	bc,5
        ldir			        ; save EXTBIO for cascading
        ld	a,(Y6683)
        ld	(EXTBIO+1),a
        ld	a,0F7H
        ld	(EXTBIO+0),a
        ld	hl,T4727
        ld	(EXTBIO+2),hl
        ld	a,0C9H
        ld	(EXTBIO+4),a	        ; setup EXTBIO
        ld	bc,S4257
        ld	hl,T4257
        ld	de,DISINT
        ldir			        ; setup DISINT and ENAINT
        xor	a		        ; channel 0
        call	A42BF		        ; set channelinfo
        ei
        ret

;         Subroutine DISINT
;            Inputs  ________________________
;            Outputs ________________________

T4257:	push	de
        ld	e,2                     ; function = disable interrupts
        jr	A425F

;         Subroutine ENAINT
;            Inputs  ________________________
;            Outputs ________________________

        push	de
        ld	e,3                     ; function = enable interrupts
A425F:	ld	d,0                     ; devices = broadcast
        push	ix
        push	iy
        call	EXTBIO
        ei
        pop	iy
        pop	ix
        pop	de
        ret

S4257   equ     $-T4257

;         Subroutine install interrupt handler
;            Inputs  ________________________
;            Outputs ________________________

A426F:	di
        ld	a,(Y66A3)
        or	a		        ; H.KEYI already hooked by this interface ?
        ret	nz		        ; yes, quit
        ld	de,Y66A3
        ld	hl,H.KEYI
        ld	bc,5
        ldir
        ld	a,0F7H
        ld	(H.KEYI+0),a
        ld	a,(Y6683)	        ; my slotid
        ld	(H.KEYI+1),a
        ld	hl,T5512
        ld	(H.KEYI+2),hl
        ld	a,0C9H
        ld	(H.KEYI+4),a
        ret

;         Subroutine install new statement handler
;            Inputs  ________________________
;            Outputs ________________________

A4297:	di
        ld	a,(Y669E)
        or	a		        ; H.NEWS already hooked ?
        ret	nz		        ; yes, quit
        ld	de,Y669E
        ld	hl,H.NEWS
        ld	bc,5
        ldir
        ld	a,0F7H
        ld	(H.NEWS+0),a
        ld	a,(Y6683)	        ; my slotid
        ld	(H.NEWS+1),a
        ld	hl,T50E4
        ld	(H.NEWS+2),hl
        ld	a,0C9H
        ld	(H.NEWS+4),a
        ret

;         Subroutine set channelinfo
;            Inputs  ________________________
;            Outputs ________________________

A42BF:	ld	(Y6688),a	        ; store current channel
        ld	b,a                     ; store current channel
        ld	hl,YA000
        add	a,h
        ld	h,a
        ld	(Y668D),hl	        ; receiver buffer of channel
        ld	a,b                     ; current channel
        ld	ix,YA400
        ld	bc,128
        ld	hl,YBFF8+1	        ; memory mapped address channel
        ld	de,-8
        or	a                       ; channel 0 ?
        jp	z,A42EE                 ; yep,
        add	ix,bc
        add	hl,de                   ; adjust for channel 1
        dec	a                       ; channel 1 ?
        jp	z,A42EE                 ; yep,
        add	ix,bc
        add	hl,de                   ; adjust for channel 2
        dec	a                       ; channel 2 ?
        jp	z,A42EE                 ; yep,
        add	ix,bc
        add	hl,de                   ; adjust for channel 3
A42EE:	ld	(Y6689),ix              ; store pointer to current channel flags
        ld	(Y668B),hl	        ; store memorymapped address of current channel
        ret

;         Subroutine clear flags and receive buffer
;            Inputs  IX = pointer to channel
;            Outputs ________________________

A42F6:	ld	(ix+9),0                ; clear flags

;         Subroutine clear receive buffer
;            Inputs  IX = pointer to channel
;            Outputs ________________________

A42FA:	ld	(ix+1),0                ; clear backup byte
        ld	(ix+2),0                ; clear backup byte receive status
        push	bc
        ld	b,4                     ; number of bytes = 4
        ld	a,5                     ; offset = 5
        call	A430C                   ; clear bytes
        pop	bc
        ret

;         Subroutine clear bytes
;            Inputs  IX = pointer to channel, A = offset, B = number of bytes
;            Outputs ________________________

A430C:	push	ix
        ex	(sp),hl
        add	a,l
        ld	l,a
        jr	nc,A4314
        inc	hl
A4314:	ld	(hl),0
        inc	hl
        djnz	A4314
        pop	hl
        ret

; RS232 default settings

T431B:	db	"8N1XHNNN"
        dw	1200
        dw	1200
        db	0

;         Subroutine test if i8251 on I/O address
;            Inputs  ________________________
;            Outputs ________________________

A4328:	xor	a
        out	(081H),a
        push	af
        pop	af
        out	(081H),a
        push	af
        pop	af
        out	(081H),a
        push	af
        pop	af
        ld	a,040H
        out	(081H),a
        ex	(sp),hl
        ex	(sp),hl
        in	a,(081H)
        and	03FH
        cp	005H
        ret

;         Subroutine test if i8251 on memory mapped address
;            Inputs  ________________________
;            Outputs ________________________

A4342:	ld	hl,(Y668B)	        ; memorymapped address of current channel
        xor	a
        ld	(hl),a
        push	af
        pop	af
        ld	(hl),a
A434A:	push	af
        pop	af
        ld	(hl),a
        push	af
        pop	af
        ld	a,040H
        ld	(hl),a
        ex	(sp),hl
        ex	(sp),hl
        ld	a,(hl)
        and	03FH
        cp	005H
        ret

;         Subroutine CALL statement handler
;            Inputs  ________________________
;            Outputs ________________________

A435A:	ei
        ld	a,(Y6682)	        ; my handler enabled ?
        or	a
        scf
        ret	nz		        ; nope, quit
        ld	(Y6685),hl	        ; store BASIC pointer
        ld	de,T43AF
        call	A436D		        ; known statement ?
        ret	c		        ; nope, quit
A436B:	push	de
        ret			        ; yep, handle

A436D:	push	bc
        push	hl
A436F:	ld	hl,PROCNM
        ld	a,(de)
        inc	a
        jr	z,A4388
        call	A438C
        jr	z,A4380
        inc	de
        inc	de
        inc	de
        jr	A436F
;
A4380:	ex	de,hl
        inc	hl
        ld	e,(hl)
        inc	hl
        ld	d,(hl)
        or	a                       ; statement handled
        jr	A4389

A4388:	scf                             ; statement not handled
A4389:	pop	hl
        pop	bc
        ret

A438C:	ld	a,(de)
        call	A5229                   ; to upper
        ld	c,a
        ld	a,(hl)
        call	A5229                   ; to upper
        cp	c
        jr	nz,A439E
        or	a
        ret	z
        inc	de
        inc	hl
        jr	A438C
;
A439E:	ld	a,(de)
        or	a
        jr	z,A43A5
        inc	de
        jr	A439E
;
A43A5:	ld	a,(hl)
        or	a
        jr	z,A43AC
        inc	hl
        jr	A43A5
;
A43AC:	ld	a,l
        or	h
        ret

; table with CALL statements

T43AF:	db	"COMINI",0
        dw	A495B
        db	"COMDTR",0
        dw	A4AF4
        db	"COMSTAT",0
        dw	A4B1F
        db	"COMBREAK",0
        dw	A4B43
        db	"COMTERM",0
        dw	A4BA3
        db	"COM",0
        dw	A5001
        db	"COMON",0
        dw	A5068
        db	"COMOFF",0
        dw	A504E
        db	"COMSTOP",0
        dw	A5082
        db	"COMHELP",0
        dw	A4E08
        db	0FFH

;         Subroutine device handler
;            Inputs  ________________________
;            Outputs ________________________

A440C:	ei
        push	af
        ld	a,(Y6682)		; my handler enabled ?
        or	a
        jr	z,A4417			; yes, handle
        pop	af
        scf                             ; device not handled
        ret

A4417:	pop	af
        cp	0FFH			; device inquiry ?
        jp	nz,A4459		; nope,
        ld	hl,PROCNM
        ld	a,(hl)
        cp	"C"
        scf
        ret	nz			; quit with device not recognized
        inc	hl
        ld	a,(hl)
        cp	"O"
        scf
        ret	nz			; quit with device not recognized
        inc	hl
        ld	a,(hl)
        cp	"M"
        scf
        ret	nz			; quit with device not recognized
        inc	hl
        ld	a,(hl)
        or	a			; is it "COM" ?
        jr	nz,A4439
        dec	hl
        ld	a,"0"			; yep, "COM" equals "COM0"
A4439:	sub	"0"
        ret	c			; quit with device not recognized
        cp	9+1
        ccf
        ret	c			; quit with device not recognized
        ld	e,a                     ; RS232 channel number
        call	A51C7			; RS232.SETCHN
        ret	c			; not a version 2.0 channel, device not recognized
        inc	hl
        ld	a,(hl)
        or	a			; end of devicename ?
        scf
        ret	nz			; nope, device not recognized
        ld	a,(Y6687)		; current channel
        ld	hl,Y6691
        sub	(hl)			; - first channel number version 2.0 rs232
        ld	hl,Y66EB
        cp	(hl)
        adc	a,0FFH			; adjust for version 1.0 interface channel between version 2.0 interfaces
        or	a			; device recognized, return devicecode
        ret

A4459:	cp	20-1
        jp	nc,A4841                ; internal error
        bit	0,a
        jp	nz,A4841                ; internal error
        push	hl
        push	af
        ld	hl,T4474
        add	a,l
        ld	l,a
        jr	nc,A446D
        inc	h
A446D:	ld	a,(hl)
        inc	hl
        ld	h,(hl)
        ld	l,a
        pop	af
        ex	(sp),hl
        ret
;
T4474:	dw	A4488			; 0, device open
        dw	A450A			; 2, device close
        dw	A4847			; 4, device random input/output -> sequential I/O only error
        dw	A456C			; 6, device sequential output
        dw	A457B			; 8, device sequential input
        dw	A4611			; 10, device loc
        dw	A466C			; 12, device lof
        dw	A4688			; 14, device eof
        dw	A4865			; 16, device fpos -> illegal function call
        dw	A46B4			; 18, device backup

;         Subroutine device open function
;            Inputs  ________________________
;            Outputs ________________________

A4488:	push	hl
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        pop	hl
        or	a		        ; already open ?
        ld	a,2
        jr	nz,A44B2	        ; yes, channel open error
        ld	a,(Y6687)	        ; current channel
        ex	de,hl
        push	hl
        add	a,a
        add	a,LOW Y665A
        ld	l,a
        ld	h,HIGH Y665A
        ld	(hl),e
        inc	hl
        ld	(hl),d                  ; store pointer to FCB
        pop	hl
        ex	de,hl
        call	A44B9		        ; RS232.OPEN
        jr	c,A44B2                 ; error,
        ld	(hl),e                  ; store mode
        ld	(PTRFIL),hl
        ret

A44B2:	dec	a
        jp	z,A483B                 ; bad filename error
        jp	A484D                   ; file already open error

;         Subroutine RS232.OPEN
;            Inputs  ________________________
;            Outputs ________________________

A44B9:	push	bc
        push	hl
        push	de
        call	A53C7		        ; buid slotinfo per channel table
        call	A426F		        ; install interrupt handler
        pop	de
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        or	a                       ; channel open ?
        jr	nz,A4505	        ; yep, channel open error
        ld	a,e
        cp	8                       ; append ?
        jr	nc,A4501                ; yep, bad file mode error
        di
        ld	(hl),e                  ; store mode
        call	A42F6		        ; clear flags and receive buffer
        call	A54FE                   ; enable RS232 interrupts
        call	A596E		        ; RTS on
        scf
A44F5:	ccf
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	hl
        pop	bc
        ei
        ret

A4501:	xor	a
        inc	a
        jr	A44F5

A4505:	ld	a,2
        or	a
        jr	A44F5

;         Subroutine device close function
;            Inputs  ________________________
;            Outputs ________________________

A450A:	call	A4709		        ; set current channel from FCB
        call	A4525		        ; RS232.CLOSE
        ld	(hl),0
        ld	a,(Y6687)	        ; current channel
        ex	de,hl
        push	hl
        add	a,a
        add	a,LOW Y665A
        ld	l,a
        ld	h,HIGH Y665A
        ld	(hl),0
        inc	hl
        ld	(hl),0                  ; clear pointer to FCB
        pop	hl
        ex	de,hl
        ret

;         Subroutine RS232.CLOSE
;            Inputs  ________________________
;            Outputs ________________________

A4525:	push	de
        push	hl
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)
        ld	(hl),0	                ; mode = 0 (channel closed)
        cp	2		        ; was in output mode ?
        ld	e,0
        scf
        ccf
        jr	nz,A4541	        ; no, skip EOF
        ld	a,01AH		        ; EOF
        call	A56E5		        ; RS232.SNDCHR
        push	af
        pop	de
A4541:	di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A5A12		        ; wait for empty transmitter
        call	A5976		        ; RTS off
        call	A5505		        ; disable RS232 interrupts
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        push	de
        pop	af
        pop	hl
        pop	de
        ei
        ret

;         Subroutine device sequential output
;            Inputs  ________________________
;            Outputs ________________________

A456C:	call	A4709		        ; set current channel from FCB
        ld	a,c
        call	A56E5		        ; RS232.SNDCHR
        ei
        jp	c,A4871                 ; aborted by CTRL-STOP, device I/O error
        jp	z,A4871                 ; timeout, device I/O error
        ret

;         Subroutine device sequential input
;            Inputs  ________________________
;            Outputs ________________________

A457B:	call	A4709		        ; set current channel from FCB
        call	A4585		        ; RS232.GETCHR
        jp	m,A4871                 ; device I/O error
        ret

;         Subroutine RS232.GETCHR
;            Inputs  ________________________
;            Outputs ________________________

A4585:	push	bc
        push	de
        push	hl
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	c,(ix+1)                ; backup byte
        ld	(ix+1),0                ; clear backup byte
        ld	a,(ix+2)                ; backup byte receive status
        ld	(ix+2),0                ; clear backup byte receive status
        ld	(ix+8),a                ; update receive status
        push	af
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	e,(hl)		        ; mode
        pop	af
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        or	a
        jr	nz,A4605
        ld	a,c
        or	a
        jr	nz,A45D6
        call	A5528                   ; wait for received byte
        ei
        ld	c,a
        jp	m,A4605
        call	A58B3
        jr	c,A4605
        jr	z,A4605
A45D6:	ld	a,e                     ; mode
        cp	4		        ; raw mode ?
        jr	z,A4609		        ; yep,
        ld	a,c
        cp	01AH		        ; EOF ?
        jr	nz,A4609	        ; no,
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	a,01AH
        ld	(ix+1),a                ; backup byte = EOF
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        or	a
        scf			        ; flag eof
        jr	A460C

A4605:	or	080H
        jr	A460B

A4609:	xor	a                       ; clear Cx
        inc	a                       ; clear Zx
A460B:	ld	a,c
A460C:	pop	hl
        pop	de
        pop	bc
        ei
        ret

;         Subroutine device loc
;            Inputs  ________________________
;            Outputs ________________________

A4611:	call	A4709		        ; set current channel from FCB
        push	hl
        call	A4622		        ; RS232.LOC

;         Subroutine put integer in DAC
;            Inputs  ________________________
;            Outputs ________________________

A4618:	ld	(DAC+2),hl
        ld	hl,VALTYP
        ld	(hl),2                  ; DAC type = integer
        pop	hl
        ret

;         Subroutine RS232.LOC
;            Inputs  ________________________
;            Outputs ________________________

A4622:	push	af
        ei
        nop
        nop
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        cp	1		        ; sequential input ?
        jr	nz,A465C	        ; no,
        ld	a,(ix+1)
        or	a                       ; backup byte ?
        jr	z,A4654		        ; nope, thats it
        sub	01AH
        jr	z,A465F		        ; EOF condition, no bytes in buffer
        ld	a,001H		        ; 1 extra for backup byte
A4654:	push	bc
        call	A46E1		        ; count seq. bytes in receivebuffer
        add	a,c
        pop	bc
        jr	A465F

A465C:	call	A5518		        ; get number of bytes in receive buffer (include backup byte)
A465F:	ld	l,a
        ld	h,000H
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	af
        ei
        ret

;         Subroutine device lof
;            Inputs  ________________________
;            Outputs ________________________

A466C:	call	A4709		        ; set current channel from FCB
        push	hl
        call	A4675		        ; RS232.LOF
A4673:	jr	A4618                   ; put integer in DAC and quit

;         Subroutine RS232.LOF
;            Inputs  ________________________
;            Outputs ________________________

A4675:	push	af
        ei
        call	A4622		; RS232.LOC
        push	de
        ex	de,hl
        ld	a,080H
        ld	l,a
        ld	h,000H
        or	a
        sbc	hl,de
        inc	hl
        pop	de
        pop	af
        ret

;         Subroutine device eof
;            Inputs  ________________________
;            Outputs ________________________

A4688:	call	A4709		        ; set current channel from FCB
        push	hl
        call	A4694                   ; determine EOF
        jp	m,A4871                 ; device I/O error
        jr	A4673                   ; put integer in DAC and quit

;         Subroutine determine EOF
;            Inputs  ________________________
;            Outputs ________________________

A4694:	push	bc
        ld	b,a
        ei
        call	A4585		        ; RS232.GETCHR
        jp	m,A46B1                 ; error, quit with error
        push	bc
        ld	c,a
        call	A46B7		        ; RS232.BACKUP
        pop	bc
        cp	01AH                    ; EOF ?
        jr	z,A46AD                 ; yep, quit with eof = true
        xor	a
        ld	l,a
        ld	h,a
        inc	a
        jr	A46B1                   ; quit with eof = false

A46AD:	ld	hl,-1
        scf
A46B1:	ld	a,b
        pop	bc
        ret

;         Subroutine device backup
;            Inputs  ________________________
;            Outputs ________________________

A46B4:	call	A4709		        ; set current channel from FCB

;         Subroutine RS232.BACKUP
;            Inputs  ________________________
;            Outputs ________________________

A46B7:	push	af
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	(ix+1),c                ; store backup byte
        ld	a,(ix+8)                ; receive status
        and	038H
        ld	(ix+2),a                ; store backup byte receive status
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	af
        ret

;         Subroutine count seq. bytes in receivebuffer
;            Inputs  ________________________
;            Outputs ________________________

A46E1:	push	af
        push	hl
        ld	c,0                     ; offset = 0
        ld	a,(ix+5)
        or	a                       ; receive buffer empty ?
        jr	z,A46F7                 ; yep,
        ld	b,a                     ; number of bytes in receiver buffer
A46EC:	call	A46FA                   ; get pointer in receive buffer (with offset)
        ld	a,(hl)
        cp	01AH                    ; EOF ?
        jr	z,A46F7                 ; yep, quit
        inc	c                       ; update offset
        djnz	A46EC                   ; next byte
A46F7:	pop	hl
        pop	af
        ret

;         Subroutine get pointer in receive buffer (with offset)
;            Inputs  ________________________
;            Outputs ________________________

A46FA:	ld	a,(ix+6)                ; get offset in receive buffer
        add	a,c
        jp	p,A4703
        sub	080H
A4703:	ld	hl,(Y668D)	        ; receivebuffer
        add	a,a
        ld	l,a
        ret

;         Subroutine set current channel from FCB
;            Inputs  HL = pointer to FCB
;            Outputs ________________________

A4709:	push	af
        push	bc
        ex	de,hl
        push	hl
        ld	b,-1                    ; channel
        ld	hl,Y665A
A4712:	inc	b
        ld	a,(hl)
        inc	hl
        ld	c,(hl)		        ; pointer to FCB
        inc	hl
        cp	e                       ; same as provided FCB ?
        jr	nz,A4712                ; nope, next channel
        ld	a,c
        cp	d                       ; same as provided FCB ?
        jr	nz,A4712	        ; nope, next channel
        ld	a,b
        ld	(Y6687),a	        ; current channel
        pop	hl
        ex	de,hl
        pop	bc
        pop	af
        ret

;         Subroutine EXTBIO handler
;            Inputs  ________________________
;            Outputs ________________________

T4727:	ei
        push	af
        ld	a,d
        inc	a		        ; device = system exclusive ?
        jp	z,A47EC		        ; yep,
        dec	a		        ; device = broadcast ?
        jp	nz,A47FF	        ; no,

; EXTBIO broadcast

        ld	a,e
        or	a                       ; function = build device name table ?
        jr	z,A4742		        ; yep,
        dec	a                       ; function = return number of trap entries used
        jr	z,A474F		        ; yep,
        dec	a                       ; function = disable interrupt ?
        jr	z,A4761		        ; yep,
        dec	a                       ; function = enable interrupt ?
        jr	z,A47A7		        ; yep,
        jp	A4826		        ; other unknown function, cascade to other EXTBIO

; broadcast, build device name table

A4742:	ld	a,8                     ; device = MSX serial
        call	A4878                   ; write byte to slot
        ld	a,0                     ; reserved byte
        call	A4878                   ; write byte to slot
        jp	A4826		        ; cascade to other EXTBIO

; broadcast, return number of trap entries used

A474F:	push	bc
        push	de
        call	A53C7		        ; buid slotinfo per channel table
        pop	de
        pop	bc
        pop	af                      ; restore previous number of trap entries
        push	hl
        ld	hl,Y6690
        add	a,(hl)		        ; number of version 2.0 channels
        pop	hl
        push	af
        jp	A4826		        ; cascade to other EXTBIO

; broadcast, disable interrupts

A4761:	push	bc
        push	de
        push	hl
        ld	a,(Y661E)
        inc	a		        ; table initalized ?
        jr	z,A47A1		        ; no, just quit
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        ld	a,(Y6691)
        ld	d,a		        ; first channel number version 2.0 rs232
        ld	e,0
        ld	hl,Y664B
        add	a,l
        ld	l,a
A4781:	ld	a,(hl)		        ; mode
        or	a		        ; channel open ?
        jr	z,A4791		        ; nope, skip
        ld	a,d                     ; channel
        push	hl
        call	A5448		        ; enable hardware channel on page 2
        call	A56B5		        ; signal sender to stop sending
        call	A5505		        ; disable RS232 interrupts
        pop	hl
A4791:	inc	hl
        inc	d
        inc	e
        ld	a,(Y6690)	        ; number of channels
        cp	e
        jr	nz,A4781	        ; next channel
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
A47A1:	pop	hl
        pop	de
        pop	bc
        jp	A4826		        ; cascade to other EXTBIO

; broadcast, enable interrupts

A47A7:	push	bc
        push	de
        push	hl
        ld	a,(Y661E)
        inc	a		        ; table initalized ?
        jr	z,A47A1		        ; no, just quit
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        ld	a,(Y6691)
        ld	d,a		        ; first channel number version 2.0 rs232
        ld	e,0
        ld	hl,Y664B
        add	a,l
        ld	l,a
A47C7:	ld	a,(hl)		        ; mode
        or	a                       ; channel open ?
        jr	z,A47DA		        ; nope,
        ld	a,d                     ; channel
        push	hl
        call	A5448		        ; enable hardware channel on page 2
        call	A54FE                   ; enable RS232 interrupts
        call	A596E		        ; RTS on
        call	A569F		        ; signal sender to resume sending
        pop	hl
A47DA:	inc	hl
        inc	d
        inc	e
        ld	a,(Y6690)	        ; number of channels
        cp	e
        jr	nz,A47C7
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        jr	A47A1

; EXTBIO system exclusive

A47EC:	ld	a,e
        or	a                       ; function = build BIOS table ?
        jr	nz,A47FD	        ; nope, let other EXTBIO handle it
        call	A482A		        ; write slotid and pointer to BIOS jumptable
        ld	a,0		        ; maker = ASCII
        call	A4878                   ; write byte to slot
        ld	a,0                     ; reserved byte
        call	A4878                   ; write byte to slot
A47FD:	jr	A4826		        ; cascade to other EXTBIO

; EXTBIO MSX-serial

A47FF:	cp	8		        ; MSX-serial ?
        jr	nz,A4826	        ; no, cascade to other EXTBIO
        ld	a,e
        or	a                       ; function = build BIOS table ?
        jr	z,A480D                 ; yep,
        cp	1                       ; function = return number of channels ?
        jr	z,A4817		        ; yep,
        jr	A4826		        ; unknown function, cascade to other EXTBIO

; MSX serial, build BIOS table

A480D:	call	A482A		        ; write slotid and pointer to BIOS jumptable
        ld	a,0                     ; reserved byte
        call	A4878                   ; write byte to slot
        jr	A4826		        ; cascade to other EXTBIO

; MSX serial, return number of channels

A4817:	push	bc
        push	de
        call	A53C7		        ; buid slotinfo per channel table
        pop	de
        pop	bc
        pop	af
        push	hl
        ld	hl,Y6690
        add	a,(hl)		        ; number of channels
        pop	hl
        push	af
A4826:	pop	af
        jp	Y6699		        ; cascade EXTBIO

;         Subroutine write slotid and pointer to BIOS jumptable
;            Inputs  ________________________
;            Outputs ________________________

A482A:	call	A5389		        ; get slotid on page 1
        call	A4878                   ; write byte to slot
        ld	a,LOW A4010
        call	A4878                   ; write byte to slot
        ld	a,HIGH A4010
        call	A4878                   ; write byte to slot
        ret

A483B:	ld	ix,DERBFN
        jr	A4875

A4841:	ld	ix,DERIER
        jr	A4875

A4847:	ld	ix,DERSOO
        jr	A4875

A484D:	ld	ix,DERFAO
        jr	A4875

A4853:	ld	ix,DERFNO
        jr	A4875

A4859:	ld	ix,USERR
        jr	A4875

A485F:	ld	ix,SNERR
        jr	A4875

A4865:	ld	ix,FCERR
        jr	A4875

A486B:	ld	ix,TMERR
        jr	A4875

A4871:	ld	ix,DIOERR
A4875:	jp	A494A

;         Subroutine write byte to slot
;            Inputs  ________________________
;            Outputs ________________________

A4878:	push	af
        push	bc
        push	de
        push	ix
        ld	e,a
        ld	a,b
        ld	ix,WRSLT
        call	A494F                   ; call mainrom
        ei
        inc	hl
        pop	ix
        pop	de
        pop	bc
        pop	af
        ret

;         Subroutine read byte from slot
;            Inputs  ________________________
;            Outputs ________________________

A488E:	push	bc
        push	de
        push	ix
        ld	a,b
        ld	ix,RDSLT
        call	A494F                   ; call mainrom
        ei
        inc	hl
        pop	ix
        pop	de
        pop	bc
        ret

;         Subroutine check if ctrl-stop pressed
;            Inputs  ________________________
;            Outputs ________________________

A48A1:	push	ix
        ld	ix,BREAKX
        call	A494F                   ; call mainrom
        pop	ix
        ret

;         Subroutine echo to screen/printer (literal)
;            Inputs  ________________________
;            Outputs ________________________

A48AD:	push	bc
        ld	b,a
        ld	a,(Y66AA)
        or	a                       ; literal mode ?
        jr	z,A48D3                 ; nope,
        ld	a,b
        cp	020H
        jr	nc,A48D3
        ld	a,'^'
        call	A48D5                   ; echo to screen/printer
        ld	a,b
        add	a,040H
        call	A48D5                   ; echo to screen/printer
        ld	a,b
        cp	00AH
        pop	bc
        ret	nz
        ld	a,00DH
        call	A48D5                   ; echo to screen/printer
        ld	a,00AH
        jr	A48D5                   ; echo to screen/printer

A48D3:	ld	a,b
        pop	bc

;         Subroutine echo to screen/printer
;            Inputs  ________________________
;            Outputs ________________________

A48D5:	push	af
        call	CHPUT
        ei
        ld	a,(Y66AC)
        or	a                       ; printer echo ?
        jr	z,A48E6                 ; nope,
        pop	af
        push	af
        call	LPTOUT
        ei
A48E6:	pop	af
        ret

;         Subroutine check for BASIC character
;            Inputs  ________________________
;            Outputs ________________________

A48E8:	ld	a,(hl)
        ex	(sp),hl
        cp	(hl)
        jp	nz,A485F                ; syntax error
        inc	hl
        ex	(sp),hl

;         Subroutine get next BASIC character
;            Inputs  ________________________
;            Outputs ________________________

A48F0:	push	ix
        ld	ix,CHRGTR
        exx
        push	hl
        exx
        call	A494A
        exx
        pop	hl
        exx
        pop	ix
        ret

;         Subroutine evaluate expression
;            Inputs  ________________________
;            Outputs ________________________

A4902:	push	ix
        ld	ix,FRMEVL
        call	A494A
        pop	ix
        ret

;         Subroutine evaluate address operand
;            Inputs  ________________________
;            Outputs ________________________

A490E:	push	ix
        ld	ix,FRMQNT
        call	A494A
        pop	ix
        ret

;         Subroutine evaluate byte operand
;            Inputs  ________________________
;            Outputs ________________________

A491A:	push	ix
        ld	ix,GETBYT
        call	A494A
        pop	ix
        ret

;         Subroutine locate variable
;            Inputs  ________________________
;            Outputs ________________________

A4926:	push	ix
        ld	ix,PTRGET
        call	A494A
        pop	ix
        ret

;         Subroutine free temporary string
;            Inputs  ________________________
;            Outputs ________________________

A4932:	push	ix
        ld	ix,FRESTR
        call	A494A
        pop	ix
        ret

;         Subroutine convert to DAC to new type
;            Inputs  ________________________
;            Outputs ________________________

A493E:	push	ix
        ld	ix,DOCNVF
        call	A494A
        pop	ix
        ret

;         Subroutine call mainrom and enable interrupts
;            Inputs  ________________________
;            Outputs ________________________

A494A:	call	A494F                   ; call mainrom
        ei
        ret

;         Subroutine call mainrom
;            Inputs  ________________________
;            Outputs ________________________

A494F:	push	iy
        ld	iy,(EXPTBL+0-1)
        call	CALSLT
        pop	iy
        ret

;         Subroutine CALL COMINI statement
;            Inputs  ________________________
;            Outputs ________________________

A495B:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A5505		        ; disable RS232 interrupts
        ld	a,(ix+12)
        ld	(Y6684),a               ; store last i8251 command byte
        exx
        ld	(Y667A),hl              ; store HL'
        exx
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        push	bc
        push	de
        push	hl
        ld	bc,13
        ld	hl,T431B
        ld	de,Y66AE
        push	de
        pop	iy
        ldir                            ; default settings as starting point
        pop	hl
        pop	de
        pop	bc
        exx
        ld	hl,(Y667A)              ; restore HL'
        exx
        ld	a,b
        and	c
        inc	a
        jr	nz,A49BF
        ld	a,d
        or	a
        jp	z,A4A9C
        cp	":"
        jp	z,A4A9C
        cp	")"
        jp	z,A4A99
        call	A48E8                   ; check for BASIC character
        defb	","
        jr	A49E6

A49BF:	push	hl
        exx
        push	hl
        exx
        pop	hl
        ld	a,b
        or	a
        jr	z,A49D8
        push	iy
        pop	de
A49CB:	ld	a,(hl)
        cp	" "
        jr	z,A49D4
        call	A5229                   ; to upper
        ld	(de),a
A49D4:	inc	de
        inc	hl
        djnz	A49CB
A49D8:	pop	hl
        dec	hl
        call	A48F0                   ; get next BASIC character
        cp	')'
        jp	z,A4A99
        call	A48E8                   ; check for BASIC character
        defb	","
A49E6:	cp	","
        jr	z,A4A38
        call	A490E                   ; evaluate address operand
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	(iy+8),e
        ld	(iy+9),d
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ld	a,(hl)
        cp	')'
        jr	nz,A4A38
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	(iy+10),e
        ld	(iy+11),d
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        jr	A4A99
;
A4A38:	call	A48E8                   ; check for BASIC character
        defb	","
        cp	","
        jr	z,A4A6A
        call	A490E                   ; evaluate address operand
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	(iy+10),e
        ld	(iy+11),d
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ld	a,(hl)
        cp	')'
        jr	z,A4A99
A4A6A:	call	A48E8                   ; check for BASIC character
        defb	","
        cp	")"
        jr	z,A4A99
        call	A491A                   ; evaluate byte operand
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	(iy+12),e
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        call	A48E8                   ; check for BASIC character
        defb	")"
        dec	hl
A4A99:	call	A48F0                   ; get next BASIC character
A4A9C:	di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A5232		        ; initialize rs232 channel
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        jp	c,A4865                 ; illegal function call
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        push	hl
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        pop	hl
        or	a                       ; channel open ?
        call	nz,A54FE        	; yep, enable RS232 interrupts
        ld	a,(Y6684)               ; stored last i8251 command byte
        bit	5,a                     ; RTS on ?
        call	nz,A596E	        ; yep, RTS on
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ei
        or	a                       ; statement handled
        ret

;         Subroutine CALL COMDTR statement
;            Inputs  ________________________
;            Outputs ________________________

A4AF4:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        call	A48E8                   ; check for BASIC character
        defb	","
        push	hl
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        pop	hl
        or	a                       ; channel open ?
        jp	z,A4853		        ; nope, file not open error
        call	A490E                   ; evaluate address operand
        call	A48E8                   ; check for BASIC character
        defb	")"
        ld	a,d
        or	e
        call	A5986		        ; RS232.DTR
        ei
        ret

;         Subroutine CALL COMSTAT statement
;            Inputs  ________________________
;            Outputs ________________________

A4B1F:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        call	A48E8                   ; check for BASIC character
        defb	","
        push	hl                      ; store BASIC pointer
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        pop	hl                      ; restore BASIC pointer
        or	a                       ; channel open ?
        jp	z,A4853		        ; nope, file not open error
        call	A4926                   ; locate variable
        push	hl                      ; store BASIC pointer
        call	A59CA		        ; RS232.STAT
        ld	(DAC+2),hl              ; store in DAC
        pop	hl                      ; restore BASIC pointer
        call	A51F0                   ; copy DAC to variable
        call	A48E8                   ; check for BASIC character
        defb	")"
        or	a                       ; statement handled
        ei
        ret

;         Subroutine CALL COMBREAK statement
;            Inputs  ________________________
;            Outputs ________________________

A4B43:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        push	hl
        ld	hl,Y664B
        ld	a,(Y6687)	        ; current channel
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        pop	hl
        or	a                       ; channel open ?
        jp	z,A4853		        ; nope, file not open error
        ld	a,d
        cp	02CH
        jr	z,A4B7F
        or	a
        jr	z,A4B7A
        cp	03AH
        jr	z,A4B7A
        call	A48E8                   ; check for BASIC character
        defb	")"
A4B7A:	ld	de,0000AH
        jr	A4B89
;
A4B7F:	call	A48F0                   ; get next BASIC character
        call	A490E                   ; evaluate address operand
        call	A48E8                   ; check for BASIC character
        defb	")"
A4B89:	push	hl
        ld	hl,00002H
        or	a
        sbc	hl,de
        jp	nc,A4865                ; illegal function call
        call	A590C		        ; RS232.SNDBRK
        pop	hl
        ei
        ld	a,000H
        inc	a
        call	A58B3
        jp	c,A4871
        or	a                       ; statement handled
        ret

;         Subroutine CALL COMTERM statement
;            Inputs  ________________________
;            Outputs ________________________

A4BA3:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        ld	a,d                     ; last BASIC character
        or	a                       ; end of line ?
        jr	z,A4BB9                 ; yep,
        cp	':'                     ; end of statement ?
        jr	z,A4BB9                 ; yep,
        call	A48E8                   ; check for BASIC character
        defb	")"
A4BB9:	ld	(Y6685),hl	        ; store BASIC pointer
        xor	a
        ld	(Y66A8),a               ; clear received ESC byte
        ld	(Y66AC),a               ; printer echo = off
        ld	(Y66AA),a               ; literal mode = off
        ld	(Y66AB),a               ; duplex mode = full
        ld	hl,FNKSTR+5*16
        ld	de,Y66BB
        ld	bc,3*16
        push	bc
        push	hl
        ldir                            ; save F5-F7 definition
        pop	hl
        pop	bc
        ld	b,c
        push	hl
A4BDA:	ld	(hl),0
        inc	hl
        djnz	A4BDA                   ; clear F5-F7 definition
        pop	de
        ld	hl,T4DC0
        ld	bc,5
        push	bc
        ldir                            ; redefine F5
        pop	bc
        ld	de,FNKSTR+6*16
        push	bc
        ldir                            ; redefine F6
        pop	bc
        ld	de,FNKSTR+7*16
        push	bc
        ldir                            ; redefine F7
        pop	bc
        ld	a,(CSRSR)
        ld	(Y66AD),a               ; store cursor display status
        call	A4DDC                   ; cursor on
        ld	e,4		        ; raw input/output mode
        call	A44B9		        ; RS232.OPEN
        jp	c,A484D                 ; file already open error

; COMTERM main loop

A4C09:	ei
        call	A4622		        ; RS232.LOC
        ei
        ld	a,l
        or	h                       ; receive buffer empty ?
        jr	z,A4C34                 ; yep, handle keyboard input
        call	A5528                   ; wait for received byte
        ei
        jr	c,A4C60                 ; EOF, quit COMTERM
        ld	c,a
        jp	m,A4C2F                 ; error,
        ld	hl,Y66A8
        ld	a,(hl)
        cp	2                       ; received 2x ESC ?
        ld	a,c
        jr	nz,A4C29                ; nope,
        ld	(hl),0                  ; clear received ESC byte
        jr	A4C90

A4C29:	cp	01BH                    ; ESC ?
        jr	nz,A4C2F                ; nope,
        inc	(hl)
        db	1                       ; skip next instruction
A4C2F:	ld	(hl),0                  ; clear received ESC byte
        call	A48AD                   ; echo to screen/printer (literal)
A4C34:	call	A4DFD                   ; STOP or CTRL-STOP pressed ?
        call	nz,A4DD4                ; send long break
        call	A48A1		        ; check if ctrl-stop pressed
        jr	c,A4C60		        ; yep, quit COMTERM
        call	CHSNS                   ; keyboard input ?
        ei
        jr	z,A4C09                 ; nope, COMTERM main loop
        call	CHGET                   ; get keyboard input
        ei
        cp	0A0H                    ; F5-F7 pressed ?
        jp	z,A4D9F                 ; yep, handle
        call	A4DCF                   ; send byte
        ld	c,a
        ld	a,(Y66AB)
        or	a                       ; full duplex mode ?
        jp	z,A4C09                 ; yep, COMTERM main loop
        ld	a,c
        call	A48AD                   ; echo to screen/printer (literal)
        jp	A4C09                   ; COMTERM main loop

; quit COMTERM

A4C60:	call	A4525		        ; RS232.CLOSE
        xor	a
T4C64:	ld	(Y66A8),a               ; clear received ESC byte
        ld	(Y66AC),a               ; printer echo = off
        ld	(Y66AA),a               ; literal mode = off
        ld	(Y66AB),a               ; duplex mode = full
        ld	hl,Y66BB
        ld	de,FNKSTR+5*16
        ld	bc,3*16
        ldir                            ; restore F5-F7 definition
        ld	hl,(Y6685)	        ; restore BASIC pointer
        ld	a,(Y66AD)
        or	a                       ; cursor was off ?
        push	af
        call	z,A4DEB                 ; yep, cursor off
        pop	af
        call	nz,A4DDC                ; nope, cursor on
        xor	a
        di
        ld	(INTFLG),a              ; clear STOP/CTRL-STOP flag
        ret

; hexdecimal transfer mode

A4C90:	ld	a,(Y66AA)
        or	a                       ; literal mode ?
        jp	nz,A4C09                ; yep, COMTERM main loop
        call	A4DEB                   ; cursor off
        ld	a,0FFH
        ld	(Y66A9),a               ; show no progress char

; intel hexfile transfer main loop

A4C9F:	call	A5528                   ; wait for received byte
        ei
        jp	c,A4C60                 ; EOF, quit COMTERM
        cp	':'
        jr	nz,A4C9F                ; nope, intel hexfile transfer main loop
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jp	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        or	a                       ; number of bytes = 0 ?
        jr	z,A4CFA                 ; yep,
        ld	b,a                     ; number of bytes
        ld	e,a                     ; checksum
        call	A4D62                   ; receive word in hexadecimal characters (address)
        jp	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jp	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        add	a,l
        add	a,h
        add	a,e
        ld	e,a
A4CC5:	call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        ld	(hl),a
        add	a,e
        ld	e,a
        inc	hl
        djnz	A4CC5
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        add	a,e
        jr	nz,A4D23                ; bad checksum, send bad and return to intel hexfile transfer mainloop
        ld	a,'G'
        call	A4DCF                   ; send byte
        ld	a,(Y66A9)
        or	a                       ; progress char shows ?
        jr	z,A4CEE                 ; yep,
        inc	a
        ld	(Y66A9),a               ; progress char show
        ld	a,'*'                   ; progress char
        call	A48AD                   ; echo to screen/printer (literal)
        jr	A4CF7
;
A4CEE:	dec	a
        ld	(Y66A9),a               ; no progress char
        ld	a,07FH                  ; remove progress char
        call	A48AD                   ; echo to screen/printer (literal)
A4CF7:	jp	A4C9F                   ; intel hexfile transfer main loop

A4CFA:	call	A4D62                   ; receive word in hexadecimal characters (address)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        ld	a,h
        or	l                       ; start address = 0 ?
        jr	nz,A4D2B                ; nope, start
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        cp	001H
        jr	nz,A4D23                ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        cp	0FFH
        jr	nz,A4D23                ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
A4D15:	ld	a,'G'
        call	A4DCF                   ; send byte
        call	A4DF4                   ; echo CR/LF to screen/printer (literal)
        call	A4DDC                   ; cursor on
        jp	A4C09                   ; COMTERM main loop

A4D23:	ld	a,'B'
        call	A4DCF                   ; send byte
        jp	A4C9F                   ; intel hexfile transfer main loop

A4D2B:	call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        cp	001H
        jr	nz,A4D23                ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        add	a,l
        add	a,h
        ld	e,a
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        jr	c,A4D23                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        add	a,e
        jr	nz,A4D23                ; bad checksum, send bad and return to intel hexfile transfer mainloop
        call	A5528                   ; wait for received byte
        ei
        jp	c,A4C60                 ; EOF, quit COMTERM
        cp	00AH                    ; LF ?
        jr	nz,A4D15                ; nope,
        ld	a,'G'
        call	A4DCF                   ; send byte
        call	A4DF4                   ; echo CR/LF to screen/printer (literal)
        push	ix
        push	hl
        ld	hl,T4D5A
        ex	(sp),hl
        jp	(hl)

T4D5A:	pop	ix
        call	A4DDC                   ; cursor on
        jp	A4C09                   ; COMTERM main loop

;         Subroutine receive word in hexadecimal characters
;            Inputs  ________________________
;            Outputs ________________________

A4D62:	call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        ret	c
        ld	h,a
        call	A4D6D                   ; receive byte in hexadecimal characters (number of bytes)
        ret	c
        ld	l,a
        ret

;         Subroutine receive byte in hexadecimal characters
;            Inputs  ________________________
;            Outputs ________________________

A4D6D:	push	bc
        call	A5528                   ; wait for received byte
        jr	c,A4D88
        call	A4D8A
        jr	c,A4D88
        add	a,a
        add	a,a
        add	a,a
        add	a,a
        ld	b,a
        call	A5528                   ; wait for received byte
        jr	c,A4D88
        call	A4D8A
        jr	c,A4D88
        add	a,b
A4D88:	pop	bc
        ret

;         Subroutine is hexadecimal character ?
;            Inputs  ________________________
;            Outputs Cx set if no hexadecimal character

A4D8A:	call	A5229                   ; to upper
        sub	'0'
        ret	c
        cp	9+1
        jr	c,A4D9D
        sub	'A'-'0'
        ret	c
        cp	'F'-'A'+1
        ccf
        ret	c
        add	a,10
A4D9D:	or	a
        ret

; handle F5-F7

A4D9F:	call	CHGET
        ei
        sub	6
        jr	z,A4DB2
        dec	a
        jr	z,A4DB7
        dec	a
        jr	nz,A4DBD
        ld	hl,Y66AC                ; flip printer echo
        jr	A4DBA
;
A4DB2:	ld	hl,Y66AA                ; flip literal mode
        jr	A4DBA
;
A4DB7:	ld	hl,Y66AB                ; flip duplex mode
A4DBA:	ld	a,(hl)
        cpl
        ld	(hl),a
A4DBD:	jp	A4C09                   ; COMTERM main loop

; functionkey definitions F5-F7

T4DC0:	defb    0A0H,006H,000H,06CH,069H
        defb    0A0H,007H,000H,068H,066H
        defb    0A0H,008H,000H,070H,065H

;         Subroutine send byte
;            Inputs  ________________________
;            Outputs ________________________

A4DCF:	call	A56E5		; RS232.SNDCHR
        ei
        ret

;         Subroutine send long break
;            Inputs  ________________________
;            Outputs ________________________

A4DD4:	ld	de,100
        call	A590C		; RS232.SNDBRK
        ei
        ret

;         Subroutine cursor on
;            Inputs  ________________________
;            Outputs ________________________

A4DDC:	ld	a,01BH
        call	A48AD                   ; echo to screen/printer (literal)
        ld	a,'y'
A4DE3:	call	A48AD                   ; echo to screen/printer (literal)
        ld	a,'5'
A4DE8:	jp	A48AD                   ; echo to screen/printer (literal)

;         Subroutine cursor off
;            Inputs  ________________________
;            Outputs ________________________

A4DEB:	ld	a,01BH
        call	A48AD                   ; echo to screen/printer (literal)
        ld	a,'x'
        jr	A4DE3

;         Subroutine echo CR/LF to screen/printer (literal)
;            Inputs  ________________________
;            Outputs ________________________

A4DF4:	ld	a,00DH
        call	A48AD                   ; echo to screen/printer (literal)
        ld	a,00AH
        jr	A4DE8                   ; echo to screen/printer (literal)

;         Subroutine STOP or CTRL-STOP pressed ?
;            Inputs  ________________________
;            Outputs ________________________

A4DFD:	ld	a,(INTFLG)
        or	a                       ; STOP/CTRL-STOP pressed ?
        ret	z                       ; nope, quit
        xor	a
        ld	(INTFLG),a              ; clear STOP/CTRL-STOP flag
        inc	a
        ret

;         Subroutine CALL COMHELP statement
;            Inputs  ________________________
;            Outputs ________________________

A4E08:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        ld	a,d                     ; last BASIC character
        or	a                       ; end of line ?
        jr	z,A4E1E                 ; yep,
        cp	':'                     ; end of statement ?
        jr	z,A4E1E                 ; yep,
        call	A48E8                   ; check for BASIC character
        defb	")"
A4E1E:	xor	a
        ld	(Y66AA),a               ; literal mode = off
        ld	(Y66AC),a               ; printer echo = off
        ld	(Y66AB),a               ; duplex mode = full
        push	hl
        call	A4DF4
        ld	hl,T4E65
A4E2F:	ld	a,(hl)
        inc	hl
        inc	a
        jr	z,A4E62
        dec	a
        jr	z,A4E44
        call	A48AD                   ; echo to screen/printer (literal)
        ld	a,(INTFLG)
        or	a                       ; STOP/CTRL-STOP pressed ?
        jr	z,A4E2F                 ; nope,
        cp	003H                    ; CTRL-STOP pressed ?
        jr	z,A4E62                 ; yep,
A4E44:	push	hl
        ld	hl,INTFLG
        ld	(hl),0                  ; clear STOP/CTRL-STOP flag
        call	A4DDC                   ; cursor on
A4E4D:	ei
        ld	a,(hl)
        or	a
        jr	z,A4E4D
        push	af
        call	A4DEB
        pop	af
        pop	hl
        cp	003H
        jr	z,A4E62
        xor	a
        ld	(INTFLG),a              ; clear STOP/CTRL-STOP flag
        jr	A4E2F
;
A4E62:	pop	hl
        or	a
        ret

T4E65:	db	"Initialize statement options",13,10
        db	13,10
        db	"CALL COMINI (",34,13,10
        db	"<device# {0,1,2,3}>:",13,10
        db	"<character length {5,6,7,8}>",13,10
        db	"<parity {E,O,I,N}>",13,10
        db	"<stop bits {1,2,3}>",13,10
        db	"<XON/XOFF {X,N}>",13,10
        db	"<CTS hand-shake {H,N}>",13,10
        db	"<auto LF on receive {A,N}>",13,10
        db	"<auto LF on transmit {A,N}>",13,10
        db	"<SI/SO {S,N}>",34,13,10
        db	",<receiver baud rate>",13,10
        db	",<transmitter baud rate>",13,10
        db	",<time out count>",13,10
        db	"                          )",13,10
        db	"Default:",13,10
        db	" CALL COMINI(",34,"0:8N1XHNNN",34,13,10
        db	"      ,1200,1200,0)",13,10
        db	0FFH

;         Subroutine CALL COM statement
;            Inputs  ________________________
;            Outputs ________________________

A5001:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        call	A48E8                   ; check for BASIC character
        defb	","
        call	A48E8                   ; check for BASIC character
        defb	08DH                    ; GOSUB token
        ld	ix,LINGET
        call	A494A                   ; collect line number
        push	hl
        ld	a,e
        or	d                       ; line number = 0 ?
        jr	z,A502B                 ; yep, skip search
        ld	ix,FNDLIN
        call	A494A                   ; search linenumber from start of program
        jp	nc,A4859                ; undefined line number error
        ld	e,c
        ld	d,b                     ; store pointer to line
A502B:	pop	hl
        push	de
        dec	hl
        call	A48F0                   ; get next BASIC character
        jr	z,A5037                 ; end of line or statement,
        call	A48E8                   ; check for BASIC character
        defb	")"
A5037:	pop	de
        push	hl
        di
        ld	a,(Y6687)	        ; current channel
        call	A5141		        ; get pointer to trap entry
        jp	c,A4865                 ; invalid trap number, illegal function call
        inc	hl
        ld	(hl),e
        inc	hl
        ld	(hl),d                  ; store pointer to line
        call	A4297		        ; install new statement handler
        ei
        pop	hl
        or	a                       ; statement handled
        ret

;         Subroutine CALL COMOFF statement
;            Inputs  ________________________
;            Outputs ________________________

A504E:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        dec	hl
        call	A48F0                   ; get next BASIC character
        jr	z,A5062                 ; end of line or statement ?
        call	A48E8                   ; check for BASIC character
        defb	")"
A5062:	ld	ix,TRPDIS
        jr	A50CF

;         Subroutine CALL COMON statement
;            Inputs  ________________________
;            Outputs ________________________

A5068:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        dec	hl
        call	A48F0                   ; get next BASIC character
        jr	z,A507C                 ; end of line or statement ?
        call	A48E8                   ; check for BASIC character
        defb	")"
A507C:	ld	ix,TRPENA
        jr	A509A

;         Subroutine CALL COMSTOP statement
;            Inputs  ________________________
;            Outputs ________________________

A5082:	ei
        call	A53C7		        ; buid slotinfo per channel table
        call	A5161                   ; evaluate optional device name, quit if not handled
        call	A51E6                   ; check for no filename specified
        dec	hl
        call	A48F0                   ; get next BASIC character
        jr	z,A5096                 ; end of line or statement ?
        call	A48E8                   ; check for BASIC character
        defb	")"
A5096:	ld	ix,TRPSTP
A509A:	push	hl
        di
        ld	a,(Y6687)	        ; current channel
        call	A5141		        ; get pointer to trap entry
        jp	c,A4865                 ; invalid trap number, illegal function call
        ld	a,(hl)
        and	001H
        jr	nz,A50CD
        push	ix
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A42FA                   ; clear receive buffer
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	ix
A50CD:	ei
        pop	hl
A50CF:	push	hl
        di
        ld	a,(Y6687)	        ; current channel
        call	A5141		        ; get pointer to trap entry
        jp	c,A4865                 ; invalid trap number, illegal function call
        call	A494A
        call	A4297		        ; install new statement handler
        ei
        pop	hl
        or	a                       ; statement handle
        ret

;         Subroutine new statement handler
;            Inputs  ________________________
;            Outputs ________________________

T50E4:	ei
        ld	a,(Y661E)
        inc	a		        ; table initalized ?
        jp	z,Y669E		        ; no, just quit to old H.NEWS
        push	bc
        push	de
        push	hl
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        ld	a,(Y6691)
        ld	d,a		        ; first channel number version 2.0 rs232
        ld	e,0
A5101:	ld	a,d
        ld	hl,Y664B
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        or	a                       ; channel open ?
        jr	z,A5116		        ; nope,
        ld	a,d                     ; channel
        call	A5448		        ; enable hardware channel on page 2
        call	A5518		        ; get number of bytes in receive buffer (include backup byte)
        ld	a,d
        call	nz,A512B	        ; not empty, flag event
A5116:	inc	d
        inc	e
        ld	a,(Y6690)	        ; number of channels
        cp	e
        jr	nz,A5101
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	hl
        pop	de
        pop	bc
        jp	Y669E		        ; cascade to old H.NEWS
;
A512B:	call	A5141		        ; get pointer to trap entry
        ret	c		        ; invalid trap number, quit
        ld	a,(hl)
        and	001H		        ; event on ?
        ret	z		        ; no, quit
        ld	a,(hl)
        or	004H
        cp	(hl)		        ; event already flaged ?
        ret	z		        ; yes, quit
        cp	005H		        ; event stopped ?
        ret	nz		        ; yes, quit
        ld	(hl),a
        ld	hl,ONGSBF	        ; flag for event
        inc	(hl)
        ret

;         Subroutine get pointer to trap entry
;            Inputs  ________________________
;            Outputs ________________________

A5141:	call	A5153		        ; get trap number
        ret	c		        ; invalid trap number, quit
        push	bc
        ld	c,a
        add	a,a
        add	a,c
        ld	c,a
        ld	b,0
        ld	hl,TRPTBL+18*3
        add	hl,bc
        pop	bc
        or	a
        ret

;         Subroutine get trap number
;            Inputs  ________________________
;            Outputs ________________________

A5153:	push	hl
        ld	hl,Y6691
        sub	(hl)		        ; first channel number version 2.0 rs232
        ld	hl,Y6692
        add	a,(hl)		        ; my trap entry
        cp	6
        ccf			        ; check if trap available (only 6!)
        pop	hl
        ret

;         Subroutine evaluate optional device name, quit if not handled
;            Inputs  ________________________
;            Outputs ________________________

A5161:	dec	hl
        call	A48F0                   ; get next BASIC character
        ld	d,a                     ; store last BASIC character
        jr	nz,A516F                ; not end of statement,
A5168:	xor	a       		; COM0
        ld	bc,-1                   ; no string
        push	hl
        jr	A51AD

A516F:	cp	"("
        jp	z,A517A
        cp	","
        jr	z,A5168
        jr	A5182

A517A:	call	A48F0                   ; get next BASIC character
        ld	d,a                     ; store last BASIC character
        cp	","
        jr	z,A5168
A5182:	call	A4902                   ; evaluate expression
        push	hl                      ; store BASIC pointer
        call	A4932                   ; free temporary string
        ld	c,0
        ld	b,(hl)                  ; size of string
        inc	hl
        ld	a,(hl)
        inc	hl
        ld	h,(hl)
        ld	l,a                     ; pointer to string
        ld	a,b
        or	a                       ; empty string ?
        jr	z,A51AD                 ; yep, COM0
        inc	hl
        ld	a,(hl)
        cp	":"                     ; device seperator ?
        jr	z,A519F                 ; yep,
        dec	hl
        xor	a                       ; COM0
        jr	A51AD

A519F:	dec	hl
        ld	a,(hl)
        sub	"0"                     ; valid COM number ?
        jr	c,A51C4                 ; nope,
        cp	9+1                     ; valid COM number ?
        jr	nc,A51C4                ; nope,
        inc	hl
        inc	hl
        dec	b
        dec	b
A51AD:	ld	e,a
        push	hl
        exx
        pop	hl
        exx
        pop	hl                      ; restore BASIC pointer
        dec	hl
        call	A48F0                   ; get next BASIC character
        ld	d,a                     ; store last BASIC character
        push	bc
        call	A51C7		        ; RS232.SETCHN
        pop	bc
        ret	nc		        ; channel is version 2.0, quit
A51BE:	pop	hl                      ; dispose stored BASIC pointer
        ld	hl,(Y6685)	        ; restore BASIC pointer
        scf			        ; flag statement not handled
        ret

A51C4:	pop	hl
        jr	A51BE

;         Subroutine RS232.SETCHN
;            Inputs  E = channel
;            Outputs ________________________

A51C7:	push	de                      ; store channel
        call	A53C7		        ; buid slotinfo per channel table
        pop	de                      ; restore channel
        ld	a,(Y66EB)
        cp	e		        ; version 1.0 interface channel between version 2.0 interfaces channels ?
        scf
        ret	z		        ; yep, quit
        ld	a,(Y6690)
        ld	c,a		        ; number of channels
        ld	a,(Y6691)
        ld	b,a		        ; first channel number version 2.0 rs232
        add	a,c
        ld	c,a
        ld	a,e
        cp	b		        ; is it handled by me ?
        ret	c		        ; no, before me, quit
        cp	c
        ccf
        ret	c		        ; no, after me, quit
        ld	(Y6687),a	        ; current rs232 channel
        ret

;         Subroutine check for no filename specified
;            Inputs  ________________________
;            Outputs ________________________

A51E6:	ld	a,b
        or	c                       ; empty string ?
        ret	z                       ; yep, quit
        ld	a,b
        and	c
        inc	a                       ; no string ?
        ret	z                       ; yep, quit
        jp	A4865                   ; illegal function call

;         Subroutine copy DAC to variable
;            Inputs  ________________________
;            Outputs ________________________

A51F0:	push	hl
        ld	hl,VALTYP
        ld	a,(hl)
        cp	2                       ; integer ?
        jr	z,A521E                 ; yep,
        cp	4                       ; single float ?
        jr	z,A520E                 ; yep,
        cp	8                       ; double float ?
        jp	nz,A486B                ; nope, type mismatch error
        ld	(hl),2                  ; DAC type = integer
        push	de
        ld	a,8                     ; double float
        call	A493E                   ; convert to DAC to new type
        ld	c,8
        jr	A5218

A520E:	ld	(hl),2                  ; DAC type = integer
        push	de
        ld	a,4                     ; single float
        call	A493E                   ; convert to DAC to new type
        ld	c,4
A5218:	pop	de
        ld	hl,DAC+0
        jr	A5223

A521E:	ld	hl,DAC+2
        ld	c,2
A5223:	ld	b,0
        ldir
        pop	hl
        ret

;         Subroutine to upper
;            Inputs  ________________________
;            Outputs ________________________

A5229:	cp	'a'
        ret	c
        cp	'z'+1
        ret	nc
        sub	020H
        ret

;         Subroutine initialize rs232 channel
;            Inputs  IY = pointer to parameters, IX = pointer to channel
;            Outputs ________________________

A5232:	ld	a,(iy+0)
        sub	"5"
        cp	3+1		        ; bitsize 5-8 ?
        jr	nc,A5253	        ; nope, quit with error
        ld	b,a                     ; store number of data bits offset
        ld	d,a                     ; store number of data bits offset
        call	A530A                   ; store data mask
        ld	a,(iy+1)
        cp	"E"
        jr	z,A5255
        cp	"O"
        jr	z,A5257
        cp	"I"
        jr	z,A525B
        cp	"N"
        jr	z,A5262
A5253:	scf
        ret

A5255:	set	3,b
A5257:	set	2,b
        jr	A5262

A525B:	ld	a,b                     ; number of data bits offset
        cp	3		        ; 8 bitsize + ignore ?
        jp	z,A5253		        ; yep, not possible, quit with error
        inc	b		        ; extra bit to ignore parity
A5262:	rlc	b
        rlc	b
        ld	a,(iy+2)
        sub	"1"
        cp	2+1		        ; stopbits 1-3 ?
        jp	nc,A5253	        ; nope, quit with error
        inc	a
        rrca
        rrca
        or	b
        ld	b,a
        ld	c,0
        ld	a,(iy+3)
        cp	"X"	        	; xon/xoff handshake ?
        jr	nz,A5282	        ; no,
        set	0,c
        jr	A5287

A5282:	cp	"N"	        	; no xon/xoff handshake ?
        jp	nz,A5253        	; not either, quit with error
A5287:	ld	a,(iy+4)
        cp	"H"     		; CTR/RTS handshake ?
        jr	nz,A5292	        ; no,
        set	1,c
        jr	A5297

A5292:	cp	"N"	        	; no CTR/RTS handshake ?
        jp	nz,A5253        	; not either, quit with error
A5297:	ld	a,(iy+5)
        cp	"A"
        jr	nz,A52A2
        set	3,c	        	; auto LF receiver
        jr	A52A7

A52A2:	cp	"N"
        jp	nz,A5253                ; nope, quit with error
A52A7:	ld	a,(iy+6)
        cp	"A"
        jr	nz,A52B2
        set	2,c	        	; auto LF sender
        jr	A52B7

A52B2:	cp	"N"
        jp	nz,A5253                ; nope, quit with error
A52B7:	ld	a,(iy+7)
        cp	"S"
        jr	nz,A52C8
        ld	a,d                     ; number of data bits offset
        cp	2                       ; 7 data bits ?
        jp	nz,A5253                ; nope, quit with error
        set	4,c		        ; SI/SO control
        jr	A52CD

A52C8:	cp	"N"
        jp	nz,A5253                ; nope, quit with error
A52CD:	ld	a,c
        ld	(ix+10),a               ; store mode flags
        ld	a,002H		        ; 16x mode
        or	b
        ld	(ix+13),a	        ; update i8251 mode byte
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        call	A58E6		        ; initialize i8251
        ld	e,(iy+8)
        ld	d,(iy+9)
        call	A531E		        ; get counter value
        jr	c,A5308
        ld	c,0                     ; counter = 0
        call	A5A3F		        ; initialize i8253 counter
        ld	e,(iy+10)
        ld	d,(iy+11)
        call	A531E	        	; get counter value
        jr	c,A5308
        ld	c,1                     ; counter = 1
        call	A5A3F		        ; initialize i8253 counter
        ld	a,(iy+12)
        ld	(ix+4),a        	; timeout counter
        call	A59B2		        ; DTR on
        or	a
A5308:	pop	hl
        ret

;         Subroutine set bit mask
;            Inputs  A = number of data bits-5
;            Outputs ________________________

A530A:	push	af
        push	bc
        xor	3                       ; 8 data bits ?
        ld	c,0FFH
        jr	z,A5317                 ; yep, use 8 bit mask
        ld	b,a
A5313:	srl	c
        djnz	A5313                   ; calculate bit mask
A5317:	ld	a,c
        ld	(ix+11),a               ; store bit mask
        pop	bc
        pop	af
        ret

;         Subroutine get counter value
;            Inputs  DE = baudrate (>0) or i8253 value (<0)
;            Outputs ________________________

A531E:	push	hl
        bit	7,d
        jr	z,A5330
        ld	a,e
        and	d
        inc	a
        jr	z,A534C
        ld	hl,0
        sbc	hl,de
        ex	de,hl
        jr	A534B

A5330:	ld	hl,T534F
A5333:	ld	c,(hl)
        inc	hl
        ld	b,(hl)
        inc	hl
        ld	a,b
        or	c
        jr	z,A534C
        push	hl
        ld	l,e
        ld	h,d
        or	a
        sbc	hl,bc
        pop	hl
        jr	z,A5348
        inc	hl
        inc	hl
        jr	A5333

A5348:	ld	e,(hl)
        inc	hl
        ld	d,(hl)
A534B:	scf
A534C:	ccf
        pop	hl
        ret

; baudrate to counter value table

T534F:	dw	50,2304
        dw	75,1536
        dw	110,1047
        dw	300,384
        dw	600,192
        dw	1200,96
        dw	1800,64
        dw	2000,58
        dw	2400,48
        dw	3600,32
        dw	4800,24
        dw	7200,16
        dw	9600,12
        dw	19200,6
        dw	0

;         Subroutine get slotid on page 1
;            Inputs  ________________________
;            Outputs ________________________

A5389:	push	bc
        push	hl
        in	a,(0A8H)
        rrca
        rrca
        and	003H
        ld	c,a
        ld	b,0
        ld	hl,EXPTBL
        add	hl,bc
        ld	a,(hl)
A5399:	and	080H
        or	c
        ld	c,a
        inc	hl
        inc	hl
        inc	hl
        inc	hl
        ld	a,(hl)
        and	00CH
        or	c
        pop	hl
        pop	bc
        ret

;         Subroutine get slotid on page 2
;            Inputs  ________________________
;            Outputs ________________________

A53A8:	in	a,(0A8H)
        rrca
        rrca
        rrca
        rrca
        and	003H
        ld	c,a
        ld	b,0
        ld	hl,EXPTBL
        add	hl,bc
        ld	a,(hl)
        and	080H
        or	c
        ld	c,a
        inc	hl
        inc	hl
        inc	hl
        inc	hl
        ld	a,(hl)
        rrca
        rrca
        and	00CH
        or	c
        ret

;         Subroutine buid slotinfo per channel table
;            Inputs  ________________________
;            Outputs ________________________

A53C7:	push	hl                      ; store BASIC pointer
        ld	a,(Y661E)
        inc	a		        ; table initalized ?
        jr	z,A53E0		        ; no, build it
        ld	hl,Y6600-2              ; MSX serial version 2.0 table
A53D1:	inc	hl
        inc	hl
        ld	a,(hl)
        or	a		        ; end of table ?
        jr	nz,A53D1	        ; no, next entry
        ld	de,(Y6680)
        sbc	hl,de
        pop	hl		        ; table still of same length ?
        ret	z		        ; yes, quit
        push	hl
A53E0:	ld	(Y6690),a	        ; number of channels = 0
        ld	hl,Y6600	        ; MSX serial version 2.0 table
        ld	de,Y661E
A53E9:	ld	a,(hl)
        or	a		        ; end of table ?
        jr	z,A5434		        ; yes, finish it
        cp	0FFH		        ; special marker ?
        jr	nz,A5405	        ; nope, handle version 2.0 entry
        ld	(de),a                  ; OR mask primairy slot (fake)
        inc	de
        ld	(de),a                  ; OR mask secundairy slot (fake)
        inc	de
        ld	(de),a                  ; channel offset (fake)
        inc	de		        ; special entry
        inc	hl
        inc	hl
        ld	a,(Y6690)
        ld	(Y66EB),a	        ; store version 1.0 interface channel between version 2.0 interfaces channels
        inc	a
        ld	(Y6690),a	        ; update number of channels
        jr	A53E9		        ; next entry

A5405:	and	003H
        add	a,a
        add	a,a
        add	a,a
        add	a,a
        ld	b,a		        ; OR mask primary slot for page 2
        ld	a,(hl)
        and	08CH		        ; is the slot expanded ?
        jp	p,A5415		        ; nope,
        add	a,a
        add	a,a		        ; OR mask secondary slot for page 2
        db	0DAH		        ; jp c, which is never true, skip next instruction
A5415:	ld	a,0FFH
        ld	c,a		        ; OR mask secondary slot for page 2
        inc	hl
        ld	a,(hl)		        ; number of channels
        ex	de,hl
A541B:	ld	(hl),b                  ; store OR mask primairy slot
        inc	hl
        ld	(hl),c                  ; store OR mask secundairy slot
        inc	hl
        ex	de,hl
        push	af
        sub	(hl)
        ld	(de),a                  ; store channel offset
        inc	de
        ld	a,(Y6690)
        inc	a
        ld	(Y6690),a	        ; update number of channels
        pop	af
        ex	de,hl
        dec	a
        jr	nz,A541B	        ; next channel
        ex	de,hl
        inc	hl
        jr	A53E9		        ; next entry

A5434:	dec	a
        ld	(de),a		        ; end marker
        ld	(Y6680),hl	        ; save end of table
        ld	hl,Y6690
        ld	a,(hl)		        ; number of channels
        cp	5		        ; number of channels >4 ?
        jr	c,A5443
        ld	(hl),4		        ; only 4 channels max supported
A5443:	pop	hl                      ; restore BASIC pointer
        ret

;         Subroutine enable hardware current channel on page 2
;            Inputs  ________________________
;            Outputs ________________________

A5445:	ld	a,(Y6687)	        ; current channel

;         Subroutine enable hardware channel on page 2
;            Inputs  A = channel
;            Outputs ________________________

A5448:	di
        push	de
        ld	hl,Y6691
        sub	(hl)		        ; - first channel number version 2.0 rs232
        ld	hl,(Y6695)              ; first channel interrupt masks
        jr	z,A5456		        ; first channel, extra i/o space bit
        ld	hl,(Y6697)	        ; next channel interrupt masks
A5456:	ld	(Y6693),hl              ; set current channel interrupt masks
        ld	hl,Y661E
        ld	c,a
        add	a,a
        add	a,c		        ; *3
        add	a,l
        ld	l,a
        ld	b,(hl)		        ; primary slot mask
        inc	hl
        ld	c,(hl)		        ; secundairy slot mask
        inc	hl
        ld	l,(hl)		        ; channel offset
        in	a,(0A8H)
        and	0CFH                    ; primairy slot register without page 2
        or	b
        out	(0A8H),a                ; switch hardware in page 2
        bit	7,c                     ; hardware in secundairy slot ?
        jp	nz,A5497                ; nope, set channel info and quit
        ld	d,a                     ; store soll primairy slot register value
        and	03FH
        ld	e,a                     ; store primairy slot register without page 3
        ld	a,b
        rlca
        rlca                            ; primairy slot mask page 3
        or	e
        out	(0A8H),a                ; switch slot in page 2 and 3
        ld	a,(YFFFF)
        cpl
        and	0CFH
        or	c
        ld	(YFFFF),a               ; switch secundairy slot in page 2
        ld	e,a                     ; store secundairy slot register value
        ld	a,d
        out	(0A8H),a                ; switch slot in page 2 (restore page 3)
        ld	a,b
        rlca
        rlca
        rlca
        rlca                            ; primairy slot mask to b1,b0 (primairy slot)
        ld	d,l                     ; store channel offset
        add	a,LOW SLTTBL
        ld	l,a
        ld	h,HIGH SLTTBL
        ld	(hl),e                  ; update SLTTBL
        ld	l,d                     ; restore channel offset
A5497:	ld	a,l
        call	A42BF		        ; set channelinfo
        pop	de
        ret

;         Subroutine restore slotid on page 2
;            Inputs  slotid on stack
;            Outputs ________________________

A549D:	di
        exx
        pop	hl                      ; return address from stack
        pop	bc                      ; stored slotid
        push	hl                      ; return address on stack
        push	af
        ld	a,b
        and	083H                    ; expanded slot ?
        jp	m,A54B8                 ; yep, handle expanded slot
        add	a,a
        add	a,a
        add	a,a
        add	a,a
        ld	b,a                     ; primairy slot in b5,b4
        in	a,(0A8H)
        and	0CFH
        or	b
        out	(0A8H),a                ; switch primairy slot in page 2
        pop	af
        exx
        ret

A54B8:	ld	a,b
        and	003H                    ; primairy slot
        add	a,LOW SLTTBL
        ld	l,a
        ld	h,HIGH SLTTBL
        ld	a,b                     ; slotid
        add	a,a
        add	a,a
        ld	e,a                     ; secundairy slot in b5,b4
        and	00CH
        add	a,a
        add	a,a
        ld	b,a                     ; primairy slot in b5,b4
        ld	a,e
        and	030H
        ld	c,a                     ; requested secundairy slot
        ld	a,(hl)
        and	030H                    ; current secundairy slot on page 2
        cp	c                       ; same as requested secundairy slot ?
        jr	nz,A54DD                ; nope, update secundairy slot register
        in	a,(0A8H)
        and	0CFH
        or	b
        out	(0A8H),a                ; switch primairy slot in page 2
        pop	af
        exx
        ret

A54DD:	in	a,(0A8H)
        and	0CFH
        or	b
        ld	d,a                     ; soll primairy slot register value
        and	03FH
        ld	e,a                     ; store primairy slot register value without page 3
        ld	a,b
        rlca
        rlca                            ; primairy slot also on page 3
        or	e
        out	(0A8H),a                ; switch primairy slot in page 2 and 3
        ld	a,(YFFFF)
        cpl
        and	0CFH
        or	c
        ld	(YFFFF),a               ; switch secundairy slot in page 2
        ld	e,a                     ; store secundairy slot register value
        ld	a,d                     ; soll primairy slot register value
        out	(0A8H),a                ; switch primairy slot in page 2 (restore page 3)
        ld	(hl),e                  ; update SLTTBL
        pop	af
        exx
        ret

;         Subroutine enable RS232 interrupts
;            Inputs  ________________________
;            Outputs ________________________

A54FE:	push	af
        push	hl
        ld	a,(Y6693)               ; interrupt mask = enable Rx RS232 interrupts
        jr	A550A

;         Subroutine disable RS232 interrupts
;            Inputs  ________________________
;            Outputs ________________________

A5505:	push	af
        push	hl
        ld	a,(Y6694)               ; interrupt mask = disable Rx RS232 interrupts
A550A:	ld	hl,(Y668B)	        ; memorymapped address of current channel
        inc	hl
        ld	(hl),a		        ; write interruptmask register
        pop	hl
        pop	af
        ret

;         Subroutine interrupt handler
;            Inputs  ________________________
;            Outputs ________________________

T5512:	call	A559B                   ; RS232 interrupt handler
        jp	Y66A3		        ; cascade to old interrupt handler

;         Subroutine get number of bytes in receive buffer (include backup byte)
;            Inputs  ________________________
;            Outputs ________________________

A5518:	ld	a,(ix+5)                ; number of bytes in receive buffer
        push	bc
        ld	b,a
        ld	a,(ix+1)                ; backup byte
        or	a		        ; valid backup byte ?
        jr	z,A5525                 ; nope,
        ld	a,1		        ; yes, add 1 extra
A5525:	add	a,b
        pop	bc
        ret

;         Subroutine wait for received byte
;            Inputs  ________________________
;            Outputs ________________________

A5528:	push	hl
        push	de
        push	bc
A552B:	ei
        nop
        nop
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A48A1		        ; check if ctrl-stop pressed
        jr	c,A5593		        ; yep,
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        ld	a,(ix+5)
        or	a                       ; receive buffer empty ?
        jr	nz,A5564                ; nope,
        call	A596E		        ; RTS on
        call	A569F		        ; signal sender to resume sending
        jr	c,A5593                 ; aborted by CTRL-STOP,
        jr	z,A5593                 ; timeout,
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        jr	A552B

A5564:	cp	3
        jr	nc,A5572
        call	A596E		        ; RTS on
        call	A569F		        ; signal sender to resume sending
        jr	c,A5593                 ; aborted by CTRL-STOP,
        jr	z,A5593                 ; timeout,
A5572:	dec	(ix+5)                  ; update bytes in receive buffer
        call	A567D		        ; get pointer in receiver buffer and update get pointer
        ld	c,(hl)		        ; received byte
        ld	b,080H
        inc	hl
        ld	a,(hl)		        ; received byte status
        ld	(ix+8),a                ; update receive status
        or	a		        ; error receiving it ?
        jr	z,A5584
        inc	b		        ; yep, flag it
A5584:	ld	a,c
        or	a
        dec	b
A5587:	call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ei
        pop	bc
        pop	de
        pop	hl
        ret

A5593:	push	af
        pop	bc
        res	7,c
        push	bc
        pop	af
        jr	A5587

;         Subroutine rs232 interrupt handler
;            Inputs  ________________________
;            Outputs ________________________

A559B:	ld	a,(Y661E)
        inc	a		        ; table initalized ?
        ret	z		        ; no, quit
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        ld	a,(Y6691)
        ld	d,a		        ; first channel number version 2.0 rs232
        ld	e,0
A55B2:	ld	a,d
        ld	hl,Y664B
        add	a,l
        ld	l,a
        ld	a,(hl)		        ; mode
        or	a                       ; channel open ?
        jr	z,A55C5		        ; nope,
        ld	a,d                     ; channel
        call	A5448		        ; enable hardware channel on page 2
        ld	a,(hl)
        and	002H		        ; RxRDY ?
        jr	nz,A55D5	        ; yes, receive
A55C5:	inc	d
        inc	e
        ld	a,(Y6690)	        ; number of channels
        cp	e
        jr	nz,A55B2
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ret

A55D5:	call	A55E0
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ret

A55E0:	dec	hl
        ld	a,(hl)		        ; received byte
        inc	hl
        and	(ix+11)	                ; mask off unused bits
        ld	c,a
        ld	a,(hl)
        and	038H		        ; any errors ?
        jp	z,A55F5		        ; nope,
        push	af
        ld	a,(ix+12)               ; last i8251 command byte
        or	010H		        ; ER (reset errors)
        ld	(hl),a
        pop	af
A55F5:	ld	b,a
        or	a		        ; any errors ?
        jr	nz,A5613	        ; yep,
        ld	a,c
        cp	011H		        ; XON char ?
        jr	z,A5608		        ; yep,
        cp	013H		        ; XOFF char ?
        jr	nz,A5623                ; nope,
        set	2,(ix+9)	        ; set XOFF flag
        jr	A560C

A5608:	res	2,(ix+9)	        ; reset XOFF flag
A560C:	bit	0,(ix+10)	        ; XON/XOFF handshake ?
        ret	nz		        ; yep, quit
        jr	A5623

A5613:	and	020H		        ; framing error ?
        jr	z,A563B		        ; nope,
        ld	a,c
        or	a		        ; zero byte ?
        jr	nz,A563B                ; nope,
        set	4,(ix+9)
        ld	b,0
        jr	A563B

A5623:	bit	4,(ix+10)	        ; SI/SO control ?
        jr	z,A563B		        ; nope,
        ld	a,c
        sub	00FH		        ; SI ?
        jr	nz,A5633                ; nope,
        res	7,(ix+9)	        ; yes, reset flag
        ret

A5633:	inc	a		        ; SO ?
        jr	nz,A563B                ; nope,
        set	7,(ix+9)	        ; yes, set flag
        ret

A563B:	ld	a,(ix+5)
        and	a                       ; receive buffer full ?
        ret	m                       ; yep, quit
        inc	(ix+5)                  ; update number of bytes in receive buffer
        call	A568E		        ; put pointer in receiver buffer and update put pointer
        bit	4,(ix+10)	        ; SI/SO control ?
        ld	a,c
        jr	z,A5659		        ; no,
        cp	020H
        jr	c,A5659		        ; control char, do not modify
        bit	7,(ix+9)
        jr	z,A5659
        or	080H		        ; SO, set bit 7 = 1
A5659:	ld	(hl),a                  ; put received byte in buffer
        ld	a,(ix+5)
        and	a                       ; receiver buffer full ?
        jp	p,A5663                 ; nope,
        set	7,b
A5663:	cp	96		        ; buffer filled with more than 96 bytes ?
        call	nc,A56B5	        ; yep, signal sender to stop sending
        ld	a,b
        inc	hl
        ld	(hl),a		        ; put received byte status in buffer
        or	a		        ; errors ?
        ret	nz		        ; yep, quit
        ld	a,(ix+10)
        bit	3,a		        ; auto LF receiver ?
        ret	z		        ; nope, quit
        dec	hl
        ld	a,(hl)
        cp	00DH		        ; CR ?
        ret	nz		        ; nope, quit
        ld	bc,0000AH
        jr	A563B		        ; 'receive' LF

;         Subroutine get pointer in receiver buffer and update get pointer
;            Inputs  ________________________
;            Outputs ________________________

A567D:	ld	hl,(Y668D)	        ; receivebuffer
        ld	a,(ix+6)                ; get offset in receive buffer
        add	a,a
        ld	l,a                     ; pointer
        inc	(ix+6)                  ; update get offset in receive buffer
        ret	p                       ; not past end, quit
        ld	(ix+6),0                ; get offset in receive buffer = 0
        ret

;         Subroutine put pointer in receiver buffer and update put pointer
;            Inputs  ________________________
;            Outputs ________________________

A568E:	ld	hl,(Y668D)	        ; receivebuffer
        ld	a,(ix+7)                ; put offset in receive buffer
        add	a,a
        ld	l,a                     ; pointer
        inc	(ix+7)                  ; update put offset in receive buffer
        ret	p                       ; not past end, quit
        ld	(ix+7),0                ; get offset in receive buffer = 0
        ret

;         Subroutine signal sender to resume sending
;            Inputs  ________________________
;            Outputs ________________________

A569F:	ld	a,(ix+9)
        bit	1,a		        ; XOFF status ?
        jr	nz,A56A9	        ; yes, send XON
        xor	a
        inc	a
        ret
;
A56A9:	ld	c,011H		        ; XON
        call	A56CD                   ; send XON/XOFF (if XON/XOFF handshake is enabled)
        ret	c
        ret	z
        res	1,(ix+9)
        ret

;         Subroutine signal sender to stop sending
;            Inputs  ________________________
;            Outputs ________________________

A56B5:	xor	a
        inc	a
        ld	a,(ix+9)
        bit	1,a		        ; already XOFF ?
        ret	nz		        ; yes, quit
        set	1,(ix+9)
        ld	c,013H		        ; XOFF
        call	A56CD		        ; send XON/XOFF (if XON/XOFF handshake is enabled)
        call	A5A12		        ; wait for empty transmitter
        call	A5976		        ; RTS off
        ret

;         Subroutine send XON/XOFF (if XON/XOFF handshake is enabled)
;            Inputs  ________________________
;            Outputs ________________________

A56CD:	ld	a,(ix+10)
        bit	0,a		        ; XON/XOFF handshake ?
        jr	nz,A56D7	        ; yes, send handshake char
        xor	a
        inc	a
        ret

A56D7:	call	A5A12		        ; wait for empty transmitter
        ld	a,c
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        dec	hl
        ld	(hl),a		        ; send char
        pop	hl
        xor	a
        inc	a
        ret

;         Subroutine RS232.SNDCHR
;            Inputs  ________________________
;            Outputs ________________________

A56E5:	push	bc
        ld	c,a
        call	A56ED                   ; send byte (with auto LF, SI/SO, XON/XOFF, CTS/RTS)
        ld	a,c
        pop	bc
        ret

;         Subroutine send byte (with auto LF, SI/SO, XON/XOFF, CTS/RTS)
;            Inputs  ________________________
;            Outputs ________________________

A56ED:	push	bc
        ld	c,a
        ei
        nop
        nop
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        bit	4,(ix+10)	        ; SI/SO control ?
        jr	z,A574E		        ; nope,
        ld	a,c
        cp	020H
        jr	c,A574E		        ; control char, unmodified
        bit	0,(ix+9)
        jr	nz,A5733
        or	a
        jp	p,A574E
        ld	(Y667C),bc              ; store
        ld	c,00EH                  ; SO
        call	A577A                   ; send byte (with auto LF, XON/XOFF, CTS/RTS)
        ld	bc,(Y667C)              ; restore
        jr	c,A576C
        jr	z,A576C
        set	0,(ix+9)
        jr	A574C

A5733:	or	a
        jp	m,A574C
        ld	(Y667C),bc              ; store
        ld	c,00FH                  ; SI
        call	A577A                   ; send byte (with auto LF, XON/XOFF, CTS/RTS)
        ld	bc,(Y667C)              ; restore
        jr	c,A576C
        jr	z,A576C
        res	0,(ix+9)
A574C:	res	7,c
A574E:	ld	a,c
        jr	A5769                   ; skip


; unused code

        ei
        push	bc
        ld	c,a
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid

A5769:	call	A577A                   ; send byte (with auto LF, XON/XOFF, CTS/RTS)
A576C:	call	A58D5                   ; update error flags
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ld	a,c
        pop	bc
        ei
        ret

;         Subroutine send byte (with auto LF, XON/XOFF, CTS/RTS)
;            Inputs  ________________________
;            Outputs ________________________

A577A:	bit	2,(ix+10)	        ; auto LF sender ?
        jr	z,A5790	        	; no,
        cp	00AH		        ; LF ?
        jr	nz,A5790	        ; no,
        bit	5,(ix+9)
        jr	z,A5790
        res	5,(ix+9)
        or	a
        ret

A5790:	bit	0,(ix+10)       	; XON/XOFF handshake ?
        jr	z,A580E	        	; nope,
        bit	2,(ix+9)
        jr	z,A580E
        ld	(Y667A),hl              ; store HL
        pop	hl
        ld	(Y667E),hl              ; store return address
        ld	a,(ix+4)
        ld	h,a                     ; timeout counter
A57A7:	ld	l,100
A57A9:	call	A5A32		        ; initialize i8253 counter 2
A57AC:	call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ei
        call	A48A1		        ; check if ctrl-stop pressed
        di
        jr	nc,A57D8	        ; nope, clear to send (XON/XOFF) ?
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        scf
A57D0:	ld	hl,(Y667E)
        push	hl                      ; restore return address
        ld	hl,(Y667A)              ; restore HL
        ret

;         Subroutine clear to send (XON/XOFF) ?
;            Inputs  ________________________
;            Outputs ________________________

A57D8:	di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        bit	2,(ix+9)
        jr	z,A5807
        ld	a,(ix+4)                ; timeout counter
        or	a                       ; endless wait ?
        jr	z,A57AC                 ; yep,
        call	A5A28		        ; counter 2 finished ?
        jr	nc,A57AC	        ; no,
        or	a
        dec	l		        ; al done ?
        jr	nz,A57A9	        ; no, next loop
        dec	h
        jr	nz,A57A7
        jr	A57D0
;
A5807:	ld	hl,(Y667E)
        push	hl                      ; restore return address
        ld	hl,(Y667A)              ; restore HL
A580E:	call	A5A12		        ; wait for empty transmitter
        bit	1,(ix+10)	        ; CTS/RTS handshaking ?
        jp	z,A589A		        ; nope, continue
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        inc	hl
        ld	a,(hl)
        pop	hl
        bit	7,a		        ; CTS ?
        jr	z,A589A		        ; yep, continue
        ld	(Y667A),hl              ; store HL
        pop	hl
        ld	(Y667E),hl              ; store return address
        ld	a,(ix+4)
        ld	h,a                     ; timeout counter
A582E:	ld	l,100
A5830:	call	A5A32		        ; initialize i8253 counter 2
A5833:	call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ei
        call	A48A1		        ; check if ctrl-stop pressed
        di
        jr	nc,A585F	        ; nope,
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        scf
A5857:	ld	hl,(Y667E)
        push	hl                      ; restore return address
        ld	hl,(Y667A)              ; restore HL
        ret

A585F:	di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        inc	hl
        ld	a,(hl)
        pop	hl
        bit	7,a		        ; CTS ?
        jr	z,A5893
        ld	a,(ix+4)                ; timeout counter
        or	a                       ; endless wait ?
        jr	z,A5833                 ; yep,
        call	A5A28		        ; counter 2 finished ?
        jr	nc,A5833	        ; no,
        or	a
        dec	l
        jr	nz,A5830
        dec	h
        jr	nz,A582E
        jr	A5857

A5893:	ld	hl,(Y667E)
        push	hl                      ; restore return address
        ld	hl,(Y667A)              ; restore HL
A589A:	ld	a,c
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        dec	hl
        ld	(hl),a		        ; send byte
        pop	hl
        cp	00DH		        ; CR ?
        jr	nz,A58AC
        set	5,(ix+9)
        jr	A58B0
;
A58AC:	res	5,(ix+9)
A58B0:	xor	a
        inc	a
        ret

A58B3:	ex	af,af'
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ex	af,af'
        call	A58D5                   ; update error flags
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        ret

;         Subroutine update error flags
;            Inputs  ________________________
;            Outputs ________________________

A58D5:	ld	(ix+8),0                ; clear receive status
        jr	c,A58E1                 ; aborted, update flag
        ret	nz                      ; no timeout, quit
        set	6,(ix+8)                ; set timeout flag
        ret

A58E1:	set	2,(ix+8)                ; set aborted flag
        ret

;         Subroutine initialize i8251
;            Inputs  ________________________
;            Outputs ________________________

A58E6:	xor	a
        ld	(hl),a
        push	af
        pop	af
        ld	(hl),a
        push	af
        pop	af
        ld	(hl),a
        push	af
        pop	af
        ld	a,040H
        ld	(hl),a
        push	af
        pop	af		        ; reset i8251
        ld	a,(ix+13)               ; i8251 mode byte
        ld	(hl),a		        ; write mode
        push	af
        pop	af
        dec	hl
        ld	a,(hl)
        inc	hl
        call	A5961		        ; read status
        ld	a,007H		        ; DTR on, Receive and Transmit enable
        call	A5A21                   ; write i8251 command byte
        dec	hl
        ld	a,(hl)
        inc	hl
        jp	A5961		        ; read status

;         Subroutine RS232.SNDBRK
;            Inputs  ________________________
;            Outputs ________________________

A590C:	push	bc
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        call	A5505		        ; disable RS232 interrupts
        ld	a,(ix+12)               ; last i8251 command byte
        or	008H		        ; SBRK
        ld	b,a
A592B:	call	A48A1		        ; check if ctrl-stop pressed
        jr	c,A5945		        ; yep,
        call	A5A12		        ; wait for empty transmitter
        xor	a
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        dec	hl
        ld	(hl),a		        ; send byte (break)
        inc	hl
        ld	a,b
        call	A5A21		        ; write i8251 command byte
        pop	hl
        dec	de
        ld	a,e
        or	d
        jr	nz,A592B
A5945:	push	af
        call	A5A12		        ; wait for empty transmitter
        ld	a,b
        and	0F7H		        ; SBRK off
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        call	A5A21		        ; write i8251 command byte
        pop	hl
        call	A54FE                   ; enable RS232 interrupts
        pop	af
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	bc
        ret

A5961:	ld	a,(hl)
        and	038H                    ; any errors ?
        ret	z                       ; nope, quit
        push	af
        ld	a,(ix+12)               ; last i8251 command byte
        or	010H		        ; ER (reset errors)
        ld	(hl),a
        pop	af
        ret

A596E:	push	af
        ld	a,(ix+12)               ; last i8251 command byte
        set	5,a		        ; RTS on
        jr	A597C
;
A5976:	push	af
        ld	a,(ix+12)               ; last i8251 command byte
        res	5,a		        ; RTS off
A597C:	push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        call	A5A21		        ; write i8251 command byte
        pop	hl
        pop	af
        ret

;         Subroutine RS232.DTR
;            Inputs  ________________________
;            Outputs ________________________

A5986:	push	af
        ld	(Y667C),a               ; store
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	a,(Y667C)               ; restore
        call	A59AF
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	af
        ei
        ret

A59AF:	or	a		        ; DTR off ?
        jr	z,A59BA		        ; yep, put it off
A59B2:	push	af
        ld	a,(ix+12)               ; last i8251 command byte
        or	002H		        ; set DTR
        jr	A59C0
;
A59BA:	push	af
        ld	a,(ix+12)               ; last i8251 command byte
        and	0FDH		        ; reset DTR
A59C0:	push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        call	A5A21		        ; write i8251 command byte
        pop	hl
        pop	af
        ret

;         Subroutine RS232.STAT
;            Inputs  ________________________
;            Outputs ________________________

A59CA:	push	af
        push	de
        di
        ld	(Y6678),sp              ; store stackpointer
        ld	sp,Y67FC                ; switch to temporary stack
        push	bc
        push	hl
        call	A53A8		        ; get slotid on page 2
        push	af                      ; store slotid
        call	A5445		        ; enable hardware current channel on page 2
        pop	af                      ; restore slotid
        pop	hl
        pop	bc
        push	af                      ; store slotid
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        inc	hl
        ld	a,(hl)		        ; read rs232 system status
        ld	e,0C1H
        xor	e		        ; invert bits
        and	e		        ; mask off unused
        ld	e,a
        dec	hl
        ld	a,(hl)
        and	080H		        ; DSR status
        jr	z,A59F3
        set	3,e		        ; set DSR flag
A59F3:	di
        ld	a,(ix+9)
        bit	4,a
        jr	z,A5A02
        set	2,e
        res	4,a
        ld	(ix+9),a
A5A02:	ld	a,(ix+8)
        ld	h,a                     ; receive status in b15-b8
        ld	l,e
        call	A549D		        ; restore slotid on page 2
        ld	sp,(Y6678)              ; restore stackpointer
        pop	de
        pop	af
        ei
        ret

;         Subroutine wait for empty transmitter
;            Inputs  ________________________
;            Outputs ________________________

A5A12:	push	af
        push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
A5A17:	ld	a,(hl)
        and	005H
        cp	005H
        jr	nz,A5A17	        ; wait until transmitter is empty
        pop	hl
        pop	af
        ret

;         Subroutine write i8251 command byte
;            Inputs  ________________________
;            Outputs ________________________

A5A21:	ld	(hl),a
        ld	(ix+12),a               ; update last i8251 command byte
        push	af
        pop	af
        ret

;         Subroutine counter 2 finished ?
;            Inputs  ________________________
;            Outputs ________________________

A5A28:	push	hl
        ld	hl,(Y668B)	        ; memorymapped address of current channel
        inc	hl
        ld	a,(hl)
        pop	hl
        rlca
        rlca
        ret

;         Subroutine initialize i8253 counter 2
;            Inputs  ________________________
;            Outputs ________________________

A5A32:	push	af
        push	bc
        push	de
        push	hl
        ld	b,030H		        ; LSB/MSB, mode 0 (down counter), binary
        ld	c,2		        ; counter 2
        ld	de,04800H
        jr	A5A45

;         Subroutine initialize i8253 counter
;            Inputs  C = counter, DE = counter value
;            Outputs ________________________

A5A3F:	push	af
        push	bc
        push	de
        push	hl
        ld	b,036H		        ; LSB/MSB, mode 3 (square wave), binary
A5A45:	ld	hl,(Y668B)	        ; memorymapped address of current channel
        inc	hl
        inc	hl
        inc	hl
        push	hl
        inc	hl
        inc	hl
        inc	hl
        ex	(sp),hl
        push	bc
        ld	b,0
        add	hl,bc
        pop	bc
        ex	(sp),hl
        ld	a,c
        rrca
        rrca
        or	b
        ld	(hl),a
        pop	hl
        ld	(hl),e
        ld	(hl),d
        pop	hl      
        pop	de
        pop	bc
        pop	af
        ret

        defs	06000H-$,0FFH
        
        end
