; Diskdriver Philips NMS8250/NMS8245 (internal floppydisk controller)
; FDC	WD2793

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by Philips and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders

BASENT  EQU     4022H
BDOS    EQU     0F37DH
SECLEN  EQU     512
MYSIZE	EQU	8
                                ; +0    disk motor timer
                                ; +1    disk change timer drive 0
                                ; +2    disk change timer drive 1
                                ; +3    current physical drive
                                ; +4    saved current track physical drive 0
                                ; +5    saved current track physical drive 1
                                ; +6    current phantom drive (used with 1 physical drive)
                                ; +7    number of physical drives

D7FF8	EQU	07FF8H			; WD2793
D7FF9	EQU	D7FF8+1			; WD2793
D7FFA	EQU	D7FF8+2			; WD2793
D7FFB	EQU	D7FF8+3			; WD2793
D7FFC	EQU	07FFCH			; side select
D7FFD	EQU	D7FFC+1			; motor/in use/drive select
D7FFF	EQU	D7FFC+3			; IRQ,DRQ

DBFF8	EQU	D7FF8+4000H		; FDC mirror in page 2

?.7405:	DEFB	7

I$7406:	DEFB	0F8h		; Media F8
        DEFW	512		; 80 Tracks
        DEFB	0Fh		; 9 sectors
        DEFB	04h		; 1 side
        DEFB	01h		; 3.5" 360 Kb
        DEFB	02h
        DEFW	1
        DEFB	2
        DEFB	112
        DEFW	12
        DEFW	355
        DEFB	2
        DEFW	5

DEFDPB  EQU     $-1

        DEFB	0F9h		; Media F9
        DEFW	512		; 80 Tracks
        DEFB	0Fh		; 9 sectors
        DEFB	04h		; 2 sides
        DEFB	01h		; 3.5" 720 Kb
        DEFB	02h
        DEFW	1
        DEFB	2
        DEFB	112
        DEFW	14
        DEFW	714
        DEFB	3
        DEFW	7

        DEFB	0FAh		; Media FA
        DEFW	512		; 80 Tracks
        DEFB	0Fh		; 8 sectors
        DEFB	04h		; 1 side
        DEFB	01h		; 3.5" 320 Kb
        DEFB	02h
        DEFW	1
        DEFB	2
        DEFB	112
        DEFW	10
        DEFW	316
        DEFB	1
        DEFW	3

        DEFB	0FBh		; Media FB
        DEFW	512		; 80 Tracks
        DEFB	0Fh		; 8 sectors
        DEFB	04h		; 2 sides
        DEFB	01h		; 3.5" 640 Kb
        DEFB	02h
        DEFW	1
        DEFB	2
        DEFB	112
        DEFW	12
        DEFW	635
        DEFB	2
        DEFW	5

;	  Subroutine DSKIO
;	     Inputs  ________________________
;	     Outputs ________________________

DSKIO:
C.744E:	EI
        PUSH	AF
        JP	NC,J$75B2		; read

; DSKIO write

        PUSH	AF
        LD	A,(RAWFLG)
        OR	A			; verify on ?
        JR	Z,J$7474		; nope, just write
        POP	AF
        PUSH	AF
        PUSH	BC
        PUSH	DE
        PUSH	HL
        CALL	C.7499			; write sectors
        POP	HL
        POP	DE
        POP	BC
        JR	C,J$7470		; error, finish
        CALL	C.7851			; reset FDC
        POP	AF
        CALL	C$756A			; verify sectors
        JR	J.7478			; DSKIO finish

J$7470:	POP	IY			; cleanup stack
        JR	J.7478			; DSKIO finish

J$7474:	POP	AF
        CALL	C.7499			; write sectors

; DSKIO finish

J.7478:	EI
        CALL	ENAINT			; enable interrupts
        POP	DE			; discard stack
J.747D:	PUSH	AF
        LD	C,50
        JR	NC,J$7484		; no error, no diskchange for 1 second
        LD	C,0			; error, diskchange unknown
J$7484:	CALL	C.7851			; reset FDC
        LD	(IX+0),3*50		; motor off timer = 3 seconds
        LD	A,D
        AND	A			; drive 0 ?
        JR	NZ,J$7494		; nope, set diskchange counter for drive 1
        LD	(IX+1),C		; set diskchange counter for drive 0
        POP	AF
        RET

J$7494:	LD	(IX+2),C		; set diskchange counter for drive 1
        POP	AF
        RET

;	  Subroutine write sectors
;	     Inputs  ________________________
;	     Outputs ________________________

C.7499:	CALL	C.76BE			; prepare for disk operation
        RET	C
        CALL	DISINT
        DI				; disable interrupts
J$74A1:	BIT	7,H			; transfer from page 2 or 3 ?
        JR	NZ,J.74CE		; yep, direct transfer
        CALL	C$7DB1			; install write sectors code in $SECBUF
        CALL	C.7D4C			; start routine in $SECBUF
        RET	C                       ; error, quit with error
        INC	B
        DEC	B			; all done ?
        RET	Z			; yep, quit
        CALL	DISINT
        DI				; disable interrupts
        BIT	7,H			; rest of the transfer from page 2 or 3 ?
        JR	NZ,J.74CE		; yep, direct transfer
        PUSH	HL
        PUSH	DE
        PUSH	BC
        LD	DE,($SECBUF)
        PUSH	DE
        LD	BC,SECLEN
        CALL	XFER			; transfer to $SECBUF
        POP	HL
        POP	BC
        POP	DE
        CALL	C.74D9			; write sector from $SECBUF
        POP	HL
        JR	J$74D1

J.74CE:	CALL	C.74D9			; write sector
J$74D1:	RET	C
        DEC	B			; all done ?
        RET	Z			; yep, quit
        CALL	C.77AD			; prepare for next sector
        JR	J$74A1			; next

;	  Subroutine write sector
;	     Inputs  ________________________
;	     Outputs ________________________

C.74D9:	LD	E,11
Y0061:
J$74DB:	CALL	C.7801			; wait for FDC
        LD	A,0A0H
        BIT	6,D
        JR	Z,J.74EC
        OR	02H
        BIT	0,D
        JR	Z,J.74EC
        OR	08H
J.74EC:	PUSH	HL
        PUSH	DE
        PUSH	BC
Y0075:  LD	DE,I$7505
        PUSH	DE			; resume here after IRQ
Y0079:  LD	BC,D7FFF
Y007C:  LD	(D7FF8),A		; start write command
J.74F9:	LD	A,(BC)
        ADD	A,A			; IRQ ?
        RET	P			; yep, quit
        JR	C,J.74F9		; no DRQ, wait
        LD	A,(HL)
Y0085:  LD	(D7FFB),A		; write data
        INC	HL
        JR	J.74F9			; next

Y008B:
I$7505:	POP	BC
        POP	DE
        POP	HL
Y008E:  LD	A,(D7FF8)
        AND	0FCH			; read status bits
Y0093:  CALL	C$7808			; wait 1.2 ms
        JR	NZ,J$751F		; error,
        BIT	7,H			; next transfer from page 2 or 3 ?
        JR	NZ,J.7567		; yep, quit
        DEC	B			; all done ?
        JR	Z,J.7567		; yep, quit
Y009F:  CALL	C.77AD			; prepare for next sector
Y00A2:  JP	0			; ?

J$751F:	BIT	6,A			; WP bit set ?
        JR	NZ,J.7549		; yep, check if WP set from write proctected disk
        PUSH	AF
Y00AA:  CALL	C.77E8			; reseek
        POP	AF
        DEC	E
        JR	NZ,J$74DB		; next try
        SCF
        LD	E,A
        BIT	7,E
        LD	A,2
        JR	NZ,J.7567		; not ready, return NOT READY
J$7533:	BIT	5,E
        LD	A,10
        JR	NZ,J.7567
        BIT	4,E
        LD	A,8
        JR	NZ,J.7567
        BIT	3,E
        LD	A,4
        JR	NZ,J.7567
        LD	A,12
        JR	J.7567

J.7549:	LD	A,80H
Y00D1:  LD	(D7FF8),A		; start read command
Y00D4:  LD	HL,D7FFF
        LD	DE,0			; wait max. 1172 ms for IRQ or DRQ
J$7554:	LD	A,(HL)
        RLCA				; DRQ ?
        JR	C,J.7565		; nope, WP valid, return WRITE PROTECT
        RLCA				; IRQ ?
        JR	NC,J.7565		; yep, WP valid, return WRITE PROTECT
        DEC	DE
        LD	A,E
        OR	D
        JR	NZ,J$7554		; wait
        LD	A,2
        SCF
        JR	J.7567			; return NOT READY

J.7565:	XOR	A
        SCF
Y00ED:
J.7567:	RET
        NOP
        NOP

S74D9   EQU     $-C.74D9

;	  Subroutine verify sectors
;	     Inputs  ________________________
;	     Outputs ________________________

C$756A:	CALL	C.76BE			; prepare for disk operation
        RET	C
        CALL	DISINT
        DI				; disable interrupts
J$7572:	BIT	7,H			; transfer from page 2 or 3 ?
        JR	NZ,J.75A5		; yep, verify direct
        CALL	C$7DC9			; install verify sectors code in $SECBUF
        LD	E,80H
        CALL	C.7D4C			; start routine in $SECBUF
        RET	C
        INC	B
        DEC	B			; all done ?
        RET	Z			; yep, quit
        CALL	DISINT
        DI				; disable interrupts
        BIT	7,H			; rest of verify in page 2 or 3 ?
        JR	NZ,J.75A5		; yep, verify direct
        PUSH	HL
        PUSH	DE
        PUSH	BC
        LD	DE,($SECBUF)
        LD	BC,SECLEN
        CALL	XFER			; transfer to $SECBUF
        POP	BC
        POP	DE
        LD	HL,($SECBUF)
        LD	E,80H			; verify
        CALL	C.7603			; read/verify sector
        POP	HL
        RET	C
        JR	J$75AB

J.75A5:	LD	E,80H			; verify
        CALL	C.7603			; read/verify sector
        RET	C
J$75AB:	DEC	B			; all done ?
        RET	Z			; yep, quit
        CALL	C.77AD			; prepare for next sector
        JR	J$7572			; next

;	  Subroutine DSKIO read
;	     Inputs  ________________________
;	     Outputs ________________________

J$75B2:	CALL	C$75B8			; read sectors
        JP	J.7478			; DSKIO finish

;	  Subroutine read sectors
;	     Inputs  ________________________
;	     Outputs ________________________

C$75B8:	CALL	C.76BE			; prepare for disk operation
        RET	C

;	  Subroutine read sectors (without selecting drive and track)
;	     Inputs  ________________________
;	     Outputs ________________________

C$75BC:	CALL	DISINT
        DI
J$75C0:	BIT	7,H			; transfer to page 2 or 3 ?
        JR	NZ,J.75F6		; yep, read direct
        CALL	C.7DEC			; install read sectors code in $SECBUF
        LD	E,11			; read, 11 tries
        CALL	C.7D4C			; start routine in $SECBUF
        RET	C
        INC	B
        DEC	B			; all done ?
        RET	Z			; yep, quit
        CALL	DISINT
        DI				; disable interrupts
        BIT	7,H			; rest of the read to page 2 or 3 ?
        JR	NZ,J.75F6		; yep, read direct
        PUSH	HL
        LD	HL,($SECBUF)
        LD	E,11			; read, 11 tries
        CALL	C.7603			; read/verify sector
        POP	HL
        RET	C
        PUSH	HL
        PUSH	DE
        PUSH	BC
        EX	DE,HL
        LD	HL,($SECBUF)
        LD	BC,SECLEN
        CALL	XFER			; copy from $SECBUF to transfer
        POP	BC
        POP	DE
        POP	HL
        AND	A			; no error (??????)
        JR	J$75FC

J.75F6:	LD	E,11			; read, 11 tries
        CALL	C.7603			; read/verify sector
        RET	C
J$75FC:	DEC	B			; all done ?
        RET	Z			; yep, quit
        CALL	C.77AD			; prepare for next sector
        JR	J$75C0			; next

;	  Subroutine read/verify sector
;	     Inputs  ________________________
;	     Outputs ________________________

X005F:
C.7603:	CALL	C.7801			; wait for FDC
        LD	A,80H
        BIT	6,D
        JR	Z,J.7614
        OR	02H
        BIT	0,D
        JR	Z,J.7614
        OR	08H
J.7614:	PUSH	HL
        PUSH	DE
        PUSH	BC
X0073:  LD	BC,I$7652
        PUSH	BC			; resume here after IRQ
X0077:  LD	BC,D7FFF
        BIT	7,E			; read or verify ?
X007C:  JR	NZ,J$768E		; verify,
X007E:  LD	(D7FF8),A		; start read command
        LD	DE,05D00H		; wait max. 300 ms for DRQ
J.7628:	LD	A,(BC)
        ADD	A,A			; DRQ ?
        JR	NC,J.7647		; yep, go!
        RET	P			; IRQ, finish
        DEC	E
        JR	NZ,J.7628
        LD	A,(BC)
        ADD	A,A			; DRQ ?
        JR	NC,J.7647		; yep, go!
        RET	P			; IRQ, finish
        DEC	D
        JR	NZ,J.7628
        LD	A,2			; NOT READY
        POP	BC
        POP	BC
        POP	DE
        POP	HL
        SCF
X009B:  JP	J.768B			; quit

J.7642:	LD	A,(BC)
        ADD	A,A			; IRQ ?
        RET	P			; yep, quit
        JR	C,J.7642		; no DRQ, wait
X00A3:
J.7647:	LD	A,(D7FFB)               ; read data
X00A6:
        LD	(HL),A			; to transfer address
        INC	HL
        JR	J.7642			; next

S00A6   EQU     $-X00A6

        DEFS    4,0                     ; space for verify routine modification

X00AE:
I$7652:	POP	BC
        POP	DE
        POP	HL
X00B1:  LD	A,(D7FF8)
        AND	9CH			; read status bits
        JR	NZ,J$7669		; error,
        BIT	7,H			; next transfer to page 2 or 3 ?
        JR	NZ,J.768B		; yep, quit
        DEC	B			; all done ?
        JR	Z,J.768B		; yep, quit
X00BF:  CALL	C.77AD			; prepare for next sector
X00C2:  JP	0

J$7669:	BIT	7,E			; verify ?
        JR	NZ,J$7675		; yep, no retry
        PUSH	AF
X00CA:  CALL	C.77E8			; reseek
        POP	AF
        DEC	E
        JR	NZ,C.7603		; next try
J$7675:	SCF
        LD	E,A
        BIT	7,E			; drive not ready ?
        LD	A,2
        JR	NZ,J.768B		; yep, NOT READY
        BIT	4,E
        LD	A,8
        JR	NZ,J.768B
        BIT	3,E
        LD	A,4
        JR	NZ,J.768B
        LD	A,12
X00E7:
J.768B:	RET

S00E7   EQU     $-X00E7

        DEFS    3-1,0

S7603   EQU     $-C.7603

; verify sector

J$768E:	LD	(D7FF8),A		; start read command
        LD	DE,5D00H		; wait max. 300 ms for DRQ
J.7694:	LD	A,(BC)
        ADD	A,A			; DRQ ?
        JR	NC,J.76B3		; yep, go!
        RET	P			; IRQ, quit
        DEC	E
        JR	NZ,J.7694
        LD	A,(BC)
        ADD	A,A			; DRQ ?
        JR	NC,J.76B3		; yep, go!
        RET	P			; IRQ, quit
        DEC	D
        JR	NZ,J.7694
        LD	A,2			; NOT READY
J$76A6:	POP	BC
        POP	BC
        POP	DE
        POP	HL
        SCF
        JP	J.768B			; quit

J.76AE:	LD	A,(BC)
        ADD	A,A			; IRQ ?
        RET	P			; yep, quit
        JR	C,J.76AE		; no DRQ, wait
J.76B3:	LD	A,(D7FFB)
I$76B6:	CP	(HL)			; compare data
        INC	HL
        JR	Z,J.76AE		; equal, continue
        LD	A,10
        JR	J$76A6			; VERIFY ERROR

S76B6   EQU     $-I$76B6

;	  Subroutine prepare for disk operation
;	     Inputs  ________________________
;	     Outputs ________________________

C.76BE:	PUSH	AF
        PUSH	BC
        PUSH	HL
        CALL	GETWRK			; GETWRK
        POP	HL
        POP	BC
        POP	AF
        CP	1+1			; driveid valid ?
        JR	C,J$76CF		; yep, continue
J$76CB:	LD	A,12			; nope, OTHER ERROR
        SCF
        RET

J$76CF:	PUSH	AF
        LD	A,C
        CP	0F8H			; mediadescriptor 0F8H-0FFH ?
        JR	C,J$76D9		; nope, quit
        CP	0FCH			; mediadescriptor 0F8H-0FBH ?
        JR	C,J$76DC		; yep, continue
J$76D9:	POP	AF
        JR	J$76CB

J$76DC:	EX	(SP),HL
        PUSH	HL
        PUSH	BC
        CALL	C.7801			; wait for FDC
        BIT	1,C			; 9 sectors per track ?
        LD	C,E
        LD	B,D
        LD	DE,8
        JR	NZ,J$76EC		; nope, 8 sectors per track
        INC	E			; yep, 9 sectors per track
J$76EC:	CALL	DIV16			; sector/sectors per track
        LD	A,L
        INC	A			; records are 1 based
        LD	(D7FFA),A		; select record
        LD	L,C
        POP	BC
        POP	AF
        LD	H,A
        XOR	A
        BIT	0,C			; double sided media ?
        JR	Z,J.7702		; nope, cylinder = track, side 0
        SRL	L			; cylinder = track/2
        JR	NC,J.7702		; even track, side 0
        INC	A			; odd track, side 1
J.7702:	LD	(D7FFC),A		; select side
        LD	D,A
        LD	A,(IX+7)
        DEC	A			; 1 physical drive ?
        JR	Z,J$770D		; yep, use drive 0
        LD	A,H
J$770D:	OR	0C4H			; motor on, in use, set b2
        PUSH	AF
        LD	A,C
        RRCA
        RRCA
        AND	0C0H			; media bit in b7,b6
        OR	D
        LD	D,A			; current side in b0
        LD	C,L			; current cylinder
        LD	A,(IX+7)
        DEC	A			; 1 physical drive ?
        JR	Z,J$7741		; yep, phantom check
        LD	A,(IX+3)
        CP	H			; same drive as last ?
        JR	Z,J.7758		; yep, no need to update the cylinder register
        XOR	01H
        LD	(IX+3),A		; new last drive
        LD	A,(D7FF9)		; cylinder register
        JR	Z,J$7736		; new last drive = drive 0, save cylinder drive 1
        LD	(IX+4),A		; save cylinder drive 0
        LD	A,(IX+5)
        JR	J$773C			; set cylinder register with cylinder drive 1

J$7736:	LD	(IX+5),A		; save cylinder drive 1
        LD	A,(IX+4)		; set cylinder register with cylinder drive 0
J$773C:	LD	(D7FF9),A
        JR	J.7758			; skip prompt

J$7741:	LD	A,(IX+6)
        CP	H			; same logical drive as last ?
        LD	(IX+6),H		; new last drive
        JR	Z,J.7758		; yep, skip prompt
        PUSH	IX
        PUSH	DE
        PUSH	BC
        CALL	C$7847			; motor off (set motor off timer = finished)
        CALL	PROMPT			; prompt
        POP	BC
        POP	DE
        POP	IX
J.7758:	POP	AF
        PUSH	BC
        PUSH	AF
        DI
        LD	A,(D7FF8)
        AND	80H
        LD	B,A			; READY signal from drive in b7
        XOR	A
        CP	(IX+0)                  ; motor off timer finished ?
        RLA
        OR	B
        LD	B,A                     ; in b0
        POP	AF
        LD	(D7FFD),A		; motor on, in use, set b2, select drive
        LD	(IX+0),0FFH		; disable motor off counter
        EI
        LD	A,(D7FF9)
        CP	C			; drive on requested cylinder ?
        CALL	NZ,C$77EE		; nope, seek to cylinder
        BIT	0,B			; motor off timer finished ?
        JR	NZ,J$7785		; nope, check if drive is ready
        BIT	7,B			; FDD READY ?
        JR	Z,J$7798		; yep, wait 1000 ms (motor spinup time) and quit
        LD	B,100
        JR	J.778C			; check if drive is ready in 1000 ms

J$7785:	LD	B,1
        JR	J.778C			; FDD READY

J$7789:	CALL	C.77A2			; wait 10 ms
J.778C:	LD	A,(D7FF8)
        RLA
        JR	NC,J.779F
        DJNZ	J$7789
        LD	A,2			; NOT READY
        JR	J.779F

J$7798:	LD	B,100
J$779A:	CALL	C.77A2			; wait 10 ms
        DJNZ	J$779A
J.779F:	POP	BC
        POP	HL
        RET

;	  Subroutine wait 10 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C.77A2:	PUSH	HL
        LD	HL,1190
J$77A6:	DEC	HL
        LD	A,H
        OR	L
        JR	NZ,J$77A6
        POP	HL
        RET

;	  Subroutine prepare for next sector
;	     Inputs  ________________________
;	     Outputs ________________________

X00EA:
Y00F0:
C.77AD:	CALL	C.7801			; wait for FDC
        INC	H
        INC	H			; update transferaddress
X00EF:
Y00F5:
        LD	A,(D7FFA)
        INC	A
X00F3:
Y00F9:
        LD	(D7FFA),A		; next record
        BIT	7,D			; 9 sectors per track ?
        JR	NZ,J$77C0		; nope, check if on record 9
        CP	9+1			; end of track ?
        RET	C			; nope, quit
J$77C0:	CP	8+1			; end of track ?
        RET	C			; nope, quit
        LD	A,1
X0102:
Y0108:
        LD	(D7FFA),A		; record 1
        BIT	6,D			; double sided media ?
        JR	Z,J.77D7		; nope, select side 0 and seek to next cylinder
        BIT	0,D			; currently on side 1 ?
        JR	NZ,J.77D7		; yep, select side 0 and seek to next cylinder
        SET	0,D			; nope, select side 1
X010F:
Y0115:
        LD	(D7FFC),A
        JR	J$77E6			; wait 18 ms (head settle)

J.77D7:	RES	0,D
        XOR	A
X0117:
Y011D:
        LD	(D7FFC),A               ; side 0
        INC	C                       ; update cylinder

;	  Subroutine seek to next cylinder
;	     Inputs  ________________________
;	     Outputs ________________________

X011B:
Y0121:
C.77DE:	CALL	C.7801			; wait for FDC
        LD	A,50H
X0120:
Y0126:
        LD	(D7FF8),A		; start step-in command
J$77E6:	JR	C.780E			; wait 18 ms (head settle)

;	  Subroutine reseek
;	     Inputs  ________________________
;	     Outputs ________________________

X0125:
Y012B:
C.77E8:	BIT	0,E
        RET	NZ
X0128:
Y012E:
        CALL	C.7814			; recalibrate

;	  Subroutine seek to cylinder
;	     Inputs  ________________________
;	     Outputs ________________________

X012B:
Y0131:
C$77EE:	CALL	C.7801			; wait for FDC
        LD	A,C
        OR	A
        JR	Z,C.781B		; seek to cylinder 0
X0132:
Y0138:
        LD	(D7FFB),A
        EX	(SP),HL
        EX	(SP),HL
        LD	A,10H
X0139:
Y013F:
        LD	(D7FF8),A		; start seek command
        JR	J$7823			; wait for FDC and wait 14 ms (head settle)

;	  Subroutine wait for FDC
;	     Inputs  ________________________
;	     Outputs ________________________

X013E:
Y0144:
C.7801:	LD	A,(D7FF8)
        RRA
        JR	C,C.7801
        RET

;	  Subroutine wait 1.2 ms
;	     Inputs  ________________________
;	     Outputs ________________________

Y014B:
C$7808:	PUSH	HL
        LD	HL,143
        JR	J.782C

;	  Subroutine wait 18 ms (head settle)
;	     Inputs  ________________________
;	     Outputs ________________________

C.780E:	PUSH	HL
        LD	HL,2142
        JR	J.782C

;	  Subroutine recalibrate
;	     Inputs  ________________________
;	     Outputs ________________________

X0151:
Y0157:
C.7814:	LD	A,(D7FF9)
        OR	A			; on cylinder 0 ?
X0155:
Y015B:
        CALL	Z,C.7835		; yep, move to 5 cylinders futher

;	  Subroutine seek to cylinder 0
;	     Inputs  ________________________
;	     Outputs ________________________

X0158:
Y015E:
C.781B:	CALL	C.7801			; wait for FDC
        LD	A,0
X015D:
Y0163:
        LD	(D7FF8),A		; start restore command
J$7823:	EX	(SP),HL
        EX	(SP),HL
X0162:
Y0168:
        CALL	C.7801			; wait for FDC
        PUSH	HL
        LD	HL,1666			; wait 14 ms (head settle)
J.782C:	PUSH	AF
J$782D:	DEC	HL
        LD	A,H
        OR	L
        JR	NZ,J$782D
        POP	AF
        POP	HL
        RET

;	  Subroutine move to 5 cylinders futher
;	     Inputs  ________________________
;	     Outputs ________________________

X0172:
Y0178:
C.7835:	PUSH	BC
        LD	B,5
X0175:
Y017B:
J$7838:	CALL	C.77DE                  ; seek to next cylinder
        DJNZ	J$7838			; seek to 5 cylinders futher
        POP	BC
        RET

S77AD   EQU     $-C.77AD

;	  Subroutine INIHRD
;	     Inputs  ________________________
;	     Outputs ________________________

INIHRD:
?.783F:	CALL	C.7851			; reset FDC
        JR	C.784B			; stop motor

;	  Subroutine MTOFF
;	     Inputs  ________________________
;	     Outputs ________________________

MTOFF:	CALL	GETWRK			; GETWRK

;	  Subroutine motor off (set motor off timer = finished)
;	     Inputs  ________________________
;	     Outputs ________________________

C$7847:	LD	(IX+0),0

;	  Subroutine motor off
;	     Inputs  ________________________
;	     Outputs ________________________

C.784B:	LD	A,3
        LD	(D7FFD),A		; motor off, in use off, reset b2, unselect drive
        RET

;	  Subroutine reset FDC
;	     Inputs  ________________________
;	     Outputs ________________________

C.7851:	LD	A,0D0H
        LD	(D7FF8),A		; start command
        EX	(SP),HL
        EX	(SP),HL
        EX	(SP),HL
        EX	(SP),HL
        LD	A,(D7FFB)               ; reset IRQ
        LD	A,(D7FF8)               ; reset DRQ
        RET

;	  Subroutine DRIVES
;	     Inputs  ________________________
;	     Outputs ________________________

DRIVES:
?.7861:	PUSH	BC
        PUSH	DE
        PUSH	AF
        CALL	GETWRK			; GETWRK
        POP	AF
        PUSH	AF
        JR	Z,J$7887		; CTRL pressed, skip drive 1 check
        LD	A,0C5H
        LD	(D7FFD),A		; motor on, in use, set b2, select drive 1
        RES	5,D                     ; ?? left over
        CALL	C.7835			; seek to 5 cylinders futher
        CALL	C.781B			; seek to cylinder 0
        LD	HL,076CAH		; wait max. 0.5 s (loop is 60T cycles)
J$787B:	LD	A,(D7FF8)
        AND	04H                     ; on cylinder 0 ?
        JR	NZ,J$788B               ; yep, initialize drive 1
        DEC	HL
        LD	A,H
        OR	L
        JR	NZ,J$787B
J$7887:	LD	L,1                     ; 1 physical drive
        JR	J$7893

J$788B:	LD	L,2                     ; 2 physical drives
        CALL	C.78B4			; initialize FDD
        CALL	C.780E			; wait 18 ms (head settle)
J$7893:	LD	A,0C4H
        LD	(D7FFD),A		; motor on, in use, set b2, select drive 0
        RES	5,D                     ; ?? left over
        CALL	C.7835			; seek to 5 cylinders futher
        CALL	C.781B			; seek to cylinder 0
        CALL	C.78B4			; initialize FDD
        LD	(IX+7),L
        CALL	C.780E			; wait 18 ms (head settle)
        CALL	C.784B			; stop motor
        POP	AF
        JR	Z,J$78B1		; CTRL pressed, do not use phantom drives
        LD	L,2			; 2 drives
J$78B1:	POP	DE
        POP	BC
        RET

;	  Subroutine initialize FDD
;	     Inputs  ________________________
;	     Outputs ________________________

C.78B4:	PUSH	DE
        RES	5,D                     ; ?? left over
        CALL	C.7814			; recalibrate
        CALL	C.7814			; recalibrate
        POP	DE
        RET

;	  Subroutine INIENV
;	     Inputs  ________________________
;	     Outputs ________________________

INIENV:
?.78BF:	CALL	GETWRK			; GETWRK
        LD	B,MYSIZE-1
        XOR	A
J$78C5:	LD	(HL),A
        INC	HL
        DJNZ	J$78C5
        LD	HL,I$78CF
        JP	SETINT			; SETINT

;	  Subroutine driver interrupt handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$78CF:	PUSH	AF                      ; store vdp status register
        CALL	GETWRK			; GETWRK
        LD	A,(HL)
        AND	A                       ; motor off timer finished ?
        JR	Z,J$78DF                ; yep, motor off
        CP	0FFH                    ; motor off timer disabled ?
        JR	Z,J.78E2                ; yep, skip
        DEC	A
        LD	(HL),A                  ; update motor off timer
        JR	NZ,J.78E2               ; not finshed, skip
J$78DF:	CALL	C.784B			; stop motor
J.78E2:	INC	HL
        LD	A,(HL)
        AND	A                       ; disk change timer drive 0 finished ?
        JR	Z,J$78E8                ; yep, skip
        DEC	(HL)
J$78E8:	INC	HL
        LD	A,(HL)
        AND	A                       ; disk change timer drive 1 finished ?
        JR	Z,J$78EE                ; yep, skip
        DEC	(HL)
J$78EE:	POP	AF                      ; restore vdp status register
        JP	PRVINT			; next timer interrupt handler

;	  Subroutine DSKCHG
;	     Inputs  ________________________
;	     Outputs ________________________

DSKCHG:
?.78F2:	EI
        PUSH	HL
        PUSH	BC
        PUSH	AF
        CALL	GETWRK			; GETWRK
        POP	AF
        POP	BC
        POP	HL
        AND	A			; drive 0 ?
        LD	B,(IX+2)
        JR	NZ,J$7905		; nope, use diskchange counter drive 1
        LD	B,(IX+1)		; diskchange counter drive 0
J$7905:	INC	B
        DEC	B			; diskchange counter zero ?
        LD	B,1
        RET	NZ			; nope, return DISK UNCHANGED
        PUSH	BC
        PUSH	HL
        LD	DE,1
        LD	HL,($SECBUF)
        PUSH	AF
        CALL	C.744E			; DSKIO (read first FAT sector)
        JR	C,J$7930		; error, quit with error
        POP	AF
        LD	HL,($SECBUF)
        LD	B,(HL)			; mediadescriptor
        POP	HL
        PUSH	BC
        CALL	C$7934			; GETDPB (update DPB)
        LD	A,10
        JR	C,J$7931		; bad mediadescriptor, return WRITE FAULT error
        POP	AF
        POP	BC
        CP	C			; mediadescriptor changed ?
        SCF
        CCF				; reset Cx
        LD	B,0FFH
        RET	NZ			; yep, return DISK CHANGED
        INC	B
        RET				; nope, return DISK CHANGE UNKNOWN

J$7930:	POP	DE
J$7931:	POP	DE
        POP	DE
        RET

;	  Subroutine GETDPB
;	     Inputs  ________________________
;	     Outputs ________________________

GETDPB:
C$7934:	EX	DE,HL
        INC	DE
        LD	A,B
        SUB	0F8H			; mediadescriptor 0F8H-0FFH ?
        RET	C			; nope, quit with error
        CP	4			; mediadescriptor 0F8H-0FBH ?
        JR	NC,J$7952		; nope, quit with WRITE FAULT error
        RLCA
        LD	C,A
        LD	B,0
        LD	L,A
        LD	H,B
        ADD	HL,HL
        ADD	HL,HL
        ADD	HL,HL
        ADD	HL,BC
        LD	BC,I$7406
        ADD	HL,BC
        LD	BC,18
        LDIR
        RET

J$7952:	LD	A,10
        SCF
        RET

I$7956:	DEFB	13,10
        DEFB	"1 - Single sided, 80 tracks",13,10
        DEFB	"2 - Double sided, 80 tracks",13,10
        DEFB	0

;	  Subroutine CHOICE
;	     Inputs  ________________________
;	     Outputs ________________________

CHOICE:
?.7993:	LD	HL,I$7956
        RET

;	  Subroutine DSKFMT
;	     Inputs  ________________________
;	     Outputs ________________________

DSKFMT:
?.7997:	PUSH	HL
        LD	HL,-7000
        ADD	HL,BC
        POP	HL
        JR	C,J$79B2
        SCF
        LD	A,14			; return INSUFFICIENT MEMORY error
        RET

J.79A3:	POP	HL
J.79A4:	SCF
        LD	A,12			; return BAD PARAMETER error
        RET

J.79A8:	POP	DE
        POP	BC
J$79AA:	POP	HL
        JP	J.747D

J.79AE:	POP	BC
J$79AF:	JP	J.747D

J$79B2:	PUSH	AF
        PUSH	HL
        CALL	GETWRK			; GETWRK
        POP	HL
        POP	AF
        OR	A			; choice 0 ?
        JR	Z,J.79A4		; yep, bad parameter
        CP	2+1			; choice 1-2 ?
        JR	NC,J.79A4		; nope, bad parameter
        DEC	A
        JR	Z,J$79C8
        LD	BC,050F9H		; double sided, 80 tracks
        JR	J$79CB

J$79C8:	LD	BC,050F8H		; single sided, 80 tracks
J$79CB:	PUSH	HL
        BIT	0,C			; single sided ?
        JR	Z,J$7A16		; yep, skip side check
        PUSH	BC
        PUSH	DE
        LD	A,D
        LD	DE,0
        PUSH	BC
J$79D7:	CALL	C.76BE			; prepare for disk operation
        POP	BC
        JR	C,J.79A8		; error,
        RES	7,C			; side 0
        CALL	C.7A60			; construct track data
        CALL	C.7BEE			; format track
        JR	C,J.79A8		; error, quit
        POP	DE
        PUSH	DE
        SET	7,C			; side 1
        LD	A,D
        LD	DE,9
        PUSH	BC
        CALL	C.76BE			; prepare for disk operation
        POP	BC
J$79F4:	JR	C,J.79A8		; error, quit
        CALL	C.7A60			; construct track data
        CALL	C.7BEE			; format track
        JR	C,J.79A8		; error,
        CALL	C.7851			; reset FDC
        LD	HL,($SECBUF)
        LD	BC,001F9H		; 1 sector, double sided media
        POP	DE
        LD	A,D
        PUSH	DE
        LD	DE,0			; sector 0
        OR	A			; read
        CALL	C.744E			; DSKIO (this fails if drive was single sided)
        POP	DE
        POP	BC
        JP	C,J.79A3		; error, bad parameter
J$7A16:	POP	HL
        PUSH	BC
        LD	A,D
        PUSH	DE
        LD	DE,0
        CALL	C.76BE			; prepare for disk operation
        POP	DE
        POP	BC
        JP	C,J$79AF		; error, quit
        LD	A,D
        CALL	C$7AC3			; construct GAP POST DATA
        PUSH	AF
        LD	D,A
J$7A2B:	RES	7,C			; side 0
        CALL	C.7A60			; construct track data
        CALL	C.7BEE			; format track
        JP	C,J.79AE		; error,
        BIT	0,C			; double sided media ?
        JR	Z,J$7A48		; nope, skip side 1
        CALL	C.7A60			; construct track data
        SET	7,C			; side 1
        CALL	C$7AA2			; adjust track data for side
        CALL	C.7BEE			; format track
        JP	C,J.79AE		; error,
J$7A48:	RES	5,D                     ; ?? left over
        CALL	C.77DE			; seek to next cylinder
        DJNZ	J$7A2B			; next
        CALL	C.7814			; recalibrate
        SET	7,C			; mediadescriptor
        POP	AF
        JP	J$7AD6			; write system sectors

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A58:	LD	A,C
        RLCA
        AND	01H
        LD	(D7FFC),A
        RET

;	  Subroutine construct track data
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A60:	PUSH	BC
        PUSH	DE
        PUSH	HL
        EX	DE,HL
        LD	HL,I$7BC2
        CALL	C.7B8F
        LD	B,9
J$7A6C:	PUSH	BC
        LD	HL,I$7BCD
        CALL	C.7B8F
        POP	BC
        DJNZ	J$7A6C
        POP	HL
        PUSH	HL
        LD	BC,122+16
        ADD	HL,BC
        LD	DE,628
        LD	B,9
        LD	A,(D7FF9)
J$7A84:	LD	(HL),A			; cylinder
        ADD	HL,DE
        DJNZ	J$7A84
        LD	BC,122+18
        POP	HL
        PUSH	HL
        ADD	HL,BC
        PUSH	HL
        POP	IY
        LD	HL,I$7ABA
        LD	B,9
J$7A96:	LD	A,(HL)
        LD	(IY+0),A		; record
        ADD	IY,DE
        INC	HL
        DJNZ	J$7A96
        POP	HL
        POP	DE
        POP	BC

;	  Subroutine adjust track data for side
;	     Inputs  ________________________
;	     Outputs ________________________

C$7AA2:	PUSH	BC
        PUSH	DE
        PUSH	HL
        LD	DE,122+17
        ADD	HL,DE
        LD	DE,628
        LD	B,9
        LD	A,C
        RLCA
        AND	01H
J$7AB2:	LD	(HL),A
        ADD	HL,DE
        DJNZ	J$7AB2
        POP	HL
        POP	DE
        POP	BC
        RET

I$7ABA:	DEFB	1,2,3,4,5,6,7,8,9

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7AC3:	PUSH	HL
        PUSH	BC
        LD	DE,5774
        ADD	HL,DE
        LD	D,H
        LD	E,L
        INC	DE
        LD	(HL),4EH
        LD	BC,2*SECLEN-1
        LDIR
        POP	BC
        POP	HL
        RET

;	  Subroutine write system sectors
;	     Inputs  ________________________
;	     Outputs ________________________

J$7AD6:	CALL	C.7B7B			; clear $SECBUF
        PUSH	BC
        LD	HL,I$7E56
        LD	DE,($SECBUF)
        LD	BC,S7E56-1
        LDIR				; copy BPB + bootloader
        POP	BC
        CALL	C$7B9C			; adjust BPB if double sided
        PUSH	BC
        LD	B,1                     ; 1 sector
        LD	DE,0                    ; sector 0
        LD	H,A
        PUSH	HL
        LD	HL,($SECBUF)
        SCF				; write
        CALL	C.744E			; DSKIO (write bootsector)
        POP	HL
        POP	BC
        RET	C			; error, quit
        CALL	C$7B32			; write FATs
        RET	C			; error, quit
        LD	A,9
        SUB	E
        LD	B,A			; rest of the track
J$7B04:	PUSH	BC
        PUSH	DE
        LD	B,1                     ; 1 sector
        LD	A,H
        PUSH	HL
        LD	HL,($SECBUF)
        SCF				; write
        CALL	C.744E			; DSKIO
        POP	HL
        POP	DE
        INC	DE
        POP	BC
        RET	C			; error, quit
        DJNZ	J$7B04			; next
        BIT	0,C			; single sided ?
        RET	Z			; yep, done
        LD	B,5			; 5 sectors
J$7B1D:	PUSH	BC
        PUSH	DE
        LD	A,H
        PUSH	HL
        LD	HL,($SECBUF)
        LD	B,1                     ; 1 sector
        SCF				; write
        CALL	C.744E			; DSKIO
        POP	HL
        POP	DE
        INC	DE
        POP	BC
        RET	C
        DJNZ	J$7B1D			; next
        RET

;	  Subroutine write FATs
;	     Inputs  ________________________
;	     Outputs ________________________

C$7B32:	LD	B,2			; 2 FATs
        LD	DE,1                    ; 1st sector of 1st FAT
        CALL	C.7B7B			; clear $SECBUF
J$7B3A:	PUSH	BC
        PUSH	DE
        LD	A,H
        PUSH	HL
        LD	HL,($SECBUF)
        LD	(HL),C
        INC	HL
        LD	(HL),0FFH
        INC	HL
        LD	(HL),0FFH
        LD	B,1                     ; 1 sector
        DEC	HL
        DEC	HL
        SCF                             ; write
        CALL	C.744E			; DSKIO
        POP	HL
        CALL	C.7B7B			; clear $SECBUF
        POP	DE
        INC	DE
        POP	BC
        RET	C			; error, quit
        PUSH	BC
        LD	B,2-1
        BIT	0,C			; single sided ?
        JR	Z,J.7B60		; yep, only 2 sectors per FAT
        INC	B			; nope, 3 sectors per FAT
J.7B60:	PUSH	BC
        LD	B,1                     ; 1 sector
        PUSH	DE
        LD	A,H
        PUSH	HL
        LD	HL,($SECBUF)
        SCF				; write
        CALL	C.744E			; DSKIO
        POP	HL
        POP	DE
        INC	DE
        POP	BC
        JR	C,J$7B79		; error, quit
        DJNZ	J.7B60			; next
        POP	BC
        DJNZ	J$7B3A			; next FAT
        RET

J$7B79:	POP	BC
        RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B7B:	PUSH	BC
        PUSH	DE
        PUSH	HL
        LD	HL,($SECBUF)
        LD	D,H
        LD	E,L
        INC	DE
        LD	BC,SECLEN-1
        LD	(HL),0
        LDIR
        POP	HL
        POP	DE
        POP	BC
        RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B8F:	LD	A,(HL)
        INC	HL
        CP	0FFH
        RET	Z
        LD	B,(HL)
        INC	HL
J$7B96:	LD	(DE),A
        INC	DE
        DJNZ	J$7B96
        JR	C.7B8F

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7B9C:	BIT	0,C
        RET	Z
        PUSH	BC
        LD	DE,I$7BB2
        LD	HL,($SECBUF)
        LD	BC,13
        ADD	HL,BC
        EX	DE,HL
        LD	BC,S7BB2
        LDIR
        POP	BC
        RET

I$7BB2:
        DEFB	2
        DEFW	1
        DEFB	2
        DEFW	112
        DEFW	1440
        DEFB	0F9H
        DEFW	3
        DEFW	9
        DEFW	2
        DEFB	0

S7BB2   EQU     $-I$7BB2


I$7BC2:	DEFB	04EH,80		; GAP PRE INDEX
        DEFB	000H,12		; GAP PRE INDEX
        DEFB	0F6H,3		; special bytes
        DEFB	0FCH,1		; INDEX MARK
        DEFB	04EH,26		; GAP POST INDEX
        DEFB	0FFH

I$7BCD:	DEFB	000H,12		; GAP PRE SECTORID
        DEFB	0F5H,3		; special bytes
        DEFB	0FEH,1		; ID ADDRESS MARK
        DEFB	000H,1		; cylinder
        DEFB	000H,1		; side
        DEFB	001H,1		; record
        DEFB	002H,1		; sectorsize id (512 bytes)
        DEFB	0F7H,1		; write CRC-16
        DEFB	04EH,24		; GAP POST SECTORID
        DEFB	000H,12		; GAP PRE SECTORDATA
        DEFB	0F5H,3		; special bytes
        DEFB	0FBH,1		; DATA ADDRESS MARK
        DEFB	0E5H,0		; 256 bytes data
        DEFB	0E5H,0		; 256 bytes data
        DEFB	0F7H,1		; write CRC-16
        DEFB	04EH,54		; GAP POST SECTORDATA
        DEFB	0FFH

;	  Subroutine format track
;	     Inputs  ________________________
;	     Outputs ________________________

C.7BEE:	CALL	C.7A58			; select side
        LD	E,11
J$7BF3:	PUSH	BC
        PUSH	DE
        PUSH	HL
        CALL	C.7801			; wait for FDC
        CALL	DISINT
        DI
        LD	DE,I$7C30
        PUSH	DE
        LD	BC,D7FFF
        LD	DE,05D00H		; wait max. 300 ms for DRQ
        LD	A,0F0H
        LD	(D7FF8),A		; start format command
J.7C0C:	LD	A,(BC)
        ADD	A,A			; DRQ ?
        JR	NC,J.7C29		; yep, start format
        RET	P			; IRQ, quit
        DEC	E
        JR	NZ,J.7C0C
        LD	A,(BC)
        ADD	A,A
        JR	NC,J.7C29
        RET	P
        DEC	D
        JR	NZ,J.7C0C
        POP	BC
        LD	A,16
        SCF
        POP	HL
        POP	DE
        POP	BC
        RET				; return OTHER ERROR

J.7C24:	LD	A,(BC)
        ADD	A,A
        RET	P
        JR	C,J.7C24
J.7C29:	LD	A,(HL)
        LD	(D7FFB),A
        INC	HL
        JR	J.7C24

I$7C30:	POP	HL
        POP	DE
        POP	BC
        LD	A,(D7FF8)
        AND	0FCH			; read status bits
        JR	Z,J$7C55		; no errors, verify track
        BIT	6,A			; WP bit set ?
        JP	NZ,J.7549		; yep, check if WP set from write proctected disk
        PUSH	AF
        LD	A,(D7FF9)
        LD	C,A			; current cylinder
        CALL	C.77E8			; reseek every two tries
        POP	AF
        DEC	E
        JR	NZ,J$7BF3		; next try
        SCF
        LD	E,A
        BIT	7,E			; NOT READY bit set ?
        LD	A,16
        RET	NZ			; yep, return OTHER ERROR
        JP	J$7533			; return error from other error bits

J$7C55:	LD	A,(RAWFLG)
        OR	A			; verify on ?
        RET	Z			; nope, quit
        PUSH	HL
        PUSH	DE
        PUSH	BC
        LD	D,0
        LD	A,C
        AND	01H
        RRCA
        RRCA
        OR	D
        LD	D,A
        CALL	C.7A58			; select side
        OR	D
        LD	D,A			; media and side flags
        LD	B,9			; 9 sectors
        LD	A,(D7FF9)
        LD	C,A			; current cylinder
        LD	A,1
        LD	(D7FFA),A		; record 1
        CALL	C$75BC			; read sectors (without selecting drive and track)
        POP	BC
        POP	DE
        POP	HL
        RET

OEMSTA:
?.7C7D:	SCF
        RET

; 0000-005E     -I$7D52
; 005F-00E9 r   -C.7603+S7D52
; 005F-00EF w   -C.74D9+S7D52
; 00EA-00xx r   -C.77AD+S7603+S7D52
; 00F0-00xx w   -C.77AD+S74D9+S7D52

; relocation table write sectors code

I$7C7F: DEFW    Y0061-C.74D9+S7D52,Y0144-C.77AD+S74D9+S7D52
        DEFW    Y0075-C.74D9+S7D52,Y008B-C.74D9+S7D52
        DEFW    Y00AA-C.74D9+S7D52,Y012B-C.77AD+S74D9+S7D52
        DEFW    Y009F-C.74D9+S7D52,Y00F0-C.77AD+S74D9+S7D52
        DEFW    Y00A2-C.74D9+S7D52,I0026-I$7D52
        DEFW    Y00ED-C.74D9+S7D52,I003C-I$7D52
        DEFW    Y0093-C.74D9+S7D52,Y014B-C.77AD+S74D9+S7D52
        ; common code
        DEFW    Y00F0-C.77AD+S74D9+S7D52,Y0144-C.77AD+S74D9+S7D52
        DEFW    Y0121-C.77AD+S74D9+S7D52,Y0144-C.77AD+S74D9+S7D52
        DEFW    Y012E-C.77AD+S74D9+S7D52,Y0157-C.77AD+S74D9+S7D52
        DEFW    Y0131-C.77AD+S74D9+S7D52,Y0144-C.77AD+S74D9+S7D52
        DEFW    Y015E-C.77AD+S74D9+S7D52,Y0144-C.77AD+S74D9+S7D52
        DEFW    Y015B-C.77AD+S74D9+S7D52,Y0178-C.77AD+S74D9+S7D52
        DEFW    Y017B-C.77AD+S74D9+S7D52,Y0121-C.77AD+S74D9+S7D52
        DEFW    Y0168-C.77AD+S74D9+S7D52,Y0144-C.77AD+S74D9+S7D52
        DEFW    0
        DEFW    Y007C-C.74D9+S7D52
        DEFW    Y0079-C.74D9+S7D52
        DEFW    Y0085-C.74D9+S7D52
        DEFW    Y008E-C.74D9+S7D52
        DEFW    Y00D1-C.74D9+S7D52
        DEFW    Y00D4-C.74D9+S7D52
        ; common code
        DEFW    Y00F5-C.77AD+S74D9+S7D52
        DEFW    Y00F9-C.77AD+S74D9+S7D52
        DEFW    Y0108-C.77AD+S74D9+S7D52
        DEFW    Y0115-C.77AD+S74D9+S7D52
        DEFW    Y011D-C.77AD+S74D9+S7D52
        DEFW    Y0126-C.77AD+S74D9+S7D52
        DEFW    Y0138-C.77AD+S74D9+S7D52
        DEFW    Y013F-C.77AD+S74D9+S7D52
        DEFW    Y0144-C.77AD+S74D9+S7D52
        DEFW    Y0163-C.77AD+S74D9+S7D52
        DEFW    Y0157-C.77AD+S74D9+S7D52
        DEFW    0

; relocation table read sectors code

I$7CE1: DEFW    X005F-C.7603+S7D52,X013E-C.77AD+S7603+S7D52
        DEFW    X0073-C.7603+S7D52,X00AE-C.7603+S7D52
        DEFW    X00CA-C.7603+S7D52,X0125-C.77AD+S7603+S7D52
        DEFW    X00BF-C.7603+S7D52,X00EA-C.77AD+S7603+S7D52
        DEFW    X00C2-C.7603+S7D52,I0026-I$7D52
        DEFW    X00E7-C.7603+S7D52,I003C-I$7D52
        DEFW    X009B-C.7603+S7D52,X00E7-C.7603+S7D52
        ; common code
        DEFW    X00EA-C.77AD+S7603+S7D52,X013E-C.77AD+S7603+S7D52
        DEFW    X011B-C.77AD+S7603+S7D52,X013E-C.77AD+S7603+S7D52
        DEFW    X0128-C.77AD+S7603+S7D52,X0151-C.77AD+S7603+S7D52
        DEFW    X012B-C.77AD+S7603+S7D52,X013E-C.77AD+S7603+S7D52
        DEFW    X0158-C.77AD+S7603+S7D52,X013E-C.77AD+S7603+S7D52
        DEFW    X0155-C.77AD+S7603+S7D52,X0172-C.77AD+S7603+S7D52
        DEFW    X0175-C.77AD+S7603+S7D52,X011B-C.77AD+S7603+S7D52
        DEFW    X0162-C.77AD+S7603+S7D52,X013E-C.77AD+S7603+S7D52
        DEFW    0
        DEFW    X0077-C.7603+S7D52
        DEFW    X007E-C.7603+S7D52
        DEFW    X00A3-C.7603+S7D52
        DEFW    X00B1-C.7603+S7D52
        ; command code
        DEFW    X00EF-C.77AD+S7603+S7D52
        DEFW    X00F3-C.77AD+S7603+S7D52
        DEFW    X0102-C.77AD+S7603+S7D52
        DEFW    X010F-C.77AD+S7603+S7D52
        DEFW    X0117-C.77AD+S7603+S7D52
        DEFW    X0120-C.77AD+S7603+S7D52
        DEFW    X0132-C.77AD+S7603+S7D52
        DEFW    X0139-C.77AD+S7603+S7D52
        DEFW    X013E-C.77AD+S7603+S7D52
        DEFW    X015D-C.77AD+S7603+S7D52
        DEFW    X0151-C.77AD+S7603+S7D52
        DEFW    0

;	  Subroutine install enter/leave code in $SECBUF
;	     Inputs  ________________________
;	     Outputs ________________________
;
C.7D3F:	LD	DE,($SECBUF)
        LD	HL,I$7D52
        LD	BC,S7D52
        LDIR
        RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7D4C:	PUSH	HL
        LD	HL,($SECBUF)
        EX	(SP),HL
        RET

; enter/leave code

I$7D52:	PUSH	HL
        PUSH	DE
        PUSH	BC
        CALL	GETSLT
        LD	HL,($SECBUF)
        LD	DE,I004F+1-I$7D52
        ADD	HL,DE
        LD	(HL),A
        LD	H,HIGH 8000H
        CALL	ENASLT
        EI
        CALL	ENAINT
        LD	A,(RAMAD1)
        LD	H,HIGH 4000H
        CALL	ENASLT
        POP	BC
        POP	DE
        POP	HL
        CALL	DISINT
        DI
I0026:  DEC	HL
        LD	A,H
        ADD	A,HIGH SECLEN
        INC	HL
        RLCA
        CCF                             ; transfer to/from page 2 or 3 ?
        JR	NC,J$7D8E               ; yep, quit
        LD	IY,($SECBUF)
        PUSH	DE
        LD	DE,I005F-I$7D52
        ADD	IY,DE
        POP	DE
        JP	(IY)                    ; write/read/verify sectors

I003C:
J$7D8E:	PUSH	HL
        PUSH	DE
        PUSH	BC
        PUSH	AF
        LD	A,(RAMAD2)
        LD	H,HIGH 8000H
        CALL	ENASLT
        CALL	$DOSON
        EI
        CALL	ENAINT
I004F:  LD	A,0
        LD	H,HIGH 4000H
        CALL	ENASLT
        EI
        CALL	ENAINT
        POP	AF
        POP	BC
        POP	DE
        POP	HL
        RET

I005F:

S7D52   EQU     $-I$7D52

;	  Subroutine install write sectors code in $SECBUF
;	     Inputs  ________________________
;	     Outputs ________________________

C$7DB1:	PUSH	HL
        PUSH	DE
        PUSH	BC
        CALL	C.7D3F                  ; install enter/leave code in $SECBUF
        LD	IY,I$7C7F               ; relocation table write sectors
        LD	HL,C.74D9
        LD	BC,S74D9
        LDIR                            ; install write sectors code in $SECBUF
        PUSH	DE
        LD	DE,Y00ED-C.74D9+S7D52
        JR	J$7E02

;	  Subroutine install verify sectors code in $SECBUF
;	     Inputs  ________________________
;	     Outputs ________________________

C$7DC9:	PUSH	HL
        PUSH	DE
        PUSH	BC
        CALL	C.7DEC                  ; install read sectors code in $SECBUF
        LD	HL,($SECBUF)
        LD	BC,X00A6-C.7603+S7D52
        ADD	HL,BC
        LD	DE,I$76B6
        EX	DE,HL
        LD	BC,S76B6
        LDIR                            ; replace read routine by verify routine
        LD	HL,($SECBUF)
        LD	BC,X007C+1-C.7603+S7D52
        ADD	HL,BC
        LD	(HL),0                  ; 'disable' JR to verify routine
        POP	BC
        POP	DE
        POP	HL
        RET

;	  Subroutine install read sectors code in $SECBUF
;	     Inputs  ________________________
;	     Outputs ________________________

C.7DEC:	PUSH	HL
        PUSH	DE
        PUSH	BC
        CALL	C.7D3F                  ; install enter/leave code in $SECBUF
        LD	IY,I$7CE1               ; relocation table read sectors
        LD	HL,C.7603
        LD	BC,S7603
        LDIR                            ; install read sectors in $SECBUF
        PUSH	DE
        LD	DE,X00E7-C.7603+S7D52

J$7E02:	LD	HL,($SECBUF)
        ADD	HL,DE
        LD	(HL),0C3H
        POP	DE
        LD	HL,C.77AD
        LD	BC,S77AD
        LDIR                            ; install common code
J$7E11:	LD	E,(IY+0)
        LD	D,(IY+1)                ; offset
        LD	A,D
        OR	E                       ; end of relocation table ?
        JR	Z,J$7E4C
        LD	HL,($SECBUF)
        ADD	HL,DE
        INC	HL
        PUSH	HL
        LD	E,(IY+2)
        LD	D,(IY+3)                ; offset
        LD	HL,($SECBUF)
        ADD	HL,DE
        EX	DE,HL
        POP	HL
        LD	(HL),E
        INC	HL
        LD	(HL),D
        INC	IY
        INC	IY
        INC	IY
        INC	IY
        JR	J$7E11

J$7E3A:	LD	E,(IY+0)
        LD	D,(IY+1)                ; offset
        LD	A,D
        OR	E                       ; end of table ?
        JR	Z,J$7E52
        LD	HL,($SECBUF)
        ADD	HL,DE
        INC	HL
        INC	HL
        LD	(HL),HIGH DBFF8
J$7E4C:	INC	IY
        INC	IY
        JR	J$7E3A

J$7E52:	POP	BC
        POP	DE
        POP	HL
        RET

I$7E56:
        .PHASE	0C000H

        DEFB	0EBH,0FEH
        DEFB	090H
        DEFB	"NMS 8250"
        DEFW	512
        DEFB	2
        DEFW	1
        DEFB	2
        DEFW	112
        DEFW	720
        DEFB	0F8H
        DEFW	2
        DEFW	9
        DEFW	1
        DEFW	0

C.C01E:	RET	NC
	LD	(C.C058+1),DE
	LD	(D.C0DA),A
	LD	(HL),LOW C.C056
	INC	HL
	LD	(HL),HIGH C.C056
J$C02B:	LD	SP,KBUF+256
	LD	DE,I.C079
	LD	C,0FH
	CALL	BDOS
	INC	A
	JP	Z,J$C063
	LD	DE,0100H
	LD	C,1AH
	CALL	BDOS
	LD	HL,1
	LD	(I.C079+14),HL
	LD	HL,4000H-0100H
	LD	DE,I.C079
	LD	C,27H
	CALL	BDOS
	JP	0100H

C.C056: DEFW    C.C058

C.C058:	CALL	0
	LD	A,C
	AND	0FEH
	CP	02H
	JP	NZ,J$C06A
J$C063:	LD	A,(D.C0DA)
	AND	A
	JP	Z,BASENT
J$C06A: LD	DE,I$C09E
        LD	C,09H
        CALL	BDOS
        LD	C,07H
        CALL	BDOS
        JR	J$C02B

I.C079:	DEFB	0
        DEFB	"MSXDOS  "
        DEFB	"SYS"
        DEFW	0
        DEFW	0
        DEFB	0,0,0,0
        DEFW	0
        DEFW	0
        DEFB	0
        DEFB	0
        DEFW	0
        DEFW	0
        DEFW	0
        DEFB	0
        DEFB	0,0,0,0

I$C09E:	DEFB	"Boot error",13,10
        DEFB	"Press any key for retry",13,10
        DEFB	'$'

D.C0DA:	DEFB	0

        .DEPHASE

S7E56   EQU     $-I$7E56


        DEFB	"v 1.08"

        DEFS    8000H-$,0FFH

        END
