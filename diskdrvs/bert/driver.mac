; Diskdriver BERT SCSI controller
; HDC	NCR 5380 compatible

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by ? and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders

	.Z80
SNSMAT	EQU	0141H

DSKBAS	EQU	4022H			; start disk basic
C.4D7D	EQU	4D7DH			; print string
C.5604	EQU	5604H			; allocate memory
J.63AB	EQU	63ABH			; finish seek

I$C000	EQU	0C000H

RECSIZ	EQU	0F33DH
TARGET	EQU	0F33FH
$SECBUF	EQU	0F34DH
$DPBLI	EQU	0F355H
BDOS	EQU	0F37DH
KBUF	EQU	0F41Fh
AUTLIN	EQU	0F6ABH
DRVINF	EQU	0FB21H
PROCNM	EQU	0FD89H
DEVICE	EQU	0FD99H

; workarea driver
;
; workarea partitions, 6 x partition info entry
;
; +0	partition info (b7-b5 = LUN, b4 = not formated, b3 = disk unchanged, b2-b0 target SCSI ID)
; +1,3	starting sector of partition, absolute
; +4,2	size of partition in sectors
; +6	partition flags (b7 = active, b1 = read access, b0 = write access)
; +7	media type FDD (0-3)
;
; workarea driver
; 
; +0	host SCSI ID bit mask
; +1	target SCSI ID bit mask
; +2	SCSI command status
; +3	SCSI command sense status
; +4,2	pointer
; +6,10	SCSI CDB (supports only 6 and 10 bytes CDBs)

MYSIZE	EQU	0			; does not use MYSIZ, because init routine is modified
SECLEN	EQU	512


DEFDPB	EQU	$-1			; does not use DEFDPB, because init routine is modified
?.6EC5:	RET

DRIVES:
?.6EC6:	LD	L,0			; does not use DRIVES, because init routine is modified
	RET

;	  Subroutine general error (DSKIO/DSKCHG/GETDPB in segment 1,2,3)
;	     Inputs  ________________________
;	     Outputs ________________________
;            Remark  Why this done this way is unknown, it is unneeded

?.6EC9:	LD	A,12
	SCF

INIENV:					; does not use INIENV, because init routine is modified
MTOFF:
J.6ECC:	RET

;	  Subroutine not formatable (CHOICE in segment 1,2,3)
;	     Inputs  ________________________
;	     Outputs ________________________
;            Remark  Why this done this way is unknown, it is unneeded

?.6ECD:	LD	HL,I$6ED1
	RET

I$6ED1:	DEFB	0

;	  Subroutine general error (DSKFMT in segment 1,2,3)
;	     Inputs  ________________________
;	     Outputs ________________________
;            Remark  Why this done this way is unknown, it is unneeded

?.6ED2:	LD	A,16
	SCF
	RET

;	  Subroutine OEMSTA (extra disksystem statement handler)
;	     Inputs  ________________________
;	     Outputs ________________________

OEMSTA:
?.6ED6:	EI
	PUSH	HL
	PUSH	DE
	LD	DE,I$6F48		; SCSIID
	LD	HL,PROCNM
J$6EDF:	LD	A,(DE)
	AND	A
	JR	Z,J.6EEE
	CP	(HL)
	JR	NZ,J.6EEA		; nope, quit with statement not handled flag
	INC	DE
	INC	HL
	JR	J$6EDF

J.6EEA:	POP	DE
	POP	HL
	SCF
	RET

J.6EEE:	LD	A,(HL)
	INC	HL
	CP	" "
	JR	Z,J.6EEE		; skip spaces
	CP	"="
	JR	NZ,J.6EEA		; quit with statement not handled flag
J$6EF8:	LD	A,(HL)
	INC	HL
	CP	" "
	JR	Z,J$6EF8		; skip spaces
	SUB	"0"
	JR	C,J.6EEA		; invalid scsi id, quit with statement not handled flag
	CP	7+1
	JR	NC,J.6EEA		; invalid scsi id, quit with statement not handled flag
	LD	B,A
	LD	A,(HL)
	OR	A			; end of statement ?
	JR	NZ,J.6EEA		; nope, quit with statement not handled flag
	LD	A,B
	AND	07H			; ?? is already verified 0-7
	LD	A,1
	JR	Z,J$6F15
J$6F12:	RLA
	DJNZ	J$6F12			; create bit mask
J$6F15:	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	POP	AF
	LD	(IX+0),A		; save host SCSI ID bit mask

; illegal code
; the following code is against the MSX coding rules, why not use the RTC BIOS calls ?
; also the alarm feature nibbles are used illegal


	LD	C,0B5H
	DI
	LD	A,0DH
	OUT	(0B4H),A
	IN	A,(C)
	PUSH	AF			; save current nibble 13
	LD	A,09H
	OUT	(C),A                	; alarm off, clock running, bank 1
	LD	A,07H
	OUT	(0B4H),A
	CALL	C.7781			; get host SCSI ID
	OUT	(C),A			; write nibble 7 (normally day of month alarm)
	LD	A,05H
	OUT	(0B4H),A
	LD	A,03H
	OUT	(C),A			; write nibble 5 = 3 (normally hour of alarm)
	LD	A,0DH
	OUT	(0B4H),A
	POP	AF
	OUT	(C),A			; restore nibble 13
	EI

; end illegal code

	POP	DE
	POP	HL
	XOR	A
	RET

I$6F48:	DEFB	"SCSIID"
	DEFB	0

;	  Subroutine DSKIO
;	     Inputs  ________________________
;	     Outputs ________________________

DSKIO:
J.6F4F:	EI
	PUSH	AF
	CP	5+1			; valid driveid ?
	JP	NC,J.7090		; nope, quit with OTHER ERROR
	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C.7A45			; get pointer to partition info
	POP	HL
	POP	DE
	POP	BC
	POP	AF

;	  Subroutine read/write sector from partition
;	     Inputs  IX = pointer to partition info, DE = sector number, B = number of sectors, C = mediadescriptor
;	     Outputs ________________________

C$6F60:	LD	A,(IX+0)
	BIT	4,A			; partition enabled ?
	JP	NZ,J$70EF		; nope, quit with UNFORMATED DISK ERROR
	PUSH	AF
	LD	A,C
	SUB	0F0H			; mediadescriptor 0F0H (PC: 1.44 MB floppy, MSX: harddisk) ?
	JR	Z,J.6F79		; yep, continue
	CP	0F8H-0F0H		; mediadescriptor 0F8H (PC: hardisk, MSX: 360KB disk) ?
	JR	Z,J.6F79		; yep, continue
	CP	0F9H-0F0H		; mediadescriptor 0F9H (PC and MSX: 720KB disk) ?
	JR	Z,J.6F79		; yep, continue
	JP	J.7090			; quit with OTHER ERROR

J.6F79:	LD	C,0
	PUSH	DE
	LD	A,B
	DEC	A			; number of sectors - 1
	ADD	A,E
	LD	E,A
	LD	A,C
	ADC	A,D
	LD	D,A
	LD	A,C
	ADC	A,C
	LD	C,A			; CDE = end sector
	LD	A,(IX+4)
	SUB	E
	LD	A,(IX+5)
	SBC	A,D
	LD	A,0
	SBC	A,C			; is end sector past end of partition ?
	POP	DE
	JP	C,J$7069		; yep, check if a valid remaining range
	LD	A,E
	ADD	A,(IX+1)
	LD	E,A
	LD	A,D
	ADC	A,(IX+2)
	LD	D,A
	LD	A,0
	ADC	A,(IX+3)
	LD	C,A			; CDE = start physical sector
	POP	AF
	PUSH	DE
	PUSH	BC
	PUSH	IX
	JR	C,J$6FB8		; write, handle
	BIT	1,(IX+6)		; have partition read access ?
	JP	Z,J$705E		; nope, quit with RECORD NOT FOUND error
	CALL	C.7AA8			; read logical block
	JR	J$6FC2

J$6FB8:	BIT	0,(IX+6)		; have partition write access ?
	JP	Z,J$7058		; nope, quit with WRITE PROTECT error
	CALL	C.7B0D			; write logical block
J$6FC2:	POP	IX
	POP	BC
	LD	A,D
	POP	DE
	OR	A			; any errors ?
	LD	A,24			; ??
	RET	Z			; nope, quit
	PUSH	DE
	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	LD	(IX+7),0		; begin forced media type select with 720 KB 3.5"
	CALL	C.7B2F			; request sense
	PUSH	AF
	CP	24			; UNFORMATED DISK error ?
	JR	NZ,J$701D		; nope, update things and quit with error
	POP	AF

; handle UNFORMATED DISK error

J$6FDF:	LD	HL,($SECBUF)
	EX	(SP),IX			; pointer to partition
	LD	A,(IX+0)		; target SCSI ID
	LD	BC,1*256+0
	LD	DE,0			; sector 0, 1 block
	CALL	C.7AA8			; read logical block
	EX	(SP),IX			;
	JR	C,J$6FFC		; error,
	POP	IX			; pointer to partition
	LD	A,24
	SCF
	PUSH	AF
	JR	J.7043			; quit with UNFORMATED DISK error

; UNFORMATED DISK, can not read boot sector

J$6FFC:	EX	(SP),IX			; pointer to partition
	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7A87			; test unit ready
	LD	A,(IX+7)		; forced media type
	CALL	C.7429			; select FDD media type
	INC	(IX+7)			; next media type
	LD	A,(IX+7)
	EX	(SP),IX			;
	CP	4			; all media bytes done ?
	JR	NZ,J$6FDF		; nope, try next media type
	POP	IX			; pointer to partition
	LD	A,12
	SCF
	JR	J.701E			; update things and quit with OTHER error

J$701D:	POP	AF
J.701E:	POP	HL
	PUSH	AF
	INC	D
	DEC	D			; SCSI status OK ?
	JR	NZ,J.7043		; nope, quit with error
	LD	A,(IX+2)
	CP	6			; UNIT ATTENTION ?
	JR	NZ,J$7047		; nope, update remaining sectors and quit (with error)
	PUSH	HL
	CALL	GETWRK			; get pointer to partition info
	POP	IX
	LD	A,(IX+0)
	OR	08H			; partition unchanged
	LD	DE,8
	LD	B,6			; 6 drives/partitions
J$703B:	CP	(HL)			; partition on same target unchanged ?
	JR	NZ,J$7040
	RES	3,(HL)			; partition changed
J$7040:	ADD	HL,DE
	DJNZ	J$703B
J.7043:	POP	AF
	POP	BC
	POP	DE
	RET

J$7047:	POP	AF
	POP	BC
	POP	DE
	BIT	7,(IX+0)		; valid bit set ?
	RET	Z			; nope, quit
	PUSH	AF
	LD	A,B			; number of sectors
	SUB	(IX+6)
	ADD	A,E
	LD	B,A
	POP	AF
	RET

J$7058:	POP	AF
	POP	BC
	POP	AF
	XOR	A
	SCF
	RET

J$705E:	POP	AF
	POP	BC
	JR	J.7084

?.7062:	POP	AF
	POP	BC
	POP	AF
	LD	A,10
	SCF
	RET

; handle a request (partly) out of range

J$7069:	LD	A,(IX+4)
	SUB	E
	LD	C,A
	INC	C
	LD	A,(IX+5)
	SBC	A,D
	JR	C,J.7084		; quit with SEEK error
	LD	A,B
	SUB	C
	LD	B,A			; number of sectors (valid range)
	POP	AF
	PUSH	BC
	LD	B,C
	LD	C,0F0H			; mediadescriptor harddisk
	CALL	C$6F60			; read/write sector from partition
	JR	C,J$7089		; error, update remaining sectors and quit
	POP	BC
	DEFB	03EH
J.7084:	POP	AF
	LD	A,8
	SCF
	RET

J$7089:	POP	DE
	PUSH	AF
	LD	A,B
	ADD	A,D
	LD	B,A
	POP	AF
	RET

J.7090:	POP	AF
J.7091:	LD	A,12
	SCF
	RET

;	  Subroutine DSKCHG
;	     Inputs  ________________________
;	     Outputs ________________________

DSKCHG:
J.7095:	EI
	CP	5+1			; valid driveid ?
	JR	NC,J.7091		; nope, quit with OTHER ERROR
	OR	A
	PUSH	AF
	PUSH	HL
	CALL	C.7A45			; get pointer to partition info
	POP	HL
	POP	AF
	LD	B,A
	LD	A,(IX+1)
	OR	(IX+2)
	OR	(IX+3)			; first sector of partition 0 (floppy) ?
	LD	A,B
	JR	J$70B6

?.70AF:	LD	B,1			; assume DISK UNCHANGED
	BIT	3,(IX+0)		; disk unchanged ?
	RET	NZ			; yep, quit

J$70B6:	LD	B,0FFH			; assume DISK CHANGED
	SET	3,(IX+0)		; set disk unchanged flag
	RES	4,(IX+0)		; enable partition
	PUSH	BC
	CALL	C.70DC			; GETDPB
	POP	BC
	LD	A,24			; ??
	OR	A			; quit with OK
	RET

I$70C9:	DEFB	0
D$70CA:	DEFB	0F9H
	DEFW	512
        DEFB	0FH
        DEFB	04H
        DEFB	1FH
        DEFB	06H
	DEFW	1
        DEFB	2
        DEFB	240
        DEFW	41
        DEFW	1300
        DEFB	12
        DEFW	25

;	  Subroutine GETDPB
;	     Inputs  ________________________
;	     Outputs ________________________

GETDPB:
C.70DC:	EI
	CP	5+1			; valid driveid ?
	JP	NC,J.7091		; nope, quit with OTHER ERROR
	PUSH	AF
	PUSH	HL
	CALL	C.7A45			; get pointer to partition info
	POP	HL
	POP	AF
	BIT	4,(IX+0)		; partition enabled ?
	JR	Z,J$70F3		; yep, continue
J$70EF:	LD	A,22			; quit with UNFORMATED DISK ERROR
	SCF
	RET

J$70F3:	LD	(IX+7),0		; begin forced media type select with 720 KB 3.5"
	PUSH	HL
	LD	HL,($SECBUF)
	PUSH	HL
	LD	A,(IX+0)		; target SCSI ID
	LD	B,1			; 1 block
	LD	C,(IX+3)
	LD	D,(IX+2)
	LD	E,(IX+1)		; first sector of partition
	CALL	C.7AA8			; read logical block
	LD	A,D			; SCSI status code
	CALL	C$71C9			; if error, try read sector 0 FDD (try with different media types)
	POP	IY
	POP	IX
	JR	NC,J.711D		; no error, build DPB and quit
	CP	24			; UNFORMATED DISK error ?
	JR	Z,J.711D		; yep, build DPB and quit
	SCF
	RET

; build DPB

J.711D:	LD	A,(IY+21)
	LD	(IX+1),A		; DPB: mediadescriptor
	CP	0F0H			; mediadescriptor 0F0H (PC: 1.44 MB floppy, MSX: harddisk) ?
	JR	Z,J.7133		; yep, continue
	CP	0F9H			; mediadescriptor 0F9H (PC and MSX: 720KB disk) ?
	JR	Z,J.7133		; yep, continue
	CP	0F8H			; mediadescriptor 0F8H (PC: hardisk, MSX: 360KB disk) ?
	JR	Z,J.7133		; yep, continue
	LD	A,18
	SCF
	RET	NZ
J.7133:	LD	L,(IY+14)
	LD	H,(IY+15)
	LD	(IX+8),L
	LD	(IX+9),H		; first FAT sector (reserved sectors)
	LD	A,(IY+16)
	LD	(IX+10),A		; number of FATs
	LD	E,(IY+22)
	LD	D,(IY+23)
	LD	(IX+16),E		; sectors per FAT
	LD	B,A
J$714F:	ADD	HL,DE
	DJNZ	J$714F
	LD	(IX+17),L
	LD	(IX+18),H		; first root directory sector
	LD	E,(IY+17)
	LD	D,(IY+18)
	LD	(IX+11),E		; number of root directory entries
	LD	C,(IY+11)
	LD	B,(IY+12)
	LD	(IX+2),C
	LD	(IX+3),B		; bytes per sector
	SRL	B
	RR	C
	SRL	B
	RR	C
	SRL	B
	RR	C
	SRL	B
	RR	C
	SRL	B
	RR	C
	DEC	C
	LD	(IX+4),C		; directory mask
	ADD	A,E
	LD	E,A
	RL	D
J$7189:	INC	B
	RR	C
	JR	C,J$7189
	DEC	B
	LD	(IX+5),B		; directory shift
J$7192:	SRL	D
	RR	E
	DJNZ	J$7192
	ADD	HL,DE
	LD	(IX+12),L
	LD	(IX+13),H		; first data sector
	EX	DE,HL
	LD	L,(IY+19)
	LD	H,(IY+20)
	OR	A
	SBC	HL,DE
	LD	A,(IY+13)
	DEC	A
	LD	(IX+6),A		; cluster mask
J$71B0:	INC	B
	RRCA
	JR	C,J$71B0
	LD	(IX+7),B		; cluster shift
	DEC	B
	JR	Z,J$71C0
J$71BA:	SRL	H
	RR	L
	DJNZ	J$71BA
J$71C0:	INC	HL
	LD	(IX+14),L
	LD	(IX+15),H		; maximium cluster number
	OR	A
	RET

;	  Subroutine if error, try read sector 0 FDD (try with different media types)
;	     Inputs  ________________________
;	     Outputs ________________________

C$71C9:	OR	A			; SCSI status = OK ?
	RET	Z			; yep, quit
	PUSH	DE
	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	LD	(IX+7),0		; begin forced media type select with 720 KB 3.5"
	CALL	C.7B2F			; request sense
	PUSH	AF
	CP	24			; UNFORMATED DISK error ?
	JR	NZ,J$71FA		; nope, update things and quit with error
	POP	AF
	POP	IX
	CALL	C.74A7			; try reading sector 0 FDD (try with different media types)
	JP	NC,J$71F4		; ok, quit with UNFORMATED DISK error
	SET	4,(IX+0)		; disable partition
	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7B2F			; request sense
	JP	J.701E			; update things and quit

J$71F4:	LD	A,24
	SCF
	POP	BC
	POP	DE
	RET

J$71FA:	POP	AF
	JP	J.701E			; update things and quit with error


;	  Subroutine CHOICE
;	     Inputs  ________________________
;	     Outputs ________________________

CHOICE:
J.71FE:	CALL	C.7A45			; get pointer to partition info
	LD	A,(IX+1)
	OR	(IX+2)
	OR	(IX+3)			; first sector of partition 0 (floppy) ?
	JR	Z,J$7210		; yep, must be a floppy disk
	LD	HL,I$7373
	RET

J$7210:	LD	HL,I$73C0
	RET

;	  Subroutine DSKFMT
;	     Inputs  ________________________
;	     Outputs ________________________

DSKFMT:
J.7214:	LD	E,A
	CP	5			; valid choice ?
	JR	NC,J$721C		; nope, quit with error
	LD	A,D
	CP	5+1			; valid driveid ?
J$721C:	CCF
	LD	A,12
	RET	C			; nope, quit with error
	SCF
	DEC	E			; choice 0 ?
	RET	M			; yep, quit with error
	PUSH	DE
	LD	A,D
	PUSH	HL
	PUSH	BC
	CALL	C.7A45			; get pointer to partition info
	POP	BC
	POP	HL
	POP	DE
	LD	A,(IX+1)
	OR	(IX+2)
	OR	(IX+3)			; first sector of partition 0 (floppy) ?
	JP	Z,J$7264		; yep, format floppy disk
	LD	D,0
	LD	HL,I$7245
	ADD	HL,DE
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)

I$7245:	DEFW	J.724D			; choice 1, enable partition
	DEFW	J.7256			; choice 2, disable partition
	DEFW	J.725B			; choice 3, write protect partition
	DEFW	J.7260			; choice 4, invalid choice

J.724D:	RES	4,(IX+0)		; enable partition
	SET	0,(IX+6)		; enable partition write access
	RET

J.7256:	SET	4,(IX+0)		; disable partition
	RET

J.725B:	RES	0,(IX+6)		; disable partition write access
	RET

J.7260:	SCF
	LD	A,12
	RET

;	  Subroutine format floppy disk
;	     Inputs  E = choice (0 based), BC = size of workspace
;	     Outputs ________________________

J$7264:	LD	A,B
	CP	HIGH 512		; enough workspace ?
	JP	C,J$7325		; nope, quit with INSUFFICIENT MEMORY error
	LD	A,E
	AND	0FH			; ?? choice value is already in range
	CALL	C.7429			; select FDD media type
	LD	A,(IX+0)		; target SCSI ID
	PUSH	HL
	CALL	C.7362			; clear sector buffer
	LD	B,0			; format bits
	PUSH	DE
	LD	DE,0			; interleave = 0
	CALL	C.7AEB			; format unit
	JR	NC,J$7291		; ok, continue
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	CALL	C.7B2F			; request sense
	POP	IX
	POP	DE
	POP	HL
	JP	J$732A			; quit with error

J$7291:	POP	DE
	LD	A,E			; choice
	ADD	A,A
	ADD	A,A
	ADD	A,A			; *8
	ADD	A,4			; +4
	LD	E,A
	LD	D,0
	LD	HL,I.74D6
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; BIOS parameter block for choice
	LD	BC,30
	POP	DE
	PUSH	DE
	LDIR				; copy BIOS parameter block
	LD	HL,I$756E
	LD	BC,L_BOOT
	LDIR				; copy bootstrap code
	POP	HL
	CALL	C.732F			; write sector
	RET	C			; error, quit
	PUSH	HL
	LD	DE,17
	ADD	HL,DE
	LD	E,(HL)			; number of rootentries
	LD	BC,4
	ADD	HL,BC
	LD	C,(HL)			; mediadescriptor
	INC	HL
	LD	B,(HL)			; number of sectors per FAT
	POP	HL
	PUSH	BC
	SLA	B			; 2 FATs
	LD	A,E
	SRL	E
	SRL	E
	SRL	E
	SRL	E
	AND	1FH
	JR	Z,J$72D6
	INC	E			; number of sectors for root directory
J$72D6:	LD	A,E
	ADD	A,B
	LD	B,A			; + number of sectors for FAT
	CALL	C.7362			; clear sector buffer
J$72DC:	CALL	C.732F			; write sector
	JR	NC,J$72E3		; ok, continue
	POP	BC
	RET

J$72E3:	DJNZ	J$72DC
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),0FFH
	INC	HL
	LD	(HL),0FFH
	DEC	HL
	DEC	HL			; first 2 special FAT entries
	LD	(IX+1),1
	LD	(IX+2),0
	LD	(IX+3),0		; starting sector = 1
	CALL	C.732F			; write sector (first sector of FAT #1)
	RET	C			; error, quit
	LD	A,B
	DEC	A			; number of sectors per FAT - 1 (because starting sector is already updated by 1)
	ADD	A,(IX+1)
	LD	(IX+1),A
	JR	NC,J.7311
	INC	(IX+2)
	JR	NZ,J.7311
	INC	(IX+3)			; update starting sector
J.7311:	CALL	C.732F			; write sector (first sector of FAT #2)
	RET	C			; error, quit
	LD	(IX+1),0
	LD	(IX+2),0
	LD	(IX+3),0		; starting sector = 0
	XOR	A			; no error
	LD	A,22			; ??
	RET

J$7325:	CCF
	LD	A,14
	RET

?.7329:	XOR	A
J$732A:	SCF
	RET

?.732C:	LD	A,4
	RET

;	  Subroutine write sector
;	     Inputs  ________________________
;	     Outputs ________________________

C.732F:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	B,1
	LD	C,(IX+3)
	LD	D,(IX+2)
	LD	E,(IX+1)		; starting sector
	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7B0D			; write logical block
	JR	NC,J$734F		; no error,
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	CALL	C.7B2F			; request sense
	POP	IX
J$734F:	PUSH	AF
	INC	(IX+1)
	JR	NZ,J.735D
	INC	(IX+2)
	JR	NZ,J.735D
	INC	(IX+3)			; starting sector + 1
J.735D:	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET

;	  Subroutine clear sector buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C.7362:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	HL
	POP	DE
	LD	(HL),0
	INC	DE
	LD	BC,512-1
	LDIR
	POP	BC
	POP	DE
	POP	HL
	RET

I$7373:	DEFB	13,10
	DEFB	"1 - Enable partition",13,10
	DEFB	"2 - Disable partition",13,10
	DEFB	"3 - Write protect partition",13,10
	DEFB	0

I$73C0:	DEFB	13,10
	DEFB	"1 - 720Kb (double side)",13,10
	DEFB	"2 - 1.44Mb (double side)",13,10
	DEFB	"3 - 2.88Mb (double side)",13,10
	DEFB	"4 - 360Kb (singel side)",13,10
	DEFB	0

;	  Subroutine select FDD media type
;	     Inputs  A = media type (0-3)
;	     Outputs Cx set if error

C.7429:	PUSH	IY
	PUSH	IX
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	PUSH	HL
	LD	B,3
J$7434:	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7A87			; test unit ready
	JR	NC,J$7440		; no error, continue
	DJNZ	J$7434
	JR	J.7498			; quit with error

J$7440:	LD	A,(IX+0)		; target SCSI ID
	LD	B,5			; PC = 0 (Current values), Page code = 5 (flexible disk)
	CALL	C.7BB2			; mode sense
J$7448:	JR	C,J.7498		; error, quit with error
	POP	IY
	LD	(IY+12),5		; flexible disk page
	LD	(IY+0),0		; Mode data length = 0
	LD	(IY+2),0		; Device-specific parameter = 0
	LD	(IY+3),0		; Block descriptor length = 0
	PUSH	IY
	POP	HL
	LD	DE,4
J$7462:	ADD	HL,DE			; +4
	PUSH	HL
	LD	DE,8
	ADD	HL,DE			; +4+8 (header + block descriptor) -> flexible disk page
	POP	DE
	LD	BC,32
	LDIR				; copy +12 to +4, length 32
	POP	AF
	LD	D,0
	ADD	A,A
	ADD	A,A
	ADD	A,A			; *8
	LD	E,A
	LD	HL,I.74D6
	ADD	HL,DE
	LD	A,(HL)
	LD	(IY+1),A		; Mode parameter header, set medium type
	INC	HL
	LD	A,(HL)
	LD	(IY+8),A		; flexible disk, update number of heads
	INC	HL
	LD	A,(HL)
	LD	(IY+9),A		; flexible disk, update sectors per track
	INC	HL
	INC	HL			; ??
	LD	A,(IX+0)		; target SCSI ID
	LD	B,32+4			; parameter list length (header + flexible disk)
	PUSH	IY
	POP	HL
	CALL	C.7ACA			; mode select
	JR	C,J$749A		; error,
	JR	J$749E			; quit without error

J.7498:	POP	HL
	POP	AF
J$749A:	XOR	A
	DEC	A			; set Cx
	JR	J$749F

J$749E:	XOR	A			; clear Cx
J$749F:	POP	BC
	POP	DE
	POP	HL
	POP	IX
	POP	IY
	RET

;	  Subroutine try reading sector 0 FDD (try with different media types)
;	     Inputs  ________________________
;	     Outputs ________________________

C.74A7:	LD	(IX+7),0		; begin forced media type select with 720 KB 3.5"
	PUSH	HL
	PUSH	DE
	PUSH	BC
J$74AE:	LD	HL,($SECBUF)
	LD	A,(IX+0)		; target SCSI ID
	LD	BC,1*256+0
	LD	DE,0			; 1 block, block 0
	CALL	C.7AA8			; read logical block
	JR	NC,J$74D2		; no error, quit
	LD	A,(IX+7)
	CALL	C.7429			; select FDD media type
	INC	(IX+7)			; next media type
	LD	A,(IX+7)
	CP	4			; all media types done ?
	JR	NZ,J$74AE		; nope, try again
	LD	A,22			; quit with UNFORMATED DISK ERROR
	SCF
J$74D2:	POP	BC
	POP	DE
	POP	HL
	RET

I.74D6:	DEFB	080H,2,9,0		; 720 KB 3.5", 2 sides, 9 sectors per track
	DEFW	I.74F6
	DEFW	0

	DEFB	088H,2,18,0		; 1.44 MB 3.5", 2 sides, 18 sectors per track
	DEFW	I.7514
	DEFW	0

	DEFB	08CH,2,36,0		; 2.88 MB 3.5", 2 sides, 36 sectors per track
	DEFW	I.7532
	DEFW	0

	DEFB	080H,1,9,0		; 720 KB 3.5", 2 sides, 9 sectors per track
	DEFW	I.7550
	DEFW	0

I.74F6:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	112
        DW	1440
        DB	0F9h
        DW	3
        DW	9
        DW	2
        DW	0

I.7514:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	240
        DW	2880
        DB	0F9h
        DW	5
        DW	18
        DW	2
        DW	0

I.7532:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	240
        DW	5760
        DB	0F9h
        DW	9
        DW	36
        DW	2
        DW	0

I.7550:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	112
        DW	720
        DB	0F8h
        DW	3
        DW	9
        DW	1
        DW	0


I$756E:
        .PHASE	0C01EH

LC01E:  RET	NC
        LD	(LC058+1),DE
        LD	(LC0C4),A
        LD	(HL),LOW LC056
        INC	HL
        LD	(HL),HIGH LC056
L7F3A:	LD	SP,KBUF+256
        LD	DE,LC09F
        LD	C,00FH
        CALL	BDOS
        INC	A
        JP	Z,LC063
        LD	DE,00100H
        LD	C,01AH
        CALL	BDOS
        LD	HL,1
        LD	(LC09F+14),HL
        LD	HL,04000H-00100H
        LD	DE,LC09F
        LD	C,027H
        CALL	BDOS
        JP	00100H

LC056:	DEFW	LC058

LC058:	CALL	0
        LD	A,C
        AND	0FEH
        CP	2
        JP	NZ,LC06A
LC063:	LD	A,(LC0C4)
        AND	A
        JP	Z,DSKBAS
LC06A:	LD	DE,LC079
        LD	C,009H
        CALL	BDOS
        LD	C,007H
        CALL	BDOS
        JR	L7F3A

LC079:	DEFB	"Boot error",13,10
        DEFB	"Press any key for retry",13,10
        DEFB	"$"

LC09F:	DEFB	0
        DEFB	"MSXDOS  SYS"

L_BOOT	EQU	$-LC01E

LC0C4	EQU	LC09F+37

	.DEPHASE

J.75FB:	LD	A,(RECSIZ+0)
	OR	A
	JP	Z,J.63AB
	LD	BC,32*256+0
	AND	A
J$7606:	ADC	HL,HL
	RL	E
	RL	D
	RL	C
	LD	A,C
	PUSH	HL
	LD	HL,RECSIZ+0
	SUB	(HL)
	POP	HL
	CCF
	JP	NC,J$761A
	LD	C,A
J$761A:	DJNZ	J$7606
	ADC	HL,HL
	RL	E
	RL	D
	JP	J.63AB

J.7625:	LD	HL,DEVICE
	INC	(HL)			; increase number of disk interfaces
	JR	J.762E

J.762B:	JR	NZ,J.762E		; no,
	INC	(HL)			; increase number of disk interfaces

J.762E:	LD	A,(DEVICE)
	OR	A			; disksystem disabled ?
	RET	M			; yep, quit
	RET	Z			; 0 disk interfaces, quit

J$7634:	CALL	C$7DEA			; test hdc
	RET	C			; error, quit
	LD	HL,16			; driver workarea controller
	CALL	C.5604			; allocate memory
	RET	C
	EX	DE,HL
	CALL	GETWRK			; get SLTWRK pointer
	LD	(HL),E
	INC	HL
	LD	(HL),D			; save driver workarea
	EX	DE,HL
	PUSH	HL
	POP	IX
	CALL	C$7715			; get host SCSI ID
	JR	C,J$7654		; CODE key pressed, skip initialisation
	LD	(HL),A
	CALL	C.798E			; initialize
	RET	C
J$7654:	LD	HL,DRVINF
	LD	B,4
	XOR	A
J.765A:	ADD	A,(HL)
	RET	C			; DRVINF corrupted, quit
	INC	HL
	INC	HL
	DJNZ	J.765A
	CP	8			; already 8 drives allocated ?
	RET	NC			; yep, quit
	LD	HL,(AUTLIN)
	LD	DE,SECLEN
	RST	20H
	JR	NC,J$7670
	LD	(AUTLIN),DE
J$7670:	LD	DE,DRVINF
	LD	B,4
	LD	C,0
J$7677:	LD	A,(DE)
	AND	A			; free entry ?
	JR	Z,J$7682		; yep, use it
	ADD	A,C
	LD	C,A
	INC	DE
	INC	DE
	DJNZ	J$7677
	RET

J$7682:	EXX
	LD	HL,6*8			; driver workarea partition
	CALL	C.5604			; allocate memory
	RET	C
	EX	DE,HL
	CALL	GETWRK			; get SLTWRK pointer
	LD	(HL),E
	INC	HL
	LD	(HL),D			; save driver workarea
	EX	DE,HL
	EXX
	LD	A,(TARGET)
	AND	A			; do not use phantom drive flag (CTRL key)
	LD	A,C
	CALL	C.7799			; initialize workarea (returns number of drives)
	ADD	A,L
	CP	8+1			; 8 drives or less ?
	LD	A,L
	JR	C,J$76A4		; yep, allocate all drives
	LD	A,8
	SUB	C			; limit number of drives
J$76A4:	PUSH	BC
	LD	(DE),A			; number of drives
	INC	DE
	CALL	GETSLT			; GETSLT
	LD	(DE),A			; slotid disk interface
	POP	BC
	LD	B,0
	LD	HL,$DPBLI
	ADD	HL,BC
	ADD	HL,BC
	PUSH	HL
	DEC	DE
	LD	A,(DE)			; number of drives
	PUSH	AF
	LD	L,A
	LD	H,0
	PUSH	DE
	LD	D,H
	LD	E,L
	ADD	HL,HL
	ADD	HL,HL			; *4
	ADD	HL,DE			; *5
	ADD	HL,HL			; *10
	ADD	HL,HL			; *20
	ADD	HL,DE			; *21
	CALL	C.5604			; allocate memory (for DPB)
	POP	DE
	JR	C,J$770E		; out of memory, quit
	PUSH	HL
	CALL	C.7A3C			; clear to end of line
	POP	DE
	POP	BC
	POP	HL
	LD	C,0
J$76D2:	LD	(HL),E
	INC	HL
	LD	(HL),D			; register DPB
	INC	HL
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,-512
	ADD	HL,SP
	LD	SP,HL
	LD	($SECBUF),HL		; allocate temporary sector buffer on stack
	LD	A,C
	LD	BC,(D$70CA)		; default mediadescriptor
	EX	DE,HL
	LD	B,0
	CALL	C.70DC			; GETDPB
	LD	HL,512
	EX	AF,AF'
	ADD	HL,SP
	EX	AF,AF'
	LD	SP,HL			; deallocate temporary sector buffer on stack
	POP	HL
	POP	DE
	LD	BC,21
	JR	C,J$76FF		; error, use the default DPB
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL
	JR	J$7706

J$76FF:	PUSH	HL
	LD	HL,I$70C9
	LDIR
	POP	HL
J$7706:	POP	BC
	INC	C
	DJNZ	J$76D2
	NOP
	NOP
	NOP
	RET

J$770E:	POP	AF
	POP	AF
	XOR	A
	LD	(DE),A
	INC	DE
	LD	(DE),A
	RET

;	  Subroutine get host SCSI ID
;	     Inputs  ________________________
;	     Outputs ________________________

C$7715:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	A,0
	CALL	SNSMAT
	CPL
	OR	A			; digit key pressed ?
	JR	Z,J$7734		; nope,
	PUSH	AF
	LD	B,8
J$7724:	RRA
	JR	C,J$7730
J$7727:	DJNZ	J$7724
	LD	A,C
	DEC	A
	JR	NZ,J$7733
	POP	AF
	JR	J.7767

J$7730:	INC	C
	JR	J$7727

J$7733:	POP	AF

; illegal code
; the following code is against the MSX coding rules, why not use the RTC BIOS calls ?
; also the alarm feature nibbles are used illegal

J$7734:	LD	C,0B5H
	DI
	LD	A,0DH
	OUT	(0B4H),A
	LD	A,09H
	OUT	(C),A                	; alarm off, clock running, bank 1
	LD	E,0
	LD	A,05H
	OUT	(0B4H),A
	IN	A,(C)
	AND	0FH			; read nibble 5 (normally hour of alarm)
	CP	03H			; special value written by BERT (?? not very relieable ??)
	JR	NZ,J.7764
	LD	A,07H
	OUT	(0B4H),A
	IN	A,(C)
	AND	0FH			; read nibble 7 (normally day of month alarm)
	LD	B,A
	LD	A,0DH
	OUT	(0B4H),A
	LD	A,B

; end illegal code

	JR	Z,J.7764
	LD	A,1
J$775F:	RLA
	DJNZ	J$775F
	JR	J.7767			; convert SCSI ID to SCSI ID bit mask

J.7764:	LD	A,(D$7FF0)		; get default SCSI ID bit mask

J.7767:	PUSH	AF
	LD	A,6
	CALL	SNSMAT
	AND	10H			; CODE key pressed ?
	LD	(IX+15),A		; save status of the CODE key
	LD	A,0
	JR	NZ,J$777B		; nope, quit with Cx reset
	POP	AF
	OR	A
	CCF				; set Cx
	JR	J$777D

J$777B:	POP	AF
	OR	A			; reset Cx
J$777D:	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine get host SCSI ID
;	     Inputs  ________________________
;	     Outputs ________________________

C.7781:	PUSH	IX
	PUSH	HL
	CALL	C.7A6A			; get pointer to driver workarea
	PUSH	BC
	LD	A,(IX+0)		; host SCSI ID bit mask
	LD	B,0
J$778D:	RRA
	JR	C,J$7793
	INC	B
	JR	J$778D			; convert to SCSI ID

J$7793:	LD	A,B
	POP	BC
	POP	HL
	POP	IX
	RET

;	  Subroutine initialize workarea
;	     Inputs  ________________________
;	     Outputs ________________________

C.7799:	PUSH	BC
	PUSH	DE
	PUSH	AF
	CALL	GETWRK
	LD	(HL),0FFH
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,6*8-1
	LDIR				; initialize driver workarea partitions
	POP	AF
	LD	HL,-512
	ADD	HL,SP
	LD	SP,HL			; allocate temporary sector buffer on stack
	LD	A,(IX+6*8+15)
	OR	A			; CODE key pressed ?
	LD	A,0
	JP	Z,J.7981		; yep, return 0 drives
	PUSH	AF
	PUSH	HL
	XOR	A
	LD	C,A			; number of 'drives' sofar = 0
	LD	(IX+0),A		; target SCSI ID = 0, LUN 0
	LD	(IX+1),A
	LD	(IX+2),A
	LD	(IX+3),A		; partition table is in logical block number 0

J.77C8:	POP	HL
	PUSH	HL
	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID + LUN
	PUSH	HL

J$77CF:	CALL	C.7BD4			; read capacity
	JR	NC,J$7816		; no error, continue
	LD	A,D
	CP	02H			; SCSI status = CHECK CONDITION ?
	JR	NZ,J$7811		; nope, stop partition search
	POP	HL
	PUSH	HL
	LD	HL,($SECBUF)
	EX	(SP),HL
	PUSH	HL
	LD	($SECBUF),HL		; $SECBUF = temporary sector buffer on stack
	LD	A,(IX+0)		; target SCSI ID + LUN
	PUSH	IX
	CALL	C.7B2F			; request sense
	POP	IX
	POP	HL
	EX	(SP),HL
	LD	($SECBUF),HL		; restore $SECBUF
	POP	HL
	PUSH	HL
	JR	NC,J$77FB		; no error,
	LD	A,E
	CP	02H			; SCSI sense code = NOT READY ?
	JR	NZ,J$7804		; nope,
J$77FB:	LD	DE,2
	ADD	HL,DE
	LD	A,(HL)
	CP	05H			; sense key = ILLEGAL REQUEST ?
	JR	NZ,J$7824		; nope, must be a FDD
J$7804:	POP	HL
	POP	BC
	LD	A,(IX+0)
	AND	07H
	LD	(IX+0),A		; LUN = 0
	JP	J.792D			; try next target

J$7811:	POP	HL
	POP	BC
	JP	J.7963			; stop partition search

; read capacity successfull

J$7816:	POP	HL
	PUSH	HL
	LD	A,(HL)			; size b24-b31
	INC	HL
	OR	(HL)			; size b16-b23
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	AND	0E0H			; size b15-b13
	DEC	HL
	OR	(HL)			; size > 8191 blocks (4 MB) ?
	JR	NZ,J$785F		; yep, must be a harddisk

; floppy

J$7824:	POP	HL
	POP	BC
	INC	C
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JP	NC,J.7963		; yep, stop partition search
	XOR	A
	LD	(IX+1),A
	LD	(IX+2),A
	LD	(IX+3),A		; starting sector = 0 (floppy has no partitions)
	LD	A,(IX+0)		; target SCSI ID
	PUSH	HL
	LD	HL,($SECBUF)
	PUSH	HL
	LD	HL,I$C000
	LD	($SECBUF),HL
	CALL	C.74A7			; try reading sector 0 FDD (try with different media types)
	POP	HL
	LD	($SECBUF),HL
	POP	HL
	LD	DE,8
	LD	A,20H
	ADD	A,(IX+0)
	ADD	IX,DE
	LD	(IX+0),A		; next partition, on same target but LUN + 1
	PUSH	BC
	PUSH	HL
	JP	J$77CF

J$785F:	POP	HL
	LD	C,(IX+3)
	LD	D,(IX+2)
	LD	E,(IX+1)		; starting sector
	LD	A,(IX+0)		; target SCSI ID
	PUSH	HL
	LD	B,1			; 1 block
	CALL	C.7AA8			; read logical block
	POP	IY
	POP	BC
	JP	C,J.7963		; error, stop partition search
	LD	DE,01BEH
	ADD	IY,DE
	LD	A,(IY+64)
	CP	55H
	JP	NZ,J.792D
	INC	HL
	LD	A,(IY+65)
	CP	0AAH			; MBR has valid bootsignature ?
	JP	NZ,J.792D		; nope, try next target
	POP	HL
	PUSH	HL
	LD	DE,01B6H
	ADD	HL,DE			; partition rights (BERT custom format)
	CALL	C.7781			; get host SCSI ID
	LD	E,A
	LD	D,0
	ADD	HL,DE
	LD	B,4			; 4 partitions
	LD	DE,8			; partition entry size

; partition rights
; 00 = ALL
; 01 = READ
; 02 = WRITE
; 03 = NONE

J$78A0:	LD	A,(HL)
	CPL
	AND	03H			; partition rights for this host = NONE ?
	JR	Z,J.7919		; yep, skip partition
	OR	0FCH			; b7-b2 = 1
	LD	(IX+6),A
	LD	A,(IY+4)
	DEC	A			; FAT12 partition ?
	JP	NZ,J$7945		; nope,
	LD	A,(IY+0)
	CPL				; active flag inverted
	AND	(IX+6)
	LD	(IX+6),A		; b7 = inactive flag
	LD	A,(IY+10)
	AND	0E0H
	OR	(IY+11)			; b31-b17 first sector of partition must be zero
	JR	NZ,J.7919		; nope, skip partition
	LD	A,(IY+12)
	SUB	1
	LD	(IX+4),A
	LD	A,(IY+13)
	SBC	A,D
	LD	(IX+5),A		; size of partition in sectors -1 (b15-b0)
	LD	A,(IY+14)
	SBC	A,D
	OR	(IY+15)			; size of partition in sectors -1 (b31-b16) must be zero
	JR	NZ,J.7919		; nope, skip partition
	INC	C
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	NC,J$78FC		; yep,
	LD	A,(IX+0)
	LD	(IX+0+8),A		; next partition same target SCSI ID
	LD	A,(IX+1)
	LD	(IX+1+8),A
	LD	A,(IX+2)
	LD	(IX+2+8),A
	LD	A,(IX+3)
	LD	(IX+3+8),A		; next partition has the partition table in the same logical block number
J$78FC:	LD	A,(IY+8)
	ADD	A,(IX+1)
	LD	(IX+1),A
	LD	A,(IY+9)
	ADC	A,(IX+2)
	LD	(IX+2),A
	LD	A,(IY+10)
	ADC	A,(IX+3)
	LD	(IX+3),A		; starting sector of partition (sector of partition tabel + first sector of partition (rel))
	ADD	IX,DE			; to next partition info
J.7919:	ADD	IY,DE
	ADD	IY,DE			; to next partition entry
	LD	A,(IY+4)
	CP	5			; next partition is a extended partition ?
	JR	Z,J$7949		; yep, handle
	DEC	B
	JP	NZ,J$78A0		; next partition entry
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	Z,J.7963		; yep, stop partition search
J.792D:	LD	A,(IX+0)
	INC	A
	CP	5+1			; maximium SCSI ID reached ?
	JR	NC,J.7963		; yep, stop partition search
	LD	(IX+0),A		; next target SCSI ID
	XOR	A
	LD	(IX+1),A
	LD	(IX+2),A
	LD	(IX+3),A		; partition table in logical block number 0
	JP	J.77C8			; start partition search

J$7945:	CP	5-1			; extended partition ?
	JR	NZ,J.7919		; nope, skip partition
J$7949:	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	Z,J.7963		; yep, stop partition search
	LD	A,(IY+8)
	LD	(IX+1),A
	LD	A,(IY+9)
	LD	(IX+2),A
	LD	A,(IY+10)
	LD	(IX+3),A		; partition table = first sector of the extended partition
	JP	J.77C8

J.7963:	POP	HL
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	Z,J$7977		; yep,
	LD	A,0FFH
	LD	(IX+3),A
	LD	(IX+2),A
	LD	(IX+1),A		; invalid starting sector
	LD	(IX+0),A		; partition disabled
J$7977:	POP	AF			; use minimal drives (CTRL pressed at startup) ?
	PUSH	AF
	LD	A,C
	JR	NZ,J.7981		; nope, return number of partitions (drives)
	CP	1			; 1 partition found ?
	JR	NZ,J.7981		; nope, return number of partitions (drives)
	INC	A			; yep, return 2 drives
J.7981:	LD	L,A
	POP	AF
	LD	IX,512
	ADD	IX,SP
	LD	SP,IX			; dispose sector buffer from stack
	POP	DE
	POP	BC
	RET

;	  Subroutine initialize
;	     Inputs  ________________________
;	     Outputs ________________________

C.798E:	XOR	A
	LD	DE,I$7A27		; version string
	CALL	C.4D7D			; print string
	LD	DE,I$7A0C		; wait string
	CALL	C.4D7D			; print string
J$799B:	CALL	C$7DCD
	JR	NZ,J$799B
	DI
	CALL	GETWRK
	LD	A,(D$7FF1)
	LD	(IX+1),A		; target SCSI ID bit mask
	XOR	A
	LD	(IX+6),A		; TEST UNIT READY
	LD	(IX+7),A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	(IX+10),A
	LD	(IX+11),A
	DEC	A
	LD	DE,6
	ADD	HL,DE			; to SCSI CDB
	LD	B,200
J.79C4:	LD	DE,0
	PUSH	BC
	PUSH	HL
	CALL	C.7C08			; execute SCSI CDB
	POP	HL
	POP	BC
	JR	NC,J$79D6		; no error,
	DJNZ	J.79C4
	LD	A,C
	OR	A
	JR	Z,J$79EB
J$79D6:	LD	A,D			; SCSI status
	CP	02H			; CHECK CONDITION ?
	JR	Z,J$79EE		; yep, wait and try again
	OR	A
	JR	NZ,J$79FC
	LD	A,(IX+1)
	SLA	A
	LD	(IX+1),A		; next target SCSI ID bit mask
	LD	BC,2*256+0
	JR	NC,J.79C4		; next target
J$79EB:	EI
	OR	A
	RET

J$79EE:	PUSH	BC
	LD	B,10
J$79F1:	CALL	C.7A51			; wait ?? ms
	DJNZ	J$79F1
	POP	BC
	LD	BC,200
	JR	J.79C4

J$79FC:	EI
	LD	DE,I$7A15
	CALL	C.4D7D			; print string
	LD	B,4
J$7A05:	CALL	C.7A51			; wait ?? ms
	DJNZ	J$7A05
	SCF
	RET

I$7A0C:	DEFB	"Wait...."
	DEFB	0

I$7A15:	DEFB	"Target off line",13,10
	DEFB	0

I$7A27:	DEFB	"SCSI V2.7 (C) 1994",13,10
	DEFB	0

;	  Subroutine clear to end of line
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A3C:	PUSH	DE
	LD	DE,I$7A5C
	CALL	C.4D7D			; print string
	POP	DE
	RET

;	  Subroutine get pointer to partition info
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A45:	ADD	A,A
	ADD	A,A
	ADD	A,A			; *8
	LD	E,A
	LD	D,0
	CALL	GETWRK
	ADD	IX,DE
	RET

;	  Subroutine wait ?? ms
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A51:	PUSH	HL
	LD	HL,0C350H
J$7A55:	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,J$7A55
J$7A5A:	POP	HL
	RET

I$7A5C:	DEFB	13
	DEFB	27,"K"
	DEFB	0

INIHRD:
J.7A60:	LD	A,7
	CALL	SNSMAT
	BIT	6,A			; SELECT pressed ?
	RET	NZ			; nope, quit
	POP	HL
	RET				; quit interface initialisation

;	  Subroutine get pointer to driver workarea
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A6A:	PUSH	HL
	PUSH	BC
	CALL	GETWRK
	LD	BC,6*8
	ADD	IX,BC
	POP	BC
	POP	HL
	RET

;	  Subroutine convert SCSI ID to SCSI ID bit mask
;	     Inputs  A = SCSI ID
;	     Outputs ________________________

C.7A77:	PUSH	BC
	AND	07H
	LD	B,A
	LD	A,1
	JR	Z,J$7A82
J$7A7F:	RLA
	DJNZ	J$7A7F
J$7A82:	LD	(IX+1),A
	POP	BC
	RET

;	  Subroutine test unit ready
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A87:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
J$7A8D:	LD	(IX+6),0		; TEST UNIT READY
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	LD	(IX+7),A		; LUN
	XOR	A
	LD	(IX+8),A		; Reserved
	LD	(IX+9),A		; Reserved
	LD	(IX+10),A		; Reserved
	LD	(IX+11),A		; CONTROL
	JP	J.7BFE

;	  Subroutine read logical block
;	     Inputs  A = SCSI ID + LUN, CDE = Logical Block Address, B = number of blocks
;	     Outputs ________________________

C.7AA8:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),08H		; READ
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	OR	C			; MSB Logical Block Address
	LD	(IX+7),A		; LUN, MSB Logical Block Address
	LD	(IX+8),D
	LD	(IX+9),E		; Logical Block Address
	LD	(IX+10),B		; Transfer Length
	LD	(IX+11),0		; CONTROL
	JP	J.7BFE

;	  Subroutine mode select
;	     Inputs  A = SCSI ID + LUN, B = parameter list length
;	     Outputs ________________________

C.7ACA:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),15H		; MODE SELECT
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	LD	(IX+7),A		; PF = 0, SP = 0
	XOR	A
	LD	(IX+8),A		; Reserved
	LD	(IX+9),A		; Reserved
	LD	(IX+10),B		; Parameter List Length
	LD	(IX+11),A		; CONTROL
	JP	J.7BFE

;	  Subroutine format unit
;	     Inputs  A = SCSI ID + LUN, B = FmtData (b4), CmpLst (b3), Defect list format (b2-b0), DE = interleave
;	     Outputs ________________________

C.7AEB:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),04H		; FORMAT UNIT
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	OR	B
	LD	(IX+7),A		; LUN
	XOR	A
	LD	(IX+8),A		; Vendor-specific = 0
	LD	(IX+9),D
	LD	(IX+10),E		; Interleave
	LD	(IX+11),A		; CONTROL
	JP	J.7BFE

;	  Subroutine write logical block
;	     Inputs  A = SCSI ID + LUN, CDE = logical block address, B = number of blocks
;	     Outputs ________________________

C.7B0D:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),0AH		; WRITE
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	OR	C
	LD	(IX+7),A		; LUN + MSB Logical Block Addres
	XOR	A
	LD	(IX+8),D
	LD	(IX+9),E		; Logical Block Addres
	LD	(IX+10),B		; Transfer Length
	LD	(IX+11),A		; CONTROL
	JP	J.7BFE

;	  Subroutine request sense
;	     Inputs  A = SCSI ID + LUN
;	     Outputs Cx set if error, A = errorcode

C.7B2F:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),03H		; REQUEST SENSE
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	LD	(IX+7),A		; LUN + Reserved
	XOR	A
	LD	(IX+8),A		; Reserved
	LD	(IX+9),A		; Reserved
	LD	B,18
	LD	(IX+10),B		; Allocation Length
	LD	(IX+11),A		; CONTROL
	LD	HL,($SECBUF)
	POP	AF
	CALL	C.7A77			; convert SCSI ID to SCSI ID bit mask
	CALL	C.7C08			; execute SCSI CDB
	POP	IX
	BIT	3,D			; SCSI status BSY ?
	LD	A,24
	SCF
	RET	NZ			; yep, quit with UNFORMATED DISK error
	INC	D
	DEC	D			; SCSI status OK ?
	LD	A,2
	SCF
	RET	NZ			; nope, quit with NOT READY error
	LD	IX,($SECBUF)
	LD	A,(IX+0)
	AND	7FH			; error code
	CP	70H			; current error ?
	LD	A,12
	SCF
	RET	NZ			; nope, quit with OTHER error
	LD	A,(IX+2)
	OR	A			; sense key = NO SENSE ?
	RET	Z			; yep, quit without error
	CP	7
	CCF				; sense key 1-6 ?
	LD	E,A
	LD	A,0
	RET	C			; nope, quit WRITE PROTECT error
	LD	HL,I$7B89
	ADD	HL,DE
	LD	A,(HL)
	SCF
	RET

I$7B89:	DEFB	24			; 0 NO SENSE, UNFORMATED DISK error
	DEFB	4			; 1 SOFT ERROR, DATA error
	DEFB	2			; 2 NOT READY, NOT READY error
	DEFB	4			; 3 MEDIUM ERROR, DATA error
	DEFB	8			; 4 HARDWARE ERROR, RECORD NOT FOUND error
	DEFB	12			; 5 ILLEGAL REQUEST, OTHER error
	DEFB	24			; 6 UNIT ATTENTION, UNFORMATED DISK error

;	  Subroutine inquiry
;	     Inputs  A = SCSI ID + LUN
;	     Outputs ________________________

J$7B90:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),12H		; INQUIRY
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	LD	(IX+7),A		; LUN, Reserved
	XOR	A
	LD	(IX+8),A		; Page Code = 0
	LD	(IX+9),A		; Reserved
	LD	B,36
	LD	(IX+10),B		; Allocation Length
	LD	(IX+11),A		; CONTROL
	JR	J.7BFE

;	  Subroutine mode sense
;	     Inputs  A = SCSI ID + LUN, B = PC + Page code
;	     Outputs ________________________

C.7BB2:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),1AH		; MODE SENSE
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	LD	(IX+7),A		; LUN, Reserved, DBD = 0
	XOR	A
	LD	(IX+8),B		; PC, Page code
	LD	(IX+9),A		; Reserved
	LD	B,128
	LD	(IX+10),B		; Allocation length = 128
	LD	(IX+11),A		; Control
	JR	J.7BFE

;	  Subroutine read capacity
;	     Inputs  A = SCSI ID + LUN
;	     Outputs ________________________

C.7BD4:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),25H		; READ CAPACITY
	POP	AF
	PUSH	AF
	AND	0E0H			; LUN
	LD	(IX+7),A		; LUN, RelAdr = 0
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	(IX+10),A
	LD	(IX+11),A		; Logical block address = 0
	LD	(IX+12),A		; Reserved
	LD	(IX+13),A		; Reserved
	LD	(IX+14),A		; Reserved, PMI = 0
	LD	(IX+15),A		; Control
J.7BFE:	POP	AF			; target SCSI ID
	CALL	C.7A77			; convert SCSI ID to SCSI ID bit mask
	CALL	C.7C08			; execute SCSI CDB
	POP	IX
	RET

;	  Subroutine execute SCSI CDB
;	     Inputs  ________________________
;	     Outputs D = SCSI status code, E = sense key code

C.7C08:	CALL	C$7C3D
	RET	C			; error, quit
	LD	A,E			; sense key code
	OR	A			; NO SENSE ?
	JR	Z,J$7C38		; yep,
	CP	04H			; HARDWARE ERROR ?
	JR	Z,J$7C18		; yep,
	LD	D,12H			; SCSI status 12H
	SCF
	RET

J$7C18:	PUSH	BC
J.7C19:	IN	A,(0D4H)		; read SCSI bus status
	CP	46H			; BSY, I, SEL ?
	JR	NZ,J.7C19		; nope, wait
	LD	A,(IX+0)		; target SCSI ID bit mask
	OR	(IX+1)
	LD	B,A
	IN	A,(0D0H)		; read SCSI data
	CP	B
	JR	NZ,J.7C19
	LD	A,08H			; assert BSY
	OUT	(0D1H),A
J$7C2F:	IN	A,(0D4H)		; read SCSI bus status
	BIT	1,A			; SEL ?
	JR	NZ,J$7C2F		; yep, wait
	JP	J.7CE1			; terminate actions

J$7C38:	LD	A,D
	OR	A			; SCSI status OK ?
	RET	Z			; yep, quit
	SCF
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7C3D:	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID bit mask
	SLA	A
J$7C43:	LD	C,A
	JR	C,J.7C4D
	SLA	A
	JR	C,J.7C4D
	OR	C
	JR	J$7C43

J.7C4D:	IN	A,(0D4H)		; read SCSI bus status
	OR	A
	JR	NZ,J.7C4D
	IN	A,(0D0H)		; read SCSI data
	OR	A
	JR	NZ,J.7C4D
	IN	A,(0D4H)		; read SCSI bus status
	OR	A
	JR	NZ,J.7C4D
	LD	A,(IX+0)		; target SCSI ID bit mask
	OUT	(0D0H),A		; write SCSI data
	LD	A,01H
	OUT	(0D2H),A		; start arbitrate
J$7C65:	IN	A,(0D1H)
	BIT	6,A			; arbitrate in progress ?
	JR	NZ,J$7C73		; yep,
	IN	A,(0D4H)		; read SCSI bus status
	AND	0FEH			; ignore DBP
	JR	NZ,J.7C86
	JR	J$7C65

J$7C73:	NOP
	NOP
	IN	A,(0D1H)
	BIT	5,A			; lost arbitrate ?
	JR	NZ,J.7C86		; yep,
	IN	A,(0D0H)		; read SCSI data
	AND	C
	JR	NZ,J.7C86
	IN	A,(0D1H)
	BIT	5,A			; lost arbitrate ?
	JR	Z,J$7C94		; nope,
J.7C86:	XOR	A
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D1H),A		; deassert
	OUT	(0D2H),A
	LD	A,R
J$7C8F:	DEC	A
	JR	NZ,J$7C8F		; wait random
	JR	J.7C4D			; try again

J$7C94:	LD	A,0CH
	OUT	(0D1H),A		; assert BSY and SEL
	NOP
	LD	A,(IX+0)		; target SCSI ID bit mask
	OR	(IX+1)
	OUT	(0D0H),A		; write SCSI data
	LD	A,0DH
	OUT	(0D1H),A		; assert BSY, SEL and databus
	XOR	A
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D4H),A		; select enable
	LD	A,05H
	OUT	(0D1H),A		; assert SEL and databus
	LD	BC,041F2H
J$7CB1:	IN	A,(0D4H)		; read SCSI bus status
	BIT	6,A			; BSY ?
	JR	NZ,J.7CE1		; yep, terminate actions
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J$7CB1
	XOR	A
	OUT	(0D0H),A		; write SCSI data
	OUT	(0D1H),A		; deassert
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D3H),A		; data out
	LD	DE,8			;
	SCF
	JR	J.7CDF

; handle non BSY

J$7CCB:	XOR	A
	OUT	(0D1H),A		; deassert
	OUT	(0D0H),A		; write SCSI data
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D3H),A		; data out
	LD	(IX+4),L
	LD	(IX+5),H		; save pointer
J$7CDA:	XOR	A
	CP	D
	JR	Z,J.7CDF
	SCF
J.7CDF:	POP	BC
	RET

;	  Subroutine terminate actions
;	     Inputs  ________________________
;	     Outputs ________________________

J.7CE1:	LD	A,00H
	OUT	(0D1H),A		; deassert
	LD	A,22H
	OUT	(0D2H),A		; enable parity, dma
	POP	BC
	PUSH	BC
	LD	C,0D0H			; SCSI data port
	PUSH	IX
	EX	(SP),HL
	LD	DE,6
	ADD	HL,DE
	EX	DE,HL
	POP	HL

; SCSI bus status main loop

J.7CF6:	XOR	A
	OUT	(0D2H),A		; stop dma
	OUT	(0D1H),A		; deassert
J$7CFB:	IN	A,(0D4H)		; read SCSI bus status
	RLCA				; RST ?
	JR	C,J$7CDA		; yep, quit
	RLCA				; BSY ?
	JR	NC,J$7CCB		; nope,
	RLCA				; REQ ?
	JR	NC,J$7CFB		; nope, get SCSI bus status again
	RLCA				; MSG ?
	JP	C,J$7D9A		; yep,
	RLCA				; C ?
	JR	C,J$7D5C		; yep,
	RLCA				; I ?
	JR	C,J$7D34		; yep,

; handle DATA OUTPUT

	OUT	(0D3H),A		; target command
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D5H),A		; Start DMA Send
	LD	A,01H
	OUT	(0D1H),A		; assert databus
J.7D1C:	IN	A,(0D5H)
	BIT	6,A			; DMA req ?
	JR	Z,J$7D2A		; nope,
	OUTI
	LD	A,01H
	OUT	(0D1H),A		; assert databus
	JR	J.7D1C

J$7D2A:	IN	A,(0D4H)		; read SCSI bus status
	AND	0DEH			; ignore REQ and DBP
	CP	40H			; BSY and output ?
	JR	Z,J.7D1C		; yep, continue pseudo DMA
	JR	J.7CF6			; scsi bus status main loop

; handle DATA INPUT

J$7D34:	LD	C,0D6H			; data input register
	OUT	(0D3H),A		; status
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D7H),A		; Start DMA Initiator Receive
	XOR	A
	OUT	(0D1H),A		; deassert
J.7D41:	IN	A,(0D5H)
	BIT	6,A			; DMA req ?
	JR	Z,J$7D50		; nope,
	INI
	IN	A,(0D0H)		; read SCSI data
	XOR	A
	OUT	(0D1H),A		; deassert
	JR	J.7D41

J$7D50:	IN	A,(0D4H)		; read SCSI bus status
	AND	0DEH			; ignore REQ and DBP
	CP	44H			; BSY and input ?
	JR	Z,J.7D41		; yep, continue pseudo DMA
	LD	C,0D0H			; SCSI data port
	JR	J.7CF6			; scsi bus status main loop

; handle C

J$7D5C:	RLCA				; I ?
	JR	C,J$7D88		; yep,
	OUT	(0D3H),A		; target command
	EX	DE,HL
	LD	A,01H
	OUT	(0D1H),A		; assert databus
J.7D66:	IN	A,(0D4H)		; read SCSI bus status
	AND	0FEH			; ignore DBP
	CP	68H			; BSY and REQ and command ?
	JR	NZ,J$7D80		; nope,
	OUTI
	LD	A,11H
	OUT	(0D1H),A		; assert ACK and databus
J$7D74:	IN	A,(0D4H)		; read SCSI bus status
	BIT	5,A			; REQ ?
	JR	NZ,J$7D74		; yep, wait
	LD	A,01H
	OUT	(0D1H),A		; assert databus
	JR	J.7D66

J$7D80:	CP	48H			; BSY no REQ and command ?
	JR	Z,J.7D66		; continue
	EX	DE,HL
J.7D85:	JP	J.7CF6			; scsi bus status main loop

J$7D88:	OUT	(0D3H),A		; target command
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D7H),A		; Start DMA Initiator Receive
	IN	A,(0D6H)		; read data from scsi bus
	LD	D,A			; SCSI status code
	IN	A,(C)
	LD	(IX+2),D
	JR	J.7D85			; scsi bus status main loop

; handle MSG

J$7D9A:	RLCA				; data ?
	JR	NC,J$7DC4		; yep,
	RLCA				; input or output ?
	JR	C,J$7DB1		; input,
	OUT	(0D3H),A		; target command
	LD	A,01H
	OUT	(0D1H),A		; assert databus
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D5H),A		; Start DMA Send
	XOR	A
	OUT	(C),A
	JR	J.7D85			; scsi bus status main loop

J$7DB1:	OUT	(0D3H),A		; target command
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D7H),A		; Start DMA Initiator Receive
	IN	A,(0D6H)		; read data from scsi bus
	LD	E,A			; command status message
	IN	A,(C)
	LD	(IX+3),E
	JP	J.7CF6			; scsi bus status main loop

J$7DC4:	LD	A,50H
	OUT	(0D1H),A		; assert testmode and ACK 
	XOR	A
	OUT	(0D1H),A		; deassert
	JR	J.7D85			; scsi bus status main loop

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7DCD:	IN	A,(0D4H)		; read SCSI bus status
	BIT	6,A			; BSY ?
	RET	Z			; yep, quit
	LD	A,7
	CALL	SNSMAT
	CP	0BFH			; SELECT pressed ?
	RET	NZ			; nope, quit

;	  Subroutine reset hdc
;	     Inputs  ________________________
;	     Outputs ________________________

J.7DDA:	LD	A,80H
	OUT	(0D1H),A		; assert RST
	XOR	A
	NOP
	NOP
	OUT	(0D1H),A		; deassert
	OUT	(0D0H),A		; scsi data = 0
	OUT	(0D2H),A		; mode = 0 (PIO)
	OUT	(0D3H),A		; target command = 0 (data out)
	RET

;	  Subroutine test hdc
;	     Inputs  ________________________
;	     Outputs ________________________

C$7DEA:	IN	A,(0D4H)		; read SCSI bus status
	INC	A
	JR	Z,J.7DFC
	LD	A,40H
	OUT	(0D1H),A		; test mode
	IN	A,(0D4H)		; read SCSI bus status
	INC	A			; because NCR5380 is disconnected, all bit should read 1
	JR	NZ,J.7DFC		; nope, self test failed
	OUT	(0D1H),A		; deassert
	OR	A
	RET

J.7DFC:	XOR	A
	OUT	(0D1H),A		; deassert
	LD	DE,I$7E0E
	CALL	C.4D7D			; print string
	LD	B,4
J$7E07:	CALL	C.7A51			; wait ?? ms
	DJNZ	J$7E07
	SCF
	RET

I$7E0E:	DEFB	"SCSI interface",13,10
	DEFB	"selftest failed",13,10
	DEFB	0

	DEFS	07F80H-$,0

	DEFB	"HD"			; SCSI BIOS id
	DEFB	021H			; SCSI BIOS 2.1
	JP	J.7DDA			; SetWD3393
	JP	J.7CE1			; TermAct
?.7F89:	JP	C.7AA8			; RdLogBlk
?.7F8C:	JP	C.7B0D			; WrLogBlk
?.7F8F:	JP	C.7B2F			; ReqSense
?.7F92:	JP	J$7B90			; Inquiry
?.7F95:	JP	C.7BD4			; ReadCap
?.7F98:	JP	C.7BB2			; ModeSense
?.7F9B:	JP	C.7ACA			; ModeSel
?.7F9E:	JP	C.7AEB			; FmtUnit
?.7FA1:	JP	C.7A87			; TstUnitRdy
?.7FA4:	JP	C.798E			; Initialise
?.7FA7:	JP	C.7799			; InsWork
?.7FAA:	JP	C.7A3C			; ClrEndLn
?.7FAD:	JP	C.7C08			; execute SCSI CDB (BERT ONLY CALL)

	DEFS	07FF0H-$,0

D$7FF0:	DEFB	080H			; host id 7
D$7FF1:	DEFB	001H			; target id 0
	DEFB	0D0H			; I/O port

	DEFS	08000H-$,0


;	  Subroutine intercept after INIENV
;	     Inputs  ________________________
;	     Outputs ________________________

; patched at 048F9H

;       LD	HL,DEVICE
;       INC	(HL)			; increase number of diskdrivers sofar
;       RET

	ORG	048F9H

	JP	J.7625
       	INC	(HL)			; increase number of diskdrivers sofar
       	RET


; patched at 04903H

;       RET	NZ			; no, quit
;       INC	(HL)			; Set 1 diskROM
;       RET

	ORG	04903H

	JP	J.762B


;	  Subroutine LOC patch
;	     Inputs  ________________________
;	     Outputs ________________________

; patch 0638DH
;
;       JR	NZ,L6399		; nop, LOF
;       PUSH	HL
;	PUSH	DE
;	LD	A,2
;	LD	DE,0
;	LD	HL,0

	ORG	0638DH

	JP	Z,J.75FB
	PUSH	HL
	PUSH	DE
	LD	A,2
	LD	DE,0
	LD	H,D
	LD	L,E



	END
