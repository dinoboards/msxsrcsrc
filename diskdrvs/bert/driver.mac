; Diskdriver BERT SCSI controller
; HDC	NCR 5380

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by ? and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders

	.Z80
SNSMAT	EQU	0141H

C.4D7D	EQU	4D7DH			; print string
C.4DBB	EQU	4DBBH			; get SLTWRK pointer
C$4E05	EQU	4E05H			; GETSLT
C.5604	EQU	5604H			; allocate memory
J.63AB	EQU	63ABH			; finish seek

I$C000	EQU	0C000H

RECSIZ	EQU	0F33DH
TARGET	EQU	0F33FH
$SECBUF	EQU	0F34DH
$DPBLI	EQU	0F355H
BDOS	EQU	0F37DH
AUTLIN	EQU	0F6ABH
DRVINF	EQU	0FB21H
PROCNM	EQU	0FD89H
DEVICE	EQU	0FD99H


MYSIZ	EQU	0
SECLEN	EQU	512


DEFDPB	EQU	$-1
?.6EC5:	RET

DRIVES:
?.6EC6:	LD	L,0
	RET

;	  Subroutine general error (DSKIO/DSKCHG/GETDPB in segment 1,2,3)
;	     Inputs  ________________________
;	     Outputs ________________________

?.6EC9:	LD	A,12
	SCF

INIENV:
MTOFF:
J.6ECC:	RET

;	  Subroutine not formatable (CHOICE in segment 1,2,3)
;	     Inputs  ________________________
;	     Outputs ________________________

?.6ECD:	LD	HL,I$6ED1
	RET

I$6ED1:	DEFB	0

;	  Subroutine general error (DSKFMT in segment 1,2,3)
;	     Inputs  ________________________
;	     Outputs ________________________

?.6ED2:	LD	A,16
	SCF
	RET

OEMSTA:
?.6ED6:	EI
	PUSH	HL
	PUSH	DE
	LD	DE,I$6F48
	LD	HL,PROCNM
J$6EDF:	LD	A,(DE)
	AND	A
	JR	Z,J.6EEE
	CP	(HL)
	JR	NZ,J.6EEA
	INC	DE
	INC	HL
	JR	J$6EDF

J.6EEA:	POP	DE
	POP	HL
	SCF
	RET

J.6EEE:	LD	A,(HL)
	INC	HL
	CP	" "
	JR	Z,J.6EEE
	CP	"="
	JR	NZ,J.6EEA
J$6EF8:	LD	A,(HL)
	INC	HL
	CP	" "
	JR	Z,J$6EF8
	SUB	"0"
	JR	C,J.6EEA
	CP	7+1
	JR	NC,J.6EEA
	LD	B,A
	LD	A,(HL)
	OR	A			; end of statement ?
	JR	NZ,J.6EEA		; nope, quit
	LD	A,B
	AND	07H			; ?? is already verified 0-7
	LD	A,1
	JR	Z,J$6F15
J$6F12:	RLA
	DJNZ	J$6F12			; create bit mask
J$6F15:	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	POP	AF
	LD	(IX+0),A		; save host SCSI ID bit mask

; illegal code
; the following code is against the MSX coding rules, why not use the RTC BIOS calls ?
; also the alarm feature nibbles are used illegal


	LD	C,0B5H
	DI
	LD	A,0DH
	OUT	(0B4H),A
	IN	A,(C)
	PUSH	AF			; save current nibble 13
	LD	A,09H
	OUT	(C),A                	; alarm off, clock running, bank 1
	LD	A,07H
	OUT	(0B4H),A
	CALL	C.7781			; get host SCSI ID
	OUT	(C),A			; write nibble 7 (normally day of month alarm)
	LD	A,05H
	OUT	(0B4H),A
	LD	A,03H
	OUT	(C),A			; write nibble 5 = 3 (normally hour of alarm)
	LD	A,0DH
	OUT	(0B4H),A
	POP	AF
	OUT	(C),A			; restore nibble 13
	EI

; end illegal code

	POP	DE
	POP	HL
	XOR	A
	RET

I$6F48:	DEFB	"SCSIID"
	DEFB	0

;	  Subroutine DSKIO
;	     Inputs  ________________________
;	     Outputs ________________________

DSKIO:
J.6F4F:	EI
	PUSH	AF
	CP	5+1			; valid driveid ?
	JP	NC,J.7090		; nope, quit with OTHER ERROR
	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C.7A45			; get pointer to partition info
	POP	HL
	POP	DE
	POP	BC
	POP	AF

;	  Subroutine read/write sector from partition
;	     Inputs  ________________________
;	     Outputs ________________________

C$6F60:	LD	A,(IX+0)
	BIT	4,A			; partition enabled ?
	JP	NZ,J$70EF		; nope, quit with UNFORMATED DISK ERROR
	PUSH	AF
	LD	A,C
	SUB	0F0H			; mediadescriptor 0F0H (PC: 1.44 MB floppy, MSX: harddisk) ?
	JR	Z,J.6F79		; yep, continue
	CP	0F8H-0F0H		; mediadescriptor 0F8H (PC: hardisk, MSX: 360KB disk) ?
	JR	Z,J.6F79		; yep, continue
	CP	0F9H-0F0H		; mediadescriptor 0F9H (PC and MSX: 720KB disk) ?
	JR	Z,J.6F79		; yep, continue
	JP	J.7090			; quit with OTHER ERROR

J.6F79:	LD	C,0
	PUSH	DE
	LD	A,B
	DEC	A			; number of sectors - 1
	ADD	A,E
	LD	E,A
	LD	A,C
	ADC	A,D
	LD	D,A
	LD	A,C
	ADC	A,C
	LD	C,A			; CDE = end sector
	LD	A,(IX+4)
	SUB	E
	LD	A,(IX+5)
	SBC	A,D
	LD	A,0
	SBC	A,C
	POP	DE
	JP	C,J$7069
	LD	A,E
	ADD	A,(IX+1)
	LD	E,A
	LD	A,D
	ADC	A,(IX+2)
	LD	D,A
	LD	A,00H
	ADC	A,(IX+3)
	LD	C,A
	POP	AF
	PUSH	DE
	PUSH	BC
	PUSH	IX
	JR	C,J$6FB8
	BIT	1,(IX+6)
	JP	Z,J$705E
	CALL	C.7AA8			; read logical block
	JR	J$6FC2

J$6FB8:	BIT	0,(IX+6)
	JP	Z,J$7058
	CALL	C.7B0D			; write logical block
J$6FC2:	POP	IX
	POP	BC
	LD	A,D
	POP	DE
	OR	A
	LD	A,18H
	RET	Z
	PUSH	DE
	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	LD	(IX+7),00H
	CALL	C.7B2F			; request sense
	PUSH	AF
	CP	18H
	JR	NZ,J$701D
	POP	AF
J$6FDF:	LD	HL,($SECBUF)
	EX	(SP),IX
	LD	A,(IX+0)		; target SCSI ID
	LD	BC,1*256+0
	LD	DE,0
	CALL	C.7AA8			; read logical block
	EX	(SP),IX
	JR	C,J$6FFC
	POP	IX
	LD	A,18H
	SCF
	PUSH	AF
	JR	J.7043

J$6FFC:	EX	(SP),IX
	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7A87			; test unit ready
	LD	A,(IX+7)
	CALL	C.7429
	INC	(IX+7)
	LD	A,(IX+7)
	EX	(SP),IX
	CP	04H	; 4 
	JR	NZ,J$6FDF
	POP	IX
	LD	A,12
	SCF
	JR	J.701E

J$701D:	POP	AF
J.701E:	POP	HL
	PUSH	AF
	INC	D
	DEC	D
	JR	NZ,J.7043
	LD	A,(IX+2)
	CP	06H
	JR	NZ,J$7047
	PUSH	HL
	CALL	GETWRK
	POP	IX
	LD	A,(IX+0)
	OR	08H			; ? bit
	LD	DE,8
	LD	B,6
J$703B:	CP	(HL)
	JR	NZ,J$7040
	RES	3,(HL)
J$7040:	ADD	HL,DE
	DJNZ	J$703B
J.7043:	POP	AF
	POP	BC
	POP	DE
	RET

J$7047:	POP	AF
	POP	BC
	POP	DE
	BIT	7,(IX+0)
	RET	Z
	PUSH	AF
	LD	A,B
	SUB	(IX+6)
	ADD	A,E
	LD	B,A
	POP	AF
	RET

J$7058:	POP	AF
	POP	BC
	POP	AF
	XOR	A
	SCF
	RET

J$705E:	POP	AF
	POP	BC
	JR	J.7084

?.7062:	POP	AF
	POP	BC
	POP	AF
	LD	A,10
	SCF
	RET

J$7069:	LD	A,(IX+4)
	SUB	E
	LD	C,A
	INC	C
	LD	A,(IX+5)
	SBC	A,D
	JR	C,J.7084
	LD	A,B
	SUB	C
	LD	B,A
	POP	AF
	PUSH	BC
	LD	B,C
	LD	C,0F0H			; mediadescriptor harddisk
	CALL	C$6F60			; read/write sector from partition
	JR	C,J$7089
	POP	BC
	DEFB	03EH
J.7084:	POP	AF
	LD	A,8
	SCF
	RET

J$7089:	POP	DE
	PUSH	AF
	LD	A,B
	ADD	A,D
	LD	B,A
	POP	AF
	RET

J.7090:	POP	AF
J.7091:	LD	A,12
	SCF
	RET

;	  Subroutine DSKCHG
;	     Inputs  ________________________
;	     Outputs ________________________

J.7095:	EI
	CP	5+1			; valid driveid ?
	JR	NC,J.7091		; nope, quit with OTHER ERROR
	OR	A
	PUSH	AF
	PUSH	HL
	CALL	C.7A45			; get pointer to partition info
	POP	HL
	POP	AF
	LD	B,A
	LD	A,(IX+1)
	OR	(IX+2)
	OR	(IX+3)			; first sector of partition 0 (floppy) ?
	LD	A,B
	JR	J$70B6

?.70AF:	LD	B,1
	BIT	3,(IX+0)
	RET	NZ
J$70B6:	LD	B,0FFH
	SET	3,(IX+0)
	RES	4,(IX+0)		; enable partition
	PUSH	BC
	CALL	C.70DC			; GETDPB
	POP	BC
	LD	A,18H			; ??
	OR	A			; quit with OK
	RET

I$70C9:	DEFB	0
D$70CA:	DEFB	0F9H
	DEFW	512
        DEFB	0FH
        DEFB	04H
        DEFB	1FH
        DEFB	06H
	DEFW	1
        DEFB	2
        DEFB	240
        DEFW	41
        DEFW	1300
        DEFB	12
        DEFW	25

;	  Subroutine GETDPB
;	     Inputs  ________________________
;	     Outputs ________________________

GETDPB:
C.70DC:	EI
	CP	5+1			; valid driveid ?
	JP	NC,J.7091		; nope, quit with OTHER ERROR
	PUSH	AF
	PUSH	HL
	CALL	C.7A45			; get pointer to partition info
	POP	HL
	POP	AF
	BIT	4,(IX+0)		; partition enabled ?
	JR	Z,J$70F3		; yep, continue
J$70EF:	LD	A,22			; quit with UNFORMATED DISK ERROR
	SCF
	RET

J$70F3:	LD	(IX+7),00H
	PUSH	HL
	LD	HL,($SECBUF)
	PUSH	HL
	LD	A,(IX+0)		; target SCSI ID
	LD	B,1
	LD	C,(IX+3)
	LD	D,(IX+2)
	LD	E,(IX+1)
	CALL	C.7AA8			; read logical block
	LD	A,D
	CALL	C$71C9
	POP	IY
	POP	IX
	JR	NC,J.711D
	CP	18H
	JR	Z,J.711D
	SCF
	RET

J.711D:	LD	A,(IY+21)
	LD	(IX+1),A
	CP	0F0H			; mediadescriptor 0F0H (PC: 1.44 MB floppy, MSX: harddisk) ?
	JR	Z,J.7133		; yep, continue
	CP	0F9H			; mediadescriptor 0F9H (PC and MSX: 720KB disk) ?
	JR	Z,J.7133		; yep, continue
	CP	0F8H			; mediadescriptor 0F8H (PC: hardisk, MSX: 360KB disk) ?
	JR	Z,J.7133		; yep, continue
	LD	A,18
	SCF
	RET	NZ
J.7133:	LD	L,(IY+14)
	LD	H,(IY+15)
	LD	(IX+8),L
	LD	(IX+9),H
	LD	A,(IY+16)
	LD	(IX+10),A
	LD	E,(IY+22)
	LD	D,(IY+23)
	LD	(IX+16),E
	LD	B,A
J$714F:	ADD	HL,DE
	DJNZ	J$714F
	LD	(IX+17),L
	LD	(IX+18),H
	LD	E,(IY+17)
	LD	D,(IY+18)
	LD	(IX+11),E
	LD	C,(IY+11)
	LD	B,(IY+12)
	LD	(IX+2),C
	LD	(IX+3),B
	SRL	B
	RR	C
	SRL	B
	RR	C
	SRL	B
	RR	C
	SRL	B
	RR	C
	SRL	B
	RR	C
	DEC	C
	LD	(IX+4),C
	ADD	A,E
	LD	E,A
	RL	D
J$7189:	INC	B
	RR	C
	JR	C,J$7189
	DEC	B
	LD	(IX+5),B
J$7192:	SRL	D
	RR	E
	DJNZ	J$7192
	ADD	HL,DE
	LD	(IX+12),L
	LD	(IX+13),H
	EX	DE,HL
	LD	L,(IY+19)
	LD	H,(IY+20)
	OR	A
	SBC	HL,DE
	LD	A,(IY+13)
	DEC	A
	LD	(IX+6),A
J$71B0:	INC	B
	RRCA
	JR	C,J$71B0
	LD	(IX+7),B
	DEC	B
	JR	Z,J$71C0
J$71BA:	SRL	H
	RR	L
	DJNZ	J$71BA
J$71C0:	INC	HL
	LD	(IX+14),L
	LD	(IX+15),H
	OR	A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$71C9:	OR	A
	RET	Z
	PUSH	DE
	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	LD	(IX+7),00H
	CALL	C.7B2F			; request sense
	PUSH	AF
	CP	18H
	JR	NZ,J$71FA
	POP	AF
	POP	IX
	CALL	C.74A7
	JP	NC,J$71F4
	SET	4,(IX+0)		; disable partition
	LD	A,(IX+0)
	CALL	C.7B2F			; request sense
	JP	J.701E

J$71F4:	LD	A,18H
	SCF
	POP	BC
	POP	DE
	RET

J$71FA:	POP	AF
	JP	J.701E


;	  Subroutine CHOICE
;	     Inputs  ________________________
;	     Outputs ________________________

CHOICE:
J.71FE:	CALL	C.7A45			; get pointer to partition info
	LD	A,(IX+1)
	OR	(IX+2)
	OR	(IX+3)			; first sector of partition 0 (floppy) ?
	JR	Z,J$7210		; yep, must be a floppy disk
	LD	HL,I$7373
	RET

J$7210:	LD	HL,I$73C0
	RET

;	  Subroutine DSKFMT
;	     Inputs  ________________________
;	     Outputs ________________________

DSKFMT:
J.7214:	LD	E,A
	CP	5			; valid choice ?
	JR	NC,J$721C		; nope, quit with error
	LD	A,D
	CP	5+1			; valid driveid ?
J$721C:	CCF
	LD	A,12
	RET	C			; nope, quit with error
	SCF
	DEC	E			; choice 0 ?
	RET	M			; yep, quit with error
	PUSH	DE
	LD	A,D
	PUSH	HL
	PUSH	BC
	CALL	C.7A45			; get pointer to partition info
	POP	BC
	POP	HL
	POP	DE
	LD	A,(IX+1)
	OR	(IX+2)
	OR	(IX+3)			; first sector of partition 0 (floppy) ?
	JP	Z,J$7264		; yep, format floppy disk
	LD	D,0
	LD	HL,I$7245
	ADD	HL,DE
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)

I$7245:	DEFW	J.724D			; choice 1, enable partition
	DEFW	J.7256			; choice 2, disable partition
	DEFW	J.725B			; choice 3, write protect partition
	DEFW	J.7260			; choice 4, invalid choice

J.724D:	RES	4,(IX+0)		; enable partition
	SET	0,(IX+6)		; write enable
	RET

J.7256:	SET	4,(IX+0)		; disable partition
	RET

J.725B:	RES	0,(IX+6)
	RET

J.7260:	SCF
	LD	A,12
	RET

J$7264:	LD	A,B
	CP	HIGH 512		; enough workspace ?
	JP	C,J$7325		; nope, quit with error
	LD	A,E
	AND	0FH
	CALL	C.7429
	LD	A,(IX+0)
	PUSH	HL
	CALL	C.7362			; clear sector buffer
	LD	B,00H
	PUSH	DE
	LD	DE,0
	CALL	C.7AEB			; format unit
	JR	NC,J$7291		; ok, continue
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	CALL	C.7B2F			; request sense
	POP	IX
	POP	DE
	POP	HL
	JP	J$732A

J$7291:	POP	DE
	LD	A,E
	ADD	A,A
	ADD	A,A
	ADD	A,A			; *8
	ADD	A,4
	LD	E,A
	LD	D,0
	LD	HL,I.74D6
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	BC,30
	POP	DE
	PUSH	DE
	LDIR
	LD	HL,I$756E
	LD	BC,L_BOOT
	LDIR
	POP	HL
	CALL	C.732F			; write sector
	RET	C			; error, quit
	PUSH	HL
	LD	DE,17
	ADD	HL,DE
	LD	E,(HL)
	LD	BC,4
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	POP	HL
	PUSH	BC
	SLA	B
	LD	A,E
	SRL	E
	SRL	E
	SRL	E
	SRL	E
	AND	1FH
	JR	Z,J$72D6
	INC	E
J$72D6:	LD	A,E
	ADD	A,B
	LD	B,A
	CALL	C.7362			; clear sector buffer
J$72DC:	CALL	C.732F			; write sector
	JR	NC,J$72E3		; ok, continue
	POP	BC
	RET

J$72E3:	DJNZ	J$72DC
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),0FFH
	INC	HL
	LD	(HL),0FFH
	DEC	HL
	DEC	HL
	LD	(IX+1),1
	LD	(IX+2),0
	LD	(IX+3),0
	CALL	C.732F			; write sector (first sector of FAT #1)
	RET	C			; error, quit
	LD	A,B
	DEC	A
	ADD	A,(IX+1)
	LD	(IX+1),A
	JR	NC,J.7311
	INC	(IX+2)
	JR	NZ,J.7311
	INC	(IX+3)
J.7311:	CALL	C.732F			; write sector (first sector of FAT #2)
	RET	C			; error, quit
	LD	(IX+1),0
	LD	(IX+2),0
	LD	(IX+3),0
	XOR	A			; no error
	LD	A,22			; ??
	RET

J$7325:	CCF
	LD	A,14
	RET

?.7329:	XOR	A
J$732A:	SCF
	RET

?.732C:	LD	A,4
	RET

;	  Subroutine write sector
;	     Inputs  ________________________
;	     Outputs ________________________

C.732F:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	B,1
	LD	C,(IX+3)
	LD	D,(IX+2)
	LD	E,(IX+1)		; starting sector
	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7B0D			; write logical block
	JR	NC,J$734F		; no error,
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	CALL	C.7B2F			; request sense
	POP	IX
J$734F:	PUSH	AF
	INC	(IX+1)
	JR	NZ,J.735D
	INC	(IX+2)
	JR	NZ,J.735D
	INC	(IX+3)
J.735D:	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET

;	  Subroutine clear sector buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C.7362:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	HL
	POP	DE
	LD	(HL),0
	INC	DE
	LD	BC,512-1
	LDIR
	POP	BC
	POP	DE
	POP	HL
	RET

I$7373:	DEFB	13,10
	DEFB	"1 - Enable partition",13,10
	DEFB	"2 - Disable partition",13,10
	DEFB	"3 - Write protect partition",13,10
	DEFB	0

I$73C0:	DEFB	13,10
	DEFB	"1 - 720Kb (double side)",13,10
	DEFB	"2 - 1.44Mb (double side)",13,10
	DEFB	"3 - 2.88Mb (double side)",13,10
	DEFB	"4 - 360Kb (singel side)",13,10
	DEFB	0

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7429:	PUSH	IY
	PUSH	IX
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	PUSH	HL
	LD	B,3
J$7434:	LD	A,(IX+0)		; target SCSI ID
	CALL	C.7A87			; test unit ready
	JR	NC,J$7440		; no error,
	DJNZ	J$7434
	JR	J.7498

J$7440:	LD	A,(IX+0)		; target SCSI ID
	LD	B,5
	CALL	C.7BB2			; mode sense
J$7448:	JR	C,J.7498		; error,
	POP	IY
	LD	(IY+12),05H	; 5 
	LD	(IY+0),00H
	LD	(IY+2),00H
	LD	(IY+3),00H
	PUSH	IY
	POP	HL
	LD	DE,4
J$7462:	ADD	HL,DE
	PUSH	HL
	LD	DE,8
	ADD	HL,DE
	POP	DE
	LD	BC,32
	LDIR
	POP	AF
	LD	D,00H
	ADD	A,A
	ADD	A,A
	ADD	A,A			; *8
	LD	E,A
	LD	HL,I.74D6
	ADD	HL,DE
	LD	A,(HL)
	LD	(IY+1),A
	INC	HL
	LD	A,(HL)
	LD	(IY+8),A
	INC	HL
	LD	A,(HL)
	LD	(IY+9),A
	INC	HL
	INC	HL
	LD	A,(IX+0)		; target SCSI ID
	LD	B,24H
	PUSH	IY
	POP	HL
	CALL	C.7ACA			; mode select
	JR	C,J$749A		; error,
	JR	J$749E

J.7498:	POP	HL
	POP	AF
J$749A:	XOR	A
	DEC	A
	JR	J$749F

J$749E:	XOR	A
J$749F:	POP	BC
	POP	DE
	POP	HL
	POP	IX
	POP	IY
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.74A7:	LD	(IX+7),00H
	PUSH	HL
	PUSH	DE
	PUSH	BC
J$74AE:	LD	HL,($SECBUF)
	LD	A,(IX+0)		; target SCSI ID
	LD	BC,1*256+0
	LD	DE,0			; 1 block, block 0
	CALL	C.7AA8			; read logical block
	JR	NC,J$74D2		; no error, quit
	LD	A,(IX+7)
	CALL	C.7429
	INC	(IX+7)
	LD	A,(IX+7)
	CP	4
	JR	NZ,J$74AE
	LD	A,22			; quit with UNFORMATED DISK ERROR
	SCF
J$74D2:	POP	BC
	POP	DE
	POP	HL
	RET

I.74D6:	DEFB	080H,002H,009H,000H
	DEFW	I.74F6
	DEFW	0

	DEFB	088H,002H,012H,000H
	DEFW	I.7514
	DEFW	0

	DEFB	08CH,002H,024H,000H
	DEFW	I.7532
	DEFW	0

	DEFB	080H,001H,009H,000H
	DEFW	I.7550
	DEFW	0

I.74F6:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	112
        DW	1440
        DB	0F9h
        DW	3
        DW	9
        DW	2
        DW	0

I.7514:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	240
        DW	2880
        DB	0F9h
        DW	5
        DW	18
        DW	2
        DW	0

I.7532:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	240
        DW	5760
        DB	0F9h
        DW	9
        DW	36
        DW	2
        DW	0

I.7550:	DB	0EBh,0FEh,090h
        DB	"SCSI FD "
        DW	512
        DB	2
        DW	1
        DB	2
        DW	112
        DW	720
        DB	0F8h
        DW	3
        DW	9
        DW	1
        DW	0


I$756E:
        .PHASE	0C01EH

LC01E:  RET	NC
        LD	(LC058+1),DE
        LD	(LC0C4),A
        LD	(HL),LOW LC056
        INC	HL
        LD	(HL),HIGH LC056
L7F3A:	LD	SP,KBUF+256
        LD	DE,LC09F
        LD	C,00FH
        CALL	BDOS
        INC	A
        JP	Z,LC063
        LD	DE,00100H
        LD	C,01AH
        CALL	BDOS
        LD	HL,1
        LD	(LC09F+14),HL
        LD	HL,04000H-00100H
        LD	DE,LC09F
        LD	C,027H
        CALL	BDOS
        JP	00100H

LC056:	DEFW	LC058

LC058:	CALL	0
        LD	A,C
        AND	0FEH
        CP	2
        JP	NZ,LC06A
LC063:	LD	A,(LC0C4)
        AND	A
        JP	Z,DSKBAS
LC06A:	LD	DE,LC079
        LD	C,009H
        CALL	BDOS
        LD	C,007H
        CALL	BDOS
        JR	L7F3A

LC079:	DEFB	"Boot error",13,10
        DEFB	"Press any key for retry",13,10
        DEFB	"$"

LC09F:	DEFB	0
        DEFB	"MSXDOS  SYS"

L_BOOT	EQU	$-LC01E

	.DEPHASE

;	  Subroutine LOC patch
;	     Inputs  ________________________
;	     Outputs ________________________

; patch 0638DH
;
;       JR	NZ,L6399		; nop, LOF
;       PUSH	HL
;	PUSH	DE
;	LD	A,2
;	LD	DE,0
;	LD	HL,0

;	JP	Z,J.75FB
;	PUSH	HL
;	PUSH	DE
;	LD	A,2
;	LD	DE,0
;	LD	H,D
;	LD	L,E


?.75FB:	LD	A,(RECSIZ+0)
	OR	A
	JP	Z,J.63AB
	LD	BC,32*256+0
	AND	A
J$7606:	ADC	HL,HL
	RL	E
	RL	D
	RL	C
	LD	A,C
	PUSH	HL
	LD	HL,RECSIZ+0
	SUB	(HL)
	POP	HL
	CCF
	JP	NC,J$761A
	LD	C,A
J$761A:	DJNZ	J$7606
	ADC	HL,HL
	RL	E
	RL	D
	JP	J.63AB

; patched at 048F9H

;       LD	HL,DEVICE
;       INC	(HL)			; increase number of diskdrivers sofar
;       RET

;	JP	J.7625
;       INC	(HL)			; increase number of diskdrivers sofar
;       RET

?.7625:	LD	HL,DEVICE
	INC	(HL)
	JR	J.762E

; patched at 04903H

;       RET	NZ			; no, quit
;       INC	(HL)			; Set 1 diskROM
;       RET

;	JP	J.762B

?.762B:	JR	NZ,J.762E
	INC	(HL)
J.762E:	LD	A,(DEVICE)
	OR	A
	RET	M
	RET	Z
J$7634:	CALL	C$7DEA			; test hdc
	RET	C			; error, quit
	LD	HL,16			; driver workarea controller
	CALL	C.5604			; allocate memory
	RET	C
	EX	DE,HL
	CALL	C.4DBB			; get SLTWRK pointer
	LD	(HL),E
	INC	HL
	LD	(HL),D			; save driver workarea
	EX	DE,HL
	PUSH	HL
	POP	IX
	CALL	C$7715			; get host SCSI ID
	JR	C,J$7654		; CODE key pressed, skip initialisation
	LD	(HL),A
	CALL	C.798E			; initialize
	RET	C
J$7654:	LD	HL,DRVINF
	LD	B,4
	XOR	A
J.765A:	ADD	A,(HL)
	RET	C			; DRVINF corrupted, quit
	INC	HL
	INC	HL
	DJNZ	J.765A
	CP	8			; already 8 drives allocated ?
	RET	NC			; yep, quit
	LD	HL,(AUTLIN)
	LD	DE,SECLEN
	RST	20H
	JR	NC,J$7670
	LD	(AUTLIN),DE
J$7670:	LD	DE,DRVINF
	LD	B,4
	LD	C,0
J$7677:	LD	A,(DE)
	AND	A			; free entry ?
	JR	Z,J$7682		; yep, use it
	ADD	A,C
	LD	C,A
	INC	DE
	INC	DE
	DJNZ	J$7677
	RET

J$7682:	EXX
	LD	HL,6*8			; driver workarea partition
	CALL	C.5604			; allocate memory
	RET	C
	EX	DE,HL
	CALL	C.4DBB			; get SLTWRK pointer
	LD	(HL),E
	INC	HL
	LD	(HL),D			; save driver workarea
	EX	DE,HL
	EXX
	LD	A,(TARGET)
	AND	A			; do not use phantom drive flag (CTRL key)
	LD	A,C
	CALL	C.7799			; initialize workarea (returns number of drives)
	ADD	A,L
	CP	8+1			; 8 drives or less ?
	LD	A,L
	JR	C,J$76A4		; yep, allocate all drives
	LD	A,8
	SUB	C			; limit number of drives
J$76A4:	PUSH	BC
	LD	(DE),A			; number of drives
	INC	DE
	CALL	C$4E05			; GETSLT
	LD	(DE),A			; slotid disk interface
	POP	BC
	LD	B,0
	LD	HL,$DPBLI
	ADD	HL,BC
	ADD	HL,BC
	PUSH	HL
	DEC	DE
	LD	A,(DE)			; number of drives
	PUSH	AF
	LD	L,A
	LD	H,0
	PUSH	DE
	LD	D,H
	LD	E,L
	ADD	HL,HL
	ADD	HL,HL			; *4
	ADD	HL,DE			; *5
	ADD	HL,HL			; *10
	ADD	HL,HL			; *20
	ADD	HL,DE			; *21
	CALL	C.5604			; allocate memory (for DPB)
	POP	DE
	JR	C,J$770E		; out of memory, quit
	PUSH	HL
	CALL	C.7A3C			; clear to end of line
	POP	DE
	POP	BC
	POP	HL
	LD	C,0
J$76D2:	LD	(HL),E
	INC	HL
	LD	(HL),D			; register DPB
	INC	HL
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,-512
	ADD	HL,SP
	LD	SP,HL
	LD	($SECBUF),HL		; allocate temporary sector buffer on stack
	LD	A,C
	LD	BC,(D$70CA)		; default mediadescriptor
	EX	DE,HL
	LD	B,0
	CALL	C.70DC			; GETDPB
	LD	HL,512
	EX	AF,AF'
	ADD	HL,SP
	EX	AF,AF'
	LD	SP,HL			; deallocate temporary sector buffer on stack
	POP	HL
	POP	DE
	LD	BC,21
	JR	C,J$76FF		; error, use the default DPB
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL
	JR	J$7706

J$76FF:	PUSH	HL
	LD	HL,I$70C9
	LDIR
	POP	HL
J$7706:	POP	BC
	INC	C
	DJNZ	J$76D2
	NOP
	NOP
	NOP
	RET

J$770E:	POP	AF
	POP	AF
	XOR	A
	LD	(DE),A
	INC	DE
	LD	(DE),A
	RET

;	  Subroutine get host SCSI ID
;	     Inputs  ________________________
;	     Outputs ________________________

C$7715:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	A,0
	CALL	SNSMAT
	CPL
	OR	A			; digit key pressed ?
	JR	Z,J$7734		; nope,
	PUSH	AF
	LD	B,8
J$7724:	RRA
	JR	C,J$7730
J$7727:	DJNZ	J$7724
	LD	A,C
	DEC	A
	JR	NZ,J$7733
	POP	AF
	JR	J.7767

J$7730:	INC	C
	JR	J$7727

J$7733:	POP	AF

; illegal code
; the following code is against the MSX coding rule, why not use the RTC BIOS calls ?
; also the alarm feature nibbles are used illegal

J$7734:	LD	C,0B5H
	DI
	LD	A,0DH
	OUT	(0B4H),A
	LD	A,09H
	OUT	(C),A                	; alarm off, clock running, bank 1
	LD	E,0
	LD	A,05H
	OUT	(0B4H),A
	IN	A,(C)
	AND	0FH			; read nibble 5 (normally hour of alarm)
	CP	03H			; special value written by BERT (?? not very relieable ??)
	JR	NZ,J.7764
	LD	A,07H
	OUT	(0B4H),A
	IN	A,(C)
	AND	0FH			; read nibble 7 (normally day of month alarm)
	LD	B,A
	LD	A,0DH
	OUT	(0B4H),A
	LD	A,B

; end illegal code

	JR	Z,J.7764
	LD	A,1
J$775F:	RLA
	DJNZ	J$775F
	JR	J.7767			; convert SCSI ID to SCSI ID bit mask

J.7764:	LD	A,(D$7FF0)		; get default SCSI ID bit mask

J.7767:	PUSH	AF
	LD	A,6
	CALL	SNSMAT
	AND	10H			; CODE key pressed ?
	LD	(IX+15),A		; save status of the CODE key
	LD	A,0
	JR	NZ,J$777B		; nope, quit with Cx reset
	POP	AF
	OR	A
	CCF				; set Cx
	JR	J$777D

J$777B:	POP	AF
	OR	A			; reset Cx
J$777D:	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine get host SCSI ID
;	     Inputs  ________________________
;	     Outputs ________________________

C.7781:	PUSH	IX
	PUSH	HL
	CALL	C.7A6A			; get pointer to driver workarea
	PUSH	BC
	LD	A,(IX+0)		; host SCSI ID bit mask
	LD	B,0
J$778D:	RRA
	JR	C,J$7793
	INC	B
	JR	J$778D			; convert to SCSI ID

J$7793:	LD	A,B
	POP	BC
	POP	HL
	POP	IX
	RET

;	  Subroutine initialize workarea
;	     Inputs  ________________________
;	     Outputs ________________________

C.7799:	PUSH	BC
	PUSH	DE
	PUSH	AF
	CALL	GETWRK
	LD	(HL),0FFH
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,6*8-1
	LDIR				; initialize driver workarea
	POP	AF
	LD	HL,-512
	ADD	HL,SP
	LD	SP,HL			; allocate temporary sector buffer on stack
	LD	A,(IX+6*8+15)
	OR	A			; CODE key pressed ?
	LD	A,0
	JP	Z,J.7981		; yep, return 0 drives
	PUSH	AF
	PUSH	HL
	XOR	A
	LD	C,A			; number of 'drives' sofar = 0
	LD	(IX+0),A		; target SCSI ID = 0
	LD	(IX+1),A
	LD	(IX+2),A
	LD	(IX+3),A		; starting sector = 0

J.77C8:	POP	HL
	PUSH	HL
	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID
	PUSH	HL
J$77CF:	CALL	C.7BD4			; read capacity
	JR	NC,J$7816		; no error, continue
	LD	A,D
	CP	02H
	JR	NZ,J$7811
	POP	HL
	PUSH	HL
	LD	HL,($SECBUF)
	EX	(SP),HL
	PUSH	HL
	LD	($SECBUF),HL
	LD	A,(IX+0)		; target SCSI ID
	PUSH	IX
	CALL	C.7B2F			; request sense
	POP	IX
	POP	HL
	EX	(SP),HL
	LD	($SECBUF),HL
	POP	HL
	PUSH	HL
	JR	NC,J$77FB		; no error,
	LD	A,E
	CP	02H
	JR	NZ,J$7804
J$77FB:	LD	DE,2
	ADD	HL,DE
	LD	A,(HL)
	CP	05H
	JR	NZ,J$7824
J$7804:	POP	HL
	POP	BC
	LD	A,(IX+0)
	AND	07H
	LD	(IX+0),A
	JP	J.792D

J$7811:	POP	HL
	POP	BC
	JP	J.7963

J$7816:	POP	HL
	PUSH	HL
	LD	A,(HL)
	INC	HL
	OR	(HL)
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	AND	0E0H
	DEC	HL
	OR	(HL)			; max block 0 ?
	JR	NZ,J$785F		; nope,
J$7824:	POP	HL
	POP	BC
	INC	C
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JP	NC,J.7963		; yep,
	XOR	A
	LD	(IX+1),A
	LD	(IX+2),A
	LD	(IX+3),A		; starting sector = 0
	LD	A,(IX+0)		; target SCSI ID
	PUSH	HL
	LD	HL,($SECBUF)
	PUSH	HL
	LD	HL,I$C000
	LD	($SECBUF),HL
	CALL	C.74A7
	POP	HL
	LD	($SECBUF),HL
	POP	HL
	LD	DE,8
	LD	A,20H
	ADD	A,(IX+0)
	ADD	IX,DE
	LD	(IX+0),A
	PUSH	BC
	PUSH	HL
	JP	J$77CF

J$785F:	POP	HL
	LD	C,(IX+3)
	LD	D,(IX+2)
	LD	E,(IX+1)		; starting sector
	LD	A,(IX+0)		; target SCSI ID
	PUSH	HL
	LD	B,1			; 1 block
	CALL	C.7AA8			; read logical block
	POP	IY
	POP	BC
	JP	C,J.7963		; error,
	LD	DE,01BEH
	ADD	IY,DE
	LD	A,(IY+64)
	CP	55H
	JP	NZ,J.792D
	INC	HL
	LD	A,(IY+65)
	CP	0AAH			; MBR has valid bootsignature ?
	JP	NZ,J.792D		; nope,
	POP	HL
	PUSH	HL
	LD	DE,01B6H
	ADD	HL,DE
	CALL	C.7781			; get host SCSI ID
	LD	E,A
	LD	D,0
	ADD	HL,DE
	LD	B,4			; 4 partitions
	LD	DE,8

J$78A0:	LD	A,(HL)
	CPL
	AND	03H
	JR	Z,J.7919		; nope, skip partition
	OR	0FCH
	LD	(IX+6),A
	LD	A,(IY+4)
	DEC	A			; FAT12 partition ?
	JP	NZ,J$7945		; nope,
	LD	A,(IY+0)
	CPL				; active flag inverted
	AND	(IX+6)
	LD	(IX+6),A		; b7 = inactive flag
	LD	A,(IY+10)
	AND	0E0H
	OR	(IY+11)			; b31-b17 first sector of partition must be zero
	JR	NZ,J.7919		; nope, skip partition
	LD	A,(IY+12)
	SUB	1
	LD	(IX+4),A
	LD	A,(IY+13)
	SBC	A,D
	LD	(IX+5),A		; size of partition in sectors -1 (b15-b0)
	LD	A,(IY+14)
	SBC	A,D
	OR	(IY+15)			; size of partition in sectors -1 (b31-b16) must be zero
	JR	NZ,J.7919		; nope, skip partition
	INC	C
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	NC,J$78FC		; yep,
	LD	A,(IX+0)
	LD	(IX+8),A
	LD	A,(IX+1)
	LD	(IX+9),A
	LD	A,(IX+2)
	LD	(IX+10),A
	LD	A,(IX+3)
	LD	(IX+11),A
J$78FC:	LD	A,(IY+8)
	ADD	A,(IX+1)
	LD	(IX+1),A
	LD	A,(IY+9)
	ADC	A,(IX+2)
	LD	(IX+2),A
	LD	A,(IY+10)
	ADC	A,(IX+3)
	LD	(IX+3),A		; ? + starting sector of partition
	ADD	IX,DE
J.7919:	ADD	IY,DE
	ADD	IY,DE
	LD	A,(IY+4)
	CP	5			; extended partition ?
	JR	Z,J$7949		; yep, handle
	DEC	B
	JP	NZ,J$78A0		; next partition entry
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	Z,J.7963		; yep,
J.792D:	LD	A,(IX+0)
	INC	A
	CP	6			; maximium number of drives reached ?
	JR	NC,J.7963		; yep,
	LD	(IX+0),A
	XOR	A
	LD	(IX+1),A
	LD	(IX+2),A
	LD	(IX+3),A		; starting sector = 0
	JP	J.77C8

J$7945:	CP	5-1			; extended partition ?
	JR	NZ,J.7919		; nope, skip partition
J$7949:	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	Z,J.7963		; yep,
	LD	A,(IY+8)
	LD	(IX+1),A
	LD	A,(IY+9)
	LD	(IX+2),A
	LD	A,(IY+10)
	LD	(IX+3),A		; starting sector = first sector of the extended partition
	JP	J.77C8

J.7963:	POP	HL
	LD	A,C
	CP	6			; maximium number of drives reached ?
	JR	Z,J$7977		; yep,
	LD	A,0FFH
	LD	(IX+3),A
	LD	(IX+2),A
	LD	(IX+1),A
	LD	(IX+0),A
J$7977:	POP	AF			; use minimal drives (CTRL pressed at startup) ?
	PUSH	AF
	LD	A,C
	JR	NZ,J.7981		; nope, return number of partitions (drives)
	CP	1			; 1 partition found ?
	JR	NZ,J.7981		; nope, return number of partitions (drives)
	INC	A			; yep, return 2 drives
J.7981:	LD	L,A
	POP	AF
	LD	IX,512
	ADD	IX,SP
	LD	SP,IX			; dispose sector buffer from stack
	POP	DE
	POP	BC
	RET

;	  Subroutine initialize
;	     Inputs  ________________________
;	     Outputs ________________________

C.798E:	XOR	A
	LD	DE,I$7A27		; version string
	CALL	C.4D7D			; print string
	LD	DE,I$7A0C		; wait string
	CALL	C.4D7D			; print string
J$799B:	CALL	C$7DCD
	JR	NZ,J$799B
	DI
	CALL	GETWRK
	LD	A,(D$7FF1)
	LD	(IX+1),A		; target SCSI ID bit mask
	XOR	A
	LD	(IX+6),A		; TEST UNIT READY
	LD	(IX+7),A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	(IX+10),A
	LD	(IX+11),A
	DEC	A
	LD	DE,6
	ADD	HL,DE			; to SCSI CDB
	LD	B,200
J.79C4:	LD	DE,0
	PUSH	BC
	PUSH	HL
	CALL	C.7C08			; execute SCSI CDB
	POP	HL
	POP	BC
	JR	NC,J$79D6		; no error,
	DJNZ	J.79C4
	LD	A,C
	OR	A
	JR	Z,J$79EB
J$79D6:	LD	A,D
	CP	02H
	JR	Z,J$79EE
	OR	A
	JR	NZ,J$79FC
	LD	A,(IX+1)
	SLA	A
	LD	(IX+1),A		; next target SCSI ID bit mask
	LD	BC,2*256+0
	JR	NC,J.79C4		; next target
J$79EB:	EI
	OR	A
	RET

J$79EE:	PUSH	BC
	LD	B,10
J$79F1:	CALL	C.7A51			; wait ?? ms
	DJNZ	J$79F1
	POP	BC
	LD	BC,200
	JR	J.79C4

J$79FC:	EI
	LD	DE,I$7A15
	CALL	C.4D7D			; print string
	LD	B,4
J$7A05:	CALL	C.7A51			; wait ?? ms
	DJNZ	J$7A05
	SCF
	RET

I$7A0C:	DEFB	"Wait...."
	DEFB	0

I$7A15:	DEFB	"Target off line",13,10
	DEFB	0

I$7A27:	DEFB	"SCSI V2.7 (C) 1994",13,10
	DEFB	0

;	  Subroutine clear to end of line
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A3C:	PUSH	DE
	LD	DE,I$7A5C
	CALL	C.4D7D			; print string
	POP	DE
	RET

;	  Subroutine get pointer to partition info
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A45:	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	E,A
	LD	D,0
	CALL	GETWRK
	ADD	IX,DE
	RET

;	  Subroutine wait ?? ms
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A51:	PUSH	HL
	LD	HL,0C350H
J$7A55:	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,J$7A55
J$7A5A:	POP	HL
	RET

I$7A5C:	DEFB	13
	DEFB	27,"K"
	DEFB	0

INIHRD:
J.7A60:	LD	A,7
	CALL	SNSMAT
	BIT	6,A			; SELECT pressed ?
	RET	NZ			; nope, quit
	POP	HL
	RET				; quit interface initialisation

;	  Subroutine get pointer to driver workarea
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A6A:	PUSH	HL
	PUSH	BC
	CALL	GETWRK
	LD	BC,6*8
	ADD	IX,BC
	POP	BC
	POP	HL
	RET

;	  Subroutine convert SCSI ID to SCSI ID bit mask
;	     Inputs  A = SCSI ID
;	     Outputs ________________________

C.7A77:	PUSH	BC
	AND	07H
	LD	B,A
	LD	A,1
	JR	Z,J$7A82
J$7A7F:	RLA
	DJNZ	J$7A7F
J$7A82:	LD	(IX+1),A
	POP	BC
	RET

;	  Subroutine test unit ready
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A87:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
J$7A8D:	LD	(IX+6),0		; TEST UNIT READY
	POP	AF
	PUSH	AF
	AND	0E0H
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	(IX+10),A
	LD	(IX+11),A
	JP	J.7BFE

;	  Subroutine read logical block
;	     Inputs  ________________________
;	     Outputs ________________________

C.7AA8:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),08H		; READ
	POP	AF
	PUSH	AF
	AND	0E0H
	OR	C
	LD	(IX+7),A
	LD	(IX+8),D
	LD	(IX+9),E
	LD	(IX+10),B
	LD	(IX+11),00H
	JP	J.7BFE

;	  Subroutine mode select
;	     Inputs  ________________________
;	     Outputs ________________________

C.7ACA:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),15H		; MODE SELECT
	POP	AF
	PUSH	AF
	AND	0E0H
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	(IX+10),B
	LD	(IX+11),A
	JP	J.7BFE

;	  Subroutine format unit
;	     Inputs  ________________________
;	     Outputs ________________________

C.7AEB:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),04H		; FORMAT UNIT
	POP	AF
	PUSH	AF
	AND	0E0H
	OR	B
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),D
	LD	(IX+10),E
	LD	(IX+11),A
	JP	J.7BFE

;	  Subroutine write logical block
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B0D:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),0AH		; WRITE
	POP	AF
	PUSH	AF
	AND	0E0H
	OR	C
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),D
	LD	(IX+9),E
	LD	(IX+10),B
	LD	(IX+11),A
	JP	J.7BFE

;	  Subroutine request sense
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B2F:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),03H		; REQUEST SENSE
	POP	AF
	PUSH	AF
	AND	0E0H
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	B,12H
	LD	(IX+10),B
	LD	(IX+11),A
	LD	HL,($SECBUF)
	POP	AF
	CALL	C.7A77			; convert SCSI ID to SCSI ID bit mask
	CALL	C.7C08			; execute SCSI CDB
	POP	IX
	BIT	3,D
	LD	A,18H
	SCF
	RET	NZ
	INC	D
	DEC	D
	LD	A,02H	; 2 
	SCF
	RET	NZ
	LD	IX,($SECBUF)
	LD	A,(IX+0)
J$7B6E:	AND	7FH
	CP	70H	; "p"
	LD	A,0CH	; 12 
	SCF
	RET	NZ
	LD	A,(IX+2)
	OR	A
	RET	Z
	CP	07H	; 7 
	CCF
	LD	E,A
	LD	A,00H
	RET	C
	LD	HL,I$7B89
	ADD	HL,DE
	LD	A,(HL)
	SCF
	RET

I$7B89:	DEFB	018H
	DEFB	004H
	DEFB	002H
	DEFB	004H
	DEFB	008H
	DEFB	00CH
	DEFB	018H

;	  Subroutine inquiry
;	     Inputs  ________________________
;	     Outputs ________________________

J$7B90:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),12H		; INQUIRY
	POP	AF
	PUSH	AF
	AND	0E0H
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	B,24H
	LD	(IX+10),B
	LD	(IX+11),A
	JR	J.7BFE

;	  Subroutine mode sense
;	     Inputs  ________________________
;	     Outputs ________________________

C.7BB2:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),1AH		; MODE SENSE
	POP	AF
	PUSH	AF
	AND	0E0H
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),B
	LD	(IX+9),A
	LD	B,80H
	LD	(IX+10),B
	LD	(IX+11),A
	JR	J.7BFE

;	  Subroutine read capacity
;	     Inputs  ________________________
;	     Outputs ________________________

C.7BD4:	PUSH	IX
	PUSH	AF
	CALL	C.7A6A			; get pointer to driver workarea
	LD	(IX+6),25H		; READ CAPACITY
	POP	AF
	PUSH	AF
	AND	0E0H
	LD	(IX+7),A
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
	LD	(IX+10),A
	LD	(IX+11),A
	LD	(IX+12),A
	LD	(IX+13),A
	LD	(IX+14),A
	LD	(IX+15),A
J.7BFE:	POP	AF			; target SCSI ID
	CALL	C.7A77			; convert SCSI ID to SCSI ID bit mask
	CALL	C.7C08			; execute SCSI CDB
	POP	IX
	RET

;	  Subroutine execute SCSI CDB
;	     Inputs  ________________________
;	     Outputs ________________________

C.7C08:	CALL	C$7C3D
	RET	C
	LD	A,E
	OR	A
	JR	Z,J$7C38
	CP	04H
	JR	Z,J$7C18
	LD	D,12H
	SCF
	RET

J$7C18:	PUSH	BC
J.7C19:	IN	A,(0D4H)		; read SCSI bus status
	CP	46H			; BSY, I, SEL ?
	JR	NZ,J.7C19		; nope, wait
	LD	A,(IX+0)		; target SCSI ID bit mask
	OR	(IX+1)
	LD	B,A
	IN	A,(0D0H)		; read SCSI data
	CP	B
	JR	NZ,J.7C19
	LD	A,08H			; assert BSY
	OUT	(0D1H),A
J$7C2F:	IN	A,(0D4H)		; read SCSI bus status
	BIT	1,A			; SEL ?
	JR	NZ,J$7C2F		; yep, wait
	JP	J.7CE1			; terminate actions

J$7C38:	LD	A,D
	OR	A
	RET	Z
	SCF
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7C3D:	PUSH	BC
	LD	A,(IX+0)		; target SCSI ID bit mask
	SLA	A
J$7C43:	LD	C,A
	JR	C,J.7C4D
	SLA	A
	JR	C,J.7C4D
	OR	C
	JR	J$7C43

J.7C4D:	IN	A,(0D4H)		; read SCSI bus status
	OR	A
	JR	NZ,J.7C4D
	IN	A,(0D0H)		; read SCSI data
	OR	A
	JR	NZ,J.7C4D
	IN	A,(0D4H)		; read SCSI bus status
	OR	A
	JR	NZ,J.7C4D
	LD	A,(IX+0)		; target SCSI ID bit mask
	OUT	(0D0H),A		; write SCSI data
	LD	A,01H
	OUT	(0D2H),A		; start arbitrate
J$7C65:	IN	A,(0D1H)
	BIT	6,A			; arbitrate in progress ?
	JR	NZ,J$7C73		; yep,
	IN	A,(0D4H)		; read SCSI bus status
	AND	0FEH			; ignore DBP
	JR	NZ,J.7C86
	JR	J$7C65

J$7C73:	NOP
	NOP
	IN	A,(0D1H)
	BIT	5,A			; lost arbitrate ?
	JR	NZ,J.7C86		; yep,
	IN	A,(0D0H)		; read SCSI data
	AND	C
	JR	NZ,J.7C86
	IN	A,(0D1H)
	BIT	5,A			; lost arbitrate ?
	JR	Z,J$7C94		; nope,
J.7C86:	XOR	A
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D1H),A		; deassert
	OUT	(0D2H),A
	LD	A,R
J$7C8F:	DEC	A
	JR	NZ,J$7C8F		; wait random
	JR	J.7C4D			; try again

J$7C94:	LD	A,0CH
	OUT	(0D1H),A		; assert BSY and SEL
	NOP
	LD	A,(IX+0)		; target SCSI ID bit mask
	OR	(IX+1)
	OUT	(0D0H),A		; write SCSI data
	LD	A,0DH
	OUT	(0D1H),A		; assert BSY, SEL and databus
	XOR	A
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D4H),A		; select enable
	LD	A,05H
	OUT	(0D1H),A		; assert SEL and databus
	LD	BC,041F2H
J$7CB1:	IN	A,(0D4H)		; read SCSI bus status
	BIT	6,A			; BSY ?
	JR	NZ,J.7CE1		; yep, terminate actions
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J$7CB1
	XOR	A
	OUT	(0D0H),A		; write SCSI data
	OUT	(0D1H),A		; deassert
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D3H),A		; data out
	LD	DE,8
	SCF
	JR	J.7CDF

J$7CCB:	XOR	A
	OUT	(0D1H),A		; deassert
	OUT	(0D0H),A		; write SCSI data
	OUT	(0D2H),A		; stop arbitrate
	OUT	(0D3H),A		; data out
	LD	(IX+4),L
	LD	(IX+5),H
J$7CDA:	XOR	A
	CP	D
	JR	Z,J.7CDF
	SCF
J.7CDF:	POP	BC
	RET

;	  Subroutine terminate actions
;	     Inputs  ________________________
;	     Outputs ________________________

J.7CE1:	LD	A,00H
	OUT	(0D1H),A		; deassert
	LD	A,22H
	OUT	(0D2H),A		; enable parity, dma
	POP	BC
	PUSH	BC
	LD	C,0D0H			; SCSI data port
	PUSH	IX
	EX	(SP),HL
	LD	DE,6
	ADD	HL,DE
	EX	DE,HL
	POP	HL
J.7CF6:	XOR	A
	OUT	(0D2H),A		; stop dma
	OUT	(0D1H),A		; deassert
J$7CFB:	IN	A,(0D4H)		; read SCSI bus status
	RLCA				; RST ?
	JR	C,J$7CDA		; yep,
	RLCA				; BSY ?
	JR	NC,J$7CCB		; nope,
	RLCA				; REQ ?
	JR	NC,J$7CFB		; nope,
	RLCA				; MSG ?
	JP	C,J$7D9A		; yep,
	RLCA				; C ?
	JR	C,J$7D5C		; yep,
	RLCA				; I ?
	JR	C,J$7D34		; yep,
	OUT	(0D3H),A		; target command
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D5H),A		; Start DMA Send
	LD	A,01H
	OUT	(0D1H),A		; assert databus
J.7D1C:	IN	A,(0D5H)
	BIT	6,A			; DMA req ?
	JR	Z,J$7D2A		; nope,
	OUTI
	LD	A,01H
	OUT	(0D1H),A		; assert databus
	JR	J.7D1C

J$7D2A:	IN	A,(0D4H)		; read SCSI bus status
	AND	0DEH			; ignore REQ and DBP
	CP	40H
	JR	Z,J.7D1C
	JR	J.7CF6

J$7D34:	LD	C,0D6H			; data input register
	OUT	(0D3H),A		; status
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D7H),A		; Start DMA Initiator Receive
	XOR	A
	OUT	(0D1H),A		; deassert
J.7D41:	IN	A,(0D5H)
	BIT	6,A			; DMA req ?
	JR	Z,J$7D50		; nope,
	INI
	IN	A,(0D0H)		; read SCSI data
	XOR	A
	OUT	(0D1H),A		; deassert
	JR	J.7D41

J$7D50:	IN	A,(0D4H)		; read SCSI bus status
	AND	0DEH
	CP	44H
	JR	Z,J.7D41
	LD	C,0D0H			; SCSI data port
	JR	J.7CF6

J$7D5C:	RLCA				; I ?
	JR	C,J$7D88		; yep,
	OUT	(0D3H),A		; target command
	EX	DE,HL
	LD	A,01H
	OUT	(0D1H),A		; assert databus
J.7D66:	IN	A,(0D4H)		; read SCSI bus status
	AND	0FEH			; ignore DBP
	CP	68H
	JR	NZ,J$7D80
	OUTI
	LD	A,11H
	OUT	(0D1H),A		; assert ACK and databus
J$7D74:	IN	A,(0D4H)		; read SCSI bus status
	BIT	5,A			; REQ ?
	JR	NZ,J$7D74		; yep, wait
	LD	A,01H
	OUT	(0D1H),A		; assert databus
	JR	J.7D66

J$7D80:	CP	48H
	JR	Z,J.7D66
	EX	DE,HL
J.7D85:	JP	J.7CF6

J$7D88:	OUT	(0D3H),A		; target command
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D7H),A		; Start DMA Initiator Receive
	IN	A,(0D6H)		; read data from scsi bus
	LD	D,A
	IN	A,(C)
	LD	(IX+2),D
	JR	J.7D85

J$7D9A:	RLCA
	JR	NC,J$7DC4
	RLCA
	JR	C,J$7DB1
	OUT	(0D3H),A		; target command
	LD	A,01H
	OUT	(0D1H),A		; assert databus
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D5H),A		; Start DMA Send
	XOR	A
	OUT	(C),A
	JR	J.7D85

J$7DB1:	OUT	(0D3H),A		; target command
	LD	A,82H
	OUT	(0D2H),A		; enable block mode dma, dma
	OUT	(0D7H),A		; Start DMA Initiator Receive
	IN	A,(0D6H)		; read data from scsi bus
	LD	E,A
	IN	A,(C)
	LD	(IX+3),E
	JP	J.7CF6

J$7DC4:	LD	A,50H
	OUT	(0D1H),A		; assert testmode and ACK 
	XOR	A
	OUT	(0D1H),A		; deassert
	JR	J.7D85

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7DCD:	IN	A,(0D4H)		; read SCSI bus status
	BIT	6,A			; BSY ?
	RET	Z			; yep, quit
	LD	A,7
	CALL	SNSMAT
	CP	0BFH			; SELECT pressed ?
	RET	NZ			; nope, quit

;	  Subroutine reset hdc
;	     Inputs  ________________________
;	     Outputs ________________________

J.7DDA:	LD	A,80H
	OUT	(0D1H),A		; assert RST
	XOR	A
	NOP
	NOP
	OUT	(0D1H),A		; deassert
	OUT	(0D0H),A		; scsi data = 0
	OUT	(0D2H),A		; mode = 0 (PIO)
	OUT	(0D3H),A		; target command = 0 (data out)
	RET

;	  Subroutine test hdc
;	     Inputs  ________________________
;	     Outputs ________________________

C$7DEA:	IN	A,(0D4H)		; read SCSI bus status
	INC	A
	JR	Z,J.7DFC
	LD	A,40H
	OUT	(0D1H),A		; test mode
	IN	A,(0D4H)		; read SCSI bus status
	INC	A			; because NCR5380 is disconnected, all bit should read 1
	JR	NZ,J.7DFC		; nope, self test failed
	OUT	(0D1H),A		; deassert
	OR	A
	RET

J.7DFC:	XOR	A
	OUT	(0D1H),A		; deassert
	LD	DE,I$7E0E
	CALL	C.4D7D			; print string
	LD	B,4
J$7E07:	CALL	C.7A51			; wait ?? ms
	DJNZ	J$7E07
	SCF
	RET

I$7E0E:	DEFB	"SCSI interface",13,10
	DEFB	"selftest failed",13,10
	DEFB	0

	DEFS	07F80H-$,0

	DEFB	"HD"			; SCSI BIOS id
	DEFB	021H			; SCSI BIOS 2.1
	JP	J.7DDA			; SetWD3393
	JP	J.7CE1			; TermAct
?.7F89:	JP	C.7AA8			; RdLogBlk
?.7F8C:	JP	C.7B0D			; WrLogBlk
?.7F8F:	JP	C.7B2F			; ReqSense
?.7F92:	JP	J$7B90			; Inquiry
?.7F95:	JP	C.7BD4			; ReadCap
?.7F98:	JP	C.7BB2			; ModeSense
?.7F9B:	JP	C.7ACA			; ModeSel
?.7F9E:	JP	C.7AEB			; FmtUnit
?.7FA1:	JP	C.7A87			; TstUnitRdy
?.7FA4:	JP	C.798E			; Initialise
?.7FA7:	JP	C.7799			; InsWork
?.7FAA:	JP	C.7A3C			; ClrEndLn
?.7FAD:	JP	C.7C08			; execute SCSI CDB (BERT ONLY CALL)

	DEFS	07FF0H-$,0

D$7FF0:	DEFB	080H			; host id 7
D$7FF1:	DEFB	001H			; target id 0
	DEFB	0D0H			; I/O port

	DEFS	08000H-$,0

	END
