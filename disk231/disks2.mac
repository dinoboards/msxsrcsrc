; DISK-S2.MAC
;
; DOS 2.31 kernel bank 2
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders


        .Z80
        ASEG
        ORG	4000H

CHSNS	equ	0009CH
CHGET	equ	0009FH
CHPUT	equ	000A2H
LPTOUT	equ	000A5H
LPTSTT	equ	000A8H
KILBUF	equ	00156H

BASENT	EQU	04022H			; Start diskbasic

.NCOMP	equ	0FFH
.WRERR	equ	0FEH
.DISK	equ	0FDH
.NRDY	equ	0FCH
.VERFY	equ	0FBH
.DATA	equ	0FAH
.RNF	equ	0F9H
.WPROT	equ	0F8H
.UFORM	equ	0F7H
.NDOS	equ	0F6H
.WDISK	equ	0F5H
.WFILE	equ	0F4H
.SEEK	equ	0F3H
.IFAT	equ	0F2H
.NOUPB	equ	0F1H
.IFORM	equ	0F0H

.INTER	equ	0DFH
.NORAM	equ	0DEH
.IBDOS	equ	0DCH
.IDRV	equ	0DBH
.IFNM	equ	0DAH
.IPATH	equ	0D9H
.PLONG	equ	0D8H
.NOFIL	equ	0D7H
.NODIR	equ	0D6H
.DRFUL	equ	0D5H
.DKFUL	equ	0D4H
.DUPF	equ	0D3H
.DIRE	equ	0D2H
.FILRO	equ	0D1H
.DIRNE	equ	0D0H
.IATTR	equ	0CFH
.DOT	equ	0CEH
.SYSX	equ	0CDH
.DIRX	equ	0CCH
.FILEX	equ	0CBH
.FOPEN	equ	0CAH
.OV64K	equ	0C9H
.FILE	equ	0C8H
.EOF	equ	0C7H
.ACCV	equ	0C6H
.IPROC	equ	0C5H
.NHAND	equ	0C4H
.IHAND	equ	0C3H
.NOPEN	equ	0C2H
.IDEV	equ	0C1H
.IENV	equ	0C0H
.ELONG	equ	0BFH
.IDATE	equ	0BEH
.ITIME	equ	0BDH
.RAMDX	equ	0BCH
.NRAMD	equ	0BBH
.HDEAD	equ	0BAH
.EOL	equ	0B9H
.ISBFN	equ	0B8H

.STOP	equ	09FH
.CTRLC	equ	09EH
.ABORT	equ	09DH
.OUTERR equ	09CH
.INERR	equ	09BH

.IPARM	equ	08BH

DBUF    EQU     0080H

DB064	EQU	0B064H	; start of BDOS data block chain
IB066	EQU	0B066H	; cursor on string
IB069	EQU	0B069H	; cursor off string
DB06C	EQU	0B06CH	; screen output buffer
IB0D0	EQU	0B0D0H	; history buffer
IB1D0	EQU	0B1D0H	; CON device console line input buffer
IB2D4	EQU	0B2D4H	; record buffer for CP/M sequential read
IB6D4	EQU	0B6D4H	; boot sector buffer
IB8D4	EQU	0B8D4H	; temporary directory entry save (used to move directory entry)
IB8F4	EQU	0B8F4H	; ASCIIZ file name of FCB (used by C3A59)
IB901	EQU	0B901H	; ? buffer
IB910	EQU	0B910H	; buffer
IB91B	EQU	0B91BH	; file name buffer
IB926	EQU	0B926H	; file name buffer
IB931	EQU	0B931H	; whole path buffer
IB975	EQU	0B975H	; temporary FCB
DB976	EQU	0B976H	; temporary store error code RDBLK/WRBLK
DB977	EQU	0B977H	; transfer address RDBLK/WRBLK

IB99A	EQU	0B99AH	; saved FIB for search next
IB9DA	EQU	0B9DAH	; buffer
IBA1A	EQU	0BA1AH	; drive assign table
IBA23	EQU	0BA23H	; drive table pointer table
IBA35	EQU	0BA35H	; memory mapper info table
IBA75	EQU	0BA75H	; upcase table
DBB76	EQU	0BB76H	; screen output buffer in double byte character flag
DBB77	EQU	0BB77H	; screen output buffer position (0-99)
DBB78	EQU	0BB78H	; pointer in console line input buffer CON device
DBB7A	EQU	0BB7AH	; force console buffered line input output to screen flag
DBB7B	EQU	0BB7BH	; insert mode (0 = normal mode, <>0 = insert mode)
DBB7C	EQU	0BB7CH	; size of line
DBB7D	EQU	0BB7DH	; maximum console column position
DBB7F	EQU	0BB7FH	; size of line
DBB80	EQU	0BB80H	; last line pointer in history buffer
DBB82	EQU	0BB82H	; current line pointer in history buffer
DBB84	EQU	0BB84H	; pointer to start of line
DBB86	EQU	0BB86H	; stored size of line
DBB87	EQU	0BB87H	; initial console column position
DBB89	EQU	0BB89H	; console redirection status
DBB8A	EQU	0BB8AH	; console output duplicated to printer flag
DBB8B	EQU	0BB8BH	; console column position
DBB8D	EQU	0BB8DH	; stored input
DBB8E	EQU	0BB8EH	; start cluster of file in sequential read buffer
DBB90	EQU	0BB90H	; drive id in sequential read buffer (0FFH means invalid)
DBB91	EQU	0BB91H	; number of random records in sequential read buffer
DBB92	EQU	0BB92H	; start random record number in sequential read buffer
DBB95	EQU	0BB95H	; search first extend
DBB96	EQU	0BB96H	; stored pointer to FCB
DBB98	EQU	0BB98H	; APPEND used
DBB99	EQU	0BB99H	; whole path buffer error
DBB9A	EQU	0BB9AH	; pointer in whole path buffer
DBB9C	EQU	0BB9CH	; pointer to last item in parse string
DBB9E	EQU	0BB9EH	; pointer in parse string
DBBA0	EQU	0BBA0H	; parse flags
DBBA1	EQU	0BBA1H	; parse string character flags
DBBA2	EQU	0BBA2H	; number of FATs - 1 (get FAT sector)
DBBA3	EQU	0BBA3H	; first free cluster
DBBA5	EQU	0BBA5H	; FAT entry content (if FAT entry in 2 sectors)
DBBA7	EQU	0BBA7H	; FAT sector number (if FAT entry in 2 sectors)
DBBA9	EQU	0BBA9H	; flags, b0 set = FAT entry in 2 sectors, b1 set = force read directory sector 
DBBAA	EQU	0BBAAH	; clear directory (cluster) flag
DBBAB	EQU	0BBABH	; starting cluster (directory move)
DBBAD	EQU	0BBADH	; pointer to file name buffer for search directory entry
DBBAF	EQU	0BBAFH	; search directory entry flags
DBBB2	EQU	0BBB2H	; overrun
DBBB4	EQU	0BBB4H	; physical sector
DBBB6	EQU	0BBB6H	; physical cluster (position in file)
DBBB8	EQU	0BBB8H	; number of sectors per cluster
DBBB9	EQU	0BBB9H	; offset in sector (position in file)
DBBBB	EQU	0BBBBH	; sector in cluster (position in file)
DBBBC	EQU	0BBBCH	; cluster number (position in file)
DBBBE	EQU	0BBBEH	; size done (file operation)
DBBC0	EQU	0BBC0H	; size (file operation)
DBBC2	EQU	0BBC2H	; transfer address (file operation)
DBBC4	EQU	0BBC4H	; operation flags
IBBC5	EQU	0BBC5H	; character buffer
IBBC6	EQU	0BBC6H	; stored directory entry locator
IBBD2	EQU	0BBD2H	; free directory entry locator
DBBDE	EQU	0BBDEH	; directory entry locator
DBBE8	EQU	0BBE8H	; cluster number current directory
DBBEA	EQU	0BBEAH	; diskoperation flag
DBBEB	EQU	0BBEBH	; physical drive id (check disk change)
DBBED	EQU	0BBEDH	; segment type (environment)
DBBEE	EQU	0BBEEH	; start of environment chain
DBBF0	EQU	0BBF0H	; start of the proces chain
DBBF2	EQU	0BBF2H	; start of the FIB chain
DBBF4	EQU	0BBF4H	; start of device chain
DBBF6	EQU	0BBF6H	; last FAT buffer read
DBBF8	EQU	0BBF8H	; start of the sector buffer chain
IBBFA	EQU	0BBFAH	; number of buffers
DBBFB	EQU	0BBFBH	; DPB ramdisk
DBBFD	EQU	0BBFDH	; last BDOS errorcode
DBBFE	EQU	0BBFEH	; current proces id
DBBFF	EQU	0BBFFH	; 64K overflow check
IBC00	EQU	0BC00H	; ramdisk bootsector
DBE00	EQU	0BE00H	; number of ramdisk segments
IBE02	EQU	0BE02H	; ramdisk segment table

JC206	EQU	0C206H	; debugger

P0_LDIR	EQU	0F1D6H	                ; transfer with page 0
P0_CALL	EQU	0F1D9H	                ; call main-bios
$FLUSH	EQU	0F1DCH	                ; print string via chput
GO_DRV	EQU	0F1DFH	                ; interslot call with prompt handler
$IRQ	EQU	0F1E5H	                ; interrupt handler
$RDSLT	EQU	0F1E8H	                ; RDSLT
$WRSLT	EQU	0F1EBH	                ; WRSLT
$CALSLT	EQU	0F1EEH	                ; CALSLT
$ENASLT	EQU	0F1F1H	                ; ENASLT
$CALLF	EQU	0F1F4H	                ; CALLF
PUT_BD	EQU	0F1F7H	                ; enable BDOS segments
PUT_US	EQU	0F1FAH	                ; enable DOS segments
RD_SEG	EQU	0F206H	                ; RD_SEG
WR_SEG	EQU	0F209H	                ; WR_SEG
PUT_P2	EQU	0F224H	                ; PUT_P2
CUR_DRV	EQU	0F23CH	                ; current drive id
DTA_AD	EQU	0F23DH	                ; transfer address

; DOS Hooks

H_BDOS	EQU	0F252H	                ; BDOS handler
H_UP	EQU	0F255H	                ; Upcase routine
H_16CH	EQU	0F258H	                ; check if double byte character
H_CHIN	EQU	0F25BH	                ; low level keyboard input
H_CHOU	EQU	0F25EH	                ; low level screen output
H_CHST	EQU	0F261H	                ; low level check keyboard
H_CHFL	EQU	0F264H	                ; low level screenbuffer
H_LSTO	EQU	0F267H	                ; low level printer output
H_LSTS	EQU	0F26AH	                ; low level check printer

RANDOM	EQU	0F2BAH	                ; random number, changed by interrupt handler
ST_COU	EQU	0F2BDH	                ; no keyboard buffer check counter, also reset by interrupt
CH_COU	EQU	0F2BEH	                ; down counter (to 1), every 100 ms
TIM_TI	EQU	0F2BFH	                ; up counter (to 7), every 100 ms
P0_SEG	EQU	0F2C7H	                ; current page 0 segment
P0_TPA	EQU	0F2CBH	                ; saved DOS page 0 segment
P2_TPA	EQU	0F2CDH	                ; saved DOS page 2 segment
DATA_S	EQU	0F2CFH	                ; BDOS data segment
$ERR_M	EQU	0F2DAH	                ; address message generator
DSK_CHK	EQU	0F2ECH	                ; disk check level
KDSK_V	EQU	0F300H	                ; pointer to diskerror handler
KAB_VE	EQU	0F302H	                ; pointer to abort handler
RAWFLG	EQU	0F30DH	                ; verify flag disk driver
KANJTA	EQU	0F30FH	                ; double byte header table
TARGET	EQU	0F33FH	                ; drive id for prompt routine
RAMAD3	EQU	0F344H	                ; slot id RAM page 3 (= system mapper)
$NUMDR	EQU	0F347H	                ; number of logical drives
MASTER	EQU	0F348H	                ; slot id of disksystem rom
$SECBUF	EQU	0F34DH	                ; pointer to disk driver sector buffer
RM_DPB	EQU	0F353H	                ; pointer to ramdisk DPB
$DPBLI	EQU	0F355H	                ; DPB pointer table (A: - G:)
$AUXIN	EQU	0F371H	                ; AUX input jump
$AUXOUT	EQU	0F374H	                ; AUX output jump
BDOS	EQU	0F37DH                  ; BDOS (disk BASIC)

LINLEN	EQU	0F3B0H	                ; current screen width
CRTCNT	EQU	0F3B1H	                ; current screen height
CNSDFG	EQU	0F3DEH	                ; functionkey display on/off
KBUF	EQU	0F41FH	                ; keyboard buffer, used for temporary stack
DRVTBL	EQU	0FB21H	                ; table with disk interfaces
INTFLG	EQU	0FC9BH	                ; used to detect CTRL-STOP
ESCCNT	EQU	0FCA7H	                ; used to detect a ESC sequence
EXPTBL	EQU	0FCC1H	                ; slot expansion table
DFFFF	EQU	0FFFFH

; FCB structure

; +0	DR	drive			drive
; +1,8	F1-F8	file name		file name
; +9,3	T1-T3	filetype		filetype
; +12	EX	extent			extent (low byte)
; +13	S1	reserved		fileattribute
; +14	S2	reserved		extent high byte / record size low byte (block)
; +15	RC	record count in extent	record count in extent / record size high byte (block)
; +16,4	AL	allocation		Filesize
; +20,4	AL	allocation		volume-id
; +24	AL	allocation	
; +25	AL	allocation	
; +26,2	AL	allocation		start cluster
; +28,2	AL	allocation		current cluster
; +30,2	AL	allocation		current relative cluster
; +32	CR	record in extent	record in extent
; +33,3	R0-R2	random access record	random access record
; +36	R4	not used		random access record when record size <64


; FIB structure

; +0		fib indicator (0FFH)
; +1,13		file name as an ASCIIZ string
; +14		file attributes byte
; +15,2		time of last modification
; +17,2		date of last modification
; +19,2		start cluster
; +21,4		file size
; +25		logical drive
; +26,4		disk serial (if on disk)
; +28,2		pointer to device jump table (if device)
; +30		device flags
; +32,2		pointer to drive table
; +34,2		current directory sector
; +36		current directory entry in sector
; +37,2		cluster number of parent directory
; +39,2		start cluster of file
; +41,2		current cluster of file
; +43,2		current relative cluster of file
; +45,4		current file position
; +49		open mode
; +50


; drive table structure

; +0		slot id interface
; +1		offset (relative to 4000H) of jumptable of interface driver
; +2,2		pointer to Drive Parameter Block (DPB) of drive
; +4		flags
; +5		flags
; +6		drive id used within interface driver
; +7		
; +8		drive name
; +9		1/10 seconds+2 that disk cannot be changed (0 = initialize, 1 = invalid)
; +10		cluster mask
; +11		cluster shift
; +12,2		number of reserved sectors (boot area)
; +14		number of FAT's
; +15		remainder of directory entries (no whole sector)
; +16		number of directory sectors (whole sectors)
; +17		number of sectors per FAT
; +18,2		first sector of root directory
; +20,2		first sector of data area
; +22,2		number of clusters+1 on disk
; +24		dirty flag Bit 0 = 1, when on a DOS2 disk file(s) have been deleted
; +25,4		volume serial number (0FFFFFFFFH if none)
; +29		media descriptor byte of disk
; +30,2		starting cluster of current directory (bit 15 = 1 means root)
; +32,64	current directory (ASCIIZ) without "drive:\" prefix


; device entry

; +0,2		pointer to jump table
; +2
; +8		device flags
; +9,11		device name
; +10,33


; directory entry
; +0,8		file name (main)
; +8,3		file name (extension)
; +11		entry attribute
; +12,10	not used
; +22,2		time
; +24,2		date
; +26,2		starting cluster
; +28,4		file size


        INCLUDE	DISK.INC


        DEFB	"AB"
        DEFW	L403C			; extension ROM initialization (only switches back to bank 0)
        DEFW	0			; extension ROM BASIC CALL statement handler (none)
        DEFW	0			; extension ROM BASIC device handler (none)
        DEFW	0			; extension ROM BASIC program (none)
        DEFS	6,0			; extension ROM further use

        DEFS	0403CH-$,0

L403C:	XOR	A			; bank = 0
        CALL	L7FD0			; select bank
        RET				; should never execute here
        RET
        RET

L4043:	RET
        RET
        RET
        RET
        RET
        RET

L4049:	PUSH	AF
        LD	A,(L40FF)
        PUSH	AF			; store current bank
        XOR	A			; bank = 0
        CALL	L7FD0			; select bank
        NOP				; should never execute here
        NOP
        NOP
        POP	AF			; restore bank
        CALL	L7FD0			; select bank
        POP	AF
        RET

L405B:	CALL	L7FD0			; select bank
        EX	AF,AF'
        CALL	L4069			; call subroutine
        EX	AF,AF'
        XOR	A			; bank = 0
        CALL	L7FD0			; select bank
        EX	AF,AF'
        RET

L4069:	JP	(IX)

        DEFS	040A6H-$-3,0

; This one must start at #40A3, because there must be a RET
; instruction at end for switching to DOS1 kernel.
; At #40A6 is at RET instruction in DOS1 kernel

L40A3:
        BNKCHG

L40A6:	RET

        DEFS	040FFH-$,0

L40FF:	DEFB	2			; present bank number register


        .PHASE	0

C0000:	JP	J0095			; init BDOS

        DEFS	00005H-$,0

C0005:	JP	J026D			; BDOS handler

        DEFS	0000CH-$,0

C000C:	JP	$RDSLT			; RDSLT

        DEFS	00014H-$,0

C0014:	JP	$WRSLT			; WRSLT

        DEFS	0001CH-$,0

C001C:	JP	$CALSLT			; CALSLT

        DEFS	00024H-$,0

C0024:	JP	$ENASLT			; ENASLT

        DEFS	00028H-$,0

C0028:	JP	JC206			; debugger

        DEFS	00030H-$,0

C0030:	JP	$CALLF			; CALLF

        DEFS	00038H-$,0

C0038:	JP	$IRQ			; KEYINT


SSLOT:
?003B:	OUT	(0A8H),A		; select slot in page 3
        LD	A,(DFFFF)
        CPL				; read secundairy slot register
        LD	L,A			; store
        AND	H			; clear slot
        OR	D			; set slot
        JR	J004E

SSLOTL:
?0046:	OUT	(0A8H),A		; select slot in page 3
        LD	A,L			; stored secundairy slot register
        JR	J004E

SSLOTE:
?004B:	OUT	(0A8H),A		; select slot in page 3
        LD	A,E
J004E:	LD	(DFFFF),A		; update secundairy slot register
        LD	A,B
        OUT	(0A8H),A		; restore page 3
        RET

        DEFS	0005CH-$,0

?005C:  JP	C11A6			; allocate segment
?005F:	JP	C1256			; free segment

        DEFS	00080H-$,0

        JP	C0A2D			; CON input
?0083:	JP	J0A6B			; CON output
?0086:	JP	C0A42			; CON check input status
?0089:	JP	C0B25			; LPT output
?008C:	JP	C0B37			; LPT check output status
?008F:	JP	J0B50			; AUX output
?0092:	JP	C0B46			; AUX input

;         Subroutine initialize BDOS
;            Inputs  ________________________
;            Outputs ________________________

J0095:	LD	IY,DBB80		; pointer to BDOS data
        LD	DE,RM_DPB		; pointer to ramdisk DPB
        LD	A,(MASTER)
        LD	C,A			; slot id of DOS systemrom
        LD	L,80H			; offset for ramdisk driver jumptable
        LD	B,1			; number of drives = 1
        CALL	C017E			; allocate and initialize drive tables (ramdisk)
        JR	NZ,J00D8		; error,
        LD	HL,DRVTBL		; disk interface table
        LD	DE,$DPBLI		; pointer to drive 0 DPB
        LD	B,4			; number of disk interfaces = 4
J00B1:	LD	A,(HL)			; number of drives for this interface
        INC	HL
        LD	C,(HL)			; slot id
        INC	HL
        OR	A			; entry used ?
        PUSH	HL			; store pointer in DRVTBL
        PUSH	BC			; store counter
        LD	B,A			; number of drives
        LD	L,10H			; offset for disk driver jumptable
        CALL	NZ,C017E		; entry used, allocate and initialize drive tables
        POP	BC			; restore counter
        POP	HL			; restore pointer in DRVTBL
        JR	NZ,J00D8		; memory allocation failed, quit with error
        DJNZ	J00B1			; next interface
        LD	D,B			; cancel all assignments
        CALL	A0E8B			; assign
        LD	HL,I012C		; DOS devicename table
J00CB:	LD	A,(HL)
        OR	A			; end of table ?
        JR	Z,J0101			; yep, quit
        INC	HL
        PUSH	HL			; store pointer in device name table
        LD	HL,43			; size of device info table
        CALL	C01CB			; allocate BDOS data block
        POP	DE			; restore pointer in device name table
J00D8:	JR	NZ,J012A		; out of memory, quit with error
        LD	BC,(DBBF4)
        LD	(DBBF4),HL		; update start of device chain
        LD	(HL),C
        INC	HL
        LD	(HL),B			; next device block is previous first block
        INC	HL
        EX	DE,HL
        LDI
        LDI				; address jump table
        EX	DE,HL
        LD	BC,6
        ADD	HL,BC
        EX	DE,HL
        LD	BC,12
        LDIR				; device flags and device name
        LD	A,80H
        LD	(DE),A			; device
        LD	B,32-12
        XOR	A
J00FB:	INC	DE
        LD	(DE),A
        DJNZ	J00FB
        JR	J00CB			; next device

J0101:	LD	B,5			; number of buffers = 5
        CALL	A0E44			; allocate buffers
        LD	B,0			; 
        CALL	A2070			; join
        CALL	C0E35			; clear ramdisk bootsector and ramdisk segment table
        CALL	C0384			; initialize buffered input history buffer
        LD	HL,I0178
        LD	DE,IB066
        LD	BC,6
        LDIR				; initialize cursor on/off strings
        LD	A,1
        LD	(ST_COU),A		; do check keyboard buffer
        LD	(IY+DBB90-DBB80),0FFH	; invalidate sequential read buffer
        CALL	C10CA			; initialize clockchip
        OR	A
        RET				; quit with no error

J012A:	SCF
        RET

I012C:	defb	0FFH
        defw	A0932			; device jump table
        defb	0A3H			; device, ascii mode, console input device, console output device
        defb	"CON        "

        defb	0FFH
        defw	A09E2			; device jump table = printer device jump table
        defb	0A0H			; device, ascii mode
        defb	"LST        "

        defb	0FFH
        defw	A09E2			; device jump table = printer device jump table
        defb	0A0H			; device, ascii mode
        defb	"PRN        "

        defb	0FFH
        defw	A0A03			; device jump table = NUL device jump table
        defb	0A0H			; device, ascii mode
        defb	"NUL        "

        defb	0FFH
        defw	A09BF			; device jump table = AUX device jump table
        defb	0A0H			; device, ascii mode
        defb	"AUX        "

        defb	0


I0178:	defb	27,"y5"
        defb	27,"x5"

;	  Subroutine allocate and initialize drive tables
;	     Inputs  B = number of drives, L = driver jump table offset, C = slot id, DE = pointer to DPB entry
;	     Outputs ________________________

C017E:	XOR	A			; disk interface drive number = 0
J017F:	EX	AF,AF'
        PUSH	HL			; store driver jump table offset
        LD	HL,96
J0184:	CALL	C01CB			; allocate BDOS data block (drive table)
        JR	NZ,J01C9		; error, quit
        EX	DE,HL
        PUSH	DE
        POP	IX			; pointer to drive table
        PUSH	BC			; store drive counter, slot id interface
        LD	C,(HL)
        INC	HL
        LD	B,(HL)
	INC	HL			; pointer to DPB
        PUSH	HL			; store pointer to next DPB entry
J0193:	LD	(IX+2),C
        LD	(IX+3),B		; save pointer to DPB
        LD	A,(BC)			; drive id from DPB
        INC	A
        LD	(IX+8),A		; update drive id (1 based)
        LD	L,A
        LD	H,0
        INC	BC
        LD	A,(BC)			; media descriptor from DPB
        LD	(IX+29),A		; media descriptor
        LD	BC,DBBFB
        JR	Z,J01AE			; ramdisk, use
        LD	BC,IBA23
J01AE:	ADD	HL,HL
        ADD	HL,BC
        LD	(HL),E
        INC	HL
        LD	(HL),D			; store pointer to drive table
        POP	DE			; restore pointer to next DPB entry
        POP	BC			; restore drive counter, slot id interface
        POP	HL
        LD	(IX+0),C		; slot id of disk interface
        LD	(IX+1),L		; disk interface jumptable offset (relative to 04000H)
        EX	AF,AF'
        LD	(IX+6),A		; disk interface drive number
        INC	A
        LD	(IX+30+1),0FFH		; starting cluster current directory = root directory
        DJNZ	J017F			; next drive of interface
        XOR	A			; no error
        RET

J01C9:	POP	HL
        RET

;	  Subroutine allocate BDOS data block
;	     Inputs  HL = size
;	     Outputs ________________________

C01CB:	PUSH	DE
        PUSH	BC
        INC	HL
        RES	0,L
        LD	B,H
        LD	C,L
        LD	HL,(DB064)
J01D5:	LD	E,(HL)
        INC	HL
        LD	D,(HL)
        INC	HL
        LD	A,D
        OR	E
        JR	Z,J0203
        BIT	0,E
        JR	NZ,J01E8
        EX	DE,HL
        SBC	HL,BC
        JR	NC,J01ED
        ADD	HL,BC
        EX	DE,HL
J01E8:	RES	0,E
        ADD	HL,DE
        JR	J01D5

J01ED:	EX	DE,HL
        DEC	HL
        DEC	HL
        JR	Z,J0217
        DEC	DE
        DEC	DE
        LD	A,D
        OR	E
        JR	Z,J01FF
        LD	(HL),E
        INC	HL
        LD	(HL),D
        INC	HL
        ADD	HL,DE
        JR	J0217

J01FF:	INC	BC
        INC	BC
        JR	J0217

J0203:	LD	A,.NORAM
        INC	BC
        INC	BC
        LD	HL,(DB064)
        OR	A
        SBC	HL,BC
        JR	C,J0227
        JP	P,J0227
        LD	(DB064),HL
        DEC	BC
        DEC	BC
J0217:	LD	(HL),C
        SET	0,(HL)
        INC	HL
        LD	(HL),B
        INC	HL
        PUSH	HL
J021E:	LD	(HL),00H
        INC	HL
        DEC	BC
        LD	A,B
        OR	C
        JR	NZ,J021E
        POP	HL
J0227:	POP	BC
        POP	DE
        OR	A			; update Zx flag
        RET

;	  Subroutine free BDOS data block
;	     Inputs  HL = address of block
;	     Outputs ________________________

C022B:	DEC	HL
        DEC	HL
        RES	0,(HL)
        PUSH	DE
        PUSH	BC
        LD	HL,(DB064)
J0234:	LD	C,(HL)
        BIT	0,C
        JR	NZ,J023F
        INC	HL
        LD	B,(HL)
        INC	HL
        ADD	HL,BC
        JR	J0234

J023F:	LD	(DB064),HL
J0242:	LD	E,(HL)
        INC	HL
        LD	D,(HL)
        INC	HL
        LD	A,D
        OR	E
        JR	Z,J026A
        BIT	0,E
        JR	NZ,J0265
J024E:	PUSH	HL
        ADD	HL,DE
        LD	C,(HL)
        INC	HL
        LD	B,(HL)
        POP	HL
        BIT	0,C
        JR	NZ,J025F
        INC	BC
        INC	BC
        EX	DE,HL
        ADD	HL,BC
        EX	DE,HL
        JR	J024E

J025F:	DEC	HL
J0260:	LD	(HL),D
        DEC	HL
        LD	(HL),E
        INC	HL
        INC	HL
J0265:	RES	0,E
        ADD	HL,DE
        JR	J0242

J026A:	POP	BC
        POP	DE
        RET

;	  Subroutine BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

J026D:	EI
        CALL	H_BDOS			; hook
        CALL	C0278			; BDOS handler
        LD	(DBBFD),A               ; save error code
        RET

;	  Subroutine BDOS handler (basic)
;	     Inputs  ________________________
;	     Outputs ________________________

C0278:	PUSH	HL			; store HL parameter
        PUSH	BC			; store B parameter
        EX	AF,AF'			; store A parameter
        LD	A,(CH_COU)
        DEC	A			; timer finished ?
        CALL	Z,C0AB9			; yep, flush screen output buffer (if any)
        LD	A,C
        CP	71H			; valid BDOS function ?
        JR	C,J0289			; yep,
        LD	C,09H			; invalid BDOS function
J0289:	EX	AF,AF'			; restore A parameter
        LD	B,0
        LD	HL,I02A2
        ADD	HL,BC
        ADD	HL,BC
        LD	C,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,C			; address BDOS function handler
        LD	IY,DBB80		; pointer to BDOS data
        POP	BC			; restore B parameter
        EX	(SP),HL			; store BDOS function handler, restore HL parameter
        RET

;	  Subroutine illegal BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

A029C:	LD	A,.IBDOS
J029E:	LD	HL,0
        RET

I02A2:	defw	A0CFB			; 00H, _TERM0 (CP/M P_TERMCPM)
	defw	A03A8			; 01H, _CONIN (CP/M C_READ)
	defw	A03B6			; 02H, _CONOUT (CP/M C_WRITE)
	defw	A042E			; 03H, _AUXIN (CP/M A_READ)
	defw	A043D			; 04H, _AUXOUT (CP/M A_WRITE)
	defw	A0441			; 05H, _LSTOUT (CP/M L_WRITE)
	defw	A03D4			; 06H, _DIRIO (CP/M C_RAWIO)
	defw	A03FE			; 07H, _DIRIN (CP/M 2.2 incompatible: Get I/O byte)
        defw	A03BE			; 08H, _INNOE (CP/M 2.2 incompatible: Set I/O byte)
	defw	A029C			; 09H, _STROUT (CP/M 2.2 C_WRITESTR illegal function because it is handled elsewhere)
	defw	A0456			; 0AH, _BUFIN (CP/M 2.2 C_READSTR)
	defw	A03CD			; 0BH, _CONST (CP/M 2.2 C_STAT)
	defw	A0B90			; 0CH, _CPMVER (CP/M 2.2 S_BDOSVER)
	defw	A0B95			; 0DH, _DSKRST (CP/M 2.2 DRV_ALLRESET)
	defw	A0BAB			; 0EH, _SELDSK (CP/M 2.2 DRV_SET)
	defw	A3771			; 0FH, _FOPEN (CP/M 2.2 F_OPEN)
        defw	A37B5			; 10H, _FCLOSE (CP/M 2.2 F_CLOSE)
	defw	A37CF			; 11H, _SFIRST (CP/M 2.2 F_SFIRST)
	defw	A37E9			; 12H, _SNEXT (CP/M 2.2 F_SNEXT)
	defw	A38E6			; 13H, _FDEL (CP/M 2.2 F_DELETE)
	defw	A384C			; 14H, _RDSEQ (CP/M 2.2 F_READ)
	defw	A3893			; 15H, _WRSEQ (CP/M 2.2 F_WRITE)
	defw	A38CE			; 16H, _FMAKE (CP/M 2.2 F_MAKE)
	defw	A3913			; 17H, _FREN (CP/M 2.2 F_RENAME)
        defw	A0BC6			; 18H, _LOGIN (CP/M 2.2 DRV_LOGINVEC)
	defw	A0BDC			; 19H, _CURDRV (CP/M 2.2 DRV_GET)
	defw	A0BE4			; 1AH, _SETDTA (CP/M 2.2 F_DMAOFF)
	defw	A0BEC			; 1BH, _ALLOC (CP/M 2.2 incompatible: DRV_ALLOCVEC)
	defw	A029C			; 1CH, illegal function (CP/M 2.2 DRV_SETRO)
	defw	A029C			; 1DH, illegal function (CP/M 2.2 DRV_ROVEC)
	defw	A029C			; 1EH, illegal function (CP/M 2.2 F_ATTRIB)
	defw	A029C			; 1FH, illegal function (CP/M 2.2 DRV_DPB)
        defw	A029C			; 20H, illegal function (CP/M 2.2 F_USERNUM)
	defw	A3953			; 21H, _RDRND (CP/M 2.2 F_READRAND)
	defw	A3967			; 22H, _WRRND (CP/M 2.2 F_WRITERAND)
	defw	A3981			; 23H, _FSIZE (CP/M 2.2 F_SIZE)
	defw	A39BA			; 24H, _SETRND (CP/M 2.2 F_RANDREC)
	defw	A029C			; 25H, illegal function (CP/M 2.2 DRV_RESET)
	defw	A3D3F			; 26H, _WRBLK (CP/M 2.2 illegal function)
	defw	A3D3B			; 27H, _RDBLK (CP/M 2.2 illegal function)
        defw	A3969			; 28H, _WRZER (CP/M 2.2 F_WRITEZF)
	defw	A029C			; 29H, illegal function (CP/M 2.2 illegal function)
	defw	A1024			; 2AH, _GDATE (CP/M 2.2 illegal function)
	defw	A1059			; 2BH, _SDATE (CP/M 2.2 illegal function)
	defw	A10A3			; 2CH, _GTIME (CP/M 2.2 illegal function)
	defw	A10AD			; 2DH, _STIME (CP/M 2.2 illegal function)
	defw	A0C48			; 2EH, _VERIFY (CP/M 2.2 illegal function)
	defw	A2576			; 2FH, _RDABS (CP/M 2.2 illegal function)
        defw	A2579			; 30H, _WRABS (CP/M 2.2 illegal function)
	defw	A0C50			; 31H, _DPARM (CP/M 2.2 illegal function)
	defw	A029C			; 32H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 33H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 34H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 35H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 36H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 37H, illegal function (CP/M 2.2 illegal function)
        defw	A029C			; 38H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 39H, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 3AH, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 3BH, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 3CH, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 3DH, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 3EH, illegal function (CP/M 2.2 illegal function)
	defw	A029C			; 3FH, illegal function (CP/M 2.2 illegal function)
        defw	A18C6			; 40H, _FFIRST
	defw	A1979			; 41H, _FNEXT
	defw	A18CA			; 42H, _FNEW
	defw	A1DA6			; 43H, _OPEN
	defw	A1D94			; 44H, _CREATE
	defw	A1DEB			; 45H, _CLOSE
	defw	A1DF8			; 46H, _ENSURE
	defw	A1E08			; 47H, _DUP
        defw	A1E1D			; 48H, _READ
	defw	A1E2D			; 49H, _WRITE
	defw	A1E3D			; 4AH, _SEEK
	defw	A1E81			; 4BH, _IOCTL
	defw	A200D			; 4CH, _HTEST
	defw	A1F14			; 4DH, _DELETE
	defw	A1F3B			; 4EH, _RENAME
	defw	A1F60			; 4FH, _MOVE
        defw	A1F85			; 50H, _ATTR
	defw	A1FBE			; 51H, _FTIME
	defw	A1F1E			; 52H, _HDELETE
	defw	A1F45			; 53H, _HRENAME
	defw	A1F6A			; 54H, _HMOVE
	defw	A1F9D			; 55H, _HATTR
	defw	A1FE0			; 56H, _HFTIME
	defw	A0CCF			; 57H, _GETDTA
        defw	A0CD5			; 58H, _GETVFY
	defw	A1836			; 59H, _GETCD
	defw	A184D			; 5AH, _CHDIR
	defw	A186D			; 5BH, _PARSE
	defw	A1882			; 5CH, _PFILE
	defw	A1894			; 5DH, _CHKCHR
	defw	A189D			; 5EH, _WPATH
	defw	A0CE0			; 5FH, _FLUSH
        defw	A2029			; 60H, _FORK
	defw	A2070			; 61H, _JOIN
	defw	A0CFD			; 62H, _TERM
	defw	A029C			; 63H, _DEFAB (illegal function because it is handled elsewhere)
	defw	A029C			; 64H, _DEFER (illegal function because it is handled elsewhere)
	defw	A0D05			; 65H, _ERROR
	defw	A0D0A			; 66H, _EXPLAIN
	defw	A0D39			; 67H, _FORMAT
        defw	A0D93			; 68H, _RAMD
	defw	A0E44			; 69H, _BUFFER
	defw	A0E8B			; 6AH, _ASSIGN
	defw	A0EDE			; 6BH, _GENV
	defw	A0EFF			; 6CH, _SENV
	defw	A0F55			; 6DH, _FENV
	defw	A0EB6			; 6EH, _DSKCHK
	defw	A0EC8			; 6FH, _DOSVER
        defw	A0ED2			; 70H, _REDIR

;	  Subroutine initialize buffered input history buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C0384:	LD	HL,IB0D0		; history buffer
        LD	(DBB82),HL		; initialize current line pointer in history buffer
        LD	(DBB80),HL		; initialize last line pointer in history buffer
        LD	DE,IB0D0+256		; end of history buffer
        EX	DE,HL
        OR	A
        SBC	HL,DE
        EX	DE,HL
J0395:	LD	(HL),0DH
        INC	HL
        DEC	DE
        LD	A,D
        OR	E
        JR	NZ,J0395		; empty lines in history buffer
        LD	(DBB7F),A		; size of line = 0

;	  Subroutine clear stored input, console output not duplicated to printer
;	     Inputs  ________________________
;	     Outputs ________________________

C03A0:	XOR	A
        LD	(DBB8D),A		; no stored input
	LD	(DBB8A),A		; console output not duplicated to printer
        RET

;	  Subroutine _CONIN
;	     Inputs  ________________________
;	     Outputs ________________________

A03A8:	CALL	A03BE			; console input without echo
        PUSH	HL
        LD	A,L
        CALL	C085A			; is outputable key ?
        CALL	NC,C0871		; yep, character to console (with redirection support and TAB translation)
        POP	HL
        XOR	A
        RET

;	  Subroutine _CONOUT
;	     Inputs  ________________________
;	     Outputs ________________________

A03B6:	LD	A,E
        CALL	C086C			; character to console (with console status, redirection support and TAB translation)
        XOR	A
        LD	H,A
        LD	L,A
        RET

;	  Subroutine _INNOE
;	     Inputs  ________________________
;	     Outputs ________________________

A03BE:	BIT	0,(IY+DBB89-DBB80)	; console input redirected ?
        LD	C,0FFH			; flag do check for CTRL-C
        JR	NZ,C0414		; yep, character from console input file handle
J03C6:	CALL	C08B2			; ensure input from keyboard
        LD	L,A
        XOR	A
        LD	H,A
        RET

;	  Subroutine _CONST
;	     Inputs  ________________________
;	     Outputs ________________________

A03CD:	CALL	C0897			; get console status
        LD	L,A
        XOR	A
        LD	H,A
        RET

;	  Subroutine _DIRIO
;	     Inputs  ________________________
;	     Outputs ________________________

A03D4:	LD	A,E
J03D5:	INC	A			; do input or output ?
        JR	Z,J03E8			; input
        BIT	1,(IY+DBB89-DBB80)	; console output redirected ?
        LD	A,E
        LD	C,00H			; do not check for CTRL-C
        JR	NZ,J042A		; yep, character to console output file handle
        CALL	C0A6C			; output character to screen
        XOR	A
        LD	H,A
        LD	L,A
        RET

J03E8:	BIT	0,(IY+DBB89-DBB80)	; console input redirected ?
        LD	C,0			; do not check for CTRL-C
        JR	NZ,C0414		; yep, character from console input file handle
        LD	HL,DBB8D
        CP	(HL)			; stored input ?
        JR	NZ,J0406		; yep,
        CALL	C0A42			; get status from keyboard
        JR	NZ,J0406
        LD	L,A
        LD	H,A
        RET

;	  Subroutine _DIRIN
;	     Inputs  ________________________
;	     Outputs ________________________

A03FE:	BIT	0,(IY+DBB89-DBB80)	; console input redirected ?
        LD	C,0			; do not check for CTRL-C
        JR	NZ,C0414		; yep, character from console input file handle
J0406:	LD	A,(DBB8D)
        OR	A			; stored input ?
        CALL	Z,C0A2D			; nope, get character from keyboard
        LD	L,A
        XOR	A
        LD	H,A
        LD	(DBB8D),A		; no stored input
        RET

;	  Subroutine character from console input file handle
;	     Inputs  ________________________
;	     Outputs ________________________

C0414:	LD	B,0			; file handle console input
        PUSH	BC
        CALL	C1D51			; read from file handle
        POP	DE
        OR	A
        JR	NZ,J0439		; error, handle "input error"
        OR	E			; check for CTRL-C ?
        JR	Z,J0426			; no, skip CTRL-C check
	LD	A,B
        SUB	03H
        JR	Z,J0439			; CTRL-C, handle "input error"
J0426:	LD	L,B
        XOR	A
        LD	H,A
        RET

;	  Subroutine character to console output file handle
;	     Inputs  ________________________
;	     Outputs ________________________

J042A:	LD	B,1			; file handle con output
        JR	J0446

;	  Subroutine _AUXIN
;	     Inputs  ________________________
;	     Outputs ________________________

A042E:	LD	B,3			; file handle AUX
        LD	C,0FFH
        CALL	C1D51			; read from file handle
        OR	A
        LD	L,B
        LD	H,A
        RET	Z			; no error, quit
J0439:	LD	C,.INERR
        JR	J044F

;	  Subroutine _AUXOUT
;	     Inputs  ________________________
;	     Outputs ________________________

A043D:	LD	B,3			; file handle AUX
        JR	J0443

;	  Subroutine _LSTOUT
;	     Inputs  ________________________
;	     Outputs ________________________

A0441:	LD	B,4			; file handle LST
J0443:	LD	C,0FFH
        LD	A,E
J0446:	CALL	C1D2C			; write to file handle
        OR	A
        LD	L,A
        LD	H,A
        RET	Z			; no error, quit
        LD	C,.OUTERR		; handle "output error"
J044F:	LD	B,A
        LD	A,C
        CALL	C3749			; call program abort routine with TPA segments active
J0454:	JR	J0454			; loop to infinety

;	  Subroutine _BUFIN
;	     Inputs  ________________________
;	     Outputs ________________________

A0456:	PUSH	DE			; store pointer to line buffer
        BIT	0,(IY+DBB89-DBB80)	; console input redirected ?
        JR	NZ,J0463		; yes,
        XOR	A			; use normal console output
        CALL	C04B1			; console line buffered input
        JR	J049E			; finish console line buffered input

; console line buffered input (file handle)

J0463:	EX	DE,HL
        LD	B,(HL)			; size of line buffer
        LD	C,0			; current position = 0
        INC	HL
        PUSH	HL			; store pointer to size of line in line buffer
J0469:	PUSH	HL			; store pointer in line buffer-1
        PUSH	BC			; store size of line buffer, current position
        LD	C,0FFH			; do check for CTRL-C
        CALL	C0414			; character from console input file handle
        LD	A,L
        POP	BC			; store size of line buffer, current position
        POP	HL			; store pointer in line buffer-1
        OR	A			; null character ?
        JR	Z,J0469			; yep, ignore
        CP	0AH			; LF ?
        JR	Z,J0469			; yep, ignore
        CP	0DH			; CR ?
        JR	Z,J0499			; yep,
        LD	E,A			; store character
        LD	A,B
        CP	C			; current position at end of line buffer ?
        JR	Z,J048E			; yep, line buffer is full
        INC	C			; update current position
        INC	HL			; update pointer in line buffer
        LD	(HL),E			; store character in line buffer
        LD	A,E			; restore character
        PUSH	HL			; store pointer in line buffer-1
        PUSH	BC			; store size of line buffer, current position
        CALL	C086C			; character to console (with console status, redirection support and TAB translation)
        JR	J0495			; next

J048E:	PUSH	HL			; store pointer in line buffer-1
        PUSH	BC			; store size of line buffer, current position
        LD	A,7			; beep
        CALL	C0A6C			; output character to screen
J0495:	POP	BC			; restore size of line buffer, current position
        POP	HL			; restore pointer in line buffer-1
        JR	J0469			; next

J0499:	POP	HL			; restore pointer to size of line in line buffer
        LD	(HL),C			; update size of line
        CALL	C086C			; character to console (with console status, redirection support and TAB translation)
J049E:	POP	HL			; restore pointer to line buffer
        PUSH	HL			; store pointer to line buffer
        LD	A,(HL)
        INC	HL
        CP	(HL)			; line buffer full ?
        JR	Z,J04AC			; yep,
        LD	E,(HL)
        LD	D,0
        ADD	HL,DE
        INC	HL
        LD	(HL),0DH		; line buffer ends with CR
J04AC:	POP	DE			; restore pointer to line buffer
        XOR	A
        LD	L,A
        LD	H,A
        RET

;	  Subroutine console line buffered input (keyboard)
;	     Inputs  A = force console output to screen flag
;	     Outputs ________________________

C04B1:	LD	(DBB7A),A		; store force console output to screen flag
        INC	DE
        XOR	A
        LD	(DE),A			; size of line = 0
        DEC	DE
        LD	(DBB7C),A		; size of line = 0

; restart console line input

J04BB:	PUSH	DE			; store pointer to line buffer
        CALL	C058B			; edit line
        POP	DE			; restore pointer to line buffer
        DEC	A			; cursor up ?
        JR	Z,J050C			; yep, previous line
        DEC	A			; cursor down ?
        JR	Z,J052A			; yep, next line
        INC	DE
        LD	A,(DE)			; size of current line
        OR	A			; empty ?
        RET	Z			; yep, quit
        LD	B,A			; store size of line
        LD	(DBB7F),A		; store size of line
        LD	A,(DBB7C)
        OR	A			; empty line ?
        JR	Z,J04EA			; yep,
        PUSH	DE			; store pointer to line buffer+1
        PUSH	BC			; store size of line
        LD	HL,(DBB82)		; current line pointer in history buffer
J04D9:	INC	DE
        LD	A,(DE)
        CP	(HL)
        JR	NZ,J04E6
        CALL	C0567			; next position in history buffer
        DJNZ	J04D9
        LD	A,(HL)
        CP	0DH
J04E6:	POP	BC			; restore size of line
        POP	DE			; restore pointer to line buffer+1
        JR	Z,J04FE
J04EA:	LD	HL,(DBB80)		; last line pointer in history buffer
J04ED:	INC	DE
        LD	A,(DE)
        LD	(HL),A			; copy character from history buffer
        CALL	C0567			; next position in history buffer
        DJNZ	J04ED			; next
        LD	A,(HL)			; store character
        LD	(HL),0DH		; end line in history buffer
        CALL	C0567			; next position in history buffer
        LD	(DBB80),HL		; update last line pointer in history buffer
J04FE:	LD	(DBB82),HL		; update current line pointer in history buffer
J0501:	CP	0DH			; was end of line ?
        RET	Z			; yep, quit
        LD	A,(HL)			; store character
        LD	(HL),0DH		; end line in history buffer
        CALL	C0567			; next position in history buffer
        JR	J0501			; continue to end of line

; previous line

J050C:	LD	A,(DBB7F)		; size of line
        OR	A			; empty line ?
        JR	Z,J04BB			; yep, restart console line buffered input
        LD	HL,(DBB82)		; current line pointer in history buffer
J0515:	CALL	C0579			; previous position in history buffer
        LD	A,(HL)
        CP	0DH			; empty line ?
        JR	Z,J0515			; yep, previous line
J051D:	CALL	C0579			; previous position in history buffer
        LD	A,(HL)
	CP	0DH			; end of line ?
        JR	NZ,J051D		; nope, go back further
        CALL	C0567			; next position in history buffer (start the line)
        JR	J0544			; update current line

; next line

J052A:	LD	A,(DBB7F)		; size of line
        OR	A			; empty line ?
        JR	Z,J04BB			; yep, restart console line buffered input
        LD	HL,(DBB82)		; current line pointer in history buffer
J0533:	LD	A,(HL)
        CP	0DH			; CR ?
        CALL	C0567			; next position in history buffer
        JR	NZ,J0533		; nope, again
        SCF				; skip to next position
J053C:	CALL	NC,C0567		; next position in history buffer
        LD	A,(HL)
        CP	0DH			; empty line ?
        JR	Z,J053C			; yep, next and again

; update current line

J0544:	LD	(DBB82),HL		; update current line pointer in history buffer
        PUSH	DE			; store pointer to line buffer
        LD	A,(DE)			; size of current line
        LD	B,A			; store size of current line
        INC	DE
        INC	DE
        LD	C,-1
J054E:	LD	A,(HL)
        LD	(DE),A
        INC	C
        CALL	C0567			; next position in history buffer
        CP	0DH			; CR ?
        INC	DE
        JR	Z,J055C			; yep,
        DJNZ	J054E
        INC	C
J055C:	POP	DE			; restore pointer to line buffer
        INC	DE
        LD	A,C
        LD	(DE),A			; update size of line
        DEC	DE
        LD	(DBB7C),A		; update size of line
        JP	J04BB			; restart console line buffered input

;	  Subroutine next position in history buffer
;	     Inputs  HL = pointer in history buffer
;	     Outputs HL = updated pointer in history buffer

C0567:	PUSH	AF
        PUSH	DE
        LD	DE,IB0D0+255
        OR	A
        SBC	HL,DE
        ADD	HL,DE			; end of history buffer ?
        INC	HL
        JR	NZ,J0576		; nope,
        LD	HL,IB0D0		; start of history buffer
J0576:	POP	DE
        POP	AF
        RET

;	  Subroutine previous position in history buffer
;	     Inputs  HL = pointer in history buffer
;	     Outputs HL = updated pointer in history buffer

C0579:	PUSH	AF
        PUSH	DE
        LD	DE,IB0D0
        OR	A
        SBC	HL,DE
        ADD	HL,DE			; start of history buffer ?
        DEC	HL
        JR	NZ,J0588		; nope,
        LD	HL,IB0D0+255		; end of history buffer
J0588:	POP	DE
        POP	AF
        RET

;	  Subroutine edit line
;	     Inputs  DE = pointer to buffer
;	     Outputs ________________________

C058B:	LD	HL,(DBB8B)		; console column position
        LD	(DBB87),HL		; initial console column position
        LD	(DBB7D),HL		; maximum console column position
        EX	DE,HL
J0595:	LD	C,(HL)			; size of buffer
        INC	HL
        LD	(DBB84),HL		; store pointer to start of line
        LD	A,(HL)			; size of line
        OR	A			; empty line ?
        LD	B,A			; store size of line
        JR	Z,J05A5			; yep, skip
        INC	HL
        CALL	C0811			; text to console, update maximum column position
        DEC	HL
        LD	A,B			; restore size of line
J05A5:	LD	(DBB86),A		; update size of line
        XOR	A			; insert mode = off
        CALL	C06BC			; set insert mode and update cursor shape
I05AC:	LD	DE,I05AC
        PUSH	DE			; restart after key operation
        PUSH	HL			; store pointer in buffer
        LD	HL,DBB86
        LD	A,(HL)
        CP	B			; current size of line > stored size of line ?
        JR	NC,J05B9		; nope,
        LD	(HL),B			; update stored size of line
J05B9:	POP	HL			; restore pointer in buffer
        CALL	C08B2			; ensure input from keyboard

	IF	OPTM EQ 0
        OR	A
        RET	Z			; ?? can never occure
	ENDIF

        CP	0AH			; LF key ?
        RET	Z			; yep, ignore
        CP	0DH			; return key ?
        JP	Z,J07A8
        CP	1DH			; cursor left key ?
        JP	Z,J06F9
        CP	1CH			; cursor right key ?
        JP	Z,J06DB
        CP	7FH			; del key ?
        JP	Z,J0748
        CP	08H			; backspace key ?
        JP	Z,J0741
        CP	12H			; insert key ?
        JP	Z,J06B8			; yep, flip insert mode and update cursor shape
        CP	1BH			; esc key ?
        JR	Z,J05EA
        CP	18H			; select key ?
        JR	Z,J05EA
        CP	15H			; CTRL-U ?
J05EA:	JP	Z,J07A1
        CP	1EH			; cursor up key ?
        JP	Z,J07BF
        CP	1FH			; cursor down key ?
        JP	Z,J07C6
        CP	0BH			; home key ?
        JP	Z,J06F2
        LD	E,A			; store keyboard input
        LD	A,(DBB7B)
        OR	A			; insert mode ?
        JP	NZ,J0653		; yep, insert character
        LD	A,(DBB86)
        CP	B			; current size of line = stored size of line ?
        JR	Z,J063F			; yep, at end of line
        INC	HL
        LD	A,E			; store keyboard input
        CALL	C17E0			; check for double byte header character if enabled
        JR	NC,J062E		; nope, continue

; new double byte character

        LD	A,(DBB86)
        DEC	A
        CP	B
        JR	NZ,J0623
        INC	A
        CP	C			; does it fit in buffer ?
        DEC	HL
        JP	NC,J06AB		; nope, ensure key and beep
        INC	HL
        INC	A
        LD	(DBB86),A		; update stored size of line
J0623:	LD	A,(HL)			; character from buffer
        CALL	C17E0			; check for double byte header character if enabled
        INC	HL			; to double byte character
        CALL	NC,C07CD                ; nope, if double byte header character in buffer, replace double byte charcter with space
        DEC	HL			; to double byte header character
        JR	J0678			; put double byte header character in buffer and handle double byte input

; new single byte character

J062E:	CALL	C07CD			; if double byte header character in buffer, replace double byte charcter with space
        JR	C,J06A3			; double byte header character, put in buffer
        LD	A,(HL)			; character from buffer
        CP	20H			; control character ?
        JR	C,J06A3			; yep, put in buffer
        LD	A,E
        CP	20H			; input control character ?
        JR	C,J06A3			; yep, put in buffer
        JR	J0649			; put in buffer

; at end of line

J063F:	CP	C			; end of buffer ?
        JR	NC,J06AE		; yep, beep
        LD	A,E
        CALL	C17E0			; check for double byte header character if enabled
        JR	C,J0659			; yep, insert double byte character
        INC	HL
J0649:	LD	(HL),E
        LD	A,E
        INC	B
        CALL	C0836			; character to console (make control character printable, allow force to screen)

	IF	OPTM EQ 0

        CALL	C0821			; update maximum column position
        RET

	ELSE

	JP	C0821			; update maximum column position

	ENDIF

; insert character

J0653:	LD	A,E
        CALL	C17E0			; check for double byte header character if enabled
        JR	NC,J0687		; nope,

; insert double byte character

J0659:	LD	A,(DBB86)		; stored size of line
        INC	A
        CP	C
        JR	NC,J06AB		; ensure key and beep
        INC	A
        LD	(DBB86),A		; update stored size of line
        DEC	A
        DEC	A
        SUB	B
        JR	Z,J0677
        PUSH	DE
        PUSH	BC
        LD	C,A
        LD	B,0
        ADD	HL,BC
        LD	D,H
        LD	E,L
        INC	DE
        INC	DE
        LDDR
        POP	BC
        POP	DE
J0677:	INC	HL
J0678:	LD	(HL),E
        INC	HL
        CALL	C08B2			; ensure input from keyboard
        LD	(HL),A
        DEC	HL
        CALL	C07DC			; refresh line on screen
        INC	B
        INC	B
        JP	C06FD			; cursor to position

; insert single byte character

J0687:	LD	A,(DBB86)		; stored size of line
        CP	C
        JR	NC,J06AE		; beep
        INC	A
        LD	(DBB86),A		; update stored size of line
        DEC	A
        SUB	B
        JR	Z,J06A2
        PUSH	DE
        PUSH	BC
        LD	C,A
        LD	B,0
        ADD	HL,BC
        LD	D,H
        LD	E,L
        INC	DE
        LDDR
        POP	BC
        POP	DE
J06A2:	INC	HL
J06A3:	LD	(HL),E
        CALL	C07DC			; refresh line on screen
        INC	B
        JP	C06FD			; cursor to position

J06AB:	CALL	C08B2			; ensure input from keyboard
J06AE:	LD	A,7			; beep
        PUSH	BC
        PUSH	HL
        CALL	C0A6C			; output character to screen
        POP	HL
        POP	BC
        RET

;	  Subroutine INS key, flip insert mode and update cursor shape
;	     Inputs  ________________________
;	     Outputs ________________________

J06B8:	LD	A,(DBB7B)
        CPL

;	  Subroutine set insert mode and update cursor shape
;	     Inputs  ________________________
;	     Outputs ________________________

C06BC:	LD	(DBB7B),A
        OR	A
        LD	A,'y'
        JR	NZ,J06C5
        DEC	A			; 'x'
J06C5:	PUSH	BC
        PUSH	HL
        PUSH	DE
        PUSH	AF
        LD	A,1BH			; ESC
        CALL	C0A6C			; output character to screen
        POP	AF
        CALL	C0A6C			; output character to screen
        LD	A,"4"
        CALL	C0A6C			; output character to screen
        POP	DE
        POP	HL
        POP	BC
        RET

; cursor right key

J06DB:	LD	A,(DBB86)		; stored size of line
        CP	B			; at end of line ?
        RET	Z			; yep, quit
        INC	HL			; update pointer
        INC	B			; position right
        LD	A,(HL)			; character from buffer
        CALL	C17E0			; check for double byte header character if enabled
        JP	NC,C0836		; nope, character to console (make control character printable, allow force to screen)
        CALL	C0836			; character to console (make control character printable, allow force to screen)
        INC	HL			; update pointer
        INC	B			; position right
        LD	A,(HL)			; character from buffer
        JP	C0836			; character to console (make control character printable, allow force to screen)

; HOME key

J06F2:	LD	A,B
        OR	A			; at start of line ?
        RET	Z			; yep, quit
        LD	B,0			; position at start of line
        JR	C06FD			; cursor to position

; cursor left key

J06F9:	LD	A,B
        OR	A			; at start of line ?
        RET	Z			; yep, quit
        DEC	B			; position left

;	  Subroutine cursor to position
;	     Inputs  B = position
;	     Outputs ________________________

C06FD:	LD	HL,(DBB84)		; pointer to start of line
        LD	DE,(DBB87)		; initial console column position
        PUSH	BC			; store size
        INC	B			; size+1 (starting at end of loop, allowing size = 0)
        JR	J0729

J0708:	INC	HL
        LD	A,(HL)
        CALL	C17E0			; check for double byte header character if enabled
        JR	NC,J0719		; nope,
        INC	HL
        DJNZ	J0727
        DEC	HL
        DEC	HL
        POP	BC
        DEC	B
        PUSH	BC
        JR	J072B

J0719:	CP	09H			; TAB ?
        JR	NZ,J0723		; nope,
        LD	A,E
        OR	07H
        LD	E,A			; column position to TAB stop -1
        JR	J0728			; to TAB stop

J0723:	CP	20H			; control character ?
        JR	NC,J0728		; nope, column+1
J0727:	INC	DE			; update column
J0728:	INC	DE			; update column
J0729:	DJNZ	J0708			; next

J072B:	PUSH	HL
        LD	HL,(DBB8B)		; console column position
        OR	A
        SBC	HL,DE
        JR	Z,J073E
J0734:	LD	A,08H			; BS
        CALL	C0836			; character to console (make control character printable, allow force to screen)
        DEC	HL
        LD	A,H
        OR	L
        JR	NZ,J0734
J073E:	POP	HL
        POP	BC
        RET

; BS key, delete left

J0741:	LD	A,B
        OR	A			; position = 0 ?
        RET	Z			; yep, quit
        DEC	B			; position left
        CALL	C06FD			; cursor to position

; DEL key, delete right

J0748:	LD	A,(DBB86)		; stored size of line
        CP	B
        RET	Z
        DEC	A
        LD	(DBB86),A		; update stored size of line
        SUB	B
        JR	Z,J0784
        LD	E,A
        INC	HL
        LD	A,(HL)
        DEC	HL
        CALL	C17E0			; check for double byte header character if enabled
        LD	A,E
        JR	NC,J0777		; nope,

; delete right double byte character

        PUSH	HL
        LD	HL,DBB86
        DEC	(HL)			; update stored size of line
        POP	HL
        DEC	A
        JR	Z,J0784
        PUSH	BC
        PUSH	HL
        LD	C,A
        LD	B,00H
        INC	HL
        LD	D,H
        LD	E,L
        INC	HL
        INC	HL
        LDIR
        POP	HL
        POP	BC
        JR	J0784

; delete right single byte character

J0777:	PUSH	BC
        PUSH	HL
        LD	C,A
        LD	B,00H
        INC	HL
        LD	D,H
        LD	E,L
        INC	HL
        LDIR
        POP	HL
        POP	BC
J0784:	INC	HL
        CALL	C07DC			; refresh line on screen
        DEC	HL
        JP	C06FD			; cursor to position

;	  Subroutine delete line on screen
;	     Inputs  ________________________
;	     Outputs ________________________

C078C:	XOR	A
        CP	B			; position = 0 ?
        LD	B,A			; position = 0
        CALL	NZ,C06FD		; nope, cursor to position
        CALL	C07D7			; clear rest of line on screen
        LD	B,0			; position = 0
        CALL	C06FD			; cursor to position
        LD	HL,(DBB84)		; pointer to start of line
        LD	(HL),0
        DEC	HL
        RET

; ESC, SELECT, CTRL-U key

J07A1:	CALL	C078C			; delete line on screen
        POP	DE
        JP	J0595

; return key

J07A8:	INC	HL
        CALL	C07DC			; refresh line on screen
        LD	HL,(DBB84)		; pointer to start of line
        LD	A,(DBB86)		; stored size of line
        LD	(HL),A
        XOR	A			; insert mode = off
        CALL	C06BC			; set insert mode and update cursor shape
        LD	A,0DH			; CR
        CALL	C0836			; character to console (make control character printable, allow force to screen)
        POP	HL
        XOR	A			; action = enter
        RET

; cursor up key

J07BF:	POP	HL
        CALL	C078C			; delete line on screen
        LD	A,1			; action = previous line
        RET

; cursor down key

J07C6:	POP	HL
        CALL	C078C			; delete line on screen
        LD	A,2			; action = next line
        RET

;	  Subroutine if double byte header character in buffer, replace double byte charcter with space
;	     Inputs  ________________________
;	     Outputs ________________________

C07CD:	LD	A,(HL)
        CALL	C17E0			; check for double byte header character if enabled
        RET	NC			; nope, quit
        INC	HL
        LD	(HL),' '
        DEC	HL
        RET

;	  Subroutine clear rest of line on screen
;	     Inputs  ________________________
;	     Outputs ________________________

C07D7:	PUSH	BC
        PUSH	DE
        PUSH	HL
        JR	J07E7

;	  Subroutine refresh line on screen
;	     Inputs  B = current position
;	     Outputs ________________________

C07DC:	PUSH	BC
        PUSH	DE
        PUSH	HL
        LD	A,(DBB86)		; stored size of line
        SUB	B
        LD	B,A
        CALL	C0811			; text to console, update maximum column position
J07E7:	LD	DE,(DBB8B)		; console column position
        LD	HL,(DBB7D)		; maximum console column position
        OR	A
        SBC	HL,DE
        JR	Z,J0803			; clear to end of line
        JR	C,J0803			; clear to end of line
J07F5:	LD	A,' '			; space
        CALL	C0836			; character to console (make control character printable, allow force to screen)
        DEC	HL
        LD	A,H
        OR	L
        JR	NZ,J07F5
        LD	(DBB7D),DE		; update maximum console column position

; clear to end of line

J0803:	LD	A,1BH			; ESC
        CALL	C0A6C			; output character to screen
        LD	A,"K"
        CALL	C0A6C			; output character to screen
        POP	HL
        POP	DE
        POP	BC
        RET

;	  Subroutine text to console, update maximum column position
;	     Inputs  HL = pointer to text, B = size of text
;	     Outputs ________________________

C0811:	PUSH	BC
        INC	B                       ; +1 (starting at end of loop, allowing size = 0)
        JR	J081D

J0815:	LD	A,(HL)
        CALL	C0836			; character to console (make control character printable, allow force to screen)
        CALL	C0821			; update maximum column position
        INC	HL
J081D:	DJNZ	J0815
        POP	BC
        RET

;	  Subroutine update maximum column position
;	     Inputs  ________________________
;	     Outputs ________________________

C0821:	PUSH	HL
        PUSH	BC
        LD	HL,(DBB7D)		; maximum console column position
        LD	BC,(DBB8B)		; console column position
        OR	A
        SBC	HL,BC
        JR	NC,J0833
        LD	(DBB7D),BC		; update maximum console column position
J0833:	POP	BC
        POP	HL
        RET

;	  Subroutine character to console (make control character printable, allow force to screen)
;	     Inputs  ________________________
;	     Outputs ________________________

C0836:	PUSH	BC
        PUSH	DE
        PUSH	HL
        CALL	C085A			; is outputable key ?
        JR	NC,J0847		; yep,
        PUSH	AF
        LD	A,'^'
        CALL	C084E			; character to console (allow force to screen)
        POP	AF
        ADD	A,40H			; make control character printable
J0847:	CALL	C084E			; character to console (allow force to screen)
        POP	HL
        POP	DE
        POP	BC
        RET

;	  Subroutine character to console (allow force to screen)
;	     Inputs  ________________________
;	     Outputs ________________________

C084E:	LD	B,A			; store character
        LD	A,(DBB7A)
        OR	A			; force console output to screen ?
        LD	A,B			; restore character
        JP	Z,C0871			; nope, character to console (with redirection support and TAB translation)
        JP	C08EE			; character to screen (with TAB translation)

;	  Subroutine is outputable key ?
;	     Inputs  ________________________
;	     Outputs ________________________

C085A:	CP	0DH			; CR ?
        RET	Z
        CP	0AH			; LF ?
        RET	Z
        CP	09H			; TAB ?
        RET	Z
        CP	08H			; BS ?
        RET	Z
        CP	7FH			; DEL ?
        RET	Z
        CP	20H
        RET

;	  Subroutine character to console (with console status, redirection support and TAB translation)
;	     Inputs  ________________________
;	     Outputs ________________________

C086C:	PUSH	AF
        CALL	C0897			; get console status
        POP	AF

;	  Subroutine character to console (with redirection support and TAB translation)
;	     Inputs  ________________________
;	     Outputs ________________________

C0871:	CP	09H			; TAB ?
        JR	NZ,C0882		; nope, character to console (with redirection support)
J0875:	LD	A,' '
        CALL	C0882			; character to console (with redirection support)
        LD	A,(DBB8B)
        AND	07H			; console column position at TAB stop ?
        JR	NZ,J0875		; nope,
        RET

;	  Subroutine character to console (with redirection support)
;	     Inputs  ________________________
;	     Outputs ________________________

C0882:	LD	HL,(DBB8B)		; console column position
        CALL	C0915			; update console column position
        LD	(DBB8B),HL		; store console column position
        BIT	1,(IY+DBB89-DBB80)	; console output redirected ?
        JP	Z,J0908			; nope, character to screen
        LD	C,0FFH			; do check for CTRL-C
        JP	J042A			; character to console output file handle

;	  Subroutine get console status
;	     Inputs  ________________________
;	     Outputs ________________________

C0897:	CALL	C0A42			; get status from keyboard
        LD	B,A			; store status
        LD	A,(DBB8D)
        OR	A			; stored input ?
        JR	NZ,J08AF		; yep,
        LD	A,B
        OR	A			; have input ?
        RET	Z			; nope, quit
        CALL	C0A2D			; get character from keyboard
        CALL	C08C5			; handle special keys
        OR	A
        RET	Z
        LD	(DBB8D),A		; store input
J08AF:	XOR	A
        DEC	A
        RET

;	  Subroutine ensure input from keyboard
;	     Inputs  ________________________
;	     Outputs ________________________

C08B2:	LD	A,(DBB8D)
        LD	(IY+DBB8D-DBB80),0	; no stored input
        OR	A			; stored input ?
        RET	NZ			; yep,
J08BB:	CALL	C0A2D			; get character from keyboard
        CALL	C08C5			; handle special keys
        OR	A
        JR	Z,J08BB
        RET

;	  Subroutine handle special keys
;	     Inputs  ________________________
;	     Outputs ________________________

C08C5:	CP	10H			; ^P ?
        JR	Z,J08E5			; yep, enable console output duplicated to printer
        CP	0EH			; ^O ?
        JR	Z,J08E8			; yep, disable console output duplicated to printer
        CP	03H			; ^C ?
        JR	Z,J08DC			; yep,
        CP	13H			; ^S ?
        RET	NZ			; nope,
        CALL	C0A2D			; get character from keyboard
        CP	03H			; ^C ?
        LD	A,0
        RET	NZ			; nope, quit
J08DC:	LD	A,.CTRLC
        LD	B,00H
        CALL	C3749			; call program abort routine with TPA segments active
J08E3:	JR	J08E3			; halt system

J08E5:	LD	A,0FFH
        DEFB	0FEH			; CP xx : trick to skip next instruction

J08E8:	XOR	A
        LD	(DBB8A),A		; update console output duplicated to printer flag
        XOR	A
        RET

;	  Subroutine character to screen (with TAB translation)
;	     Inputs  ________________________
;	     Outputs ________________________

C08EE:	CP	9			; TAB ?
        JR	NZ,C08FF		; nope, character to screen
J08F2:	LD	A,' '
        CALL	C08FF			; character to screen
        LD	A,(DBB8B)
        AND	07H			; console column position at TAB stop ?
        JR	NZ,J08F2		; nope,
        RET

;	  Subroutine character to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C08FF:	LD	HL,(DBB8B)		; console column position
        CALL	C0915			; update console column position
        LD	(DBB8B),HL		; store console column position
J0908:	CALL	C0A6C			; output character to screen
        LD	HL,DBB8A
        BIT	0,(HL)			; console output duplicated to printer ?
        RET	Z			; nope, quit
        LD	E,A
        JP	A0441			; _LSTOUT

;	  Subroutine update console column position
;	     Inputs  ________________________
;	     Outputs ________________________

C0915:	INC	HL
        CP	7FH			; DEL ?
        JR	Z,J091D			; yep, control character
        CP	20H			; other control character ?
        RET	NC			; nope, quit
J091D:	DEC	HL
        LD	B,A			; store character
        LD	A,H
        OR	L
        LD	A,B			; restore character
        RET	Z
        DEC	HL
        CP	08H			; BS ?
        RET	Z			; yep,
        CP	7FH			; DEL ?
        RET	Z			; yep,
        INC	HL
        CP	0DH			; CR ?
        RET	NZ			; nope,
        LD	HL,0
        RET

; CON device jumptable

A0932:	JP	J0941			; input
        JP	J098E			; output
        JP	J09A1			; check if input ready
        JP	J0A1C			; check if output ready
        JP	J09B1			; get screensize

; CON device input handler

J0941:	BIT	5,C			; ascii mode ?
        JR	NZ,J094B		; yep, get character from console line buffered input
        CALL	C0A2D			; get character from keyboard
        LD	B,A
        XOR	A
        RET

J094B:	LD	HL,(DBB78)		; pointer in console line input buffer CON device
        LD	A,(HL)
        OR	A			; end of line ?
        JR	NZ,J0979		; nope,
        LD	DE,IB1D0		; pointer to console line input buffer CON device
        LD	A,255
        LD	(DE),A			; size of console line input buffer CON device = 255
        LD	A,0FFH			; force console output to screen
        CALL	C04B1			; console line buffered input
        LD	A,0AH			; LF
        CALL	C08EE			; character to screen (with TAB translation)
        LD	HL,IB1D0+1
        LD	E,(HL)
        LD	D,0			; size of console line input CON device
        INC	HL			; pointer to buffer
        EX	DE,HL
        ADD	HL,DE			; end of console line input
        LD	(HL),0DH		; add CR
        INC	HL
        LD	(HL),0AH		; add LF
        INC	HL
        LD	(HL),0			; end of line
        EX	DE,HL			; pointer to buffer
        LD	A,(HL)
        CP	1AH			; first character = end of file ?
        JR	Z,J0985			; yep,
J0979:	INC	HL
        LD	(DBB78),HL		; update pointer in console line input buffer CON device
        LD	B,A			; start character
        CP	0AH			; LF ?
        LD	A,.EOL
        RET	Z			; yep, quit with end of line 'error'
        XOR	A			; no error
        RET

J0985:	LD	B,A			; store EOF
        LD	(HL),0
        LD	(DBB78),HL		; empty console line input CON device
        LD	A,.EOF			; end of file 'error'
        RET

; CON device output handler

J098E:	BIT	5,C			; ascii mode ?
        JR	NZ,J0997		; yep,
        CALL	C0A6C			; output character to screen
        XOR	A
        RET

J0997:	PUSH	AF
        CALL	C0897			; get console status
        POP	AF
        CALL	C08EE			; character to screen (with TAB translation)
        XOR	A
        RET

; CON device check if input ready handler

J09A1:	BIT	5,C			; ascii mode ?
        JR	NZ,J09AB		; yep,
        CALL	C0A42			; get status from keyboard
        LD	E,A
        XOR	A
        RET

J09AB:	CALL	C0897			; get console status
        LD	E,A
        XOR	A
        RET

; CON device get screen size handler

J09B1:	CALL	C0A20			; get screen size
        XOR	A
        RET

;	  Subroutine clear line input buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C09B6:	LD	HL,IB1D0+2
        LD	(DBB78),HL		; pointer in console line input buffer CON device = start of CON device buffer
        LD	(HL),0			; console line input = empty line
        RET

; AUX device jumptable

A09BF:	JP	J09CE			; input
        JP	J09DD			; output
        JP	J0A1C			; check if input ready
        JP	J0A1C			; check if output ready
        JP	J0A17			; get srceensize

; AUX device input handler

J09CE:	CALL	C0B46			; get character from AUX device
        LD	B,A			; store character
        CP	1AH			; EOF ?
        JR	Z,J0A14			; yep,
        CP	0DH			; CR ?
        LD	A,.EOL
        RET	Z			; yep,
        XOR	A
        RET

; AUX device output handler

J09DD:	CALL	C0B51			; output character to AUX device
        XOR	A
        RET

; LST/PRN device jumptable

A09E2:	JP	J0A12			; input
        JP	J09F1			; output
        JP	J0A1C			; check if input ready
        JP	J09FD			; check if output ready
        JP	J0A17			; get screensize

; LST/PRN device output handler

J09F1:	CALL	C0B25			; output character to printer
        JR	NC,J0A1A		; no error, quit
        RES	0,(IY+DBB8A-DBB80)	; console output not duplicated to printer
        LD	A,.STOP
        RET

; LST/PRN device check if output ready handler

J09FD:	CALL	C0B37			; get printer status
        LD	E,A
        XOR	A
        RET

; NUL device jumptable

A0A03:	JP	J0A12			; input
        JP	J0A1A			; output
        JP	J0A1C			; check if input ready
        JP	J0A1C			; check if output ready
        JP	J0A17			; get screensize

J0A12:	LD	B,1AH
J0A14:	LD	A,.EOF
        RET

J0A17:	LD	DE,0
J0A1A:	XOR	A
        RET

J0A1C:	LD	E,0FFH
        XOR	A
        RET

;	  Subroutine get screen size
;	     Inputs  ________________________
;	     Outputs ________________________

C0A20:	LD	A,(LINLEN)
        LD	E,A
        LD	A,(CRTCNT)
        LD	HL,CNSDFG
        ADD	A,(HL)
        LD	D,A
        RET

;	  Subroutine get character from keyboard
;	     Inputs  ________________________
;	     Outputs ________________________

C0A2D:	CALL	H_CHIN
        CALL	C0AB9			; flush screen output buffer (if any)
        PUSH	IX
        LD	IX,CHGET
        CALL	C0B78			; main-bios call CHGET
        CALL	C0B5B			; check and handle CTRL-STOP
        POP	IX
        RET

;	  Subroutine get status from keyboard
;	     Inputs  ________________________
;	     Outputs ________________________

C0A42:	CALL	H_CHST
        LD	HL,ST_COU
        DEC	(HL)			; should keyboard buffer be checked ?
        JR	NZ,J0A69		; not yet, quit
        INC	(HL)
        LD	A,(CH_COU)
        DEC	A			; timer finished ?
        CALL	Z,C0AB9			; yep, flush screen output buffer (if any)
        PUSH	IX
        LD	IX,CHSNS
        CALL	C0B78			; main-bios call CHSNS
        CALL	C0B5B			; check and handle CTRL-STOP
        POP	IX
        LD	A,0FFH
        RET	NZ
        LD	A,100+1
        LD	(ST_COU),A		; 100 times no keyboardbuffer check
J0A69:	XOR	A
        RET

J0A6B:	LD	A,C

;	  Subroutine output character to screen
;	     Inputs  ________________________
;	     Outputs ________________________

CHR_OUT:
C0A6C:	CALL	H_CHOU

	IF USESBF EQ 0

        PUSH	IX
        LD	IX,CHPUT
        CALL	C0B78			; main-bios call CHPUT
        POP	IX
        RET

	ENDIF

	IF	(OPTM EQ 0) OR (USESBF EQ 1)

	LD	E,A
        CP	1BH
        CALL	Z,C0AB9			; begin of an ESC sequence, flush screen output buffer (if any)
        LD	HL,DBB76
        BIT	0,(HL)			; in double byte character ?
        RES	0,(HL)			; not anymore
        JR	NZ,J0A91		; 2nd byte of double byte character
        CALL	C17E0			; check for double byte header character if enabled
        JR	NC,J0A91
        SET	0,(HL)			; is header character, flag it
J0A91:	LD	A,2
        LD	(CH_COU),A		; wait at least 100 ms for actual screenoutput
        LD	A,(DBB77)
        LD	C,A
        LD	B,0
        LD	HL,DB06C
        ADD	HL,BC			; screen output buffer pointer
        LD	(HL),E			; put in buffer
        INC	A
        LD	(DBB77),A
        CP	100
        JR	Z,C0ACE			; buffer full, flush screen output buffer
        LD	A,(ESCCNT)
        OR	A
        JR	NZ,C0ACE		; screenouput in ESC sequence, flush screen output buffer
        LD	A,E
        CP	0AH
        JR	Z,C0ACE			; linefeed character, flush screen output buffer
        CP	07H
        JR	Z,C0ACE			; bell character, flush screen output buffer
        RET
	
	ENDIF

;	  Subroutine flush screen output buffer (if any)
;	     Inputs  ________________________
;	     Outputs ________________________

C0AB9:	CALL	H_CHFL
        PUSH	AF
        LD	A,(DBB77)
        OR	A
        JR	Z,J0ACC			; nothing in buffer, quit
        PUSH	BC
        PUSH	DE
        PUSH	HL
        CALL	C0ACE			; flush screen output buffer
        POP	HL
        POP	DE
        POP	BC
J0ACC:	POP	AF
        RET

;	  Subroutine flush screen output buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C0ACE:	EX	AF,AF'
        EXX
        PUSH	AF
        PUSH	BC
        PUSH	DE
        PUSH	HL
        PUSH	IX
        PUSH	IY
        LD	HL,DB06C
        LD	A,(DBB76)
        BIT	0,A			; buffer in double byte character sequence ?
        PUSH	AF
        LD	A,(DBB77)
        JR	Z,J0AE9			; nope, empty complete buffer
        DEC	A			; do not include the double byte character header (save it for later)
        JR	Z,J0B07			; only 1 character in buffer (not the complete double byte character), keep this in buffer and quit
J0AE9:	LD	B,A
        LD	A,(ESCCNT)
        OR	A
        JR	NZ,J0AF6		; in ESC sequence, skip cursor off
        LD	HL,IB069
        INC	B
        INC	B
        INC	B			; include cursor off string
J0AF6:	CALL	$FLUSH			; print string via chput
        PUSH	HL
        LD	HL,IB066
        LD	B,3
        LD	A,(ESCCNT)
        OR	A
        CALL	Z,$FLUSH		; not in ESC sequence, print cursor on string via chput
        POP	HL
J0B07:	XOR	A
        LD	(DBB77),A		; empty screen output buffer
        LD	(CH_COU),A		; disable timer screenout buffer timer
        POP	AF
        JR	Z,J0B1A			; not in a double byte character sequence, quit
        LD	A,(HL)
        LD	(DB06C),A		; last character of buffer now the only character
        LD	A,1
        LD	(DBB77),A		; 1 character in screenoutput buffer
J0B1A:	POP	IY
        POP	IX
        POP	HL
        POP	DE
        POP	BC
        POP	AF
        EXX
        EX	AF,AF'
        RET

;	  Subroutine output character to printer
;	     Inputs  ________________________
;	     Outputs ________________________

C0B25:	CALL	H_LSTO
        CALL	C0AB9			; flush screen output buffer (if any)
        PUSH	IX
        LD	IX,LPTOUT
        CALL	C0B78			; main-bios call LPTOUT
        POP	IX
        RET

;	  Subroutine get printer status
;	     Inputs  ________________________
;	     Outputs ________________________

C0B37:	CALL	H_LSTS
        PUSH	IX
        LD	IX,LPTSTT
        CALL	C0B78			; main-bios call LPTSTT
        POP	IX
        RET

;	  Subroutine get character from AUX device
;	     Inputs  ________________________
;	     Outputs ________________________

C0B46:	CALL	C0AB9			; flush screen output buffer (if any)
        LD	HL,$AUXIN

	IF	OPTM EQ 0

        CALL	C374C			; call AUX-input with TPA segments active
        RET

	ELSE

	JP	C374C

	ENDIF

J0B50:	LD	A,C

;	  Subroutine output character to AUX device
;	     Inputs  ________________________
;	     Outputs ________________________

C0B51:	CALL	C0AB9			; flush screen output buffer (if any)
        LD	HL,$AUXOUT

	IF	OPTM EQ 0

        CALL	C374C			; call AUX-output with TPA segments active
        RET

	ELSE

	JP	C374C

	ENDIF

;	  Subroutine check and handle CTRL-STOP
;	     Inputs  ________________________
;	     Outputs ________________________

C0B5B:	PUSH	AF
        LD	A,(INTFLG)
        SUB	03H			; CTRL-STOP pressed ?
        JR	Z,J0B65			; yep,
        POP	AF
        RET

J0B65:	LD	(INTFLG),A		; clear CTRL-STOP flag
        LD	IX,KILBUF
        CALL	C0B78			; main-bios call KILBUF
        LD	A,.STOP
        LD	B,00H
        CALL	C3749			; call program abort routine with TPA segments active
J0B76:	JR	J0B76			; loop to infinety

;	  Subroutine call main-bios
;	     Inputs  ________________________
;	     Outputs ________________________

C0B78:	EX	AF,AF'
        EXX
        PUSH	AF
        PUSH	BC
        PUSH	DE
        PUSH	HL
        PUSH	IY
        EXX
        EX	AF,AF'
        CALL	P0_CALL
        EX	AF,AF'
        EXX
        POP	IY
        POP	HL
        POP	DE
        POP	BC
        POP	AF
        EXX
        EX	AF,AF'
        RET

;	  Subroutine _CPMVER
;	     Inputs  ________________________
;	     Outputs ________________________

A0B90:	LD	HL,256*00H+22H		; machine type = i8080, CP/M type = plain, CP/M version = 2.2
        XOR	A
        RET

;	  Subroutine _DSKRST
;	     Inputs  ________________________
;	     Outputs ________________________

A0B95:	LD	B,0FFH			; all drives
        LD	D,0			; flush only
        CALL	A0CE0			; flush buffers
        LD	A,1
        LD	(CUR_DRV),A		; current drive id = A:
        LD	HL,DBUF
        LD	(DTA_AD),HL		; transfer address to 00080H
        XOR	A
        LD	H,A
        LD	L,A
        RET

;	  Subroutine _SELDSK
;	     Inputs  ________________________
;	     Outputs ________________________

A0BAB:	INC	E			; drive id to 1 based
        LD	A,E
        LD	C,.IDRV			; error = invalid drive
        CALL	NZ,C362C		; 0 based drive id <> 0FFH, translate drive assigment and get pointer to drive tabel
        JR	Z,J0BBF			; no valid drive id or 0 based drive id = 0FFH, return invalid drive error and number of drives
        LD	A,(HL)
        INC	HL
        OR	(HL)			; drive table entry in use ?
        JR	Z,J0BBF			; nope, return number of drives
        LD	A,E
        LD	(CUR_DRV),A		; update current drive id
        LD	C,0			; error = no error
J0BBF:	LD	HL,($NUMDR)
        LD	H,0			; number of drives
        LD	A,C			; error
        RET

;	  Subroutine _LOGIN
;	     Inputs  ________________________
;	     Outputs ________________________

A0BC6:	LD	B,8			; drive counter = 8
        LD	HL,0			; login vector = 0
J0BCB:	ADD	HL,HL			; shift left
        PUSH	HL			; store current login vector
        LD	A,B			; drive id = current counter
        CALL	C362C			; translate drive assigment and get pointer to drive tabel
        LD	A,(HL)
        INC	HL
        OR	(HL)			; drive table entry in use ?
        POP	HL			; restore login vector
        JR	Z,J0BD8			; nope, leave bit cleared
        INC	HL			; yep, set bit
J0BD8:	DJNZ	J0BCB			; next drive
        XOR	A
        RET

;	  Subroutine _CURDRV
;	     Inputs  ________________________
;	     Outputs ________________________

A0BDC:	LD	A,(CUR_DRV)		; current drive id
        DEC	A
        LD	L,A
        XOR	A
        LD	H,A			; drive id to 0 based
        RET

;	  Subroutine _SETDTA
;	     Inputs  DE = transfer address
;	     Outputs ________________________

A0BE4:	LD	(DTA_AD),DE
        XOR	A
        LD	H,A
        LD	L,A
        RET

;	  Subroutine _ALLOC
;	     Inputs  ________________________
;	     Outputs ________________________

A0BEC:	LD	C,E
        LD	B,0			; type = for disk
        LD	IX,IB9DA		; buffer
        CALL	C31AB			; check disk change
        OR	A			; error ?
        LD	C,0FFH
        RET	NZ			; yep, quit
        PUSH	HL
        POP	IX
        LD	E,(IX+22)
        LD	D,(IX+23)		; number of clusters+1
        PUSH	DE
        LD	DE,2			; begin with FAT entry 2 (first two are reserved)
        LD	B,D
        LD	C,D			; free = 0
J0C09:	PUSH	DE			; store cluster number
        CALL	C2DA4			; get FAT entry content
        LD	A,D
        OR	E			; free cluster ?
        JR	NZ,J0C12
        INC	BC			; yep, free+1
J0C12:	POP	DE			; restore cluster number
        EX	(SP),HL
        SBC	HL,DE
        ADD	HL,DE			; last FAT entry ?
        EX	(SP),HL
        INC	DE
        JR	NZ,J0C09		; nope, continue with the next
        PUSH	BC
        LD	E,(IX+12)
        LD	D,(IX+13)		; first FAT sector
        CALL	C2B88			; get FAT sector
        LD	DE,11
        ADD	HL,DE			; pointer to the sector buffer
        LD	DE,($SECBUF)		; pointer to disk driver sector buffer
        PUSH	DE
        LD	BC,512
        LDIR				; copy first FAT sector in the disk driver sector buffer
        POP	IY
        POP	HL
        POP	DE
        DEC	DE
        NOP
        LD	C,(IX+2)
        LD	B,(IX+3)		; pointer to DPB
        PUSH	BC			; store pointer to DPB
        LD	C,(IX+10)		; cluster mask
        INC	C			; number of sectors per cluster
        POP	IX			; restore pointer to DPB
        XOR	A
        RET

;	  Subroutine _VERIFY
;	     Inputs  ________________________
;	     Outputs ________________________

A0C48:	LD	A,E
        LD	(RAWFLG),A
        XOR	A
        LD	H,A
        LD	L,A
        RET

;	  Subroutine _DPARM
;	     Inputs  ________________________
;	     Outputs ________________________

A0C50:	LD	IX,IB9DA		; buffer
        LD	B,0			; type = for disk
        LD	C,L
        PUSH	DE
        CALL	C31AB			; check disk change
        POP	DE
        OR	A			; error ?
        RET	NZ			; yep, quit
        PUSH	HL
        POP	IX
        PUSH	DE
        LD	BC,8
        ADD	HL,BC
        LDI
        LD	BC,512
        LD	A,C
        LD	(DE),A
        INC	DE
        LD	A,B
        LD	(DE),A
        INC	DE
        INC	HL
        LD	A,(HL)
        INC	HL
        INC	A
        LD	(DE),A
        INC	DE
        INC	HL
        LDI
        LDI
        LDI
        LD	A,(HL)
        INC	HL
        PUSH	HL
        LD	L,(HL)
        LD	H,00H
        ADD	HL,HL
        ADD	HL,HL
        ADD	HL,HL
        ADD	HL,HL
        ADD	A,L
        LD	(DE),A
        INC	DE
        LD	A,H
        LD	(DE),A
        INC	DE
        POP	HL
        INC	HL
        INC	DE
        INC	DE
        PUSH	DE
        INC	DE
        LD	BC,12
        LDIR
        PUSH	DE
        EX	DE,HL
        LD	BC,-7
        ADD	HL,BC
        INC	(HL)
        JR	NZ,J0CA4
        INC	HL
        INC	(HL)
J0CA4:	EX	DE,HL
        POP	DE
        LD	B,08H	; 8 
        XOR	A
J0CA9:	LD	(DE),A
        INC	DE
        DJNZ	J0CA9
        POP	DE
        LDI
        LD	L,(IX+22)
        LD	H,(IX+23)
        DEC	HL			; number of clusters
        LD	B,(IX+11)
        JR	J0CBD

J0CBC:	ADD	HL,HL
J0CBD:	DJNZ	J0CBC
        LD	C,(IX+20)
        LD	B,(IX+21)
        ADD	HL,BC
        EX	DE,HL
        DEC	HL
        DEC	HL
        LD	(HL),D
        DEC	HL
        LD	(HL),E
        POP	DE
        XOR	A
        RET

;	  Subroutine _GETDTA
;	     Inputs  ________________________
;	     Outputs DE = transfer address

A0CCF:	LD	DE,(DTA_AD)
        XOR	A
        RET

;	  Subroutine _GETVFY
;	     Inputs  ________________________
;	     Outputs ________________________

A0CD5:	LD	A,(RAWFLG)
        OR	A
        JR	Z,J0CDD
        LD	A,0FFH
J0CDD:	LD	B,A
        XOR	A
        RET

;	  Subroutine _FLUSH
;	     Inputs  ________________________
;	     Outputs ________________________

A0CE0:	LD	A,B
        CP	0FFH
        JR	Z,J0CEB			; all drives
        CALL	C362C			; translate drive assigment and get pointer to drive tabel
        LD	B,A			; physical drive id
        LD	A,C			; error = invalid drive
        RET	Z			; invalid drive id, quit
J0CEB:	LD	A,B
        CALL	C2C68			; flush sector buffers of physical drive
        LD	A,D
        OR	A
        RET	Z			; flush only, quit
        LD	A,B			; drive id
        CALL	C2C78			; mark sector buffers of physical drive unused
        CALL	C3611			; disk change status of all drives to flushed
        XOR	A
        RET

;	  Subroutine _TERM0
;	     Inputs  ________________________
;	     Outputs ________________________

A0CFB:	LD	B,0

;	  Subroutine _TERM
;	     Inputs  ________________________
;	     Outputs ________________________

A0CFD:	LD	A,B
        LD	B,0
        CALL	C3749			; call program abort routine with TPA segments active
J0D03:	JR	J0D03			; loop to infinety

;	  Subroutine _ERROR
;	     Inputs  ________________________
;	     Outputs ________________________

A0D05:	LD	B,(IY+DBBFD-DBB80)      ; last BDOS errorcode
        XOR	A
        RET

;	  Subroutine _EXPLAIN
;	     Inputs  B = error code
;	     Outputs ________________________

A0D0A:	LD	A,B                     ; error code
        PUSH	DE
        PUSH	IY
        LD	IY,(MASTER-1)		; slot id master disk ROM
        LD	IX,($ERR_M)		; error message handler
        CALL	C001C                   ; call slot
        EI
        POP	IY
        LD	B,A
        OR	A                       ; built in explanation string ?
        DEC	HL
        CALL	NZ,C0D26                ; nope, convert byte number to string
        XOR	A
        LD	(HL),A                  ; end marker string
        POP	DE
        RET

;	  Subroutine convert byte number to string
;	     Inputs  A = number (0-99), HL = pointer to string
;	     Outputs ________________________

C0D26:	LD	C,-1
J0D28:	INC	C
        SUB	10
        JR	NC,J0D28
        ADD	A,'0'+10
        PUSH	AF                      ; store ASCII digit
        LD	A,C
        OR	A                       ; tens = 0 ?
        CALL	NZ,C0D26                ; nope, convert tens number to string
        POP	AF                      ; restore ASCII digit
        LD	(HL),A                  ; store ASCII digit
        INC	HL
        RET

;	  Subroutine _FORMAT
;	     Inputs  ________________________
;	     Outputs ________________________

A0D39:	EX	AF,AF'
        PUSH	HL
        POP	IX			; pointer to buffer
        LD	A,B
        CALL	C362C			; translate drive assigment and get pointer to drive tabel
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A
        OR	H			; drive table entry in use ?
        LD	A,C			; error = invalid drive
        RET	Z			; nope, quit
        EX	AF,AF'
        OR	A			; sub function = get format choice string ?
        JR	NZ,J0D58		; nope,
        CALL	C3031			; get format choice string
        PUSH	HL
        POP	IX
        LD	B,(IX+0)		; slot id
        EX	DE,HL
        OR	A			; Zx holds error flag
        RET

J0D58:	EX	AF,AF'
        CALL	C2C67			; flush sector buffers of drive table
        CALL	C2C77			; mark sector buffers of drive table unused
        PUSH	HL
J0D60:	PUSH	DE
        PUSH	IX
        POP	DE
        XOR	A			; segment type = TPA
        CALL	C274F			; get segment number
        LD	HL,04000H
        OR	A
        SBC	HL,DE
        EX	(SP),HL
        POP	BC
        SBC	HL,BC
        JR	C,J0D7E
        SBC	HL,BC
        JR	C,J0D81
        ADD	HL,BC
        EX	DE,HL
        ADD	IX,BC
        JR	J0D60

J0D7E:	ADD	HL,BC
        LD	B,H
        LD	C,L
J0D81:	SET	7,D
        PUSH	DE
        POP	IX
        LD	D,A
        EX	AF,AF'
        POP	HL
        CALL	C304E			; format disk
        LD	BC,9
        ADD	HL,BC			; +9
        LD	(HL),0			; disk change counter = initialize
        RET

;	  Subroutine _RAMD
;	     Inputs  ________________________
;	     Outputs ________________________

A0D93:	PUSH	BC			; store B parameter
        LD	B,8			; logical drive = ramdisk
        LD	D,B			; physical drive = ramdisk
        CALL	A0E8B			; assign
        POP	BC			; restore B parameter
        INC	B			; return ramdisk size ?
        JP	Z,J0E2D			; yep, return info
        DEC	B			; destroy ramdisk ?
        JP	Z,J0E04			; yep, destory ramdisk
        LD	HL,(IBA23+8*2)
        LD	A,H
        OR	L			; ramdisk already in use ?
        LD	C,.RAMDX
        JP	NZ,J0E2F		; yep, quit with ramdisk exists error

; create ramdisk

        CALL	C0E35			; clear ramdisk bootsector and ramdisk segment table
        LD	DE,IBE02		; ramdisk segment table
        LD	HL,DBE00
J0DB6:	EXX
        LD	A,1			; type = user
        LD	B,30H			; first other mappers, then DOS mapper
        CALL	C11A6			; allocate segment
        JR	C,J0DCA			; failed, stop allocating
        PUSH	BC			; store slot id
        EXX
        INC	(HL)			; increase number of ramdisk segments
        LD	(DE),A			; segment number
        INC	DE
        POP	AF			; restore slot id
        LD	(DE),A			; slot id mapper
        INC	DE
        DJNZ	J0DB6			; next segment
J0DCA:	LD	A,(DBE00)
        OR	A			; no ramdisk segments ?
        LD	A,C
        LD	C,.NORAM
        JP	Z,J0E2F			; yep, quit with no ramdisk error
        LD	HL,(DBBFB)		; pointer to drive table ramdisk
        LD	(IBA23+8*2),HL		; fill in H: drive table pointer
        LD	A,8			; drive id ramdisk
        PUSH	HL
        POP	IX
        LD	(IX+8),A		; drive id (1 based)
        LD	(IX+9),0		; driver drive id
        LD	(IX+30+1),0FFH		; starting cluster current directory = root directory
        LD	C,A			; store drive id
        LD	IX,IB9DA		; buffer
        LD	B,0			; type = for disk
        CALL	C31AB			; check disk change
        LD	A,0FFH			; media descriptor for ramdisk is 0FFH
        CALL	C2F38			; clear FAT
        LD	DE,0			; whole rootdirectory
        CALL	C2FC7			; clear directory
        CALL	C2C67			; flush sector buffers of drive table
        JR	J0E2D			; return info

; destroy ramdisk

J0E04:	LD	HL,(IBA23+8*2)
        LD	A,H
        OR	L			; was ramdisk in use ?
        JR	Z,J0E2D			; nope, return info
        LD	A,8			; drive id ramdisk
        CALL	C2C78			; mark sector buffers of physical drive unused
        LD	HL,0
        LD	(IBA23+8*2),HL		; drive H: not in use
        XOR	A
        LD	(DBE00),A		; no ramdisk segments
        LD	HL,IBE02		; ramdisk segment table
J0E1D:	LD	C,(HL)			; segment
        INC	HL
        LD	B,(HL)			; slot id mapper
        INC	HL
        LD	A,B
        OR	A			; end of table ?
        JR	Z,J0E2D			; yep, return info
        PUSH	HL
        LD	A,C
        CALL	C1256			; free segment
        POP	HL
        JR	J0E1D			; next segment

J0E2D:	LD	C,0			; no error
J0E2F:	LD	A,(DBE00)
        LD	B,A			; number of segments ramdisk
        LD	A,C			; error
        RET

;	  Subroutine clear ramdisk bootsector and ramdisk segment table
;	     Inputs  ________________________
;	     Outputs ________________________

C0E35:	LD	HL,IBC00
        LD	DE,512+2+255*2
J0E3B:	LD	(HL),0
        INC	HL
        DEC	DE
        LD	A,D
        OR	E
        JR	NZ,J0E3B
        RET

;	  Subroutine _BUFFER
;	     Inputs  ________________________
;	     Outputs ________________________

A0E44:	LD	A,B
        CP	2			; number of buffers >= 2 ?
        JR	C,J0E86			; nope, quit
J0E49:	LD	A,B
        CP	(IY+IBBFA-DBB80)	; same as current number of buffers ?
        JR	Z,J0E86			; yep, quit
        JR	NC,J0E6E		; more as current, allocate extra buffers
        LD	HL,(DBBF8)		; start of the sector buffer chain
        CALL	C2D2D			; flush sector buffer
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to next buffer
        DEC	HL
        LD	(DBBF8),DE		; update start of the sector buffer chain
        CALL	C022B			; free BDOS data block
        LD	HL,0
        LD	(DBBF6),HL		; no last FAT buffer read
        LD	HL,IBBFA
        DEC	(HL)			; update number of buffers
        JR	J0E49			; again

J0E6E:	LD	HL,512+11
        CALL	C01CB			; allocate BDOS data block
        JR	NZ,J0E86		; error, quit
        LD	DE,(DBBF8)		; start of the sector buffer chain
        LD	(DBBF8),HL		; update start of the sector buffer chain
        LD	(HL),E
        INC	HL
        LD	(HL),D			; pointer to next buffer
        LD	HL,IBBFA
        INC	(HL)			; update number of buffers
        JR	J0E49			; again

J0E86:	LD	B,(IY+IBBFA-DBB80)	; number of buffers
        XOR	A			; no error
        RET

;	  Subroutine _ASSIGN
;	     Inputs  ________________________
;	     Outputs ________________________

A0E8B:	LD	HL,IBA1A		; drive assignment table
        LD	A,B
        OR	A			; cancel assignments on all drives ?
        JR	Z,J0EAC			; yep,
        CP	8+1			; valid logical drive id ?
        LD	A,.IDRV
        RET	NC			; nope, quit
        LD	C,B
        LD	B,0
        ADD	HL,BC			; assignment entry, assume new physical drive id = logical drive id
        LD	A,D
        INC	A			; get current assignment ?
        JR	Z,J0EA9			; yep, return current assigment
        DEC	A			; cancel current assignment ?
        JR	Z,J0EA8			; yep, update assignment
        CP	8+1			; valid physical drive id ?
        LD	A,.IDRV
        RET	NC			; nope, quit
        LD	C,D			; new physical drive id
J0EA8:	LD	(HL),C
J0EA9:	LD	D,(HL)			; current assigment
        XOR	A			; no error
        RET

J0EAC:	LD	(HL),A			; reset assigment
        INC	HL
        INC	A
        CP	8+1			; more drive id's ?
        JR	NZ,J0EAC		; yep next drive id
        XOR	A			; no error
        LD	D,A			; physical drive id = 0
        RET

;	  Subroutine _DSKCHK
;	     Inputs  ________________________
;	     Outputs ________________________

A0EB6:	OR	A			; function = get ?
        JR	Z,J0EC2			; yep, return current setting
        LD	A,B
        OR	A			; new value = 0 ?
        JR	Z,J0EBF			; yep, disk check level = strong
        LD	A,0FFH			; disk check level = weak
J0EBF:	LD	(DSK_CHK),A		; set disk check level
J0EC2:	LD	A,(DSK_CHK)
        LD	B,A			; return disk check level
        XOR	A
        RET

;	  Subroutine _DOSVER
;	     Inputs  none
;	     Outputs ________________________

A0EC8:	LD	B,02H
        LD	C,31H			; version 2.31
        XOR	A
        LD	H,A
        LD	L,A			; ?
        LD	D,A
        LD	E,A			; MSXDOS system file version (set by MSXDOS BDOS handler)
        RET

;	  Subroutine _REDIR
;	     Inputs  ________________________
;	     Outputs ________________________

A0ED2:	LD	C,(IY+DBB89-DBB80)	; current console redirection status
        OR	A
        JR	Z,J0EDB
        LD	(IY+DBB89-DBB80),B	; update console redirection status
J0EDB:	LD	B,C
        XOR	A
        RET

;	  Subroutine _GENV
;	     Inputs  HL = pointer to environmentname, DE = pointer to buffer, B = size of buffer
;	     Outputs ________________________

A0EDE:	XOR	A			; segment type = TPA

;	  Subroutine get environment
;	     Inputs  A = segment type (0 = TPA, A<>0 = current)
;	     Outputs ________________________

C0EDF:	LD	(DBBED),A		; update segment type
        XOR	A			; do upcasing
        PUSH	BC
        CALL	C0FA2			; validate environment name
        POP	BC
        RET	NZ			; error, quit
        PUSH	DE
        PUSH	BC
        LD	DE,DBBEE		; start of environment chain
        CALL	C0F8B			; search for environment
        LD	DE,I0F76
        JR	NC,J0EF8		; not found, use empty string as value
        LD	D,B
        LD	E,C
J0EF8:	POP	BC
        POP	HL
        CALL	C0FC8			; copy environment value to buffer
        EX	DE,HL
        RET

;	  Subroutine _SENV
;	     Inputs  HL = pointer to environment name, DE = pointer to value
;	     Outputs ________________________

A0EFF:	XOR	A
        LD	(DBBED),A		; segment type = TPA
        XOR	A			; do upcasing
        CALL	C0FA2			; validate environment name
        RET	NZ			; error, quit
        LD	A,B
        OR	A
        RET	Z			; empty string, quit
        EX	AF,AF'
        EX	DE,HL
        LD	A,0FFH			; no upcasing
        CALL	C0FA2			; validate environment value
        RET	NZ			; error, quit
        LD	A,B
        OR	A
        JR	Z,J0F46			; empty value, kill environment
        EX	AF,AF'
        ADD	A,B
        LD	C,A
        LD	A,0
        ADC	A,A
        LD	B,A			; bc = totalsize (name+value)
        PUSH	HL
        LD	HL,4
        ADD	HL,BC			; 2 extra bytes for pointer, 2 extra bytes for 2 endmarkers
        CALL	C01CB			; allocate BDOS data block
        POP	BC
        RET	NZ			; failed, quit
        PUSH	BC
        LD	BC,(DBBEE)
        LD	(DBBEE),HL		; new element in chain
        LD	(HL),C
        INC	HL
        LD	(HL),B			; which points to rest of the chain
        INC	HL
        EX	DE,HL
        XOR	A			; do upcasing
        CALL	C0FDF			; copy environmentname to environment
        EX	(SP),HL
        LD	A,0FFH			; no upcasing
        CALL	C0FDF			; copy environmentvalue to environment
        POP	HL
        LD	DE,(DBBEE)
        JR	J0F4A			; kill old version of environment if exists

J0F46:	EX	DE,HL
        LD	DE,DBBEE		; start of environment chain
J0F4A:	CALL	C0F8B			; search for environment
        LD	HL,DBBEE		; start or environment chain
        CALL	C,C2192			; found, remove element from chain
        XOR	A
        RET

;	  Subroutine _FENV
;	     Inputs  DE = environment number, HL = pointer to buffer, B = size of buffer
;	     Outputs ________________________

A0F55:	XOR	A
        LD	(DBBED),A		; segment type = TPA
        PUSH	HL
        PUSH	BC
        LD	B,D
        LD	C,E
        LD	HL,(DBBEE)		; start of environment chain
J0F60:	LD	A,H
        OR	L			; end of chain ?
        LD	DE,I0F76
        JR	Z,J0F71			; yep, use empty string
        LD	E,(HL)
        INC	HL
        LD	D,(HL)
        INC	HL
        EX	DE,HL			; pointer to next item in chain
        DEC	BC
        LD	A,B
        OR	C			; requested environmentnumber found ?
        JR	NZ,J0F60		; nope, continue
J0F71:	POP	BC
        POP	HL
        JP	C0FC8			; copy environmentname to buffer

I0F76:	DEFW	0


	IF	OPTM EQ 1

;	  Subroutine 
;	     Inputs  ________________________
;	     Outputs 
;	     Remark  UNUSED CODE

        LD	HL,(DBBEE)
J0F7B:	LD	A,H
        OR	L
        RET	Z
        LD	E,(HL)
        INC	HL
        LD	D,(HL)
        DEC	HL
        CALL	C022B			; free BDOS data block
        EX	DE,HL
        LD	(DBBEE),HL
        JR	J0F7B

	ENDIF


;	  Subroutine search for environment
;	     Inputs  ________________________
;	     Outputs Cx set if found

C0F8B:	EX	DE,HL
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A
        OR	H
        EX	DE,HL
        RET	Z
        PUSH	DE
        PUSH	HL
        INC	DE
        INC	DE
        CALL	C0FF1			; check if environment
        LD	B,D
        LD	C,E
        POP	HL
        POP	DE
        JR	NZ,C0F8B
        SCF
        RET

;	  Subroutine validate environment string
;	     Inputs  ________________________
;	     Outputs ________________________

C0FA2:	PUSH	HL
        AND	01H
        LD	C,A			; upcasing flag
        LD	B,255
J0FA8:	CALL	C1003			; read byte (environment)
        INC	HL
        CALL	C17AE			; check character
        JR	Z,J0FC1			; end marker,
        BIT	0,C			; supress upcasing ?
        JR	NZ,J0FBB		; yep, skip illegal check
        BIT	4,C			; illegal character ?
        LD	A,.IENV
        JR	NZ,J0FC5		; yep, quit with illegal environment error
J0FBB:	DJNZ	J0FA8
        LD	A,.ELONG
        JR	J0FC5			; more as 255 characters, quit with environment too long error

J0FC1:	DEC	A			; 255
        SUB	B
        LD	B,A			; size of string
        XOR	A			; no error
J0FC5:	POP	HL
        OR	A			; Zx = error flag
        RET

;	  Subroutine copy from environment to buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C0FC8:	PUSH	HL
        PUSH	DE
J0FCA:	LD	A,B
        DEC	B
        OR	A
        LD	A,.ELONG
        JR	Z,J0FDB
        LD	A,(DE)
        CALL	C1012			; write byte (environment)
        INC	HL
        LD	A,(DE)
        INC	DE
        OR	A
        JR	NZ,J0FCA
J0FDB:	POP	DE
        POP	HL
        OR	A			; update Zx flag
        RET

;	  Subroutine copy from buffer to environment
;	     Inputs  ________________________
;	     Outputs ________________________

C0FDF:	PUSH	HL
        AND	01H
        LD	C,A
J0FE3:	CALL	C1003			; read byte (environment)
        INC	HL
        CALL	C17AE			; check character
        LD	(DE),A
        INC	DE
        OR	A
        JR	NZ,J0FE3
        POP	HL
        RET

;	  Subroutine check if environment
;	     Inputs  ________________________
;	     Outputs ________________________

C0FF1:	LD	C,0
J0FF3:	CALL	C1003			; read byte (environment)
        INC	HL
        CALL	C17AE			; check character
        LD	B,A
        LD	A,(DE)
        INC	DE
        CP	B
        RET	NZ
        OR	A
        JR	NZ,J0FF3
        RET

;	  Subroutine read byte (environment)
;	     Inputs  ________________________
;	     Outputs ________________________

C1003:	PUSH	HL
        EX	DE,HL
        LD	A,(DBBED)		; segment type
        CALL	C274F			; get segment number
        EX	DE,HL
        CALL	RD_SEG			; RD_SEG
        EI
        POP	HL
        RET

;	  Subroutine write byte (environment)
;	     Inputs  ________________________
;	     Outputs ________________________

C1012:	PUSH	HL
        PUSH	DE
        LD	E,A
        EX	DE,HL
        LD	A,(DBBED)		; segment type
        CALL	C274F			; get segment number
        EX	DE,HL
        CALL	WR_SEG			; WR_SEG
        EI
        POP	DE
        POP	HL
        RET

;	  Subroutine _GDATE
;	     Inputs  ________________________
;	     Outputs ________________________

A1024:	CALL	C111B			; read time and date from real time clock
        LD	C,D
        LD	B,0			; year
        LD	E,L			; day
        LD	D,H			; month
        LD	HL,1980
        ADD	HL,BC			; offset year to absolute year
        LD	A,D
        CP	03H
        LD	A,C
        SBC	A,0FCH
        AND	0FCH
        RRCA
        RRCA
        ADD	A,C
        PUSH	HL
        LD	HL,I104D-1
        LD	C,D
        ADD	HL,BC
        ADD	A,(HL)
        POP	HL
        ADD	A,E
J1044:	SUB	07H
        JR	NC,J1044
        ADD	A,07H
        LD	C,A
        XOR	A
        RET

I104D:	defb	1,4,4,7,9,12,14,17,20,22,25,27

;	  Subroutine _SDATE
;	     Inputs  ________________________
;	     Outputs ________________________

A1059:	LD	BC,-1980
        ADD	HL,BC			; valid year (>=1980) ?
        JR	NC,J1091		; nope,
        LD	A,H
        OR	A			; valid year (<2080) ?
        JR	NZ,J1091		; nope,
        LD	A,L
        CP	100			; valid year (<2080) ?
        JR	NC,J1091		; nope,
        LD	B,A			; store offset to 1980
        LD	A,D
        DEC	A
        CP	12			; valid month (1-12) ?
        JR	NC,J1091		; nope,
        LD	HL,I1096
        ADD	A,L
        LD	L,A
        JR	NC,J1077
        INC	H
J1077:	CP	LOW I1096+1		; februari ?
        JR	NZ,J1083		; nope, skip leap year update
        LD	A,B
        AND	03H			; leap year ?
        JR	NZ,J1083		; nope,
        LD	HL,I10A2		; use 29 days
J1083:	LD	A,E
        DEC	A
        CP	(HL)			; valid day ?
        JR	NC,J1091		; nope,
        LD	L,E			; store day
        LD	H,D			; store month
        LD	D,B			; store year (offset to 1980)
        CALL	C1167			; write year,month and day to real time clock
        XOR	A
        LD	C,A
        RET

J1091:	LD	C,0FFH
        LD	A,.IDATE
        RET

I1096:	defb	31,28,31,30,31,30,31,31,30,31,30,31
I10A2:	defb	29

;	  Subroutine _GTIME
;	     Inputs  ________________________
;	     Outputs ________________________

A10A3:	CALL	C111B			; read time and date from real time clock
        LD	H,B			; hour
        LD	L,C			; minute
        LD	D,E			; seconds
        LD	E,0			; milliseconds = 0
        XOR	A
        RET

;	  Subroutine _STIME
;	     Inputs  ________________________
;	     Outputs ________________________

A10AD:	LD	A,H
        CP	24			; valid hour ?
        JR	NC,J10C5		; nope,
        LD	A,L
        CP	60			; valid minute ?
        JR	NC,J10C5		; nope,
        LD	A,D
        CP	60			; valid seconds ?
        JR	NC,J10C5		; nope,
        LD	B,H			; hour
        LD	C,L			; minute
        LD	E,D			; second
        CALL	C1155			; write hour,minute and second to real time clock
        XOR	A
        LD	C,A
        RET

J10C5:	LD	C,0FFH
        LD	A,.ITIME
        RET

;	  Subroutine initialize clockchip
;	     Inputs  ________________________
;	     Outputs ________________________

C10CA:	LD	A,13
        OUT	(0B4H),A		; select register 13
        IN	A,(0B5H)
        AND	04H
        LD	B,A
        INC	A
        OUT	(0B5H),A		; pause real time clock, select bank 1
        LD	A,10
        OUT	(0B4H),A
        LD	A,1
        OUT	(0B5H),A		; 24 hour mode
        LD	A,13
        OUT	(0B4H),A
        LD	A,B
        OUT	(0B5H),A		; pause real time clock, select bank 0
        LD	BC,13*256+0
J10E8:	LD	A,C
        OUT	(0B4H),A		; select register
        IN	A,(0B5H)
        PUSH	AF			; read register and store value
        INC	C
        DJNZ	J10E8			; next register
        LD	A,14
        OUT	(0B4H),A
        LD	A,0
        OUT	(0B5H),A		; reset TEST bits
        LD	B,13
J10FB:	DEC	C
        POP	DE			; restore value
        LD	A,C
        OUT	(0B4H),A		; select register
        LD	A,D
        OUT	(0B5H),A		; restore register
        DJNZ	J10FB			; next register

;	  Subroutine resume real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

J1105:	LD	A,13
        OUT	(0B4H),A
        IN	A,(0B5H)
        OR	08H
        OUT	(0B5H),A
        RET

;	  Subroutine pause real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

C1110:	LD	A,13
        OUT	(0B4H),A		; select RP-501 register 13
        IN	A,(0B5H)
        AND	04H
        OUT	(0B5H),A		; clear running flag
        RET

;	  Subroutine read time and date from real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

C111B:	CALL	C1110			; pause real time clock
        LD	E,12+1			; register = 12
        CALL	C113C			; read byte from real time clock
        LD	D,A			; year
        CALL	C113C			; read byte from real time clock
        LD	H,A			; month
        CALL	C113C			; read byte from real time clock
        LD	L,A			; day
        DEC	E			; register = 6
        CALL	C113C			; read byte from real time clock
        LD	B,A			; hour
        CALL	C113C			; read byte from real time clock
        LD	C,A			; minute
        CALL	C113C			; read byte from real time clock
        LD	E,A			; second
        JP	J1105			; resume real time clock

;	  Subroutine read byte (BCD) from real time clock
;	     Inputs  E = register+1
;	     Outputs E = register-1

C113C:	PUSH	BC
        CALL	C114C			; read nibble from real time clock
        LD	B,A
        ADD	A,A
        ADD	A,A			; *4
        ADD	A,B			; *5
        ADD	A,A			; *10
        LD	B,A
        CALL	C114C			; read nibble from real time clock
        ADD	A,B
        POP	BC
        RET

;	  Subroutine read nibble from real time clock
;	     Inputs  E = register+1
;	     Outputs E = register

C114C:	DEC	E
        LD	A,E
        OUT	(0B4H),A
        IN	A,(0B5H)
        AND	0FH
        RET

;	  Subroutine write hour,minute and second to real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

C1155:	LD	L,E			; second
        LD	H,C			; minute
        LD	D,B			; hour
        CALL	C1110			; pause real time clock
        LD	A,15
        OUT	(0B4H),A		; select register 15
        LD	A,02H
        OUT	(0B5H),A		; reset divider stages
        LD	E,0			; register = 0
        JR	J117D

;	  Subroutine write year,month and day to real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

C1167:	CALL	C1110			; pause real time clock
        OR	01H
        OUT	(0B5H),A		; select bank 1
        LD	A,11
        OUT	(0B4H),A		; select register 11
        LD	A,D
        OUT	(0B5H),A		; write year to real time clock
        CALL	C1110			; pause real time clock
        CALL	C1110			; pause real time clock
        LD	E,7			; register = 7

J117D:	LD	A,L			; day/second
        CALL	C118C			; convert byte to BCD and write to real time clock
        LD	A,H			; month/minute
        CALL	C118C			; convert byte to BCD and write to real time clock
	LD	A,D			; year/hour
        CALL	C118C			; convert byte to BCD and write to real time clock
        JP	J1105			; resume real time clock

;	  Subroutine convert byte to BCD and write to real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

C118C:	LD	C,A
        XOR	A
        LD	B,8
J1190:	RLC	C
        ADC	A,A
        DAA
        DJNZ	J1190
        CALL	C119D			; write nibble to real time clock
        RRCA
        RRCA
        RRCA
        RRCA

;	  Subroutine write nibble to real time clock
;	     Inputs  ________________________
;	     Outputs ________________________

C119D:	LD	B,A
        LD	A,E
        OUT	(0B4H),A
        LD	A,B
        OUT	(0B5H),A
        INC	E
        RET

;	  Subroutine ALLSEG
;	     Inputs  ________________________
;	     Outputs ________________________

C11A6:	OR	A			; user segment ?
        LD	A,(DBBFE)
        JR	Z,J11AE			; yep, use owner = proces id
        LD	A,0FFH			; owner = system
J11AE:	EX	AF,AF'
        LD	C,B
        LD	A,C
        AND	8FH			; slot id mapper specified ?
        JR	NZ,J11BA
        LD	A,(RAMAD3)		; no, use disksystem (primary) mapper
        OR	C
        LD	C,A			; combine with allocation strategy
J11BA:	LD	A,C
        AND	70H
        JR	NZ,J11C1
        JR	C1206			; allocate segment of the specfied slot and quit

J11C1:	LD	B,C
        CP	20H
        JR	NZ,J11CB
        CALL	C1206			; allocate segment of the specfied slot
        JR	NC,J11FF		; succeeded, finish
J11CB:	XOR	A
        LD	HL,EXPTBL
J11CF:	BIT	7,(HL)
        JR	Z,J11D5
        SET	7,A
J11D5:	LD	C,A
        XOR	B
        AND	8FH
        JR	Z,J11E2			; skip the slot if it is the specified slot
        PUSH	HL
        CALL	C1206			; allocate segment of current slot
        POP	HL
        JR	NC,J11FF		; succeeded, finish
J11E2:	LD	A,C
        BIT	7,A
        JR	Z,J11ED
        ADD	A,04H
        BIT	4,A
        JR	Z,J11D5
J11ED:	INC	HL
        INC	A
        AND	03H
        JR	NZ,J11CF		; next slot
        LD	A,B
        AND	70H
        CP	30H			; first others, next specified strategy ?
        SCF
        JR	NZ,J11FF		; no, quit with error
        LD	C,B
        CALL	C1206			; allocate segment of the specfied slot
J11FF:	PUSH	AF
        LD	A,C
        AND	8FH
        LD	B,A
        POP	AF
        RET

;	  Subroutine allocate segment of the specified slot
;	     Inputs  ________________________
;	     Outputs ________________________

C1206:	PUSH	BC
        LD	A,C
        AND	0FH			; slot
        ADD	A,A
        ADD	A,A
        LD	E,A
        LD	D,0
        LD	HL,IBA35
        ADD	HL,DE
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; memory mapper info table
        INC	HL
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A
        OR	H			; memory mapper segment table available (memory mapper in specified slot) ?
        JR	Z,J1253			; no, quit with error
        LD	A,(DE)
        INC	DE
        LD	C,A			; number of segments in mapper
        EX	AF,AF'
        LD	B,A			; owner
        EX	AF,AF'
        INC	B
        JR	Z,J123B			; system, allocate from high to low
        LD	B,0			; current segment number
J1229:	LD	A,(HL)
        OR	A			; free segment ?
        JR	Z,J1234			; yep, allocate
        INC	B
        INC	HL
        DEC	C
        JR	NZ,J1229		; try next
        JR	J1253			; none left, quit with error

J1234:	EX	DE,HL
        DEC	(HL)			; decrease number of free segments
        INC	HL
        INC	HL
        INC	(HL)			; increase number of allocated user segments
        JR	J124C			; flag allocated

J123B:	ADD	HL,BC			; to the end of the segment table
J123C:	DEC	HL
        LD	A,(HL)
        OR	A			; free segment ?
        JR	Z,J1246			; yep, allocate
        DEC	C
        JR	NZ,J123C		; try next
        JR	J1253			; none left, quit with error

J1246:	LD	B,C
        DEC	B
        EX	DE,HL
        DEC	(HL)			; decrease number of free segments
        INC	HL
        INC	(HL)			; increase number of allocated system segments
J124C:	EX	AF,AF'
        LD	(DE),A			; owner (also flags allocated)
        EX	AF,AF'
        LD	A,B
        POP	BC
        OR	A
        RET

J1253:	POP	BC
        SCF
        RET

;	  Subroutine FRESEG
;	     Inputs  ________________________
;	     Outputs ________________________

C1256:	LD	C,A
        LD	A,B
        AND	8FH
        JR	NZ,J125F
        LD	A,(RAMAD3)
J125F:	AND	0FH
        ADD	A,A
        ADD	A,A
        LD	E,A
        LD	D,00H
        LD	HL,IBA35
        ADD	HL,DE
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; memory mapper info table
        INC	HL
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A
        OR	H			; memory mapper segment table available (memory mapper in specified slot) ?
        JR	Z,J128E			; nope, quit with error
        LD	A,(DE)
        CP	C
        JR	C,J128E
        JR	Z,J128E
        LD	B,00H
        ADD	HL,BC
        LD	A,(HL)
        OR	A
        JR	Z,J128E
        LD	(HL),B
        EX	DE,HL
        INC	HL
        INC	(HL)
        INC	HL
        INC	A
        JR	Z,J128B
        INC	HL
J128B:	DEC	(HL)
        OR	A
        RET

J128E:	SCF
        RET

;	  Subroutine free user segments
;	     Inputs  B = proces id
;	     Outputs ________________________

C1290:	LD	C,16			; mapper count = 16
        LD	HL,IBA35
J1295:	LD	E,(HL)
        INC	HL
        LD	D,(HL)			; memory mapper info table
        PUSH	DE			; store pointer to memory mapper info table
        INC	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; memory mapper segment table
        INC	HL
        EX	(SP),HL			; store pointer in, restore pointer to memory mapper info table
        LD	A,H
        OR	L			; memory mapper in slot ?
        JR	Z,J12BE			; nope, skip to next slot
        PUSH	BC			; store mapper count
        LD	C,(HL)			; segment count = number of segments
J12A5:	LD	A,(DE)
        INC	A			; segment = system reserved ?
        JR	Z,J12B9			; yep, skip
        DEC	A			; segment = free ?
        JR	Z,J12B9			; yep, skip
        DEC	A
        CP	B			; segment is user reserved and belongs to this proces or child proces ?
        JR	C,J12B9			; nope, skip
        PUSH	HL			; store pointer
        XOR	A
        LD	(DE),A			; free segment
        INC	HL
        INC	(HL)			; update number of free segments
        INC	HL
        INC	HL
        DEC	(HL)			; update number of reserved segments
        POP	HL			; restore pointer
J12B9:	INC	DE
        DEC	C
        JR	NZ,J12A5		; next segment
        POP	BC			; restore mapper count
J12BE:	POP	HL			; restore pointer
        DEC	C
        JR	NZ,J1295		; next slot
        RET

;	  Subroutine parse path
;	     Inputs  A = drive id, C = parse flag, B = attributes
;	     Outputs ________________________

C12C3:	LD	(IX+0),0FFH		; FIB indentifier
        LD	(IX+31),B		; update request attribute
        LD	(IY+DBBA0-DBB80),C	; store parse flags
        LD	(DBB9E),DE		; pointer in parse string = start of parse string
        OR	A			; current drive ?
        JR	NZ,J12D7
        LD	A,(CUR_DRV)		; yep, use drive id current drive
J12D7:	LD	D,A			; store drive id
        CALL	C13BC			; try to parse drive indicator
        OR	A
        JR	Z,J12E9			; no drive specfied, use parameter
        CP	D
        JR	Z,J12E9			; same as parameter,
        LD	D,A
        BIT	7,(IY+DBBA0-DBB80)
        LD	A,.IDRV
        RET	NZ
J12E9:	LD	(IX+25),D		; update logical drive id
        BIT	3,(IX+31)		; parse a volume name ?
        JR	NZ,J12FF		; yep, skip pathcheck
        CALL	C1782			; get parse string character
        JR	Z,J1304			; end of parse string,
        CP	"\"
        JR	NZ,J1304		; no absolute path, undo get and continue
        SET	0,B			; flag characters parsed other than drive name
        SET	1,B			; flag directorypath specified
J12FF:	SET	5,(IY+DBBA0-DBB80)
        XOR	A			; no undo
J1304:	CALL	NZ,C179C		; undo, undo get parse string character
        LD	DE,(DBB9E)		; pointer in parse string
        LD	(DBB9C),DE		; update pointer to last item in parse string
        CALL	C16BC			; initialize whole path buffer
        BIT	3,(IX+31)		; parse a volume name ?
        JR	Z,J1320			; nope,
        LD	DE,IB926		; file name buffer
        CALL	C13E9			; parse volume name
        JR	J1391

J1320:	LD	DE,IB926		; file name buffer
        CALL	C13FF			; parse file name
        CP	"\"
        JR	NZ,J1366
        SET	1,B			; flag any directory path specified
        CALL	C1782			; get parse string character
        LD	DE,(DBB9E)		; pointer in parse string
        LD	(DBB9C),DE		; update pointer to last item in parse string
        LD	DE,IB926		; file name buffer
        CALL	C14CB			; next item
        JR	NZ,J13A6
        LD	DE,IB926		; file name buffer
        CALL	C16E7			; add item to whole path buffer
        JR	Z,J1320
        JR	J13A6

;	  Subroutine parse file name
;	     Inputs  C = parse flags, B = attributes
;	     Outputs ________________________

C1349:	LD	(IX+0),0FFH		; FIB identifier
        LD	(IX+31),B		; update request attribute
        LD	(IX+25),A		; update logical drive id
        LD	(IY+DBBA0-DBB80),C	; store parse flags
        LD	(DBB9E),DE		; pointer in parse string = start of parse string
        LD	(DBB9C),DE		; pointer to last item in parse string = start of parse string
        LD	B,0			; reset parse flags
        LD	DE,IB926		; file name buffer
        CALL	C13FF			; parse file name
J1366:	LD	A,B
        AND	18H
        JR	NZ,J1383		; file name or fileextension specified,
        BIT	1,(IY+DBBA0-DBB80)
        JR	Z,J1383
        PUSH	HL
        PUSH	BC
        LD	HL,I13B1
        LD	DE,IB926		; file name buffer
        LD	BC,11
        LDIR				; use *.* as file name/extension
        POP	AF
        OR	39H
        LD	B,A			; flag file name specfied, extension specfied, last item ambiguous
        POP	HL
J1383:	XOR	A
        BIT	0,(IY+DBBA0-DBB80)
        LD	DE,IB926		; file name buffer
        CALL	Z,C14F4			; check if device and get device flags
        OR	A
        JR	NZ,J139D		; it is a device,
J1391:	SET	4,(IY+DBBA0-DBB80)
        LD	DE,IB926		; file name buffer
        CALL	C14CB			; next item
        JR	NZ,J13A6
J139D:	LD	(IX+30),A		; update device flags
        LD	DE,IB926		; file name buffer
        CALL	C16E7			; add item to whole path buffer
J13A6:	PUSH	AF
        CALL	C1782			; get parse string character
        CALL	NZ,C179C		; not end of parse string, undo get parse string character
        LD	C,A			; character 
        POP	AF
        OR	A			; update Zx flag
        RET

I13B1:	defb	"???????????"

;	  Subroutine try to parse drive indicator
;	     Inputs  ________________________
;	     Outputs ________________________

C13BC:	LD	(IY+DBBA1-DBB80),00H	; reset parse string character flags
        CALL	C1782			; get parse string character
        JR	Z,J13E6			; end of parse string, quit
        BIT	1,(IY+DBBA1-DBB80)
        JR	NZ,J13E3		; 1st double byte character, undo get and quit
        SUB	"A"
        JR	C,J13E3			; not a driveletter, undo get and quit
        CP	1AH
        JR	NC,J13E3		; not a driveletter, undo get and quit
        INC	A
        LD	B,A
        CALL	C1782			; get parse string character
        JR	Z,J13E3			; end of parse string, no drive specifier
        CP	":"			; driveletter seperator ?
        LD	A,B			; drive id
        LD	B,04H
        RET	Z			; yep, flag driveindicator found
        CALL	C179C			; undo get parse string characters
J13E3:	CALL	C179C			; undo get parse string characters
J13E6:	XOR	A
        LD	B,A
        RET

;	  Subroutine parse volume name
;	     Inputs  ________________________
;	     Outputs ________________________

C13E9:	PUSH	HL
        EX	DE,HL
        LD	A,B
        AND	07H
        LD	B,A
        LD	(IY+DBBA1-DBB80),09H	; supress upcasing, volume name
        LD	C,0BH
        CALL	C146C			; parse name
        DEC	D
        JR	NZ,J13FD
        SET	3,B
J13FD:	POP	HL
        RET

;	  Subroutine parse file name
;	     Inputs  ________________________
;	     Outputs ________________________

C13FF:	PUSH	HL
        EX	DE,HL
        LD	A,B
        AND	07H			; reset parse flags
        LD	B,A
        LD	(IY+DBBA1-DBB80),00H	; reset parse string characters flags
        LD	C,8
        CALL	C1782			; get parse string character
        JR	Z,J1454
        CP	"."
        JR	NZ,J1451
        LD	D,1			; D=1
        CALL	C1782			; get parse string character
        JR	Z,J143A			; end of string,
        BIT	4,(IY+DBBA1-DBB80)
        JR	Z,J144E			; not a invalid character,
        CP	"."
        JR	NZ,J1437
        SET	7,B			; flag last item is ..
        INC	D			; D=2
        CALL	C1782			; get parse string character
        JR	Z,J143A			; end of string
        BIT	4,(IY+DBBA1-DBB80)
        JR	Z,J1449			; not a invalid character,
        CP	"."
        JR	Z,J1449			; ..., not a relative path
J1437:	CALL	C179C			; undo get parse string character
J143A:	LD	(HL),"."
        INC	HL
        DEC	C
        DEC	D
        JR	NZ,J143A
        SET	6,B			; flag last item is . or ..
        SET	3,B			; flag main file name is specified
        SET	0,B			; flag parse any other chat than drive specifier
        JR	J1454

J1449:	RES	7,B
        CALL	C179C			; undo get parse string character
J144E:	CALL	C179C			; undo get parse string character
J1451:	CALL	C179C			; undo get parse string character
J1454:	CALL	C146C			; parse name
        DEC	D
        JR	NZ,J145C
        SET	3,B			; flag main file name is specified
J145C:	CP	"."
        JR	NZ,J1465
        SET	4,B			; flag extention file name is specified
        CALL	C1782			; get parse string character
J1465:	LD	C,3
        CALL	C146C			; parse name
        POP	HL
        RET

;	  Subroutine parse name
;	     Inputs  ________________________
;	     Outputs ________________________

C146C:	LD	D,0
        INC	C
        CALL	C1782			; get parse string character
        JR	Z,J14C4
        CALL	C179C			; undo get parse string character
        CP	" "
        JR	Z,J14C4
        DEC	C
J147C:	INC	C
J147D:	CALL	C1782			; get parse string character
        JR	Z,J14C4
        BIT	1,(IY+DBBA1-DBB80)
        JR	Z,J1490			; not the 1st double byte character
        DEC	C
        DEC	C
        JR	NZ,J148E
        LD	A," "
J148E:	INC	C
        INC	C
J1490:	BIT	4,(IY+DBBA1-DBB80)
        JR	NZ,J14C1		; invalid character,
        BIT	3,(IY+DBBA1-DBB80)
        JR	NZ,J14AC		; volume name,
        BIT	2,(IY+DBBA1-DBB80)
        JR	NZ,J14AC		; 2nd double byte character,
        CP	"*"
        JR	Z,J14B7
        CP	"?"
        JR	NZ,J14AC
J14AA:	SET	5,B			; flag last item ambiguous
J14AC:	SET	0,B			; flag parse any other chat than drive specifier
        LD	D,1
        DEC	C
        JR	Z,J147C
        LD	(HL),A
        INC	HL
        JR	J147D

J14B7:	LD	A,C
J14B8:	LD	C,A
        DEC	A
        JR	Z,J14AA
        LD	(HL),"?"
        INC	HL
        JR	J14B8

J14C1:	CALL	C179C			; undo get parse string character
J14C4:	DEC	C
        RET	Z
        LD	(HL)," "
        INC	HL
        JR	J14C4

;	  Subroutine next item
;	     Inputs  ________________________
;	     Outputs ________________________

C14CB:	XOR	A
        BIT	3,(IY+DBBA0-DBB80)
        RET	Z
        PUSH	DE
        BIT	6,(IY+DBBA0-DBB80)
        SET	6,(IY+DBBA0-DBB80)
        CALL	Z,C151A			; first directory
        POP	DE
        OR	A
        RET	NZ
        BIT	4,(IY+DBBA0-DBB80)
        JR	Z,J14EF
        BIT	0,(IY+DBBA0-DBB80)
        RET	Z
        LD	A,B
        AND	18H
        RET	Z
J14EF:	CALL	C15A6			; next directory
        OR	A
        RET

;	  Subroutine check if device and get device flags
;	     Inputs  ________________________
;	     Outputs A = device flags

C14F4:	PUSH	BC
        PUSH	HL
        CALL	C1698			; check if devicename
        LD	A,0			; clear device flags
        JR	NC,J1517		; nope, quit
        POP	AF			; dispose
        LD	(IX+26),L
        LD	(IX+27),H		; device entry pointer
        PUSH	HL			; store pointer to device block

	IF	OPTM EQ 0
        LD	BC,0			;
        ADD	HL,BC			; Unneeded instructions
	ENDIF

        LD	C,(HL)
        INC	HL
        LD	B,(HL)			; pointer to device jump table
        LD	(IX+28),C
        LD	(IX+29),B		; pointer to device jump table
        LD	BC,7
        ADD	HL,BC
        LD	A,(HL)			; device flags
J1517:	POP	HL
        POP	BC
        RET

;	  Subroutine first directory
;	     Inputs  ________________________
;	     Outputs ________________________

C151A:	PUSH	BC
        LD	C,(IX+25)		; logical drive id
        LD	B,0			; type = for disk
        CALL	C31AB			; check disk change
        POP	BC
        OR	A			; error ?
        RET	NZ			; yep, quit
        PUSH	BC
        PUSH	HL
        BIT	5,(IY+DBBA0-DBB80)
        JR	NZ,J1597
        LD	DE,30
        ADD	HL,DE
        LD	E,(HL)
        INC	HL
        LD	D,(HL)
        BIT	7,D
        JR	NZ,J1597
        LD	BC,(DBB9E)		; pointer in parse string
        PUSH	BC
        PUSH	HL
        LD	A,D
        OR	E
        JR	Z,J1547
        RES	3,(IY+DBBA0-DBB80)
J1547:	INC	HL
        LD	(DBB9E),HL		; update pointer in parse string
        LD	BC,-32
        ADD	HL,BC
        PUSH	DE
        CALL	C159F			; initialize whole path buffer and select root directory
        POP	DE
        LD	B,0			; reset parse flags
J1556:	PUSH	DE
        LD	DE,IB910		; buffer
        CALL	C13FF			; parse file name
        BIT	3,(IY+DBBA0-DBB80)
        JR	Z,J156E
        LD	DE,IB910		; buffer
        CALL	C15A6			; next directory
        OR	A
        JR	NZ,J157E
        POP	AF
        PUSH	DE
J156E:	LD	DE,IB910		; buffer
        CALL	C16E7			; add item to whole path buffer
        JR	NZ,J157E
        POP	DE
        CALL	C1782			; get parse string character
        JR	NZ,J1556
        JR	J1582

J157E:	POP	DE
        LD	DE,0FFFFH
J1582:	POP	HL
        LD	(HL),D
        DEC	HL
        LD	(HL),E
        POP	BC
        LD	(DBB9E),BC		; update pointer in parse string
        SET	3,(IY+DBBA0-DBB80)
        BIT	7,D
        JR	Z,J1597
        INC	HL
        INC	HL
        LD	(HL),0
J1597:	POP	HL
        POP	BC

	IF	OPTM EQ 0

        JR	NZ,C159F		; ,initialize whole path buffer and select root directory
        CALL	C1C4A			; select sub directory (cluster number)
        RET

	ELSE

	JP	Z,C1C4A			; select sub directory (cluster number)

	ENDIF

;	  Subroutine initialize whole path buffer and select root directory
;	     Inputs  ________________________
;	     Outputs ________________________

C159F:	CALL	C16BC			; initialize whole path buffer

	IF	OPTM EQ 0

        CALL	C1C47			; select root directory
        RET
	
	ELSE

	JP	C1C47			; select root directory
	
	ENDIF

;	  Subroutine next directory
;	     Inputs  ________________________
;	     Outputs ________________________

C15A6:	LD	A,.IPATH
        BIT	3,B
        RET	Z
        BIT	5,B
        RET	NZ
        PUSH	DE
        CALL	C1C5D			; get first directory entry
J15B2:	JR	Z,J15C9			; unused directory entry found, not need to search futher
        EX	(SP),HL
        PUSH	HL
        PUSH	BC
        XOR	A			; do not search volume name directory entry
        CALL	C15D2			; does directory entry match the search ?
        POP	BC
        POP	HL
        EX	(SP),HL
        JR	NC,J15C4		; nope, next
        BIT	4,A
        JR	NZ,J15CD		; directory,
J15C4:	CALL	C1C94			; get next directory entry
        JR	NC,J15B2		; there is, try that one
J15C9:	POP	DE
        LD	A,.NODIR		; "directory not found" error
        RET

J15CD:	POP	AF

	IF	OPTM EQ 0

        CALL	C1C3A			; select sub directory
        RET

	ELSE

	JP	C1C3A			; select sub directory

	ENDIF

;	  Subroutine does directory entry match the search
;	     Inputs  DE = pointer to directory entry, HL = pointer to searchstring, A(b3) = volume
;	     Outputs Cx set if match, Zx set if free entry or matched

C15D2:	AND	08H
        LD	C,A			; set volume bit of character flag
        LD	A,(DE)
        OR	A
        RET	Z			; unused directory entry, quit
        CP	0E5H
        RET	Z			; deleted file directory entry, quit
        PUSH	DE
        LD	B,11
        CP	05H
        JR	NZ,J15E4
        LD	A,0E5H			; replacement character
J15E4:	PUSH	AF
        LD	A,(HL)
        CALL	C17AE			; check character
        POP	AF
        BIT	3,C			; volume name ?
        JR	NZ,J15FA		; yep, no check on name
        SUB	(HL)			; matches the one to find ?
        JR	Z,J15FA			; yep, next character
        BIT	2,C			; 2nd byte of double byte character ?
        JR	NZ,J1609		; yep, no match and quit
        LD	A,(HL)
        SUB	"?"			; wildcard character ?
        JR	NZ,J1609		; nope, flag no match and quit
J15FA:	INC	HL
        INC	DE
        LD	A,(DE)
        DJNZ	J15E4			; next
        EX	DE,HL
        LD	A,C
        XOR	(HL)
        AND	08H			; is volume attribute bit of correct value ?
        JR	NZ,J1609		; nope, flag no match and quit
        LD	A,(HL)			; directory entry attribute
        SCF				; flag match
        DEFB	006H			; ld b,xx : trick to skip next instruction

J1609:	OR	A
        POP	DE
        RET

;	  Subroutine copy name and expand wildcard
;	     Inputs  HL = source, DE = current directory entry, BC = destination
;	     Outputs ________________________

C160C:	PUSH	BC
        EX	(SP),IX
        LD	BC,0B00H		; 11 characters, reset all character flags
        LD	A,(DE)
        CP	05H
        JR	NZ,J1619
        LD	A,0E5H
J1619:	PUSH	DE
        LD	D,A
        LD	A,(HL)
        CALL	C17AE			; check character
        BIT	2,C			; 2nd character of double byte character ?
        JR	NZ,J1628		; yep, copy
        CP	"?"
        JR	NZ,J1628		; no wildcard character, copy
        LD	A,D			; wildcard, use the one from the directory entry
J1628:	LD	(IX+0),A
        POP	DE
        INC	DE
        INC	HL
        INC	IX
        LD	A,(DE)
        DJNZ	J1619			; next character
        EX	(SP),IX
        POP	BC
        RET

;	  Subroutine test name
;	     Inputs  ________________________
;	     Outputs ________________________

C1637:	PUSH	AF
        CALL	C2553			; check if special subdirectory directory entry
        POP	BC
        JR	NC,J1640		; not a special subdirectory directory entry,
        XOR	A			; no error
        RET

J1640:	PUSH	HL
        PUSH	DE			; store pointer to string
        LD	A,B
        OR	A
        CALL	NZ,C1698		; check if devicename
        POP	HL			; restore pointer to string
        LD	A,.IDEV
        JR	C,J1666			; yep, quit with "illegal device" error
        LD	BC,0B09H		; 11 characters, supress upcasing, volume name
        BIT	3,(IX+31)		; request volume name ?
        JR	NZ,J1662		; yep,
        LD	BC,0800H		; 8 characters, clear character flags
        LD	A," "			; end marker is space
        CALL	C1669			; validate name
        JR	NZ,J1666		; error, quit
        LD	BC,0300H		; 3 characters, clear character flags
J1662:	XOR	A			; endmarker is end of string
        CALL	C1669			; validate name
J1666:	POP	HL
        OR	A
        RET

;	  Subroutine validate name
;	     Inputs  HL = pointer, A = endmarker, B = maximum length, C = character flags
;	     Outputs ________________________

C1669:	CP	(HL)
        JR	Z,J1694			; begins with end marker, quit with error
J166C:	LD	A,(HL)
        CALL	C17AE			; check character
        LD	(HL),A
        INC	HL
        BIT	4,C			; invalid character ?
        JR	NZ,J168C		; yep,
        BIT	2,C			; 2nd character of double byte character ?
        JR	NZ,J1686		; yep, copy ok
        BIT	3,C			; volume name
        JR	NZ,J1686		; yep, copy ok
        CP	"?"
        JR	Z,J1694
        CP	"*"
        JR	Z,J1694			; wildcard characters, quit with invalid file name error
J1686:	DJNZ	J166C			; next
        JR	J1692			; all ok

J168A:	LD	A,(HL)
        INC	HL
J168C:	CP	" "			; space character ?
        JR	NZ,J1694		; nope, other invalid character, quit with invalid file name error
        DJNZ	J168A			; spaces are ignored
J1692:	XOR	A
        RET

J1694:	LD	A,.IFNM
        OR	A
        RET

;	  Subroutine check if device name
;	     Inputs  DE = pointer to string
;	     Outputs Cx set if device name, Cx reset if no device name

C1698:	LD	HL,(DBBF4)		; start of device chain
        PUSH	HL			; store pointer to device info block
J169C:	POP	HL			; restore pointer to device info block
        LD	A,H
        OR	L			; end of chain ?
        RET	Z			; yep, quit
        LD	C,(HL)
        INC	HL
        LD	B,(HL)			; pointer to next device info block
        INC	HL
        PUSH	BC			; store pointer to next device info block
        PUSH	HL			; store pointer in device info block
        PUSH	DE			; store pointer to search string
        LD	BC,9
        ADD	HL,BC			; to device name
        LD	B,8
J16AD:	LD	A,(DE)
        CP	(HL)			; equal ?
        JR	NZ,J16B5		; nope, next
        INC	DE
        INC	HL
        DJNZ	J16AD			; next character
J16B5:	POP	DE			; restore pointer to search string
        POP	HL			; restore pointer in device info block
        JR	NZ,J169C		; not equal, next device block
        POP	BC			; restore pointer to next device info block
        SCF				; set device name found flag
        RET

;	  Subroutine initialize whole path buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C16BC:	PUSH	HL
        LD	HL,IB931+66
        LD	(HL),2			; end of whole path buffer marker
        LD	HL,IB931
        LD	(HL),0			; start of whole path buffer marker
        INC	HL
        LD	(DBB9A),HL		; intialize pointer in whole path buffer
        POP	HL
        LD	(IY+DBB99-DBB80),0	; no whole path buffer error

;	  Subroutine terminate whole path buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C16D0:	PUSH	HL
        LD	A,2
        LD	HL,(DBB9A)		; pointer in whole path buffer
        CP	(HL)			; at end of whole path buffer ?
        JR	Z,J16E3			; yep, quit with path too long error
        LD	(HL),0
        INC	HL			; add end of string character
        CP	(HL)			; at end of whole path buffer ?
        JR	Z,J16E1			; yep, quit without error
        LD	(HL),0
J16E1:	LD	A,0-(.PLONG-2)
J16E3:	ADD	A,.PLONG-2
        POP	HL
        RET

;	  Subroutine add item to whole path buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C16E7:	PUSH	BC
        PUSH	HL
        LD	HL,(DBB9A)		; pointer in whole path buffer
        LD	A,B
        AND	18H
        JR	Z,J172F
        BIT	6,B
        JR	Z,J1706
        BIT	7,B
        JR	Z,J1723
J16F9:	DEC	HL
        LD	A,(HL)
        CP	1
        JR	Z,J1723
        OR	A
        JR	NZ,J16F9
        LD	A,.IPATH
        JR	J172B			; quit with invalid path error

J1706:	PUSH	HL			; store pointer in whole path buffer
        LD	HL,IB901		; ? buffer
        PUSH	HL			; store pointer to ? buffer
        LD	(HL),1
        INC	HL
        LD	A,(DE)			; first character
        CALL	C173A			; make ASCIIZ string of name
        POP	DE			; restore pointer to ? buffer
        POP	HL			; restore pointer in whole path buffer
J1714:	LD	A,(HL)
        CP	2			; whole path buffer end marker ?
        LD	A,.PLONG
        JR	Z,J172B			; yep, quit with path too long error
        LD	A,(DE)
        LD	(HL),A
        INC	HL
        INC	DE
        OR	A			; end of string ?
        JR	NZ,J1714		; nope, next character
        DEC	HL
J1723:	LD	(DBB9A),HL		; update pointer in whole path buffer
        CALL	C16D0			; terminate whole path buffer
        JR	Z,J172F
J172B:	LD	(IY+DBB99-DBB80),0FFH	; whole path buffer error
J172F:	POP	HL
        POP	BC
        BIT	2,(IY+DBBA0-DBB80)
        JR	Z,J1738
        XOR	A			; no error
J1738:	OR	A
        RET

;	  Subroutine make ASCIIZ string of file or volume name
;	     Inputs  A = first character, HL = pointer to buffer
;	     Outputs ________________________

C173A:	PUSH	BC
        PUSH	HL
        LD	B,13
J173E:	LD	(HL),0
        INC	HL
        DJNZ	J173E
        POP	HL
        LD	BC,11*256+9		; 11 characters, supress upcasing, volume name
        BIT	3,(IX+31)		; request volume name ?
        JR	NZ,J175A		; yep,
        LD	BC,8*256+0		; 8 characters, clear character flags
        CALL	C176A			; copy name
        LD	(HL),"."
        INC	HL
        LD	A,(DE)			; first character of file extension
        LD	BC,3*256+0		; 3 characters, clear character flags
J175A:	CALL	C176A			; copy name
        BIT	7,C
        JR	NZ,J1768		; something was copied (file has extensionname), ok
        BIT	0,C
        JR	NZ,J1768		; volume name, ok
        DEC	HL
        LD	(HL),0			; replace the "." with the endmarker
J1768:	POP	BC
        RET

;	  Subroutine copy name
;	     Inputs  DE = pointer to string, A = first character, HL = buffer, B = maximum length, C = character flags
;	     Outputs ________________________

C176A:	INC	DE
        CALL	C17AE			; check character
        BIT	2,C			; 2nd character of double byte character ?
        JR	NZ,J177A		; yep, copy
        BIT	3,C			; volume name ?
        JR	NZ,J177A		; yep, copy
        CP	" "			; space character ?
        JR	Z,J177E			; yep, skip
J177A:	SET	7,C			; flag something copied
        LD	(HL),A
        INC	HL
J177E:	LD	A,(DE)
        DJNZ	C176A			; next
        RET

;	  Subroutine get parse string character
;	     Inputs  ________________________
;	     Outputs ________________________

C1782:	PUSH	HL
        LD	HL,(DBB9E)		; pointer in parse string
        LD	A,(HL)
        OR	A			; end marker ?
        JR	Z,J178E			; yep, do not update pointer (so endmarker is read again)
        INC	HL
        LD	(DBB9E),HL		; update pointer in parse string
J178E:	POP	HL
        PUSH	BC
        LD	C,(IY+DBBA1-DBB80)	; character flags
        CALL	C17AE			; check character
        LD	(IY+DBBA1-DBB80),C	; update character flags
        POP	BC
        OR	A
        RET

;	  Subroutine undo get parse string character
;	     Inputs  ________________________
;	     Outputs ________________________

C179C:	PUSH	HL
        LD	HL,(DBB9E)		; pointer in parse string
        DEC	HL
        LD	(DBB9E),HL		; update pointer in parse string
        RES	1,(IY+DBBA1-DBB80)
        RES	2,(IY+DBBA1-DBB80)	; reset parse string double byte flags
        POP	HL
        RET

;	  Subroutine check character
;	     Inputs  C = character flags (b0 set, suppress upcasing, b1 set 1st double byte character, b2 set 2nd double byte character, b3 set volume name)
;	     Outputs ________________________

C17AE:	RES	4,C			; not a endmarker
        SET	2,C			; assume 2nd double byte character
        BIT	1,C			; previous was double byte header character ?
        RES	1,C			; not in a double byte character sequence
        JR	NZ,J17D1		; yep, this is the 2nd byte, quit
        RES	2,C			; not a 2nd double byte character
        SET	1,C			; assume 1st double byte character
        CALL	C17D6			; check for double byte header character
        JR	C,J17D1			; yep, quit
        RES	1,C			; not a 1st double byte character
        BIT	0,C			; upcase flag ?
        CALL	Z,C17FD			; yep, make upcase
        BIT	3,C			; volume name flag
        CALL	C180D			; validate character
        JR	NC,J17D1		; ok,
        SET	4,C			; illegal, set end flag
J17D1:	OR	A			; end of string character ?
        RET	NZ			; nope, quit
        SET	4,C			; set end flag
        RET



        IF ROMVER GE 3
;	  Subroutine check for double byte header character
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  extra routine in dos 2.31

C17D6:	PUSH	HL
        LD	HL,I17DC
        JR	J17E7

I17DC:	DEFB	080H,0A0H
        DEFB	0E0H,0FDH

        ELSE
C17D6:
        ENDIF

;	  Subroutine check for double byte header character if enabled
;	     Inputs  ________________________
;	     Outputs ________________________

C17E0:	CALL	H_16CH
        PUSH	HL
        LD	HL,KANJTA
J17E7:	CP	(HL)
        INC	HL
        JR	C,J17EE
        CP	(HL)
        JR	C,J17F6
J17EE:	INC	HL
        CP	(HL)
        JR	C,J17FA
        INC	HL
        CP	(HL)
        JR	NC,J17FA
J17F6:	OR	A
        SCF
        POP	HL
        RET

J17FA:	OR	A
        POP	HL
        RET

;	  Subroutine make upcase
;	     Inputs  ________________________
;	     Outputs ________________________

C17FD:	PUSH	HL
        LD	HL,IBA75
        CALL	H_UP
        PUSH	BC
        LD	B,0
        LD	C,A
        ADD	HL,BC
        LD	A,(HL)
        POP	BC
        POP	HL
        RET

;	  Subroutine validate character
;	     Inputs  A = character, Zx set = file name, Zx reset = volume name
;	     Outputs Cx set if illgeal character

C180D:	PUSH	HL
        PUSH	BC
        LD	BC,17
        LD	HL,I1826
        JR	Z,J181A
        LD	BC,6
J181A:	CP	20H
        JR	C,J1822
        CPIR
        JR	NZ,J1823
J1822:	SCF
J1823:	POP	BC
        POP	HL
        RET

I1826:	defb	07FH,'|<>/',0FFH,' :;.,=+\"[]'

;	  Subroutine _GETCD
;	     Inputs  ________________________
;	     Outputs ________________________

A1836:	LD	A,B			; drive id
        LD	B,00H
        LD	IX,IB9DA		; buffer
        LD	C,09H			; parse flags =
        PUSH	DE
        LD	DE,I184C
        CALL	C12C3			; parse path
        POP	DE
        RET	NZ
        JP	A189D			; _WPATH

I184C:	defb	0

;	  Subroutine _CHDIR
;	     Inputs  ________________________
;	     Outputs ________________________

A184D:	XOR	A			; default drive id
        LD	B,A
        LD	IX,IB9DA		; buffer
        LD	C,09H			; parse flags =
        CALL	C12C3			; parse path
        RET	NZ			; error, quit
        OR	C
        LD	A,.IPATH
        RET	NZ			; not at end of string, quit with "illegal path" error
        LD	BC,30
        ADD	HL,BC
        LD	DE,(DBBE8)		; cluster number current directory
        LD	(HL),E
        INC	HL
        LD	(HL),D
J1868:	INC	HL
        EX	DE,HL
        JP	A189D			; _WPATH

;	  Subroutine _PARSE
;	     Inputs  ________________________
;	     Outputs ________________________

A186D:	LD	C,04H			; parse flags =
        LD	IX,IB9DA		; buffer
        XOR	A			; default drive id
        CALL	C12C3			; parse path
        LD	C,(IX+25)		; logical drive id
        LD	DE,(DBB9E)		; pointer to terminator character = pointer in parse string
        LD	HL,(DBB9C)		; pointer to last item = pointer to last item in parse string
        RET

;	  Subroutine _PFILE
;	     Inputs  ________________________
;	     Outputs ________________________

A1882:	PUSH	HL
        LD	(DBB9E),DE		; update pointer in parse string
        EX	DE,HL
        LD	B,0			; reset parse flags
        CALL	C13FF			; parse file name
        LD	DE,(DBB9E)		; pointer in parse string
        POP	HL
        XOR	A
        RET

;	  Subroutine _CHKCHR
;	     Inputs  ________________________
;	     Outputs ________________________

A1894:	LD	A,E			; character
        LD	C,D			; character flags
        CALL	C17AE			; check character
        LD	D,C			; updated character flags
        LD	E,A			; character
        XOR	A			; no error
        RET

;	  Subroutine _WPATH
;	     Inputs  ________________________
;	     Outputs ________________________

A189D:	PUSH	DE			; store pointer to buffer
        LD	HL,IB931+2
        LD	C,0
        PUSH	DE			; store pointer to buffer
        LD	A,(DBB99)
        OR	A			; whole path buffer error
        JR	NZ,J18C1		; yep, quit with path too long error
J18AA:	LD	A,(HL)
        INC	HL
        CP	2			; whole path buffer end marker ?
        JR	Z,J18C1			; yep, quit with path too long error
        CP	1			; whole path buffer subdirectory marker ?
        JR	NZ,J18BA		; nope,
        POP	AF			; dispose pointer
        LD	A,"\"
        INC	DE
        PUSH	DE			; store pointer
        DEC	DE
J18BA:	LD	(DE),A
        INC	DE
        OR	A
        JR	NZ,J18AA
        JR	J18C3

J18C1:	LD	A,.PLONG
J18C3:	POP	HL			; restore
        POP	DE			; restore pointer to buffer
        RET

;	  Subroutine _FFIRST
;	     Inputs  ________________________
;	     Outputs ________________________

A18C6:	LD	A,4			; search directory entry
        JR	J18CB

;	  Subroutine _FNEW
;	     Inputs  ________________________
;	     Outputs ________________________

A18CA:	XOR	A			; create directory entry
J18CB:	LD	(DBBAF),A		; update search directory entry flags
        LD	A,(DE)
        INC	A			; is pointer to a FIB ?
        JR	Z,J18DF			; yep,
        XOR	A			; default drive id
        LD	C,0AH			; parse flags =
        CALL	C12C3			; parse path
        RET	NZ
        OR	C
        LD	A,.IPATH
        RET	NZ
        JR	J1929

J18DF:	PUSH	HL
        PUSH	DE
        EX	(SP),IX
        CALL	C1A02			; get directory entry from FIB info with disk change check
        LD	C,(IX+25)		; logical drive id
        POP	IX
        JP	NZ,J1977
        LD	A,.IDEV
        JP	C,J1977
        PUSH	HL
        LD	HL,11
        ADD	HL,DE
        LD	A,(HL)
        POP	HL
        BIT	4,A
        LD	A,.IATTR
        JR	Z,J1977
        BIT	3,B
        JR	NZ,J1977
        CALL	C1C3A			; select sub directory
        PUSH	BC
        PUSH	HL
        LD	BC,25
        ADD	HL,BC
        PUSH	IX
        POP	DE
        EX	DE,HL
        LD	BC,26
        ADD	HL,BC
        EX	DE,HL
        LD	BC,4
        LDIR
        POP	HL
        POP	BC
        POP	DE
        LD	A,C
        LD	C,4EH			; parse flags =
        CALL	C1349			; parse file name
        RET	NZ
        OR	C
        LD	A,.IPATH
        RET	NZ

J1929:	BIT	2,(IY+DBBAF-DBB80)	; search only ?
        JR	NZ,J195F		; yep,
        BIT	5,B
        JR	Z,J195F
        PUSH	IX
        EX	(SP),HL
        LD	BC,1
        ADD	HL,BC
        LD	(DBB9E),HL		; update pointer in parse string
        POP	HL
        LD	DE,IB91B
        CALL	C13FF			; parse file name
        OR	A
        LD	A,.IFNM
        RET	NZ			; error,
        PUSH	HL
        LD	HL,IB926		; file name buffer
        LD	DE,IB91B
        LD	BC,IB926
        CALL	C160C			; copy name and expand wildcard
        POP	HL
        LD	DE,IB926		; file name buffer
        CALL	C14F4			; check if device and get device flags
        LD	(IX+30),A		; update device flags
J195F:	LD	DE,IB926		; file name buffer
        PUSH	IX
        EX	(SP),HL
        LD	BC,32
        ADD	HL,BC
        EX	DE,HL
        PUSH	DE
        LD	BC,11
        LDIR
        POP	DE
        POP	HL
        CALL	C1A53			; get directory entry
        JR	J198D

J1977:	POP	DE
        RET

;	  Subroutine _FNEXT
;	     Inputs  ________________________
;	     Outputs ________________________

A1979:	LD	(IY+DBBAF-DBB80),4	; search directory entry
        CALL	C1A02			; get directory entry from FIB info with disk change check
        RET	NZ			; error, quit
        PUSH	IX
        EX	(SP),HL
        LD	DE,32
        ADD	HL,DE
        EX	DE,HL
        POP	HL			; pointer to directory entry locator
        CALL	C1A91			; get next directory entry
J198D:	PUSH	AF
        CALL	Z,C1999			; if no error, update FIB with directory entry info
        POP	AF
        CALL	C1A45			; get pointer to directory entry locators
        EX	DE,HL
        LDIR				; update FIB directory entry locator
        RET

;	  Subroutine update FIB with directory entry info
;	     Inputs  IX = pointer to FIB, DE = pointer to directory entry
;	     Outputs ________________________

C1999:	PUSH	IX
        EX	(SP),HL
        PUSH	HL
        INC	HL			; FIB+1
        LD	A,(DE)
        CP	05H
        JR	NZ,J19A5
        LD	A,0E5H
J19A5:	CALL	C173A			; make ASCIIZ string of name
        POP	HL
        LD	BC,14
        ADD	HL,BC
        LD	A,(DE)
        LD	(HL),A			; fileattribute
        EX	DE,HL
        INC	DE
        LD	BC,11
        ADD	HL,BC
        LD	BC,10
        LDIR				; file time, file date, file starting cluster and file size
        POP	HL
        RET

;	  Subroutine open file and create or update FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C19BC:	LD	(IY+DBBAF-DBB80),4	; search directory entry
        LD	B,16H
        LD	A,(DE)
        INC	A
        JR	Z,J19E8			; parameter is a FIB, search file and update FIB
        JR	J19CC			; parameter is a ASCIIZ string, search file and create FIB

;	  Subroutine create new file and FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C19C8:	LD	(IY+DBBAF-DBB80),0	; create directory entry
J19CC:	XOR	A			; default drive id
        LD	IX,IB9DA		; buffer
        LD	C,08H			; parse flags =
        CALL	C12C3			; parse path
        RET	NZ			; error, quit
        OR	C
        LD	A,.IPATH
        RET	NZ			; "illegal path" error
        BIT	5,B
        LD	A,.IFNM
        RET	NZ			; "illegal filename" error
        LD	DE,IB926		; file name buffer
        CALL	C1A53			; get directory entry
        JR	J19F7

J19E8:	PUSH	DE
        POP	IX
        CALL	C1A02			; get directory entry from FIB info with disk change check
        RET	NZ			; error, quit
        BIT	3,(IX+31)		; request volume name ?
        LD	A,.IATTR
        RET	NZ			; yep, quit with "invalid attribute" error
        XOR	A
J19F7:	OR	A
        RET	NZ
        PUSH	HL
        LD	HL,11
        ADD	HL,DE
        LD	A,(HL)
        POP	HL
        CP	A
        RET

;	  Subroutine get directory entry from FIB info with disk change check
;	     Inputs  ________________________
;	     Outputs ________________________

C1A02:	PUSH	BC
        BIT	7,(IX+30)		; device ?
        JR	Z,J1A10			; nope,
        CALL	C1A25			; create fake directory for device
        POP	BC
        XOR	A
        SCF
        RET

J1A10:	CALL	C1A45			; get pointer to directory entry locators
        LDIR				; update directory entry locator with directory entry locator in FIB
        LD	C,(IX+25)		; logical drive id
        LD	B,1			; type = for file
        CALL	C31AB			; check disk change
        POP	BC
        OR	A			; error ?
        RET	NZ			; yep, quit
        CALL	C1C7A			; get current directory entry
        XOR	A
        RET

;	  Subroutine create fake directory for device
;	     Inputs  ________________________
;	     Outputs ________________________

C1A25:	LD	L,(IX+26)
        LD	H,(IX+27)
        PUSH	HL
        LD	DE,9
        ADD	HL,DE
        PUSH	HL
        LD	DE,22
        ADD	HL,DE
        EX	DE,HL
        PUSH	IX
        POP	HL
        LD	BC,15
        ADD	HL,BC
        LD	BC,4
        LDIR
        POP	DE
        POP	HL
        RET

;	  Subroutine get pointer to directory entry locators
;	     Inputs  IX = pointer to FIB
;	     Outputs HL = pointer to FIB directory entry locators, DE = pointer to directory entry locators

C1A45:	LD	DE,DBBDE		; pointer to directory entry locator
        PUSH	IX
        POP	HL
        LD	BC,43
        ADD	HL,BC			; pointer to directory entry locator in FIB
        LD	BC,12			; size of directory entry locator
        RET

;	  Subroutine get directory entry
;	     Inputs  DE = file name buffer
;	     Outputs ________________________

C1A53:	BIT	2,(IY+DBBAF-DBB80)	; search only ?
        JR	NZ,J1A6E		; yep,
        PUSH	DE			; store pointer to file name buffer
        LD	A,(IX+31)
        AND	10H			; request file or directory ?
        CALL	C1637			; test name
        POP	DE			; restore pointer to file name buffer
        RET	NZ			; error, quit
        BIT	7,(IX+31)
        JR	Z,J1A6E
        SET	3,(IY+DBBAF-DBB80)
J1A6E:	RES	7,(IX+31)
        LD	(DBBAD),DE		; store pointer to file name buffer for search directory entry
        BIT	7,(IX+30)		; device ?
        JR	NZ,J1A84		; yep,
        CALL	C1C5D			; get first directory entry
        CALL	C1BD2			; search directory entry
        JR	J1AA3

J1A84:	PUSH	HL
        LD	DE,9
        ADD	HL,DE
        EX	DE,HL
        CALL	C1BA0			; change time and date directory entry
        POP	HL
        JP	J1B2E

;	  Subroutine get next directory entry
;	     Inputs  DE = pointer to file name buffer
;	     Outputs ________________________

C1A91:	BIT	7,(IX+30)		; device ?
        LD	A,.NOFIL
        RET	NZ			; yep, quit with "File not found" error
        SET	1,(IY+DBBA9-DBB80)	; force read directory sector
        LD	(DBBAD),DE		; store pointer to file name buffer for search directory entry
J1AA0:	CALL	C1BCF			; search next directory entry
J1AA3:	JR	C,J1AB1			; match,
        BIT	2,(IY+DBBAF-DBB80)	; search only ?
        LD	A,.NOFIL		; "File not found" error
        CALL	Z,C1C04			; create flag, get free directory entry
        RET	NZ			; search only, quit with file not found error
        JR	J1AF0

J1AB1:	BIT	2,(IY+DBBAF-DBB80)	; search only ?
        JR	Z,J1AC6			; nope, create
        BIT	3,A			; volume name ?
        JR	NZ,J1B2E		; yep,
        AND	16H
        CPL				; only directory, system or hidden cares
        OR	(IX+31)			; request attributes
        INC	A
        JR	NZ,J1AA0
        JR	J1B2E

J1AC6:	LD	B,A
        BIT	3,(IY+DBBAF-DBB80)
        JR	NZ,J1ADD
        BIT	2,B
        LD	A,.SYSX
        JR	NZ,J1B2F		; system attribute, "system file exists" error
        BIT	4,B
        LD	A,.DIRX
        JR	NZ,J1B2F		; directory attribute, "directory exists" error
        BIT	4,(IX+31)		; request directory ?
J1ADD:	LD	A,.FILEX
        JR	NZ,J1B2F		; want to create directory but file with same name exists, "file exists" error
        CALL	C1C7A			; get current directory entry
        XOR	A			; delete is not recoverable by UNDEL
        CALL	C2350			; mark current directory entry deleted and remove FAT chain
        PUSH	AF
        CALL	C1C7A			; get current directory entry
        POP	AF
        OR	A			; error ?
        JR	NZ,J1B2F		; yep,
J1AF0:	LD	DE,(DBBAD)		; restore pointer to file name buffer for search directory entry
        CALL	C2553			; check if special subdirectory directory entry
        JR	NC,J1AFB		; not a special subdirectory directory entry,
        OR	A
        RET

J1AFB:	LD	BC,0
        BIT	4,(IX+31)		; request directory ?
        JR	Z,J1B0E			; not a directory, skip subdirectory cluster creation
        LD	A,0FFH			; clear directory cluster
        INC	BC			; 1 cluster
        CALL	C2F5E			; allocate clusters
        RET	NZ			; error, quit
        CALL	C1B31			; setup the first two directory entries
J1B0E:	CALL	C1C7A			; get current directory entry
        LD	A,28H			; archive + volume
        BIT	3,(IX+31)		; request volume name ?
        JR	NZ,J1B26		; yep,
        LD	A,(IX+31)
        SET	5,A			; set archive bit
        BIT	4,A			; request file ?
        JR	Z,J1B24			; yep,
        AND	0DAH			; directory, reset archive, system and read-only
J1B24:	AND	3FH			; clear unused bits
J1B26:	PUSH	HL
        LD	HL,(DBBAD)		; restore pointer to file name buffer for search directory entry
        CALL	C1B73			; setup directory entry
        POP	HL
J1B2E:	XOR	A
J1B2F:	CP	A
        RET

;	  Subroutine setup the first two directory entries
;	     Inputs  ________________________
;	     Outputs ________________________

C1B31:	PUSH	DE
        LD	D,B
        LD	E,C
        XOR	A			; sector offset = 0
        CALL	C2DD4			; convert cluster number to sector number
        PUSH	HL
        EX	(SP),IX
        PUSH	BC
        LD	B,1			; real read, ignore not recommended
        CALL	C2B96			; get directory sector
        POP	BC
        PUSH	BC
        LD	DE,11
        ADD	HL,DE
        EX	DE,HL
        LD	HL,I1B68		; .
        LD	A,10H			; directory attribute
        CALL	C1B73			; setup directory entry
        LD	HL,32
        ADD	HL,DE
        EX	DE,HL
        LD	HL,I1B67		; ..
        LD	BC,(DBBE8)		; cluster number current directory
        LD	A,10H			; directory attribute
        CALL	C1B73			; setup directory entry
        POP	BC
        EX	(SP),IX
        POP	HL
        POP	DE
        RET

I1B67:	defb	"."
I1B68:	defb	".          "

;	  Subroutine setup directory entry
;	     Inputs  HL = pointer to file name, DE = pointer to directory entry, BC = cluster, A = attribute
;	     Outputs ________________________

C1B73:	PUSH	DE
        PUSH	BC
        LD	B,A
        LD	A,(HL)
        CP	0E5H			; special character which is used in directory entries as deleted file marker ?
        JR	NZ,J1B7D
        LD	A,05H			; yep, use replacement character
J1B7D:	LD	(DE),A
        LD	A,B
        INC	HL
        INC	DE
        LD	BC,10
        LDIR				; copy rest of file name to directory entry
        CALL	C2C56			; mark buffer last read as dirty
        LD	(DE),A			; file attribute
        EX	DE,HL
        LD	B,20
J1B8D:	INC	HL
        LD	(HL),C
        DJNZ	J1B8D			; rest of directory entry fields clear
        POP	DE
        BIT	7,D
        JR	Z,J1B98			; subdirectory, use given cluster number for first cluster
        LD	D,B
        LD	E,B			; rootdirectory, use 0 for first cluster
J1B98:	LD	BC,-4
        ADD	HL,BC
        LD	(HL),D
        DEC	HL
        LD	(HL),E
        POP	DE

;	  Subroutine change time and date directory entry
;	     Inputs  DE = pointer to directory entry
;	     Outputs ________________________

C1BA0:	PUSH	HL
        PUSH	BC
        PUSH	DE
        LD	HL,22
        ADD	HL,DE			; time field of directory entry
        PUSH	HL
        CALL	C111B			; read time and date from real time clock
        EX	(SP),HL
        LD	A,C
        ADD	A,A
        ADD	A,A
        LD	C,3
J1BB1:	ADD	A,A
        RL	B
        DEC	C
        JR	NZ,J1BB1
        SRL	E
        ADD	A,E
        LD	(HL),A
        INC	HL
        LD	(HL),B
        INC	HL
        POP	BC
        LD	A,B
        OR	A
        RRA
        RRA
        RRA
        RRA
        RL	D
        ADD	A,C
        LD	(HL),A
        INC	HL
        LD	(HL),D
        POP	DE
        POP	BC
        POP	HL
        RET

;	  Subroutine search next directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C1BCF:	CALL	C1C94			; get next directory entry

;	  Subroutine search directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C1BD2:	JR	C,J1BEE			; no more entries, quit
        PUSH	IX
        EX	(SP),HL
        LD	HL,(DBBAD)		; store pointer to file name buffer for search directory entry
        LD	A,(IX+31)		; request attribute
        CALL	C15D2			; does directory entry match the search ?
        POP	HL
        RET	C			; yep, quit
        JR	NZ,C1BCF		; not a free entry, search next directory entry
        BIT	0,(IY+DBBAF-DBB80)	; free directory entry found ?
        CALL	Z,C1BF0			; nope, register free directory entry
        OR	A			; deleted entry ?
        JR	NZ,C1BCF		; yep, search next directory entry
J1BEE:	XOR	A			; Cx reset
        RET

;	  Subroutine register free directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C1BF0:	PUSH	HL
        PUSH	DE
        PUSH	BC
        CALL	C1A45			; get pointer to directory entry locators
        EX	DE,HL
        LD	DE,IBBD2
        LDIR				; update free directory entry locator with directory entry locator
        SET	0,(IY+DBBAF-DBB80)	; flag free directory entry found
        POP	BC
        POP	DE
        POP	HL
        RET

;	  Subroutine get free or registered directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C1C04:	PUSH	BC
        BIT	0,(IY+DBBAF-DBB80)	; free directory entry found ?
        JR	Z,J1C17			; nope, try to expand directory
        PUSH	HL
        CALL	C1A45			; get pointer to directory entry locators
        LD	HL,IBBD2
        LDIR				; update directory entry locator with free directory entry locator
        POP	HL
        JR	J1C37			; ok

J1C17:	LD	DE,(DBBDE+8)
        BIT	7,D
        LD	A,.DRFUL
        JR	NZ,J1C38		; not a subdirectory, quit with "directory full" error
        LD	A,0FFH			; clear directory cluster
        LD	BC,1			; 1 cluster
        CALL	C2F5E			; allocate clusters
        JR	NZ,J1C38		; error, quit
        PUSH	BC
        CALL	C2DF1			; reset deleted files status disk and set FAT entry
        POP	BC
        LD	(DBBDE+6),BC
        CALL	C1C94			; get next directory entry
J1C37:	XOR	A
J1C38:	POP	BC
        RET

;	  Subroutine select sub directory
;	     Inputs  ________________________
;	     Outputs ________________________

C1C3A:	PUSH	HL			; store pointer to directory entry
        LD	HL,26
        ADD	HL,DE
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; starting cluster
        POP	HL			; restore pointer to directory entry
        LD	A,D
        OR	E			; directory entry has cluster chain ?
        JR	NZ,C1C4A		; yep, select sub directory (cluster number)

;	  Subroutine select root directory
;	     Inputs  ________________________
;	     Outputs ________________________

C1C47:	LD	DE,0FFFFH		; cluster number = root directory

;	  Subroutine select sub directory (cluster number)
;	     Inputs  ________________________
;	     Outputs ________________________

C1C4A:	LD	(DBBE8),DE		; update cluster number current directory
        PUSH	HL			; store pointer to directory entry
        LD	HL,(DBBAB)
        XOR	A
        SBC	HL,DE
        JR	NZ,J1C5B
        SET	1,(IY+DBBAF-DBB80)
J1C5B:	POP	HL			; restore pointer to directory entry
        RET

;	  Subroutine get first directory entry
;	     Inputs  HL = pointer to drive table
;	     Outputs ________________________

C1C5D:	LD	DE,(DBBE8)		; cluster number current directory
        BIT	7,D			; root directory ?
        JR	Z,J1CC4			; nope,
        PUSH	BC
        PUSH	HL
        LD	BC,15
        ADD	HL,BC
        LD	C,(HL)			; Number of directory entries of partly root directory sector
        INC	HL
        LD	A,(HL)			; Number of whole root directory sectors
        INC	HL
        INC	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; first rootdirectory sector
        POP	HL
        LD	B,0FFH
        PUSH	BC			; fake end cluster to mark end of rootdirectory
        PUSH	BC
        JR	J1CDE

;	  Subroutine get current directory entry
;	     Inputs  HL = pointer to drive table
;	     Outputs ________________________

C1C7A:	PUSH	HL
        LD	DE,8
        ADD	HL,DE
        BIT	7,(HL)			; device ?
        EX	DE,HL
        INC	DE
        POP	HL
        JP	NZ,J1D29		; yep,
        SET	1,(IY+DBBA9-DBB80)	; force read directory sector
        INC	(IY+DBBDE+2-DBB80)
        PUSH	BC
        LD	BC,0			; offset = current directory entry
        JR	J1C98

;	  Subroutine get next directory entry
;	     Inputs  HL = pointer to drive table, DE = pointer to current directory entry
;	     Outputs ________________________

C1C94:	PUSH	BC
        LD	BC,32			; offset = next directory entry
J1C98:	PUSH	HL
        EX	DE,HL
        ADD	HL,BC
        LD	DE,(DBBDE+4)		; current directory sector
        LD	A,(DBBDE+2)
        DEC	A			; entries left ?
        JR	Z,J1CAE			; nope, try next sector
        BIT	1,(IY+DBBA9-DBB80)	; force read directory sector ?
        JP	Z,J1D23			; nope, use the buffer
        JR	J1D03			; actually read the sector in buffer and return

J1CAE:	POP	HL
        INC	DE
        LD	A,(DBBDE+3)
        DEC	A			; still sectors left ?
        JR	NZ,J1CEB		; yep, next sector
        CP	(IY+DBBDE+0-DBB80)	; partly dirsector ?
        JR	NZ,J1CED		; yep, partly (=last) sector
        LD	DE,(DBBDE+6)
        BIT	7,D			; end cluster (of subdirectory) ?
        SCF
        POP	BC
        RET	NZ			; yep, then is the end of directory, quit
J1CC4:	PUSH	BC
        PUSH	DE			; store cluster number
        CALL	C2DA4			; get FAT entry content
        LD	B,D
        LD	C,E
        POP	DE			; restore cluster number
        PUSH	DE			; store cluster number
        XOR	A			; sector offset = 0
        CALL	C2DD4			; convert cluster number to sector number
        PUSH	DE
        EX	DE,HL
        LD	HL,10
        ADD	HL,DE
        LD	A,(HL)
        INC	A			; number of whole directory sectors (in this cluster)
        EX	DE,HL
        POP	DE			; sector number
        PUSH	BC
        LD	C,0			; no partly directory entries
J1CDE:	LD	(IY+DBBDE+0-DBB80),C	; update partly directory entries
        POP	BC
        LD	(DBBDE+6),BC
        POP	BC
        LD	(DBBDE+8),BC
J1CEB:	LD	B,16
J1CED:	OR	A
        JR	NZ,J1CF7		; not a partly directory sector, 16 entries in sector
        LD	B,(IY+DBBDE+0-DBB80)	; number of directory entries in partly sector
        LD	(DBBDE+0),A		; update number of directory entries in partly sector
        INC	A			; 1 sector
J1CF7:	LD	(DBBDE+3),A		; number of sectors left
        LD	(DBBDE+4),DE		; current sector
        LD	(IY+DBBDE+1-DBB80),B	; number of entries left
        LD	A,B
        PUSH	HL
J1D03:	EX	(SP),IX
        PUSH	AF
        LD	B,1			; real read, ignore not recommended
        CALL	C2B96			; get directory sector
        POP	BC
        EX	(SP),IX
        LD	DE,11-32
        ADD	HL,DE			; to the buffer itself
        LD	A,(DBBDE+1)
        INC	A
        SUB	B
        LD	DE,32
J1D1A:	ADD	HL,DE
        DEC	A
        JR	NZ,J1D1A
        LD	A,B
        RES	1,(IY+DBBA9-DBB80)	; use directory sector buffer
J1D23:	LD	(DBBDE+2),A
        EX	DE,HL
        POP	HL
        POP	BC
J1D29:	LD	A,(DE)
        OR	A
        RET

;	  Subroutine write to file handle
;	     Inputs  B = file handle
;	     Outputs ________________________

C1D2C:	EX	AF,AF'
        CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        BIT	7,(IX+30)		; device ?
        JR	Z,J1D43			; nope,

; write to file handle (device)

        LD	L,(IX+28)
        LD	H,(IX+29)		; pointer to device jump table
        INC	HL
        INC	HL
        INC	HL			; device output handler
        EX	AF,AF'

;	  Subroutine call device handler
;	     Inputs  ________________________
;	     Outputs ________________________

C1D42:	JP	(HL)

; write to file handle (disk)

J1D43:	EX	AF,AF'
        LD	DE,IBBC5
        LD	(DE),A			; store character in character buffer
        LD	BC,1			; record size = 1
        LD	A,0FFH			; segment type = current

	IF	OPTM EQ 0

        CALL	C2771			; write to FIB
        RET

	ELSE

	JP	C2771			; write to FIB

	ENDIF

;	  Subroutine read from file handle
;	     Inputs  B = file handle
;	     Outputs ________________________

C1D51:	CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        BIT	7,(IX+30)		; device ?
        JR	Z,J1D77			; nope,

; read from file handle (device)

        RES	6,(IX+30)		; reset EOF flag
        LD	L,(IX+28)
        LD	H,(IX+29)		; pointer to device jump table (device input handler)
        PUSH	BC			; store device flags
        CALL	C1D42			; call device input handler
        POP	DE			; restore device flags
        CP	.EOL			; end of line character ?
        JR	Z,J1D75			; yep, quit without error
        BIT	5,E			; ascii mode ?
        RET	NZ			; yep, quit
        CP	.EOF			; EOF character ?
        RET	NZ			; nope, quit
J1D75:	XOR	A			; no error
        RET

; read from file handle (disk)

J1D77:	PUSH	BC
        LD	DE,IBBC5		; character buffer
        LD	BC,1			; record size = 1
        LD	A,0FFH			; segment type = current
        CALL	C2775			; read from FIB
        LD	HL,IBBC5
        LD	B,(HL)			; character read
        POP	DE
        OR	A			; error ?
        RET	NZ			; yep, quit with error
        OR	E			; ascii mode ?
        RET	Z			; nope, quit
        LD	A,B
        CP	1AH			; EOF character ?
        LD	A,.EOF
        RET	Z			; yep, quit with end of file error
        XOR	A			; no error
        RET

;	  Subroutine _CREATE
;	     Inputs  ________________________
;	     Outputs ________________________

A1D94:	EX	AF,AF'
        BIT	3,B			; volume attribute ?
        LD	A,.IATTR
        RET	NZ			; yep, quit with invalid attribute error
        CALL	C19C8			; create new file and FIB
        RET	NZ			; error, quit
        LD	B,0FFH
        BIT	4,A
        JR	NZ,J1DE6
        JR	J1DB0

;	  Subroutine _OPEN
;	     Inputs  ________________________
;	     Outputs ________________________

A1DA6:	EX	AF,AF'
        CALL	C19BC			; open file and create or update FIB
        RET	NZ			; error, quit
        BIT	4,A			; directory entry ?
        LD	A,.DIRX
        RET	NZ			; yep, quit with "directory exists" error
J1DB0:	PUSH	HL
        CALL	C212B			; find free file handle
        JR	NZ,J1DE9		; not found, quit with error
        PUSH	HL
        CALL	C21AD			; create FIB
        JR	NZ,J1DE8		; error,
        EX	DE,HL
        EX	(SP),HL
        LD	(HL),E
        INC	HL
        LD	(HL),D			; setup file handle entry with pointer to FIB
        PUSH	BC
        PUSH	DE
        EX	(SP),IX
        POP	HL
        LD	BC,32
        LDIR
        POP	BC
        POP	DE
        LD	(IX+31),06H		; request attribute = volume name + system
        XOR	A
        LD	(IX+45),A
        LD	(IX+46),A
        LD	(IX+47),A
        LD	(IX+48),A		; position in file = 0
        POP	HL
        EX	AF,AF'			; open mode
        CALL	C228E			; setup FIB for open
        CALL	C20F2			; update redirect status
J1DE6:	XOR	A
        RET

J1DE8:	POP	HL
J1DE9:	POP	HL
        RET

;	  Subroutine _CLOSE
;	     Inputs  B = file handle
;	     Outputs ________________________

A1DEB:	CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        CALL	C22D7			; free file handle
        CALL	C20F2			; update redirect status
        JR	J1DFD

;	  Subroutine _ENSURE
;	     Inputs  B = file handle
;	     Outputs ________________________

A1DF8:	CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
J1DFD:	CALL	C2244			; ensure directory entry (when file is modified)
        LD	A,(IX+25)		; logical drive id
        CALL	C2C5F			; flush sector buffers of logical drive
        XOR	A
        RET

;	  Subroutine _DUP
;	     Inputs  B = file handle
;	     Outputs ________________________

A1E08:	CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        CALL	C212B			; find free file handle
        RET	NZ			; not found, quit with error
        CALL	C2166			; increase file handle count of FIB
        RET	NZ			; error, quit
        LD	(HL),E
        INC	HL
        LD	(HL),D			; pointer to FIB
        CALL	C20F2			; update redirect status
        XOR	A
        RET

;	  Subroutine _READ
;	     Inputs  B = file handle
;	     Outputs ________________________

A1E1D:	PUSH	DE
        PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	BC
        POP	DE
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        XOR	A			; segment type = TPA
        CALL	C2775			; read from FIB
        PUSH	BC
        POP	HL
        RET

;	  Subroutine _WRITE
;	     Inputs  B = file handle
;	     Outputs ________________________

A1E2D:	PUSH	DE
        PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	BC
        POP	DE
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        XOR	A			; segment type = TPA
        CALL	C2771			; write to FIB
        PUSH	BC
        POP	HL
        RET

;	  Subroutine _SEEK
;	     Inputs  B = file handle
;	     Outputs ________________________

A1E3D:	EX	AF,AF'
        PUSH	DE
        PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	DE
        POP	HL
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        EX	AF,AF'
        PUSH	HL
        LD	HL,0
        LD	BC,0			; position = first position of file
        OR	A			; relative to beginning ?
        JR	Z,J1E6D			; yep, use first position
        LD	L,(IX+45)
        LD	H,(IX+46)
        LD	C,(IX+47)
        LD	B,(IX+48)		; position = current position in file
        DEC	A			; relative to current ?
        JR	Z,J1E6D			; yep, use current position
        LD	L,(IX+21)
        LD	H,(IX+22)
        LD	C,(IX+23)
        LD	B,(IX+24)		; position = last position in file (file size)
J1E6D:	ADD	HL,DE			; add low word offset
	EX	(SP),HL			; store low word position, restore high word offset
        POP	DE			; restore low word position
        ADC	HL,BC			; add high word offset
        EX	DE,HL
        LD	(IX+45),L
        LD	(IX+46),H
        LD	(IX+47),E
        LD	(IX+48),D		; update current position in file
        XOR	A			; no error
        RET

;	  Subroutine _IOCTL
;	     Inputs  B = file handle
;	     Outputs ________________________

A1E81:	EX	AF,AF'
        PUSH	DE
        CALL	C2140			; get pointer to FIB of file handle
        POP	DE
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        EX	AF,AF'
        LD	L,(IX+28)
        LD	H,(IX+29)		; pointer to device jump table
        OR	A
        JR	Z,J1EB4			; get file handle status
        DEC	A
        JR	Z,J1EA2			; set filemode (ascii/binary)
        DEC	A
        JR	Z,J1ED5			; test input ready
        DEC	A
        JR	Z,J1EEB			; test output ready
        DEC	A
        JR	Z,J1F05			; find screensize
J1E9F:	LD	A,.ISBFN
        RET

J1EA2:	BIT	7,(IX+30)		; device ?
        JR	Z,J1E9F			; nope,
        LD	A,(IX+30)
        XOR	E
        AND	0DFH			; only ascii/binary flag
        XOR	E
        RES	6,A			; reset EOF flag
        LD	(IX+30),A
J1EB4:	LD	E,(IX+30)
        XOR	A
        LD	D,A
        BIT	7,E			; device ?
        RET	NZ			; yep, quit

;	  Subroutine get mode of handle
;	     Inputs  ________________________
;	     Outputs ________________________

C1EBC:	LD	E,(IX+25)
        DEC	E
        LD	B,04H	; 4 
J1EC2:	LD	A,(IX+48)
        CP	(IX+24)
        JR	C,J1ED2
        JR	NZ,J1ED0
        DEC	IX
        DJNZ	J1EC2
J1ED0:	SET	6,E
J1ED2:	XOR	A
        LD	D,A
        RET

J1ED5:	BIT	1,(IX+49)
        JR	NZ,J1EFA		; file mode no read, return not ready
        BIT	7,(IX+30)		; device ?
        JR	NZ,J1EFD		; yep, continue to device check if input handler
        CALL	C1EBC			; get mode of handle
        BIT	6,E
        JR	NZ,J1EFA
        LD	E,0
        RET

J1EEB:	BIT	0,(IX+49)
        JR	NZ,J1EFA		; file mode no write, return not ready
        INC	HL
        INC	HL
        INC	HL
        BIT	7,(IX+30)		; device ?
        JR	NZ,J1EFD		; yep, continue to device check if output handler
J1EFA:	LD	E,-1
        RET

J1EFD:	LD	BC,6
        ADD	HL,BC
        LD	C,(IX+30)		; device flags
        JP	(HL)

J1F05:	BIT	7,(IX+30)		; device ?
        JR	NZ,J1F0F		; yep, continue to device get screen size
        XOR	A
        LD	E,A
        LD	D,A
        RET

J1F0F:	LD	BC,12
        ADD	HL,BC
        JP	(HL)

;	  Subroutine _DELETE
;	     Inputs  ________________________
;	     Outputs ________________________

A1F14:	CALL	C19BC			; open file and create or update FIB
        RET	NZ			; error, quit
        LD	A,0FFH			; delete is recoverable by UNDEL

	IF	OPTM EQ 0
        CALL	C2350			; mark current directory entry deleted and remove FAT chain
        RET
	ELSE
	JP	C2350
	ENDIF

;	  Subroutine _HDELETE
;	     Inputs  B = file handle
;	     Outputs ________________________

A1F1E:	CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        CALL	C22D7			; free file handle
        CALL	C20F2			; update redirect status
        CALL	C224A			; ensure directory entry
        SET	3,(IX+49)		; file deleted
        OR	A
        RET	NZ
        CALL	C1C7A			; get current directory entry
        LD	A,0FFH			; delete is recoverable by UNDEL

	IF	OPTM EQ 0
        CALL	C2350			; mark current directory entry deleted and remove FAT chain
        RET
	ELSE
	JP	C2350
	ENDIF

;	  Subroutine _RENAME
;	     Inputs  ________________________
;	     Outputs ________________________

A1F3B:	PUSH	HL
        CALL	C19BC			; open file and create or update FIB
        POP	BC
        RET	NZ			; error, quit

	IF	OPTM EQ 0
        CALL	C23B6			; rename current directory entry
        RET
	ELSE
	JP	C23B6
	ENDIF

;	  Subroutine _HRENAME
;	     Inputs  B = file handle
;	     Outputs ________________________

A1F45:	PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	BC
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        PUSH	BC
        CALL	C224A			; ensure directory entry
        POP	BC
        OR	A
        RET	NZ
        CALL	C1C7A			; get current directory entry
        CALL	C23B6			; rename current directory entry
        OR	A
        RET	NZ
        CALL	C2288			; update FIB (directory entry changed)
        XOR	A
        RET

;	  Subroutine _MOVE
;	     Inputs  ________________________
;	     Outputs ________________________

A1F60:	PUSH	HL
        CALL	C19BC			; open file and create or update FIB
        POP	BC
        RET	NZ			; error, quit

	IF	OPTM EQ 0
        CALL	C241B			; move current directory entry
        RET
	ELSE
	JP	C241B
	ENDIF

;	  Subroutine _HMOVE
;	     Inputs  B = file handle
;	     Outputs ________________________

A1F6A:	PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	BC
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        PUSH	BC
        CALL	C224A			; ensure directory entry
        POP	BC
        OR	A
        RET	NZ
        CALL	C1C7A			; get current directory entry
        CALL	C241B			; move current directory entry
        OR	A
        RET	NZ			; error, quit
        CALL	C2288			; update FIB (directory entry changed)
        XOR	A
        RET

;	  Subroutine _ATTR
;	     Inputs  ________________________
;	     Outputs ________________________

A1F85:	EX	AF,AF'
        PUSH	HL
        CALL	C19BC			; open file and create or update FIB
        POP	BC
        RET	NZ			; error, quit
        EX	AF,AF'
        OR	A
        CALL	NZ,C24FD		; , update attribute directory entry
        OR	A
        RET	NZ
        CALL	C1C7A			; get current directory entry
        LD	HL,11
        ADD	HL,DE
        LD	L,(HL)
        XOR	A
        RET

;	  Subroutine _HATTR
;	     Inputs  B = file handle
;	     Outputs ________________________

A1F9D:	EX	AF,AF'
        LD	C,L
        CALL	C2140			; get pointer to FIB of file handle
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        EX	AF,AF'
        OR	A
        JR	Z,J1FB9
        PUSH	BC
        CALL	C224A			; ensure directory entry
        POP	BC
        OR	A
        RET	NZ
        CALL	C1C7A			; get current directory entry
        CALL	C24FD			; update attribute directory entry
        RET	NZ
        CALL	C2288			; update FIB (directory entry changed)
J1FB9:	LD	L,(IX+14)		; file attribute
        XOR	A
        RET

;	  Subroutine _FTIME
;	     Inputs  ________________________
;	     Outputs ________________________

A1FBE:	EX	AF,AF'
        PUSH	IX
        PUSH	HL
        CALL	C19BC			; open file and create or update FIB
        POP	BC
        POP	DE
        RET	NZ			; error, quit
        EX	AF,AF'
        OR	A
        CALL	NZ,C2522		; , update timestamp directory entry
        OR	A
        RET	NZ
        CALL	C1C7A			; get current directory entry
        LD	HL,22
        ADD	HL,DE
        LD	E,(HL)
        INC	HL
        LD	D,(HL)
        INC	HL
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A
        XOR	A
        RET

;	  Subroutine _HFTIME
;	     Inputs  B = file handle
;	     Outputs ________________________

A1FE0:	EX	AF,AF'
        PUSH	IX
        PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	BC
        POP	DE
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        EX	AF,AF'
        OR	A
        JR	Z,J1FFF
        PUSH	BC
        PUSH	DE
        CALL	C224A			; ensure directory entry
        POP	DE
        POP	BC
        OR	A
        RET	NZ
        CALL	C2522			; update timestamp directory entry
        RET	NZ
        CALL	C2288			; update FIB (directory entry changed)
J1FFF:	LD	E,(IX+15)
        LD	D,(IX+16)
        LD	L,(IX+17)
        LD	H,(IX+18)
        XOR	A
        RET

;	  Subroutine _HTEST
;	     Inputs  B = file handle
;	     Outputs ________________________

A200D:	PUSH	BC
        CALL	C19BC			; open file and create or update FIB
        POP	BC
        RET	NZ			; error, quit
        BIT	7,(IX+30)		; device ?
        JR	NZ,J2026		; yep,
        PUSH	HL
        CALL	C2140			; get pointer to FIB of file handle
        POP	HL
        RET	NC			; invalid file handle, quit
        RET	Z			; file handle not in use, quit
        LD	B,0FFH
        CALL	C2312			; compare with FIB
        RET	Z
J2026:	XOR	A
        LD	B,A
        RET

;	  Subroutine _FORK
;	     Inputs  ________________________
;	     Outputs ________________________

A2029:
	IF	OPTM EQ 0

	LD	HL,64
        ADD	HL,HL

	ELSE

	LD	HL,2*64

	ENDIF

        CALL	C01CB			; allocate BDOS data block
        RET	NZ			; error, quit
        LD	DE,(DBBF0)		; current start of the proces chain
        LD	(DBBF0),HL		; update start of the proces chain
        LD	(HL),E
        INC	HL
        LD	(HL),D			; chain previous start of the proces chain
        LD	A,D
        OR	E			; no previous proces table ?
        JR	Z,J2063			; yep, skip
        INC	DE
        LD	B,63			; number of file handles = 63
J2042:	PUSH	BC			; store file handle counter
        INC	HL
        INC	DE
        LD	A,(DE)
        LD	C,A
        INC	DE
        LD	A,(DE)			; pointer to FIB of file handle
        LD	B,A
        OR	C			; file handle in use ?
        JR	Z,J205F			; nope, skip
        PUSH	BC
        POP	IX
        BIT	2,(IX+49)		; file handle inheritable ?
        JR	Z,J205F			; nope, skip this file handle
        CALL	C2166			; increase file handle count of FIB
        JR	NZ,J205F		; error, next
        LD	(HL),C
        INC	HL
        LD	(HL),B			; store pointer to FIB
        DEC	HL
J205F:	INC	HL
        POP	BC			; restore file handle counter
        DJNZ	J2042
J2063:	LD	A,(DBBFE)
        LD	B,A
        INC	A
        LD	(DBBFE),A		; increase proces id
        CALL	C20F2			; update redirect status
        XOR	A			; no error
        RET

;	  Subroutine _JOIN
;	     Inputs  ________________________
;	     Outputs ________________________

A2070:	LD	A,B
        OR	A			; proces id = 0 ?
        JR	Z,J207B			; yep, skip check
        LD	HL,DBBFE
        CP	(HL)			; valid proces id ?
        LD	A,.IPROC
        RET	NC			; nope, quit with invalid proces id error
J207B:	CALL	C1290			; free user segments
        LD	HL,(DBBF0)		; start of the proces chain
        PUSH	HL			; store start of the proces chain
J2082:	LD	A,H
        OR	L			; no proces table ?
        JR	Z,J20B3			; yep, skip
        PUSH	BC			; store proces number
        PUSH	HL			; store pointer to proces chain
        CALL	C022B			; free BDOS data block
        LD	B,-1
J208D:	INC	B
        CALL	C2140			; get pointer to FIB of file handle
        JR	NC,J2098		; invalid file handle, continue
        CALL	NZ,C2175		; file handle in use, decrease file handle count of FIB and remove FIB if zero count
        JR	J208D			; next file handle

J2098:	POP	HL			; restore pointer to proces chain
        POP	BC			; restore proces number
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to next proces table
        EX	DE,HL
        LD	(DBBF0),HL		; remove proces table from proces chain
        LD	A,(DBBFE)
        DEC	A
        LD	(DBBFE),A		; decrease proces id
        INC	B
        DEC	B			; proces id = 0 ?
        JR	Z,J2082			; yep, remove next proces table
        CP	B			; reached proces id requested ?
        JR	NZ,J2082		; nope, remove next proces table
        XOR	A
        LD	(DE),A
        DEC	DE
        LD	(DE),A			; end of proces chain
J20B3:	LD	A,B
        LD	(DBBFE),A		; update proces id
J20B7:	POP	HL			; restore start of the proces chain
        LD	A,H
        OR	L			; no proces table ?
        JR	Z,J20D6			; yep, skip
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to next proces table
        PUSH	DE			; store pointer to next proces table
        LD	B,63			; number of file handles = 63
J20C2:	INC	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to FIB of file handle
        PUSH	DE
        POP	IX			; pointer to FIB of file handle
        LD	A,D
        OR	E			; file handle in use ?
        PUSH	HL			; store pointer in proces table
        PUSH	BC			; store file handle counter
        CALL	NZ,C2244		; yep, ensure directory entry (when file is modified)
        POP	BC			; restore pointer in proces table
        POP	HL			; restore file handle counter
        DJNZ	J20C2			; next file handle
        JR	J20B7			; next proces table

J20D6:	LD	A,0FFH			; all drives
        CALL	C2C68			; flush sector buffers of physical drive
        LD	A,(DBBFE)
        OR	A			; current proces id = 0 ?
        JR	NZ,J20EA		; yep, skip
        CALL	A2029			; fork
        CALL	C21C5			; open default file handles
        CALL	C03A0			; clear stored input, console output not duplicated to printer
J20EA:	CALL	C20F2			; update redirect status
        CALL	C09B6			; clear line input buffer
        XOR	A			; no error
        RET

;	  Subroutine update redirect status
;	     Inputs  ________________________
;	     Outputs ________________________

C20F2:	PUSH	BC
        PUSH	DE
        PUSH	HL
        PUSH	IX
        LD	C,0
        LD	B,0			; console input file handle
        CALL	C2140			; get pointer to FIB of file handle
        JR	NC,J210D		; invalid file handle,
        JR	Z,J210D			; file handle not in use,
        LD	A,(IX+30)		; device flags
        AND	81H
        CP	81H			; is this the console input device ?
        JR	Z,J210D
        SET	0,C			; nope, flag console input redirected
J210D:	LD	B,1			; console output file handle
        CALL	C2140			; get pointer to FIB of file handle
        JR	NC,J2121		; invalid file handle,
        JR	Z,J2121			; file handle not in use,
        LD	A,(IX+30)		; deviceflags
        AND	82H
        CP	82H			; is this the console output device ?
        JR	Z,J2121
        SET	1,C			; nope, flag console output redirected
J2121:	LD	A,C
        LD	(DBB89),A		; update console redirection status
        POP	IX
        POP	HL
        POP	DE
        POP	BC
        RET

;	  Subroutine find free file handle
;	     Inputs  ________________________
;	     Outputs B = free file handle, A = error code

C212B:	PUSH	DE
        PUSH	IX
        LD	B,-1
J2130:	INC	B
        CALL	C2140			; get pointer to FIB of file handle
        LD	A,.NHAND
        JR	NC,J213B		; invalid file handle, quit with no free file handles error
        JR	NZ,J2130		; in use, try next file handle
        XOR	A			; found free file handle
J213B:	POP	IX
        POP	DE
        OR	A
        RET

;	  Subroutine get pointer to FIB of file handle
;	     Inputs  B = file handle
;	     Outputs Cx reset if invalid file handle, Cx set if valid. Zx reset if fib found

C2140:	LD	A,B
        CP	63			; valid file handle ?
        JR	NC,J2162		; nope, quit with invalid file handle error
        LD	HL,(DBBF0)		; start of the proces chain
        LD	A,H
        OR	L			; no proces table ?
        JR	Z,J2162			; yep, quit with invalid file handle error
        PUSH	BC			; store file handle
        INC	HL
        INC	HL			; pointer to proces table
        LD	C,B
        LD	B,0
        ADD	HL,BC
        ADD	HL,BC			; pointer to file handle entry
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to FIB of file handle
        DEC	HL
        POP	BC			; restore file handle
        PUSH	DE
        POP	IX			; pointer to FIB of file handle
        LD	A,D
        OR	E			; file handle in use ?
        SCF				; file handle is valid
        LD	A,.NOPEN
        RET

J2162:	LD	A,.IHAND
        OR	A			; file handle is invalid
        RET

;	  Subroutine increase file handle count of FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C2166:	LD	A,(IX-1)		; file handle count
        INC	A			; increase
        JR	Z,J2171			; overflow, quit with no more file handle count
        LD	(IX-1),A		; update file handle count
        XOR	A			; no error
        RET

J2171:	LD	A,.NHAND
        OR	A
        RET

;	  Subroutine decrease file handle count of FIB and remove FIB if zero count
;	     Inputs  ________________________
;	     Outputs ________________________

C2175:	LD	A,(IX-1)
        DEC	A
        LD	(IX-1),A		; decrease file handle count
        RET	NZ			; file file hand count >0, quit
        PUSH	DE
        PUSH	BC
        PUSH	IX
        EX	(SP),HL
        LD	BC,-3
        ADD	HL,BC
        EX	DE,HL
        LD	HL,DBBF2		; start of FIB chain
        CALL	C2192			; remove FIB from chain
        POP	HL
        POP	BC
        POP	DE
        XOR	A			; no error
        RET

;	  Subroutine remove element from chain
;	     Inputs  HL = start of chain, DE = address of element
;	     Outputs ________________________

C2192:	EX	DE,HL
        LD	B,H
        LD	C,L
        CALL	C022B			; free BDOS data block
        EX	DE,HL
J2199:	LD	E,(HL)
        INC	HL
        LD	D,(HL)
        LD	A,D
        OR	E			; end of chain ?
        RET	Z			; yep, then I am done
        EX	DE,HL
        SBC	HL,BC
        ADD	HL,BC
        JR	NZ,J2199		; not the element we are searching, continue in chain
        DEC	DE
        LD	A,(HL)
        LD	(DE),A
        INC	HL
        INC	DE
        LD	A,(HL)
        LD	(DE),A			; link chain past removed element
        RET

;	  Subroutine create FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C21AD:	LD	HL,54
        CALL	C01CB			; allocate BDOS data block
        RET	NZ			; error, quit
        PUSH	DE
        LD	DE,(DBBF2)		; current start of the FIB chain
        LD	(DBBF2),HL
        LD	(HL),E
        INC	HL
        LD	(HL),D			; link the new FIB in front of the chain
        INC	HL
        LD	(HL),01H		; use count=1
        INC	HL
        POP	DE
        RET

;	  Subroutine open default file handles
;	     Inputs  ________________________
;	     Outputs ________________________

C21C5:	LD	B,5
        LD	HL,I21E5
J21CA:	PUSH	BC			; store counter
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to device name
        INC	HL
        LD	B,(HL)			; device flags
        INC	HL
        PUSH	HL			; store pointer in table
        PUSH	BC			; store device flags
        LD	A,B			; device flags
        CALL	A1DA6			; open file handle
        POP	BC			; restore device flags
        OR	A			; error ?
        LD	DE,T2200		; null device name
        LD	A,B			; device flags
        CALL	NZ,A1DA6		; open file handle
        POP	HL			; restore pointer in table
        POP	BC			; restore counter
        DJNZ	J21CA			; next file handle
        RET

I21E5:	defw	T21F4
        defb	101b			; CON read only
        defw	T21F4
        defb	110b			; CON write only
        defw	T21F4
        defb	100b			; CON read & write
        defw	T21F8
        defb	100b			; AUX read & write
        defw	T21FC
        defb	110b			; PRN write only

T21F4:	defb	"CON",0
T21F8:	defb	"AUX",0
T21FC:	defb	"PRN",0
T2200:	defb	"NUL",0 

;	  Subroutine get directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C2204:	BIT	7,(IX+30)		; device ?
        JR	Z,J220F			; nope,
        CALL	C1A25			; create fake directory for device
        XOR	A			; no error
        RET

J220F:	LD	C,(IX+25)		; logical drive id
        LD	B,1			; type = for file
        CALL	C31AB			; check disk change
        OR	A			; error ?
        RET	NZ			; yep, quit
        LD	E,(IX+37)
        LD	D,(IX+38)		; first directory cluster of current directory
        LD	(DBBE8),DE		; cluster number current directory
        PUSH	IX
        EX	(SP),HL
        LD	BC,1
        ADD	HL,BC			; pointer to file name in FIB
        LD	(DBB9E),HL		; update pointer in parse string
        POP	HL
        LD	DE,IB926		; file name buffer
        CALL	C13FF			; parse file name
        OR	A			; error ?
        LD	A,.IFNM
        RET	NZ			; yep, quit with invalid file name error
        LD	DE,IB926		; file name buffer
        LD	(IY+DBBAF-DBB80),4	; search directory entry
        CALL	C1A53			; get directory entry
        OR	A
        RET

;	  Subroutine ensure directory entry (when file is modified)
;	     Inputs  ________________________
;	     Outputs ________________________

C2244:	XOR	A			; no error
        BIT	7,(IX+49)		; file modified ?
        RET	Z			; nope, quit

;	  Subroutine ensure directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C224A:	BIT	3,(IX+49)		; file deleted ?
        LD	A,.HDEAD
        RET	NZ			; yep, quit with file handle dead error
        CALL	C2204			; get directory entry
        RET	NZ			; error, quit
        BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit
        BIT	7,(IX+49)		; file modified ?
        RET	Z			; nope, quit
        CALL	C1BA0			; change time and date directory entry
        PUSH	IX
        EX	(SP),HL
        LD	BC,21
        ADD	HL,BC
        EX	DE,HL			; pointer to filesize FIB
        LD	BC,11
        ADD	HL,BC
        SET	5,(HL)			; set archive bit directory entry
        LD	BC,15
        ADD	HL,BC
        LD	C,(IX+39)
        LD	B,(IX+40)		; start cluster of file
        LD	(HL),C
        INC	HL
        LD	(HL),B			; set start cluster directory entry
        INC	HL
        EX	DE,HL
        LD	BC,4
        LDIR				; set filesize directory entry
        CALL	C2C56			; mark buffer last read as dirty
        POP	HL

;	  Subroutine update FIB (directory entry changed)
;	     Inputs  ________________________
;	     Outputs ________________________

C2288:	CALL	C1C7A			; get current directory entry
        LD	A,(IX+49)		; current open mode

;	  Subroutine setup FIB for open
;	     Inputs  ________________________
;	     Outputs ________________________

C228E:	PUSH	BC
        EX	AF,AF'
        CALL	C1999			; update FIB with directory entry info
        EX	AF,AF'
        AND	07H			; clear unused open mode bits
        LD	(IX+49),A		; open mode
        LD	(IX+32),L
        LD	(IX+33),H		; pointer to drive table
        LD	BC,(DBBDE+4)
        LD	(IX+34),C
        LD	(IX+35),B		; current directory sector
        LD	A,(DBBDE+1)
        SUB	(IY+DBBDE+2-DBB80)
        LD	(IX+36),A		; current directory entry in sector
        LD	BC,(DBBE8)		; cluster number current directory
        LD	(IX+37),C
        LD	(IX+38),B		; cluster number of parent directory
        LD	C,(IX+19)
        LD	B,(IX+20)
        LD	(IX+39),C
        LD	(IX+40),B		; start cluster of file
        LD	(IX+41),C
        LD	(IX+42),B		; current cluster of file = start cluster
        XOR	A
        LD	(IX+43),A
        LD	(IX+44),A		; current relative cluster of file = 0
        POP	BC
        RET

;	  Subroutine free file handle
;	     Inputs  ________________________
;	     Outputs ________________________

C22D7:	CALL	C2175			; decrease file handle count of FIB and remove FIB if zero count
        XOR	A
        LD	(HL),A
        INC	HL
        LD	(HL),A			; clear file handle entry in proces table
        RET

;	  Subroutine check if file is opened by some other FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C22DF:	PUSH	DE
        PUSH	BC
        EX	DE,HL
        PUSH	IX
        POP	BC
        LD	IX,DBBF2+3		; start with begin of the FIB chain
J22E9:	LD	L,(IX-3)
        LD	H,(IX-2)
        LD	A,H
        OR	L
        JR	Z,J230A			; end of chain, quit
        PUSH	DE
        LD	DE,3
        ADD	HL,DE
        POP	DE
        PUSH	HL
        POP	IX			; next FIB block
        OR	A
        SBC	HL,BC
        JR	Z,J22E9			; same as requested, next
        EX	DE,HL
        CALL	C2312			; compare with FIB
        EX	DE,HL
        JR	NZ,J22E9		; , next
        LD	A,.FOPEN
J230A:	PUSH	BC
        POP	IX
        EX	DE,HL
        POP	BC
        POP	DE
        OR	A
        RET

;	  Subroutine compare with FIB
;	     Inputs  IX = pointer to FIB
;	     Outputs ________________________

C2312:	BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit
        LD	A,(DBBDE+1)
        SUB	(IY+DBBDE+2-DBB80)
        CP	(IX+36)			; current directory entry in sector from FIB
        RET	NZ
        PUSH	HL
        LD	DE,(DBBDE+4)		; current directory sector
        LD	L,(IX+34)
        LD	H,(IX+35)		; current directory sector from FIB
        OR	A
        SBC	HL,DE			; same ?
        POP	HL
        RET	NZ			; nope, quit
        LD	E,(IX+32)
        LD	D,(IX+33)
        XOR	A
        SBC	HL,DE
        ADD	HL,DE
        RET	NZ
        PUSH	HL
        PUSH	BC
        LD	HL,25
        ADD	HL,DE
        EX	DE,HL
        PUSH	IX
        POP	HL
        LD	BC,26
        ADD	HL,BC
        CALL	C3311			; compare disk serials
        POP	BC
        POP	HL
        RET

;	  Subroutine mark current directory entry deleted and remove FAT chain
;	     Inputs  A = 0 (deleted is not recoverable), <> 0 (delete is recoverable)
;	     Outputs ________________________

C2350:	LD	C,A
        XOR	A
        BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit
        CALL	C22DF			; check if file is opened by some other FIB
        RET	NZ			; yep, quit with error
        PUSH	HL
        LD	HL,11
        ADD	HL,DE
        LD	B,(HL)			; directory entry attribute
        POP	HL
        BIT	0,B
        LD	A,.FILRO
        RET	NZ			; read only file, quit with error
        BIT	4,B
        JR	Z,J2388			; no directory, skip empty directory check
        CALL	C2553			; check if special subdirectory directory entry
        RET	C			; it is, quit with "invalid operation" error
        CALL	C1BF0			; register free directory entry
        CALL	C1C3A
        CALL	C1C5D			; get first directory entry
J2378:	JR	Z,J2385			; unused directory entry, not need to search futher
        CALL	C2553			; check if special subdirectory directory entry
        LD	A,.DIRNE
        RET	NZ			; not a free or special subdirectory entry, quit with error
        CALL	C1C94			; get next directory entry
        JR	NC,J2378		; there is, try that one
J2385:	CALL	C1C04			; get registered directory entry
J2388:	CALL	C1C7A			; get current directory entry
        LD	A,C
        PUSH	HL
        LD	HL,26
        ADD	HL,DE
        LD	C,(HL)
        INC	HL
        LD	B,(HL)			; starting cluster
        POP	HL
        OR	A
        CALL	NZ,C2ECC		; flag set, set deleted files status disk
        LD	D,B
        LD	E,C			; store starting cluster
        LD	A,D
        OR	E			; does file/directory have a cluster chain ?
        CALL	NZ,C301A		; yes, delete chain
        CALL	C1C7A			; get current directory entry
        PUSH	HL
        LD	HL,12
        ADD	HL,DE
        LD	A,(DE)
        LD	(HL),A			; save 1st character of name
        LD	A,0E5H
        LD	(DE),A			; mark directory entry as deleted
        POP	HL
J23AE:	CALL	C2541			; mark directory entry as changed
        CALL	NZ,C34E9		; , current subdirectory invalid
        XOR	A
        RET

;	  Subroutine rename current directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C23B6:	XOR	A
        BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit
        CALL	C22DF			; check if file is opened by some other FIB
        RET	NZ			; yep, quit with error
        CALL	C2553			; check if special subdirectory directory entry
        RET	C			; it is, quit with error
        LD	(DBB9E),BC		; update pointer in parse string
        PUSH	DE
        LD	DE,IB91B
        CALL	C13FF			; parse file name
        POP	DE
        OR	A
        LD	A,.IFNM
        RET	NZ
        PUSH	HL
        LD	HL,IB91B
        LD	BC,IB91B
        CALL	C160C			; copy name and expand wildcard
        POP	HL
        LD	DE,IB91B
        LD	(DBBAD),DE		; pointer to file name buffer for search directory entry = file name buffer
        LD	A,0FFH			; device name check
        CALL	C1637			; test name
        RET	NZ
        CALL	C2553			; check if special subdirectory directory entry
        RET	C			; it is, quit with error
        CALL	C1BF0			; register free directory entry
        CALL	C1C5D			; get first directory entry
        CALL	C1BD2			; search directory entry
        LD	A,.DUPF
        RET	C			; found, "Duplicate filename" error and quit
        CALL	C1C04			; get registered directory entry
        CALL	C1C7A			; get current directory entry
        PUSH	HL
        PUSH	DE
        LD	HL,IB91B
        LD	B,11
        LD	A,(HL)
        CP	0E5H
        JR	NZ,J2410
        LD	A,05H
J2410:	LD	(DE),A
        INC	HL
        INC	DE
        LD	A,(HL)
        DJNZ	J2410
        POP	DE
        POP	HL
        JP	J23AE

;	  Subroutine move current directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C241B:	XOR	A
        BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit (without error)
        CALL	C22DF			; check if file is opened by some other FIB
        RET	NZ			; yep, quit with error
        CALL	C2553			; check if special subdirectory directory entry
        RET	C			; it is, quit with error
        PUSH	HL			; store pointer to directory entry
        LD	HL,26
        ADD	HL,DE
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A			; starting cluster
        LD	(DBBAB),HL		; store starting cluster
        LD	HL,11
        ADD	HL,DE
        LD	A,(HL)			; directory entry attribute
        POP	HL			; restore pointer to directory entry
        BIT	4,A
        CALL	NZ,C34E9		; it is a subdirectory, current subdirectory invalid
        PUSH	BC
        PUSH	HL			; store pointer to directory entry
        LD	HL,IB91B
        LD	B,8+3
        LD	A,(DE)
        CP	05H			; replacement character for 0E5H ?
        JR	NZ,J244E		; nope,
        LD	A,0E5H			; replace by 0E5H
J244E:	LD	(HL),A
        INC	HL
        INC	DE
        LD	A,(DE)
        DJNZ	J244E
        LD	HL,DBBDE
        LD	DE,IBBC6
        LD	BC,12
        LDIR				; store directory entry locator
        POP	HL			; restore pointer to directory entry
        POP	DE
        LD	C,89H			; parse flags =
        LD	B,(IX+31)		; request attribute
        LD	A,(IX+25)		; logical drive id
        LD	(IY+DBBAF-DBB80),0	; create directory entry
        CALL	C12C3			; parse path
        RET	NZ			; error, quit
        OR	C
        LD	A,.IPATH
        RET	NZ
        BIT	1,(IY+DBBAF-DBB80)
        LD	A,.DIRE
        RET	NZ
        CALL	C1C5D			; get first directory entry
        LD	BC,IB91B
        LD	(DBBAD),BC		; pointer to file name buffer for search directory entry = file name buffer
        CALL	C1BD2			; search directory entry
        LD	A,.DUPF
        RET	C
        CALL	C1C04			; get free directory entry
        RET	NZ
        CALL	C1BF0			; register free directory entry
        PUSH	HL			; store pointer to directory entry
        LD	HL,IBBC6
        LD	DE,DBBDE
        LD	BC,12
        LDIR				; restore directory entry locators
        POP	HL			; restore pointer to directory entry
        CALL	C1C7A			; get current directory entry
        PUSH	HL
        LD	HL,IB8D4
        PUSH	DE
        EX	DE,HL
        LD	BC,32
        LDIR				; save directory entry
        POP	HL
        LD	(HL),0E5H		; mark directory entry as deleted
        CALL	C2C56			; mark buffer last read as dirty
        POP	HL
        CALL	C1C04			; get registered directory entry
        CALL	C1C7A			; get current directory entry
        PUSH	HL
        LD	HL,IB8D4
        LD	BC,32
        PUSH	DE
        LDIR				; restore orginal directory entry
        POP	DE
        POP	HL
        CALL	C2541			; mark directory entry as changed
        RET	Z
        CALL	C34E9			; current subdirectory invalid
        LD	BC,(DBBE8)		; cluster number current directory
        PUSH	BC			; store cluster number current directory
        CALL	C1C3A
        CALL	C1C5D			; get first directory entry
        LD	BC,I256A
        LD	(DBBAD),BC		; pointer to file name buffer for search directory entry = special "root directory" entry
        CALL	C1BD2			; search directory entry
        POP	BC			; restore cluster number current directory
        RET	NC
        AND	10H
        RET	Z
        BIT	7,B
        JR	Z,J24EF
        LD	BC,0
J24EF:	PUSH	HL
        LD	HL,26
        ADD	HL,DE
        LD	(HL),C
        INC	HL
        LD	(HL),B			; update starting cluster
        CALL	C2C56			; mark buffer last read as dirty
        XOR	A
        POP	HL
        RET

;	  Subroutine update attribute directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C24FD:	XOR	A
        BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit
        CALL	C22DF			; check if file is opened by some other FIB
        RET	NZ			; yep, quit with error
        PUSH	HL
        LD	HL,11
        ADD	HL,DE
        LD	A,(HL)			; current attribute
        LD	B,11011101B		; assume directory: ignore archive, hidden
        BIT	4,A			; directory ?
        JR	NZ,J2515		; yep,
        LD	B,11011000B		; file: ignore archive, system, hidden, read only
J2515:	XOR	C
        AND	B
        LD	A,.IATTR
        JR	NZ,J2520
        LD	(HL),C			; update attribute
        CALL	C2C56			; mark buffer last read as dirty
        XOR	A
J2520:	POP	HL
        RET

;	  Subroutine update time stamp directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C2522:	XOR	A
        BIT	7,(IX+30)		; device ?
        RET	NZ			; yep, quit
        CALL	C22DF			; check if file is opened by some other FIB
        RET	NZ			; yep, quit with error
        PUSH	HL
        PUSH	DE
        CALL	C1C7A			; get current directory entry
        LD	HL,22
        ADD	HL,DE			; +22
        EX	DE,HL
        EX	(SP),HL
        EX	DE,HL
        LD	(HL),E
        INC	HL
        LD	(HL),D
        INC	HL
        LD	(HL),C
        INC	HL
        LD	(HL),B
        POP	DE
        POP	HL

;	  Subroutine mark directory entry as changed
;	     Inputs  ________________________
;	     Outputs ________________________

C2541:	PUSH	HL
        LD	HL,11
        ADD	HL,DE
        BIT	4,(HL)
        JR	NZ,J254C
        SET	5,(HL)
J254C:	CALL	C2C56			; mark buffer last read as dirty
        POP	HL
        LD	A,00H
        RET

;	  Subroutine check if special subdirectory directory entry
;	     Inputs  ________________________
;	     Outputs Cx set if special directory entry, Zx set if free or special directory entry

C2553:	PUSH	HL
        PUSH	BC
        LD	HL,I256B		; special "this directory" entry
        XOR	A			; no volume directory entry
        CALL	C15D2			; does directory entry match the search ?
        JR	Z,J2565			; free entry or match, quit
        LD	HL,I256A		; special "root directory" entry
        XOR	A			; no volume directory entry
        CALL	C15D2			; does directory entry match the search ?
J2565:	POP	BC
        POP	HL
        LD	A,.DOT
        RET

I256A:	defb	"."
I256B:	defb	".          "

;	  Subroutine _RDABS
;	     Inputs  ________________________
;	     Outputs ________________________

A2576:	LD	A,1			; read operation, segment type = TPA
        defb	0FEH			; CP xx : trick to skip next instruction

;	  Subroutine _WRABS
;	     Inputs  ________________________
;	     Outputs ________________________

A2579:	XOR	A			; write operation, segment type = TPA
        LD	(DBBC4),A		; store operation flags
        LD	(DBBB4),DE		; store physical sector
        LD	BC,(DTA_AD)		; transfer address
        LD	(DBBC2),BC		; update transfer address
        LD	A,B
        ADD	A,H
        JR	C,J258E
        ADD	A,H
J258E:	LD	A,.OV64K		; check for warparound page3 - page0
        RET	C			; yep, quit
        PUSH	HL
        LD	IX,IB9DA		; buffer
        LD	B,2			; type = flush dirty sector buffers
        LD	C,L
        INC	C
        CALL	C31AB			; check disk change
        POP	BC
        OR	A			; error ?
        RET	NZ			; yep, quit
        CALL	C2C67			; flush sector buffers of drive table
        CALL	C2C77			; mark sector buffers of drive table unused
        CALL	C25B7			; read/write sectors
        CALL	C2C67			; flush sector buffers of drive table
        CALL	C2C77			; mark sector buffers of drive table unused
        LD	DE,9
        ADD	HL,DE			; +9
        LD	(HL),1			; disk change counter = invalid
        XOR	A
        RET

;	  Subroutine read/write sectors
;	     Inputs  DE = transfer address, B = number of sectors, HL = pointer to drive table, IX = pointer to FIB
;	     Outputs ________________________

C25B7:	XOR	A
        CP	B			; number of sectors = 0 ?
        RET	Z			; yep, quit
        LD	A,(DBBC4)		; operation flags
        AND	04H			; segment type
        LD	DE,(DBBC2)		; transfer address
        CALL	C274F			; get segment number
        SET	7,D			; transfer address in page 2
        EX	AF,AF'			; store segment number
        PUSH	HL			; store pointer to drive table
        LD	HL,0C000H-0200H
        OR	A
        SBC	HL,DE			; overflow to page 3 ?
        JR	C,J263A			; yep,
        LD	A,H
        SRL	A
        INC	A			; number of sectors in page 2 +1
        CP	B			; number of sectors requested > number of sectors in page 2 +1 ?
        JR	C,J25DA			; yep, use number of sectors in page 2 +1
        LD	A,B			; use number of sectors requested
J25DA:	LD	C,A			; store number of sectors in this transfer
        POP	HL			; restore pointer to drive table
        SUB	B
        NEG
        LD	B,A
        PUSH	BC
        LD	B,C			; number of sectors in this transfer
        EX	AF,AF'			; restore segment number
        LD	C,A			; store segment number
        PUSH	BC			; store number of sectors this transfer, segment number
        XOR	A			; ignore occured = false
J25E6:	PUSH	BC			; store number of sectors left, segment number
        PUSH	DE			; store transfer address
        PUSH	DE
        EX	(SP),IX			; store pointer to FIB, restore transfer address
        LD	DE,(DBBB4)		; physical sector
        PUSH	DE			; store physical sector
        DEC	A			; ignore occured ?
        JR	Z,J2602			; skip
        LD	A,0			; function = DSKIO read
        BIT	0,(IY+DBBC4-DBB80)	; read operation ?
        JR	NZ,J25FD		; yep,
        LD	A,1			; function = DSKIO write
J25FD:	CALL	C326D			; execute disk driver read/write sectors (with disk check)
        JR	J2604

J2602:	LD	B,1			; number of sectors = 1
J2604:	EX	AF,AF'			; store error code, error flag
        POP	DE			; restore physical sector
        POP	IX			; restore pointer to FIB
        PUSH	HL			; store pointer to drive table
        LD	L,B
        LD	H,0			; number of sectors
        ADD	HL,DE			; update physical sector
        LD	(DBBB4),HL		; store new physical sector
        POP	HL			; restore pointer to drive table
        POP	DE			; restore transfer address
        LD	A,D			; high byte transfer address
        ADD	A,B
        ADD	A,B
        LD	D,A			; new high bytes transfer address = + 512*number of sectors
        LD	A,B
        POP	BC
        SUB	B
        NEG
        LD	B,A
        EX	AF,AF'			; restore error code, error flag
        PUSH	DE			; store new transfer address
        LD	DE,(DBBB4)		; physical sector
        CALL	NZ,C36AC		; error occured, handle error (ignore is valid)
        POP	DE			; restore new transfer address
        INC	B
        DEC	B			; number of sectors left = 0 ?
        JR	NZ,J25E6		; nope, next block
        POP	BC			; restore sectors left, segment number
        CALL	C2651			; update to/from sector buffer
        POP	BC			; restore sectors left, number of sectors
        LD	A,(IY+DBBC2+1-DBB80)	; high byte transfer address
        ADD	A,C
        ADD	A,C
        LD	(IY+DBBC2+1-DBB80),A	; update high byte transfer address
        JP	C25B7			; read/write sectors

J263A:	POP	HL			; restore pointer to drive table
        DEC	B			; update number of sectors left
        PUSH	BC			; store number of sectors left
        LD	DE,512			; number of bytes = 512
        LD	B,E
        LD	C,E			; start offset = 0
        CALL	C26A6			; read/write sector
        POP	BC			; restore number of sectors left
        INC	(IY+DBBB4-DBB80+0)
        JR	NZ,J264E
        INC	(IY+DBBB4-DBB80+1)	; update physical sector
J264E:	JP	C25B7			; read/write sectors

;	  Subroutine update to/from sector buffer
;	     Inputs  DE = sector number, B = number of sectors, C = segment number
;	     Outputs ________________________

C2651:	CALL	C2C8D			; mark sector buffers of drive table
J2654:	PUSH	BC			; store number of sectors, segment number
        EXX
        CALL	C2CBD			; find marked sectorbuffer
        JR	Z,J26A3			; no more, quit
        LD	BC,4
        ADD	HL,BC			; +4
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; sector number of buffer
        EX	DE,HL
        LD	BC,(DBBB4)		; physical sector
        SBC	HL,BC			; offset sector with sector in buffer
        POP	BC			; restore number of sectors, segment number
        LD	A,H
        INC	A			; sector range includes sector in buffer ?
        JR	NZ,J2683		; nope, next buffer
        LD	A,L
        ADD	A,B			; sector range includes sector in buffer ?
        JR	NC,J2683		; nope, next buffer
        DEC	DE
        DEC	DE			; +3
        EX	DE,HL
        BIT	0,(IY+DBBC4-DBB80)	; read operation ?
        JR	NZ,J2686		; yep, check if dirty buffer
        DEC	HL			; +2
        LD	(HL),0			; buffer = invalid
        DEC	HL
        DEC	HL			; +0
        CALL	C2CD5			; sector buffer at start of chain
J2683:	EXX
        JR	J2654			; next buffer

J2686:	BIT	7,(HL)			; sector buffer dirty ?
        JR	Z,J2683			; nope, next buffer
        LD	A,C			; segment number
        EXX
        PUSH	DE			; store sector number
        EXX
        LD	BC,8
        ADD	HL,BC			; +11
        EX	(SP),HL			; store pointer to buffer, restore sector number
        LD	D,E
        LD	E,B			; low byte offset = 0
        ADD	HL,DE
        ADD	HL,DE
        EX	DE,HL
        RES	7,D			; address in page 0
        POP	HL			; restore pointer to buffer
        LD	BC,512			; sector size
        CALL	P0_LDIR			; transfer with page 0
        JR	J2683			; next buffer

J26A3:	EXX
        POP	BC
        RET

;	  Subroutine read/write sector
;	     Inputs  HL = pointer to drive table, IX = pointer to FIB, DE = number of bytes, BC = start offset
;	     Outputs ________________________

C26A6:	PUSH	HL			; store pointer to drive table
        EX	(SP),IX			; store pointer to FIB, restore pointer to drive table
        PUSH	DE			; store number of bytes
        PUSH	BC			; store start offset
        BIT	0,(IY+DBBC4-DBB80)	; read operation ?
        JR	NZ,J26D6		; yep, read sector
        BIT	1,D			; number of bytes = 512 ?
        JR	NZ,J26D9		; yep, read sector skipped
        BIT	1,(IY+DBBC4-DBB80)	; zero write ?
        JR	NZ,J26D6		; yep, read sector first
        PUSH	DE			; store number of bytes
        LD	HL,(DBBC0)		; restore size
        LD	DE,(DBBB2)		; overrun
        OR	A
        SBC	HL,DE			; end of file reached ?
        POP	DE			; restore number of bytes
        JR	C,J26D3			; yep,
        LD	A,B
        OR	C			; offset = 0 ?
        JR	NZ,J26D6		; nope, read sector first
        SBC	HL,DE
        JR	C,J26D9
        JR	J26D6

J26D3:	ADD	HL,BC
        JR	NC,J26D9
J26D6:	LD	B,3			; real read, ignore not problem
        defb	021H			; LD HL,xxxx : trick to skip next instruction

J26D9:	LD	B,2			; no real read, ignore not problem
        LD	DE,(DBBB4)		; physical sector
        CALL	C2B96			; get sector
        POP	DE			; restore start offset
        ADD	HL,DE
        LD	BC,11
        ADD	HL,BC			; pointer in buffer
        POP	BC			; restore size
        PUSH	DE			; store start offset
        PUSH	BC			; store size
        LD	DE,(DBBC2)		; transfer address
        PUSH	DE
        LD	A,(DBBC4)		; to/from, segment type
        CALL	C2711			; segment LDIR
        POP	HL			; restore size
        POP	BC			; restore start offset
        ADD	HL,BC
        LD	(DBBC2),HL		; update transfer address
        BIT	0,(IY+DBBC4-DBB80)	; read operation ?
        CALL	Z,C2C56			; nope, mark buffer last read as dirty
        POP	HL			; restore number of bytes
        ADD	HL,BC			; end offset
        BIT	1,H			; at the end of the sector ?
        LD	HL,(DBBF6)		; last buffer read
        CALL	NZ,C2CD2		; yep, flush sector buffer, sector buffer at start of chain
        EX	(SP),IX			; store pointer to drive table, restore pointer to FIB
        POP	HL			; restore pointer to drive table
        RET

;	  Subroutine segment LDIR
;	     Inputs  DE = address, BC = size, A (b0 = to/from),(b2 = segment type)
;	     Outputs ________________________

C2711:	PUSH	DE
        PUSH	BC
        PUSH	AF
        PUSH	HL
        AND	04H			; segment type
        CALL	C274F			; get segment number
        LD	HL,04000H
        OR	A
        SBC	HL,DE
        SBC	HL,BC
        JR	NC,J2727		; does fit in one page, do all
        ADD	HL,BC
        LD	C,L
        LD	B,H			; only do transfer of first page
J2727:	POP	HL
        EX	(SP),HL
        BIT	0,H
        EX	(SP),HL
        PUSH	BC
        JR	NZ,J2730
        EX	DE,HL
J2730:	CALL	P0_LDIR			; transfer with page 0
        JR	NZ,J2736
        EX	DE,HL
J2736:	POP	BC
        POP	AF
        EX	(SP),HL
        OR	A
        SBC	HL,BC
        LD	B,H
        LD	C,L
        POP	HL
        JR	Z,J274D			; all done, quit
        LD	E,A
        POP	AF
        AND	0C0H
        ADD	A,40H
        LD	D,A
        LD	A,E
        LD	E,0
        JR	C2711			; next

J274D:	POP	DE
        RET

;	  Subroutine get segment number
;	     Inputs  DE = address, A = segment type (0 = TPA, A<>0 = current)
;	     Outputs DE = page 0 based address, A = segment number

C274F:	PUSH	DE			; store address
        PUSH	HL			; store
        LD	HL,P0_TPA		; saved DOS page 0 segment
        OR	A
        JR	Z,J275A
        LD	HL,P0_SEG		; current segment
J275A:	LD	A,D
        AND	0C0H
        RLCA
        RLCA
        LD	E,A
        LD	D,0
        ADD	HL,DE
        LD	A,(HL)
        POP	HL			; restore
        POP	DE			; restore address
        RES	6,D
        RES	7,D			; force to page offset
        RET


	IF	OPTM EQ 1

;	  Subroutine zero write to FIB
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  not used

?276B:	AND	04H			; segment type, operation = write
        OR	02H			; operation = write zero fill
        JR	C2779			; read/write from FIB

	ENDIF

;	  Subroutine write to FIB
;	     Inputs  BC = size, DE = transfer address
;	     Outputs ________________________

C2771:	AND	04H			; segment type, operation = write
        JR	C2779			; read/write from FIB

;	  Subroutine read from FIB
;	     Inputs  BC = size, DE = transfer address
;	     Outputs ________________________

C2775:	AND	04H			; segment type
        OR	01H			; operation = read

;	  Subroutine read/write from FIB
;	     Inputs  BC = size, DE = transfer address, IX = FIB, A = operation flags
;	     Outputs ________________________

C2779:	BIT	7,(IX+30)		; device ?
        JR	NZ,J27C8		; yep,
        LD	(DBBC4),A		; store operation flags
        AND	10H			; no alter file size
        OR	B
        OR	C			; AND size = 0 ?
        RET	Z			; yep, quit
        XOR	A
        LD	(DBBBE+0),A
        LD	(DBBBE+1),A		; size done = 0
        LD	(DBBC0),BC		; store size
        LD	(DBBC2),DE		; store transfer address
        CALL	C2881			; read/write file
        LD	BC,(DBBBE)		; size done
        LD	DE,(DBBC2)		; restore transfer address
J27A1:	LD	L,(IX+45)
        LD	H,(IX+46)		; low word current position in file
        ADD	HL,BC			; + size done
        LD	(IX+45),L
        LD	(IX+46),H		; update low word current position in file
        JR	NC,J27B8		; no carry,
        INC	(IX+47)
        JR	NZ,J27B8		; no carry,
        INC	(IX+48)
J27B8:	OR	A			; error ?
        RET	NZ			; yep, quit with error
        BIT	4,(IY+DBBC4-DBB80)	; alter file size ?
        JR	NZ,J27C6		; yep, quit without error
        LD	A,B
        OR	C			; size done = 0 ?
        LD	A,.EOF
        JR	Z,J27B8			; yep, quit with end of file error
J27C6:	XOR	A			; no error
        RET

; read from or write to device

J27C8:	LD	H,A			; store operation flags
        AND	04H
        LD	(IX+50),A		; store segment type
        LD	A,B
        OR	C			; size = 0 ?
        RET	Z			; yep, quit
        BIT	0,H			; read operation ?
        JR	NZ,J281A		; yep,

; write to device

        LD	L,(IX+28)
        LD	H,(IX+29)		; pointer to device jump table
        INC	HL
        INC	HL
        INC	HL			; device output handler
        PUSH	BC			; store size
J27DF:	PUSH	DE			; store transfer address
        LD	A,(IX+50)		; segment type
        CALL	C274F			; get segment number
        EX	DE,HL
        CALL	RD_SEG			; RD_SEG
        EI
        EX	DE,HL
        POP	DE			; restore transfer address
        BIT	5,(IX+30)		; binary filemode ?
        JR	Z,J27F7			; yep,
        CP	1AH			; EOF ?
        JR	Z,J280F			; yep, finish
J27F7:	PUSH	IX			; store pointer to FIB
        PUSH	BC			; store size left
        PUSH	DE			; store transfer address
        PUSH	HL			; store handler
        CALL	C287D			; call device handler
        POP	HL			; restore handler
        POP	DE			; restore transfer address
        POP	BC			; restore size left
        POP	IX			; restore pointer to FIB
        OR	A			; error ?
        JR	NZ,J2812		; yep,
        INC	DE			; update transfer address
        DEC	BC			; update size left
        LD	A,B
        OR	C			; finished ?
        JR	NZ,J27DF		; nope, again
        JR	J2812			; finish file operation

J280F:	XOR	A			; no error
        INC	DE			; update transfer address
        DEC	BC			; update size left
J2812:	POP	HL			; restore size
        OR	A
        SBC	HL,BC
        LD	B,H
        LD	C,L			; size done = size - size left
J2818:	JR	J27A1			; finish file operation

; read from device

J281A:	LD	L,(IX+28)
        LD	H,(IX+29)		; pointer to device jump table (device input handler)
        PUSH	BC			; store size
        RES	6,(IX+30)		; reset end of file flag
J2825:	PUSH	BC			; store size left
        PUSH	IX			; store pointer to FIB
        PUSH	DE			; store transfer address
        PUSH	HL			; store handler
        CALL	C287D			; call device handler
        POP	HL			; restore handler
        POP	DE			; restore transfer address
        POP	IX			; restore pointer to FIB
        LD	C,0			; reset flags
        OR	A			; error ?
        JR	Z,J284E			; nope,
        CP	.EOF			; EOF character ?
        JR	Z,J2845			; yep, flag end of file
        CP	.EOL			; EOL character ?
        JR	NZ,J286E		; nope, finish file operation
        BIT	2,(IX+30)		; cp/m mode flag
        JR	NZ,J284E		; yep, ignore end of file
        INC	C
J2845:	INC	C
        BIT	5,(IX+30)		; ascii filemode ?
        JR	NZ,J284E		; yep,
        LD	C,0			; reset flags
J284E:	PUSH	DE			; store transfer address
        PUSH	HL			; store handler
        LD	A,(IX+50)		; segment type
        CALL	C274F			; get segment number
        EX	DE,HL
        LD	E,B
        CALL	WR_SEG			; WR_SEG
        EI
        POP	HL			; restore handler
        POP	DE			; restore transfer address
        LD	A,C			; flags
        POP	BC			; restore size left
        DEC	A			; end of file ?
        JR	Z,J2871			; yep, flag end of file and finish file operation
        INC	DE			; update transfer address
        DEC	BC			; update size left
        DEC	A			; end of line ?
        JR	Z,J2875			; yep, finish file operation
        LD	A,B
        OR	C			; finished ?
        JR	NZ,J2825		; nope, again
        JR	J2875			; finish file operation

J286E:	POP	BC			; restore size left
        JR	J2875

J2871:	SET	6,(IX+30)		; set EOF flag
J2875:	POP	HL			; restore size
        OR	A
        SBC	HL,BC
        LD	B,H
        LD	C,L			; size done = size - size left
        JR	J2818			; finish file operation

;	  Subroutine call device handler
;	     Inputs  ________________________
;	     Outputs ________________________

C287D:	LD	C,(IX+30)		; device flags
        JP	(HL)

;	  Subroutine read/write file
;	     Inputs  ________________________
;	     Outputs ________________________

C2881:	LD	A,.HDEAD
        BIT	3,(IX+49)		; file deleted ?
        RET	NZ			; yep, quit with file handle dead error
        LD	A,.ACCV
        BIT	0,(IY+DBBC4-DBB80)	; read operation ?
        JR	Z,J2897			; nope,
        BIT	1,(IX+49)		; file mode = read ?
        RET	NZ			; nope, quit with file access violation error
        JR	J28A3			; continue

J2897:	BIT	0,(IX+49)		; file mode = write ?
        RET	NZ			; nope, quit with file access violation error
        LD	A,.FILRO
        BIT	0,(IX+14)		; file read only ?
        RET	NZ			; yep, quit with file ready only error
J28A3:	BIT	0,(IY+DBBFF-DBB80)	; check enabled ?
        JR	Z,J28B0			; nope, skip check
        LD	HL,(DBBC2)		; restore transfer address
        ADD	HL,BC			; transfer over 64K boundary ?
        LD	A,.OV64K
        RET	C			; yep, quit with 64K overflow error
J28B0:	LD	C,(IX+25)		; logical drive id
        LD	B,1			; type = for file
        CALL	C31AB			; check disk change
        OR	A			; error ?
        RET	NZ			; yep, quit
        CALL	C29D4			; start read/write file
        RET	NZ			; error, quit with error
        LD	BC,(DBBC0)		; restore size
        LD	A,B
        OR	C			; size = 0 ?
        RET	Z			; yep, quit
        LD	DE,(DBBBC)		; cluster number of position in file
        CALL	C2B58			; translate logical cluster to physical cluster
        LD	(DBBB6),DE		; update physical cluster (position in file)
        RET	NZ			; error, quit with error
        LD	BC,(DBBB9)		; offset in sector
        LD	A,B
        OR	C			; offset = 0 ?
        CALL	NZ,C2954		; nope, transfer sector partly
        RET	NZ			; error, quit with error
J28DB:	LD	C,(IY+DBBC0+1-DBB80)	; high byte size
        SRL	C			; number of complete sectors
        JR	Z,J2938			; no complete sectors, handle part of sector
        CALL	C297D			; update to next sector
        RET	NZ			; error, quit with error
        SUB	(IY+DBBBB-DBB80)	; sector in cluster (position in file)
        LD	B,A			; store number of sectors
        LD	DE,(DBBB6)		; physical cluster (position in file)
        CALL	C29B1			; calculate physical sector from physical cluster and sector in cluster
J28F1:	LD	A,B
        ADD	A,(IY+DBBB8-DBB80)
        LD	B,A			; + number of sectors per cluster
        CP	C
        JR	NC,J2918		;  ,block ends
        PUSH	DE			; store cluster number
        CALL	C2DA4			; get FAT entry content
        EX	(SP),HL			; store next cluster number, restore cluster number
        OR	A
        INC	HL
        SBC	HL,DE			; next cluster sequential ?
        JR	NZ,J290F		; nope, block ends
        INC	(IY+DBBBC-DBB80+0)
        JR	NZ,J290C
        INC	(IY+DBBBC-DBB80+1)	; update cluster number of position in file
J290C:	POP	HL			; restore next cluster number
        JR	J28F1			; next cluster

J290F:	ADD	HL,DE
        EX	DE,HL
        DEC	DE
        POP	HL			; restore next physical cluster
        LD	A,(DBBB8)		; number of sectors per cluster
        JR	J291E

J2918:	LD	A,(DBBB8)
        SUB	B
        ADD	A,C
        LD	B,C
J291E:	DEC	A
        LD	(DBBBB),A		; update sector in cluster (position in file)
        LD	(DBBB6),DE		; update physical cluster (position in file)
        PUSH	BC			; store number of sectors
        CALL	C25B7			; read/write sectors
        POP	BC			; restore number of sectors
        SLA	B
        LD	C,0			; size of transfer = number of sectors * 512
        CALL	C29C2			; update size done, size left
        SET	3,(IY+DBBC4-DBB80)	; set must update to next sector flag
        JR	J28DB			; next block

J2938:	LD	BC,0			; start offset = 0
        CALL	C2954			; transfer sector partly
        RET	NZ			; error, quit with error
        LD	DE,(DBBB6)		; physical cluster (position in file)
        LD	(IX+41),E
        LD	(IX+42),D		; update current cluster of file in FIB
        LD	DE,(DBBBC)		; cluster number of position in file
        LD	(IX+43),E
        LD	(IX+44),D		; update current relative cluster of file in FIB
        RET

;	  Subroutine transfer sector partly
;	     Inputs  BC = offset, (0BBC0H) = size, IX = pointer to FIB
;	     Outputs ________________________

C2954:	PUSH	HL			; store
        LD	HL,512
        OR	A
        SBC	HL,BC			; size left in sector
        EX	DE,HL
        LD	HL,(DBBC0)		; restore size
        SBC	HL,DE			; size > size left in sector ?
        JR	NC,J2966		; yep, number of bytes to transfer = size left
        ADD	HL,DE
        LD	E,L
        LD	D,H			; nope, number of bytes to transfer = size
J2966:	LD	A,D
        OR	E			; number of bytes to transfer = 0 ?
        POP	HL			; restore
        RET	Z			; yep, quit without error
        CALL	C297D			; update to next sector
        RET	NZ			; error, quit with error
        CALL	C29B1			; calculate physical sector from physical cluster and sector in cluster
        CALL	C26A6			; read/write sector
        SET	3,(IY+DBBC4-DBB80)	; set must update to next sector flag
        CALL	C29C2			; update size done, size left
        XOR	A			; no error
        RET

;	  Subroutine update to next sector
;	     Inputs  ________________________
;	     Outputs ________________________

C297D:	XOR	A			; no error
        BIT	3,(IY+DBBC4-DBB80)	; must update to next sector ?
        RET	Z			; nope, quit
        RES	3,(IY+DBBC4-DBB80)	; clear must update to next sector flag
        LD	A,(DBBBB)		; sector in cluster (position in file)
        INC	A			; next sector
        CP	(IY+DBBB8-DBB80)	; < number of sectors per cluster ?
        JR	NZ,J29AC		; yep, update and quit
        PUSH	DE
        LD	DE,(DBBBC)		; cluster number of position in file
        INC	DE			; next cluster
        LD	(DBBBC),DE		; update cluster number of position in file
        LD	DE,(DBBB6)		; cluster number (position in file)
        CALL	C2DA4			; get FAT entry content
        LD	(DBBB6),DE		; update physical cluster (position in file)
        BIT	7,D			; end of file cluster ?
        POP	DE
        LD	A,.FILE
        RET	NZ			; yep, quit with file allocation error
        XOR	A			; sector in cluster = 0
J29AC:	LD	(DBBBB),A		; update sector in cluster (position in file)
        XOR	A			; no error
        RET

;	  Subroutine calculate physical sector from physical cluster and sector in cluster
;	     Inputs  ________________________
;	     Outputs ________________________

C29B1:	PUSH	DE
        LD	A,(DBBBB)		; sector in cluster (position in file)
        LD	DE,(DBBB6)		; physical cluster (position in file)
        CALL	C2DD4			; convert cluster number to sector number
        LD	(DBBB4),DE		; physical sector
        POP	DE
        RET

;	  Subroutine update size done, size left
;	     Inputs  ________________________
;	     Outputs ________________________

C29C2:	PUSH	HL
        LD	HL,(DBBBE)		; restore size done
        ADD	HL,BC
        LD	(DBBBE),HL		; update size done
        LD	HL,(DBBC0)		; restore size left
        SBC	HL,BC
        LD	(DBBC0),HL		; update size left
        POP	HL
        RET

;	  Subroutine start read/write file
;	     Inputs  IX = FIB, HL = pointer to drive table
;	     Outputs ________________________

C29D4:	PUSH	HL			; store pointer to drive table
        LD	C,(IX+45)
        LD	B,(IX+46)
        LD	E,(IX+47)
        LD	D,(IX+48)		; current position in file
        PUSH	DE
        PUSH	BC			; store current position in file
        CALL	C2B23			; convert position in file to cluster, sector and offset
        JR	NZ,J2A37		; error, clean up stack and quit with error
        LD	(DBBBC),DE		; store cluster
        LD	(DBBBB),A		; store sector in cluster
        LD	(DBBB9),BC		; store offset in sector
        POP	HL			; restore low word position in file
        LD	DE,(DBBC0)		; restore size
        DEC	DE
        ADD	HL,DE			; update low word position in file + size-1
        EX	(SP),HL			; store low word new position in file, restore high word position in file
        POP	BC			; restore low word new position in file
        EX	DE,HL
        EX	(SP),HL			; store size-1, restore pointer to drive table
        PUSH	HL			; store pointer to drive table
        LD	HL,0
        BIT	4,(IY+DBBC4-DBB80)	; alter file size ?
        JR	Z,J2A09			; nope,
        DEC	HL
J2A09:	ADC	HL,DE			; update high word position in file
        EX	DE,HL
        BIT	7,D
        JR	NZ,J2A80
        POP	HL			; restore pointer to drive table
        PUSH	DE
        PUSH	BC			; store new position in file
        CALL	C2B23			; convert position in file to cluster, sector and offset
        JR	NZ,J2A37		; error, clean up stack and quit with error
        PUSH	DE			; store cluster
        LD	C,(IX+21)
        LD	B,(IX+22)
        LD	E,(IX+23)
        LD	D,(IX+24)		; file size
        LD	A,B
        OR	C			; low word file size = 0 ?
        DEC	BC
        JR	NZ,J2A2D		; nope,
        OR	D
        OR	E			; file size = 0 ?
        DEC	DE
J2A2D:	PUSH	DE
        PUSH	BC			; store
        CALL	NZ,C2B23		; nope,	convert position in file to cluster, sector and offset
        EXX
        POP	HL
        POP	DE			; restore
        EXX
        POP	BC
J2A37:	JR	NZ,J2AB0		; error, clean up stack and quit with error
        EXX
        POP	BC			; restore cluster
        XOR	A
        SBC	HL,BC
        EX	(SP),HL
        EX	DE,HL
        SBC	HL,DE
        EXX
        BIT	7,D
        EX	AF,AF'
        BIT	0,(IY+DBBC4-DBB80)	; read operation ?
        JP	NZ,J2B08		; yep,
        PUSH	HL
        LD	H,B
        LD	L,C
        INC	DE
        OR	A
        SBC	HL,DE
        LD	C,L
        LD	B,H
        INC	BC
        JR	NC,J2A94
        ADD	HL,DE
        EX	DE,HL
        POP	HL
        BIT	4,(IY+DBBC4-DBB80)	; alter file size ?
        JR	Z,J2AC7			; nope,
        CALL	C2B58			; translate logical cluster to physical cluster
        JR	NZ,J2AB2
        PUSH	DE			; store cluster number
        CALL	C2DA4			; get FAT entry content
        BIT	7,D			; end of file cluster ?
        CALL	Z,C301A			; nope, delete chain
        POP	DE			; restore cluster number
        LD	B,0FFH
        CALL	C2DF1			; reset deleted files status disk and set FAT entry
        LD	C,(IX+39)
        LD	B,(IX+40)		; start cluster of file
        SCF
        EX	AF,AF'
        JR	J2AB4

J2A80:	EXX
        EX	AF,AF'
        POP	HL
        LD	E,(IX+39)
        LD	D,(IX+40)		; start cluster of file
        LD	A,D
        OR	E			; file has cluster chain ?
        CALL	NZ,C301A		; yep, delete chain
        PUSH	DE
        LD	BC,0			; start cluster of file = 0
        JR	J2AB4

J2A94:	POP	HL
        LD	A,(IY+DBBC4-DBB80)
        AND	02H			; write zero fill operation ?
        CALL	C2F5E			; allocate clusters
        JR	NZ,J2AB1		; error, quit
        DEC	DE
        BIT	7,D
        JR	NZ,J2AB4
        PUSH	BC
        CALL	C2B58			; translate logical cluster to physical cluster
        POP	BC
        JR	NZ,J2AB1
        CALL	C2DF4			; set FAT entry
        JR	J2AC7

J2AB0:	POP	DE
J2AB1:	POP	DE
J2AB2:	POP	DE
        RET

J2AB4:	LD	(IX+39),C
        LD	(IX+40),B		; update start cluster of file
        XOR	A
        LD	(IX+41),C
        LD	(IX+42),B		; update current cluster of file = start cluster of file
        LD	(IX+43),A
        LD	(IX+44),A		; current relative cluster of file = 0
J2AC7:	SET	7,(IX+49)		; file modified
        EXX
        EX	AF,AF'
        JR	NZ,J2AD1
        JR	NC,J2AE3
J2AD1:	INC	BC
        LD	A,B
        OR	C
        JR	NZ,J2AD7
        INC	DE
J2AD7:	LD	(IX+21),C
        LD	(IX+22),B
        LD	(IX+23),E
        LD	(IX+24),D		; update file size
J2AE3:	POP	BC
        POP	DE
        LD	A,B
        OR	C
        DEC	BC
        JR	NZ,J2AEB
        DEC	HL
J2AEB:	BIT	7,H
        JR	Z,J2AFF
        LD	A,H
        AND	L
        INC	A
        LD	HL,0FFFFH
        JR	NZ,J2B02		; overrun = -1 and quit
        INC	HL			; 0
        SBC	HL,BC
        JR	NZ,J2B02		; update overrun and quit
        DEC	HL
        JR	J2B02			; update overrun and quit

J2AFF:	LD	HL,0			; overrun = 0
J2B02:	LD	(DBBB2),HL		; update overrun
        EXX
        XOR	A			; no error
        RET

J2B08:	EX	AF,AF'
        POP	DE
        EX	(SP),HL
        JR	NZ,J2B19
        JR	NC,J2B20
        EXX
        LD	A,H
        AND	L
        INC	A
        EXX
        JR	NZ,J2B19
        ADD	HL,DE
        JR	C,J2B1C
J2B19:	LD	HL,0FFFFH
J2B1C:	INC	HL
        LD	(DBBC0),HL		; update size
J2B20:	XOR	A
        POP	HL
        RET

;	  Subroutine convert position in file to cluster, sector and offset
;	     Inputs  DEBC = position, HL = pointer to drive table
;	     Outputs DE = relative cluster, A = sector in cluster, HL = offset in sector

C2B23:	PUSH	HL			; store pointer to drive table
        LD	A,B
        SRL	D
        RR	E
        RRA
        LD	B,0
        RL	B
        PUSH	BC			; store offset in sector
        LD	BC,10
        ADD	HL,BC
        PUSH	AF
        AND	(HL)			; cluster mask
        LD	C,A			; store sector in cluster
        LD	A,(HL)
        INC	A
        LD	(DBBB8),A		; store number of sectors per cluster
        POP	AF
        INC	HL
        LD	B,(HL)			; cluster shift
        JR	J2B45

J2B40:	SRL	D
        RR	E
        RRA
J2B45:	DJNZ	J2B40			; relative sector to relative cluster
        INC	D
        DEC	D			; valid relative cluster ?
        JR	NZ,J2B53		; nope,
        BIT	7,E			; valid relative cluster ?
        JR	NZ,J2B53		; nope,
        LD	D,E
        LD	E,A			; relative cluster
        LD	A,C			; sector in cluster
        DEFB	021H			; LD HL,xxxx : trick to skip next instruction

J2B53:	LD	A,.FILE			; file allocation error
        POP	BC			; restore offset in sector
        POP	HL			; restore pointer in drive table
        RET

;	  Subroutine translate logical cluster to physical cluster
;	     Inputs  ________________________
;	     Outputs ________________________

C2B58:	PUSH	HL
        EX	DE,HL
        LD	E,(IX+41)
        LD	D,(IX+42)		; current cluster of file
        LD	A,D
        OR	E
        JR	Z,J2B83
        LD	C,(IX+43)
        LD	B,(IX+44)		; current relative cluster of file
        SBC	HL,BC
        JR	NC,J2B75
        ADD	HL,BC
        LD	E,(IX+39)
        LD	D,(IX+40)		; start cluster of file
J2B75:	EX	(SP),HL
        POP	BC
J2B77:	LD	A,B
        OR	C
        RET	Z
        DEC	BC
        CALL	C2DA4			; get FAT entry content
        BIT	7,D			; end of file cluster ?
        JR	Z,J2B77			; nope,
        DEFB	03EH			; LD A,xx : trick to skip next instruction

J2B83:	POP	HL
        LD	A,.FILE
        OR	A			; file allocation error
        RET

;	  Subroutine get FAT sector
;	     Inputs  ________________________
;	     Outputs ________________________

C2B88:	LD	B,1			; real read, ignore not recommended
        LD	A,(IX+14)		; number of FAT copies
        BIT	0,(IX+24)
        JR	Z,J2B98			; no DOS2 deleted files, all FAT copies
        DEC	A			; more as 1 FAT copy ?
        JR	NZ,J2B98		; yes, do not use the last FAT copy
                                        ; no, there is only 1 to use, use it

;	  Subroutine get sector
;	     Inputs  B = flag (b0 reset do not real read, b1 reset ignore not recommended), IX = pointer to drive table, DE = sector number
;	     Outputs ________________________

C2B96:	LD	A,1			; only one time
J2B98:	LD	(DBBA2),A
        LD	C,(IX+8)		; drive id (1 based)
        LD	HL,(DBBF6)		; last buffer read
        LD	A,H
        SUB	01H
        CALL	NC,C2C44		; buffer contains sector of drive ?
        RET	Z			; yep, quit
        LD	HL,(DBBF8)		; start of the sector buffer chain
        PUSH	HL
J2BAC:	CALL	C2C44			; buffer contains sector of drive ?
        JP	Z,J2C37			; yep,
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A			; pointer to next buffer
        OR	H			; end of chain ?
        JR	NZ,J2BAC		; nope, continue
        POP	HL			; last buffer
        INC	HL
        INC	HL			; +2
        BIT	7,(HL)
        DEC	HL
        LD	A,(HL)
        DEC	HL
        JR	Z,J2BC5			; yep, this buffer
        LD	L,(HL)
        LD	H,A			; pointer to next buffer
J2BC5:	CALL	C2D2D			; flush sector buffer
        PUSH	HL			; store pointer to sector buffer
        INC	HL
        INC	HL			; +2
        LD	(HL),C			; update drive id
        INC	HL			; +3
        LD	A,B
        AND	02H
        LD	(HL),A			; update flag
        INC	HL			; +4
        LD	(HL),E
        INC	HL
        LD	(HL),D			; update sector number
        INC	HL			; +6
        LD	A,(IY+DBBA2-DBB80)
        LD	(HL),A			; times
        INC	HL			; +7
        LD	C,(IX+17)
        LD	(HL),C			; offset = number of sectors per FAT
        INC	HL			; +8
        PUSH	DE			; store sector number
        INC	HL
        INC	HL
        INC	HL			; +11, the buffer itself
        PUSH	HL			; store pointer to buffer
        LD	E,L
        LD	D,H
        INC	DE
        LD	(HL),0
        PUSH	BC
        LD	BC,512-1
        LDIR				; clear buffer
        POP	BC
        EX	(SP),IX			; store pointer to drive table, restore pointer to buffer
        POP	HL			; restore pointer to drive table
        LD	(IX-2),L
        LD	(IX-1),H		; update pointer to drive table
        POP	DE			; restore sector number
        BIT	0,B			; actually read the sector ?
        JR	Z,J2C33			; nope, then finish
J2BFF:	PUSH	BC
        PUSH	DE
        LD	B,(IY+DBBA2-DBB80)	; times
        JR	J2C0C

J2C06:	LD	A,E
        ADD	A,C
        LD	E,A
        JR	NC,J2C0C
        INC	D			; update sector number to next FAT
J2C0C:	PUSH	DE			; store sector number
        PUSH	BC
        LD	B,1			; 1 sector
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,0			; function = DSKIO read
        CALL	C326D			; execute disk driver read/write sectors (with disk check)
        POP	BC
        POP	DE			; restore sector number
        JR	Z,J2C31			; no error,
        CP	.NOUPB			; unexpected disk change ?
        JR	Z,J2C23			; yep,
        DJNZ	J2C06			; try the next copy (for FAT)
J2C23:	POP	DE
        POP	BC
        OR	A			; reset Cx
        BIT	1,B
        JR	NZ,J2C2B
        SCF				; ignore not recommended
J2C2B:	CALL	C36B0			; handle error
        JR	Z,J2BFF			; retry, do it again
        DEFB	0CAH			; JP Z,xxxx : trick to skip next 2 instructions

J2C31:	POP	DE
        POP	BC
J2C33:	EX	(SP),HL
        POP	IX
        DEFB	0FEH			; CP xx : trick to skip next instruction

J2C37:	POP	BC
        SET	1,(IY+DBBA9-DBB80)	; force read directory sector
        LD	(DBBF6),HL		; last buffer read
        CALL	C2CF5			; sector buffer at end of chain
        XOR	A			; no error
        RET

;	  Subroutine buffer contains sector of drive ?
;	     Inputs  ________________________
;	     Outputs ________________________

C2C44:	PUSH	HL
        INC	HL
        INC	HL			; +2
        LD	A,(HL)
        SUB	C			; sector buffer holds sector of requested drive ?
        JR	NZ,J2C54		; nope, quit
        INC	HL
        INC	HL			; +4
        LD	A,(HL)
        SUB	E			; sector buffer holds requested sector ?
        JR	NZ,J2C54		; nope, quit
        INC	HL
        LD	A,(HL)
        SUB	D			; sector buffer holds requested sector ?
J2C54:	POP	HL
        RET

;	  Subroutine mark buffer last read as dirty
;	     Inputs  ________________________
;	     Outputs ________________________

C2C56:	LD	HL,(DBBF6)		; last FAT buffer read
        INC	HL
        INC	HL
        INC	HL			; +3
        SET	7,(HL)			; buffer dirty flag
        RET

;	  Subroutine flush sector buffers of logical drive
;	     Inputs  ________________________
;	     Outputs ________________________

C2C5F:	PUSH	BC
        PUSH	HL
        CALL	C362C			; translate drive assigment and get pointer to drive table
        POP	HL
        POP	BC
        DEFB	0FEH			; CP xx : trick to skip next instruction

;	  Subroutine flush sector buffers of drive table
;	     Inputs  HL = pointer to drive table
;	     Outputs ________________________

C2C67:	DEFB	0F6H			; OR xx : trick to skip next instruction, use drive table

;	  Subroutine flush sector buffers of physical drive
;	     Inputs  A = physical drive id
;	     Outputs ________________________

C2C68:	SCF				; use drive id
        CALL	C2C8B			; mark sector buffers of drive or drive table
        PUSH	HL
J2C6D:	CALL	C2CBD			; find marked sectorbuffer
        JR	Z,J2CBB			; no more,
        CALL	C2D2D			; flush sector buffer
        JR	J2C6D			; next

;	  Subroutine mark sector buffers of drive table unused
;	     Inputs  ________________________
;	     Outputs ________________________

C2C77:	DEFB	0F6H			; OR xx : trick to skip next instruction, use drive table

;	  Subroutine mark sector buffers of physical drive unused
;	     Inputs  A = physical drive id
;	     Outputs ________________________

C2C78:	SCF				; use drive id
        CALL	C2C8B			; mark sector buffers of drive
        PUSH	HL
J2C7D:	CALL	C2CBD			; find marked sectorbuffer
        JR	Z,J2CBB			; no more, quit
        CALL	C2CD5			; sector buffer at start of chain
        INC	HL
        INC	HL			; +2
        LD	(HL),0			; sectorbuffer unused
        JR	J2C7D			; next

;	  Subroutine mark sector buffers of drive or drive table
;	     Inputs  Cx = set, use drive id, Cx = reset, use drive table, A = drive id (Cx set), HL = pointer to drive table (Cx reset)
;	     Outputs ________________________

C2C8B:	JR	C,C2C96			; use physical drive id

;	  Subroutine mark sector buffers of drive table
;	     Inputs  HL = pointer to drive table
;	     Outputs ________________________

C2C8D:	PUSH	HL			; store pointer to drive table
        PUSH	BC
        LD	BC,8
        ADD	HL,BC			; +8
        LD	A,(HL)			; physical drive id
        POP	BC
        POP	HL			; restore pointer to drive table

;	  Subroutine mark sector buffers of drive
;	     Inputs  A = drive id
;	     Outputs ________________________

C2C96:	PUSH	HL
        PUSH	DE
        PUSH	BC
        LD	B,A			; store physical drive id
        LD	HL,(DBBF8)		; start of sector buffer chain
J2C9D:	LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to next sector buffer
        INC	HL
        LD	A,(HL)			; drive id
        INC	HL
        RES	0,(HL)			; unmark sector buffer
        OR	A			; sector buffer unused ?
        JR	Z,J2CB4			; yep, next
        CP	B			; sector buffer holds sector of requested drive ?
        JR	Z,J2CB2			; yep, mark
        RLCA
        JR	C,J2CB4			; yep, next
        LD	A,B
        INC	A			; all drives ?
        JR	NZ,J2CB4		; nope, next
J2CB2:	SET	0,(HL)			; mark sector buffer
J2CB4:	LD	A,D
        OR	E			; end of buffer chain ?
        EX	DE,HL
        JR	NZ,J2C9D		; nope, next
        POP	BC
        POP	DE
J2CBB:	POP	HL
        RET

;	  Subroutine find marked sector buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C2CBD:	LD	HL,(DBBF8)		; start of sector buffer chain
J2CC0:	PUSH	HL
        INC	HL
        INC	HL
        INC	HL			; +3
        BIT	0,(HL)			; sector buffer marked ?
        RES	0,(HL)			; clear sector buffer mark
        POP	HL
        RET	NZ			; yep, quit
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A			; pointer to next sector buffer
        OR	H			; end of buffer chain ?
        JR	NZ,J2CC0		; nope, continue
        RET

;	  Subroutine flush sector buffer, sector buffer at start of chain
;	     Inputs  ________________________
;	     Outputs ________________________

C2CD2:	CALL	C2D2D			; flush sector buffer

;	  Subroutine sector buffer at start of chain
;	     Inputs  HL = pointer to buffer
;	     Outputs ________________________

C2CD5:	PUSH	DE
        LD	DE,(DBBF8)		; start of sector buffer chain
        OR	A
        SBC	HL,DE
        ADD	HL,DE			; sector buffer at the start of buffer chain ?
        JR	Z,J2D1C			; yep, quit
        PUSH	BC
        PUSH	HL			; store pointer to sector buffer
        LD	(DBBF8),HL		; update start of the sector buffer chain
        LD	C,(HL)
        INC	HL
        LD	B,(HL)			; pointer to next sector buffer
        PUSH	BC			; store pointer to next sector buffer
        LD	(HL),D
        DEC	HL
        LD	(HL),E			; update pointer to next sector buffer
        EX	DE,HL
        LD	B,D
        LD	C,E			; pointer to old next buffer
        CALL	C2D1E			; search requested sector buffer
        POP	BC			; restore pointer to next buffer
        JR	J2D16			; update pointer to next buffer and quit

;	  Subroutine sector buffer at end of chain
;	     Inputs  ________________________
;	     Outputs ________________________

C2CF5:	LD	A,(HL)
        INC	HL
        OR	(HL)
        DEC	HL			; end of chain ?
        RET	Z			; yep, quit
        PUSH	DE
        PUSH	BC
        PUSH	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to next buffer
        PUSH	DE			; store pointer to next buffer
        XOR	A
        LD	(HL),A
        DEC	HL
        LD	(HL),A			; end of chain
        LD	B,H
        LD	C,L			; requested buffer = 
        LD	HL,DBBF8		; start at sector buffer chain
        CALL	C2D1E			; search requested sector buffer
        EX	DE,HL
        POP	DE
        LD	(HL),E
        INC	HL
        LD	(HL),D
        DEC	HL
        CALL	C2D1E			; search requested sector buffer
J2D16:	EX	DE,HL
        LD	(HL),C
        INC	HL
        LD	(HL),B
        POP	HL
        POP	BC
J2D1C:	POP	DE
        RET

;	  Subroutine search requested sector buffer
;	     Inputs  HL = pointer to starting buffer, BC = pointer to requested buffer
;	     Outputs HL = pointer to requested buffer, DE = pointer to previous buffer

C2D1E:	LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to next buffer
        DEC	HL
        EX	DE,HL
        LD	A,H
        OR	L			; end of chain ?
        RET	Z			; yep, quit
        SBC	HL,BC
        ADD	HL,BC			; next buffer = requested buffer ?
        JR	NZ,C2D1E		; nope, next
        OR	A
        RET

;	  Subroutine flush sector buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C2D2D:	SET	1,(IY+DBBA9-DBB80)	; force directory sector read
        PUSH	HL
        INC	HL
        INC	HL
        LD	A,(HL)
        OR	A			; buffer not used ?
        JR	Z,J2DA2			; yep, quit
        INC	HL
        BIT	7,(HL)			; buffer changed ?
        JR	Z,J2DA2			; nope, quit
        RES	7,(HL)			; buffer unchanged
        PUSH	DE
        PUSH	BC
        PUSH	IX
J2D43:	PUSH	HL
        BIT	6,(HL)			; update last FAT only ?
        INC	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; sector number
        INC	HL
        LD	B,(HL)			; times
        INC	HL
        JR	Z,J2D59			; nope, skip
        LD	A,E
J2D50:	ADD	A,(HL)			; number of sectors per FAT
        JR	NC,J2D54
        INC	D
J2D54:	DJNZ	J2D50
        LD	E,A			; to the last FAT
        LD	B,1			; 1 FAT
J2D59:	PUSH	DE
        INC	HL
        INC	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; drive table of drive
        INC	HL
        EX	DE,HL
        PUSH	DE
        POP	IX			; IX = sectorbuffer
        LD	C,1
        POP	DE
        PUSH	DE
J2D68:	PUSH	DE
        PUSH	BC
        LD	B,1			; 1 sector
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,1			; function = DSKIO write
        CALL	C326D			; execute disk driver read/write sectors (with disk check)
        POP	BC
        POP	DE
        JR	NZ,J2D7A		; error,
        INC	C
J2D7A:	CP	.NOUPB			; unexpected disk change ?
        JR	NZ,J2D81		; nope,
        LD	BC,0101H		; disk changed, quit writing FAT (flag no FAT copy writen)
J2D81:	PUSH	AF
        LD	A,E
        ADD	A,(IX-4)		; number of sectors per FAT
        LD	E,A
        JR	NC,J2D8A
        INC	D
J2D8A:	POP	AF
        DJNZ	J2D68			; next FAT
        POP	DE
        DEC	C			; writen a copy of the FAT without error ?
        JR	NZ,J2D9B		; yep,
        BIT	1,(IX-8)
        JR	NZ,J2D98
        SCF				; ignore not recommended
J2D98:	CALL	C36B0			; handle error
J2D9B:	POP	HL
        JR	Z,J2D43			; retry, do it again
        POP	IX			; ignore, quit
        POP	BC
        POP	DE
J2DA2:	POP	HL
        RET

;	  Subroutine get FAT entry content
;	     Inputs  DE = cluster number, HL = pointer to drive table
;	     Outputs ________________________

C2DA4:	CALL	C2E55			; find cluster
        JR	Z,J2DB9			; no error, continue
J2DA9:	XOR	A
        LD	(DBBEA),A		; a read diskoperation
        LD	A,.IFAT			; bad file allocation table
        LD	DE,0FFFFH		; no sector number
        CALL	C36AC			; handle error (ignore is valid)
        JR	Z,J2DA9			; retry, again
        JR	J2DD0			; ignore,

J2DB9:	PUSH	HL
        LD	A,(DE)
        LD	L,A
        INC	DE
        LD	A,(DE)
        JR	NC,J2DC5		; even FAT entry
        LD	H,A
        CALL	C2EB6			; shift 4 bits left
        LD	L,H
J2DC5:	AND	0FH
        LD	H,A
        EX	DE,HL
        LD	HL,0FF7H
        SBC	HL,DE			; last cluster in file ?
        POP	HL
        RET	NC			; nope, quit
J2DD0:	LD	DE,0FFFFH		; yep,
        RET

;	  Subroutine convert cluster number to sector number
;	     Inputs  HL = pointer to drive table, DE = cluster number, A = sector in cluster
;	     Outputs ________________________

C2DD4:	PUSH	HL
        PUSH	BC
        LD	BC,11
        ADD	HL,BC
        LD	B,(HL)			; cluster shift
        EX	DE,HL
        DEC	HL
        DEC	HL
        DEFB	00EH			; LD C,xx: trick to skip next instruction

J2DDF:	ADD	HL,HL
        DJNZ	J2DDF
        ADD	A,L
        LD	L,A
        EX	DE,HL
        LD	C,20-11
        ADD	HL,BC
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A			; first datasector
        ADD	HL,DE
        EX	DE,HL
        POP	BC
        POP	HL
        RET

;	  Subroutine reset deleted files status disk and set FAT entry
;	     Inputs  ________________________
;	     Outputs ________________________

C2DF1:	CALL	C2EC0			; reset deleted files status disk

;	  Subroutine set FAT entry
;	     Inputs  BC = cluster number
;	     Outputs ________________________

C2DF4:	PUSH	DE
        LD	A,B
        CP	0FH+1
        JR	C,J2DFD
        LD	BC,0FFFH		; cluster 0F00-FFFF, use endmarker
J2DFD:	CALL	C2E55			; find cluster
        JR	Z,J2E13			; no error,
J2E02:	LD	A,0FFH
        LD	(DBBEA),A		; a write diskoperation
        LD	A,.IFAT			; bad file allocation table
        LD	DE,0FFFFH		; no sector number
        CALL	C36AC			; handle error (ignore is valid)
        JR	Z,J2E02			; retry, loop again
        JR	J2E53			; ignore, quit

J2E13:	PUSH	HL
        JR	C,J2E20
        LD	A,C
        LD	(DE),A
        INC	DE
        LD	A,(DE)
        AND	0F0H
        OR	B
        LD	(DE),A
        JR	J2E2D

J2E20:	LD	H,B
        LD	L,C
        CALL	C2EB6			; shift 4 bits left
        LD	A,(DE)
        AND	0FH
        OR	L
        LD	(DE),A
        INC	DE
        LD	A,H
        LD	(DE),A
J2E2D:	CALL	C2C56			; mark buffer last read as dirty
        BIT	0,(IY+DBBA9-DBB80)	; FAT entry in 2 sectors ?
        JR	Z,J2E52			; nope, quit
        LD	BC,8
        ADD	HL,BC
        LD	(HL),A
        DEC	DE
        LD	A,(DE)
        LD	DE,(DBBA7)		; FAT sector number (if FAT entry in 2 sectors)
        EX	(SP),IX
        PUSH	AF
        CALL	C2B88			; get FAT sector
        CALL	C2C56			; mark buffer last read as dirty
        LD	BC,512+7
        ADD	HL,BC
        POP	AF
        LD	(HL),A
        EX	(SP),IX
J2E52:	POP	HL
J2E53:	POP	DE
        RET

;	  Subroutine find cluster
;	     Inputs  DE = cluster number, HL = pointer to drive table
;	     Outputs ________________________

C2E55:	PUSH	IX
        PUSH	BC
        PUSH	HL
        PUSH	HL
        POP	IX
        RES	0,(IY+DBBA9-DBB80)	; clear FAT entry in 2 sectors flag
        LD	L,(IX+22)
        LD	H,(IX+23)		; number of clusters+1
        XOR	A
        SBC	HL,DE			; valid cluster number ?
        JR	C,J2EB1			; nope, quit
        LD	H,D
        LD	L,E			; cluster number
        ADD	HL,HL
        ADD	HL,DE			; *3
        SRL	H
        RR	L			; *2
        PUSH	AF
        PUSH	HL
        LD	E,H
        SRL	E
        LD	D,A
        LD	L,(IX+12)
        LD	H,(IX+13)		; first FAT sector = number of reserved sectors
        ADD	HL,DE			; + offset in FAT
        EX	DE,HL
        CALL	C2B88			; get FAT sector
        LD	BC,11
        ADD	HL,BC			; pointer to the sector buffer
        POP	BC
        LD	A,B
        AND	01H
        LD	B,A			; offset in FAT sector
        ADD	HL,BC			; pointer in FAT sector buffer
        ADD	A,C			; FAT entry continues in next sector ?
        JR	NC,J2EAC		; nope,
        LD	A,(HL)			; 1st FAT entry byte
        SET	0,(IY+DBBA9-DBB80)	; set FAT entry in 2 sectors flag
        LD	(DBBA7),DE		; store FAT sector number (if FAT entry in 2 sectors)
        LD	(DBBA5+0),A		; store 1st FAT entry byte
        INC	DE			; next sector number
        CALL	C2B88			; get FAT sector
        LD	BC,11
        ADD	HL,BC			; pointer to the sector buffer
        LD	A,(HL)			; 2nd FAT entry byte
        LD	(DBBA5+1),A		; store 2nd FAT entry byte
        LD	HL,DBBA5		; pointer to stored FAT entry
J2EAC:	EX	DE,HL
        POP	AF
        SBC	A,A
        CP	A
        RRCA
J2EB1:	POP	HL
        POP	BC
        POP	IX
        RET

;	  Subroutine shift 4 bits left
;	     Inputs  ________________________
;	     Outputs ________________________

C2EB6:	XOR	A
        ADD	HL,HL
        RLA
        ADD	HL,HL
        RLA
        ADD	HL,HL
        RLA
        ADD	HL,HL
        RLA
        RET

;	  Subroutine reset deleted files status disk
;	     Inputs  ________________________
;	     Outputs ________________________

C2EC0:	PUSH	HL
        EX	(SP),IX
        BIT	0,(IX+24)
        JR	Z,J2F34			; disk was not in deleted files mode, quit
        XOR	A
        JR	J2EDD

;	  Subroutine set deleted files status disk
;	     Inputs  ________________________
;	     Outputs ________________________

C2ECC:	PUSH	HL
        EX	(SP),IX
        BIT	7,(IX+25)
        JR	NZ,J2F34		; disk has not serial number, quit
        BIT	0,(IX+24)
        JR	NZ,J2F34		; disk is already in deleted files mode, quit
        LD	A,1
J2EDD:	PUSH	BC
        PUSH	DE
        LD	B,(IX+14)
        DEC	B
        JR	Z,J2F14			; disk has only 1 FAT,
        LD	E,(IX+12)
        LD	D,(IX+13)		; first FAT sector
        LD	B,(IX+17)		; number of sectors per FAT
J2EEE:	PUSH	BC
        PUSH	AF
        DEC	A
        LD	B,00H			; no real read, ignore not recommended
        JR	NZ,J2EFA		; disk currently in delete file mode,
        CALL	C2B96			; get sector
        JR	J2F07

J2EFA:	CALL	C2B88			; get FAT sector
        CALL	C2D2D			; flush sector buffer
        PUSH	HL
        CALL	C2C56			; mark buffer last read as dirty
        SET	6,(HL)
        POP	HL
J2F07:	CALL	C2CD2			; flush sector buffer, sector buffer at start of chain
        INC	HL
        INC	HL
        LD	(HL),00H		; buffer not used
        POP	AF
        POP	BC
        INC	DE
        DJNZ	J2EEE			; next FAT sector
        LD	B,A
J2F14:	LD	A,B
        CP	(IX+24)
        JR	Z,J2F32
        PUSH	BC
        LD	DE,0
        LD	B,1			; real read, ignore not recommended
        CALL	C2B96			; get sector
        CALL	C2CD5			; sector buffer at start of chain
        CALL	C2C56			; mark buffer last read as dirty
        LD	DE,46
        ADD	HL,DE
        POP	BC
        LD	(HL),B
        LD	(IX+24),B
J2F32:	POP	DE
        POP	BC
J2F34:	EX	(SP),IX
        POP	HL
        RET

;	  Subroutine clear FAT
;	     Inputs  ________________________
;	     Outputs ________________________

C2F38:	LD	DE,0
        LD	C,A
        LD	B,0FH			; cluster 0 is 0FxxH, xx= mediadescriptor
        CALL	C2DF1			; reset deleted files status disk and set FAT entry
        INC	DE
        LD	BC,0FFFFH		; cluster 1 is 0FFFH
        CALL	C2DF1			; reset deleted files status disk and set FAT entry
J2F48:	INC	DE
        LD	BC,0			; free entry
        CALL	C2DF1			; reset deleted files status disk and set FAT entry
        PUSH	HL
        LD	BC,22
        ADD	HL,BC
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A
        SBC	HL,DE			; done all clusters ?
        POP	HL
        JR	NZ,J2F48		; nope, next
        RET

;	  Subroutine allocate clusters
;	     Inputs  HL = drive table, BC = number of clusters, DE = previous cluster in chain (0FFFF if none), A <>0 clears directory
;	     Outputs ________________________

C2F5E:	LD	(DBBAA),A		; update clear cluster flag
        PUSH	DE			; store previous cluster in chain
        PUSH	BC			; store cluster counter
        LD	DE,0FFFFH
        LD	(DBBA3),DE		; no free cluster found
        PUSH	DE			; store no chain allocated flag
        LD	DE,2-1			; start with cluster 2 (first cluster)
        JR	J2F72

J2F70:	PUSH	BC			; store cluster counter
        PUSH	DE			; store no chain allocated flag

J2F72:	INC	DE			; next cluster number
        PUSH	HL			; store pointer to drive table
        LD	BC,22
        ADD	HL,BC
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A			; maximum cluster
        SBC	HL,DE			; no more clusters ?
        POP	HL			; restore pointer to drive table
        JR	C,J2FB7			; yep, quit with disk full error
        PUSH	DE			; store cluster number
        CALL	C2DA4			; get FAT entry content
        LD	A,D
        OR	E			; free cluster ?
        POP	DE			; restore cluster number
        JR	NZ,J2F72		; nope, next cluster
        LD	B,D
        LD	C,E			; store free cluster
        POP	DE			; restore no chain allocated flag
        PUSH	BC			; store free cluster
        BIT	7,D			; chain allocted ?

	IF	OPTM EQ 0
        JR	Z,J2F96			; yep, skip
        LD	(DBBA3),BC		; free cluster found
J2F96:	CALL	Z,C2DF4			; set FAT entry
	ELSE
	JR	Z,J2F99
        LD	(DBBA3),BC		; store first cluster of chain
	CALL	C2DF4			; set FAT entry
J2F99:
	ENDIF

        POP	DE			; restore free cluster (now allocated)
        LD	A,(DBBAA)
        OR	A			; clear cluster ?
        CALL	NZ,C2FC7		; yep, clear directory (cluster)
        POP	BC			; restore cluster counter
	DEC	BC
        LD	A,B
        OR	C
        JR	NZ,J2F70		; next cluster
        LD	BC,0FFFFH		; end cluster
        CALL	C2DF4			; set FAT entry
        CALL	C2EC0			; reset deleted files status disk
        LD	BC,(DBBA3)		; first cluster of allocated chain
        POP	DE			; store previous cluster in chain
        XOR	A			; no error
        RET

J2FB7:	POP	DE
        POP	DE
        LD	DE,(DBBA3)
        BIT	7,D
        CALL	Z,C301A			; , delete chain
        POP	DE
        LD	A,.DKFUL
        OR	A
        RET

;	  Subroutine clear directory (cluster)
;	     Inputs  DE = cluster number
;	     Outputs ________________________

C2FC7:	PUSH	DE			; store directory cluster number
        LD	A,D
        OR	E			; root directory ?
        JR	NZ,J2FE2		; nope,
        PUSH	HL			; store pointer to drive table
        LD	BC,18
        ADD	HL,BC
        LD	C,(HL)
        INC	HL
        LD	B,(HL)			; first sector of root directory
        INC	HL
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; first data sector
        LD	H,D
        LD	L,E
        SBC	HL,BC			; number of sectors root directory
        LD	B,L
        DEC	B			; number of sectors - 1
        DEC	DE			; last directory sector
	POP	HL			; restore pointer to drive table
        JR	J2FED

J2FE2:	PUSH	HL			; store pointer to drive table
        LD	BC,10
        ADD	HL,BC
        LD	B,(HL)			; cluster mask
        POP	HL			; restore pointer to drive table
        LD	A,B			; sector in cluster = last sector
        CALL	C2DD4			; convert cluster number to sector number
J2FED:	LD	A,B
        INC	A			; number of sectors
        POP	BC			; restore cluster number
        PUSH	HL			; store pointer to drive table
        EX	(SP),IX			; store IX, restore pointer to drive table
        PUSH	BC			; store cluster number
        LD	B,A			; number of sectors
J2FF5:	PUSH	BC			; store sector counter

	IF	OPTM EQ 0
        JR	NZ,J2FFB
        CALL	C2CD5			; sector buffer at start of chain
	ELSE
	CALL	Z,C2CD5			; sector buffer at start of chain
	ENDIF

J2FFB:	LD	B,0			; no real read, ignore not recommended
        CALL	C2B96			; get sector
        PUSH	HL			; store pointer to buffer
        LD	BC,11
        ADD	HL,BC			; pointer to buffer
        XOR	A
J3006:	LD	(HL),A
        INC	HL
        LD	(HL),A
        INC	HL
        DJNZ	J3006			; clear sector buffer
        CALL	C2C56			; mark buffer last read as dirty
        POP	HL			; restore pointer to buffer
        POP	BC			; restore sector counter
        DEC	DE			; previous sector
        XOR	A
        DJNZ	J2FF5			; next sector
        POP	DE			; restore cluster number
        EX	(SP),IX			; store pointer to drive table, restore IX
        POP	HL			; restore pointer to drive table
        RET

;	  Subroutine delete chain
;	     Inputs  ________________________
;	     Outputs ________________________

C301A:	PUSH	DE			; store cluster number
        CALL	C2DA4			; get FAT entry content
        POP	BC			; restore cluster number
        PUSH	DE			; store next cluster number
        LD	D,B
        LD	E,C			; cluster number
        LD	BC,0			; free cluster
        CALL	C2DF4			; set FAT entry
        POP	DE			; restore next cluster number
        LD	A,D
        OR	E			; free cluster ?
        RET	Z			; yep, quit
        BIT	7,D			; end of chain ?
        JR	Z,C301A			; nope, next
        RET

;	  Subroutine get format choice string
;	     Inputs  ________________________
;	     Outputs ________________________

C3031:	LD	A,4			; function = CHOICE
        CALL	C34FA			; execute disk driver function
        RET	NZ			; error, quit
        LD	A,E
        OR	D			; null pointer (no choice) ?
        RET	Z			; yep, quit without error
        PUSH	HL
        EX	(SP),IX
        EX	DE,HL
        LD	A,(IX+0)		; slot id
	CALL	C000C			; read byte from slot
        EX	DE,HL
        EX	(SP),IX
        POP	HL
        OR	A			; empty string ?
        LD	A,.IFORM
        RET	Z			; yep, quit with unable to format error
        XOR	A
        RET				; quit without error

;	  Subroutine format disk
;	     Inputs  ________________________
;	     Outputs ________________________

C304E:	BIT	7,A			; sub function = update boot sector ?
        JR	NZ,J305D		; yep, skip format
        LD	E,C
        LD	C,D
        LD	D,B
        LD	B,A			; choice
        LD	A,5			; function = DSKFMT
        CALL	C34FA			; execute disk driver function
        RET	NZ			; error, quit
        INC	A			; update DPB and volume id
J305D:	PUSH	AF			; store sub function
        LD	IX,IB6D4
        LD	DE,0			; sector = 0
        LD	B,1			; number of sectors = 1
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,0			; function = DSKIO read
        CALL	C34FA			; execute disk driver function
        POP	BC			; restore sub function
        RET	NZ			; error, quit
        PUSH	BC			; store sub function
        CALL	C336C			; validate bootsector and update DPB
        LD	DE,1
        JR	NZ,J3081		; not valid, use sector 1
        LD	E,(IX+14)
        LD	D,(IX+15)		; first FAT sector from the DPB
J3081:	LD	B,1			; number of sectors = 1
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,0			; function = DSKIO read
        CALL	C34FA			; execute disk driver function
        POP	BC			; restore sub function
        RET	NZ			; error, quit
        LD	A,(IX+1)
        AND	(IX+2)
        INC	A			; byte 1 and 2 0FFH ?
        JR	NZ,J3104		; nope, not a dos disk error
        LD	A,(IX+0)
        CP	0F8H			; media descriptor 0F8H-0FFH ?
        JR	C,J3104			; nope, not a dos disk error
        LD	C,A			; media descriptor
        PUSH	BC			; store sub function, media descriptor
        LD	DE,0			; sectors = 0
        LD	B,1			; number of sectors = 1
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,0			; function = DSKIO read
        CALL	C34FA			; execute disk driver function
        POP	BC			; restore sub function, media descriptor
        RET	NZ			; error, quit
        PUSH	BC			; store sub function, media descriptor
        LD	A,C			; media descriptor
        CALL	C33A8			; update BPB boot sector from DPB
        POP	BC			; restore sub function, media descriptor
        RET	NZ			; error, quit
        BIT	0,B			; write volume id ?
        JR	Z,J30F5			; nope, write bootsector and quit
        PUSH	HL
        CALL	C32E9			; get pointer to disk serial of bootsector
        JR	Z,J30D7			; has disk serial,
        LD	HL,I3112
        LD	DE,IB6D4+0001EH
        LD	BC,0099H
        LDIR				; copy DOS2 bootloader
        EX	DE,HL
        LD	DE,0FFB7H
J30D0:	LD	(HL),B
        INC	HL
        INC	DE
        LD	A,D
        OR	E
        JR	NZ,J30D0		; and clear the remainer
J30D7:	LD	HL,(RANDOM+0)
        LD	A,(RANDOM+2)
        LD	B,A
        XOR	A
        SRL	L
        RLA
        SRL	H
        RLA
        SRL	B
        RLA
        LD	C,A
        LD	(IB6D4+00027H+0),HL
        LD	(IB6D4+00027H+2),BC	; serial number disk
        XOR	A
        LD	(IB6D4+00026H),A
        POP	HL
J30F5:	LD	DE,0			; sector = 0
        LD	B,1			; number of sectors = 1
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,1			; function = DSKIO write

	IF	OPTM EQ 0
        CALL	C34FA			; execute disk driver function
        RET
	ELSE
	JP	C34FA
	ENDIF

J3104:	LD	A,.NDOS
        RET

I3107:	defb	0EBH,0FEH               ; x86 JMP +256
        defb	090H                    ; x86 NOP
        defb	"MSXDOS23"

I3112:
        .DEPHASE
        .PHASE	0C01EH

RC01E:	jr	RC030
        defb	"VOL_ID"
        defb	0
        defw	0FFFFH,0FFFFH
        defs	5
RC030:	ret	nc
        ld	(RC069+1),de
        ld	(RC071+1),a
        ld	(hl),LOW RC067
        inc	hl
        ld	(hl),HIGH RC067
RC03D:	ld	sp,KBUF+256
        ld	de,RC0AB
        ld	c,00FH
        call	BDOS
        inc	a
        jr	z,RC071
        ld	de,00100H
        ld	c,01AH
        call	BDOS
        ld	hl,1
        ld	(RC0AB+14),hl
        ld	hl,04000H-00100H
        ld	de,RC0AB
        ld	c,027H
        call	BDOS
        jp	00100H

RC067:	defw	RC069

RC069:	call	0
        ld	a,c
        and	0FEH
        sub	002H
RC071:	or	000H
        jp	z,BASENT
        ld	de,RC085
        ld	c,009H
        call	BDOS
        ld	c,007H
        call	BDOS
        jr	RC03D

RC085:	defb	"Boot error",13,10
        defb	"Press any key for retry",13,10
        defb	"$"

RC0AB:	defb	0,"MSXDOS  SYS"

RC0B7:
        .DEPHASE
        .PHASE	I3112+RC0B7-RC01E


;	  Subroutine check disk change
;	     Inputs  C = drive, B = type (0 = for disk, 1 = for file, 2 = flush dirty sector buffers), IX = pointer to FIB
;	     Outputs ________________________

C31AB:	LD	A,C			; logical drive id
        CALL	C362C			; translate drive assigment and get pointer to drive tabel
        LD	(DBBEB),A		; store physical drive id
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to drive table
        LD	A,D
        OR	E			; drive table in use ?
        LD	A,C			; error = invalid drive
        RET	Z			; nope, quit with error
        PUSH	DE			; store pointer to drive table
        DEC	B			; type = for file ?
        JR	NZ,J3229		; nope,

; for file

J31BD:	PUSH	IX
        POP	HL			; pointer to FIB
        LD	BC,26
        ADD	HL,BC
        EX	DE,HL			; DE = pointer disk serial of FIB
        POP	HL			; restore pointer to drive table
        CALL	C364D			; update disk change counter of all drives
        PUSH	IX
        PUSH	HL
        LD	C,9
        ADD	HL,BC			; +9
        LD	A,(HL)			; disk change counter
        OR	A
        JR	Z,J31E4			; initialize, do not flush dirty sector buffers of drive
        LD	C,10H
        ADD	HL,BC			; disk serial of drive table
        LD	C,A
        PUSH	DE
        CALL	C3311			; compare disk serials drive table and FIB
        POP	DE
        JR	Z,J31ED			; equal,
        LD	A,(DBBEB)		; physical drive id
        CALL	C2C68			; flush sector buffers of physical drive
J31E4:	POP	HL
        CALL	C331B			; read bootsector and make valid
        PUSH	HL
        LD	C,1			; flag update drive table
        JR	J31FF

J31ED:	POP	HL
        PUSH	HL
        DEC	C
        JR	Z,J31FA			; special value 1 (ERROR), skip disk change check (as if disk is changed)
        DEC	C
        JR	NZ,J3217		; within 0.5 seconds of last diskoperation of drive, assume disk is unchanged, quit
        CALL	C32B2			; get disk change status
        JR	Z,J3217			; unchanged,
J31FA:	CALL	C331B			; read bootsector and make valid
        LD	C,0			; flag do not update drive table
J31FF:	CALL	C3273			; restart disk change counter
        PUSH	DE
        CALL	C32E9			; get pointer to disk serial of bootsector
        POP	DE
        CALL	C3311			; compare disk serials
J320A:	POP	HL
        PUSH	HL
        JR	NZ,J3219		; not equal, error!
        DEC	C
        JR	NZ,J3217		; do not update drive table, quit
        CALL	C3427			; update drive table and DPB from BPB boot sector
        CALL	C2C77			; mark sector buffers of drive table unused
J3217:	JR	J3268			; quit

J3219:	LD	A,.WFILE		; "wrong disk for file" error
        LD	DE,0FFFFH
        CALL	C36AF			; handle error (ignore not recommended)
        POP	HL
        JR	NZ,J324F		; ignore, update drive table and serials
        POP	IX
        PUSH	HL
        JR	J31BD			; retry, check again

J3229:	POP	HL
        CALL	C2C67			; flush sector buffers of drive table
        CALL	C364D			; update disk change counter of all drives
        PUSH	IX
        PUSH	HL
        LD	DE,9
        ADD	HL,DE			; +9
        LD	A,(HL)			; disk change counter
        POP	HL
        DEC	B			; type = flush dirty sector buffers ?
        JR	Z,J3255			; yep, skip
        OR	A
        JR	Z,J324C			; initialize, treat as disk changed
        DEC	A
        JR	Z,J324C			; invalid, treat as disk changed
        DEC	A
        JR	NZ,J3258		; within 0.5 seconds of last diskoperation of drive, skip
        CALL	C32B2			; get disk change status
        JR	C,J324C			; disk driver does not know, treat this as disk changed
        JR	Z,J3258			; unchanged,
J324C:	CALL	C331B			; read bootsector and make valid
J324F:	CALL	C3427			; update drive table and DPB from BPB boot sector
        CALL	C2C77			; mark sector buffers of drive table unused
J3255:	CALL	C3273			; restart disk change counter
J3258:	POP	DE
        PUSH	DE
        PUSH	HL
        LD	BC,25
        ADD	HL,BC			; disk serial of drive table
        EX	DE,HL
        LD	C,26
        ADD	HL,BC			; disk serial of FIB
        EX	DE,HL
        LD	C,4
        LDIR				; copy drive table disk serial to FIB disk serial
J3268:	POP	HL
        POP	IX
        XOR	A			; no error
        RET

;	  Subroutine execute disk driver read/write sectors (with disk check)
;	     Inputs  A = function (0 = read sectors, 1 = write sectors)
;	     Outputs ________________________

RW_UNIT:
C326D:	CALL	C3282			; validate if same disk
        CALL	C34FA			; execute disk driver function

;	  Subroutine restart disk change counter
;	     Inputs  ________________________
;	     Outputs ________________________

SET_TIMEOUT:
C3273:	PUSH	HL			; store pointer to drive table
        CALL	C364D			; update disk change counter of all drives
        EX	(SP),IX			; store IX, restore pointer to drive table
        LD	(IX+9),2+5		; next 0.5 seconds no disk change
        EX	(SP),IX			; store pointer to drive table, restore IX
        POP	HL			; restore pointer to drive table
        OR	A
        RET

;	  Subroutine validate if same disk
;	     Inputs  HL = pointer to drive table
;	     Outputs ________________________

VAL_SAME:
C3282:	CALL	C364D			; update disk change counter of all drives
        PUSH	AF
        PUSH	DE
        PUSH	HL
        LD	DE,9
        ADD	HL,DE			; +9
        LD	A,2
        CP	(HL)			; disk change counter = initialize or invalid ?
        POP	HL
        JR	C,J32AF			; yep, quit
        PUSH	BC
        CALL	Z,C32B2			; disk change counter finished, get disk change status
        JR	Z,J32AE			; unchanged, quit
        PUSH	IX
J329A:	CALL	C331B			; read bootsector and make valid
        CALL	C32D3			; compare disk serial bootsector and drive table
        JR	Z,J32AC			; equal, quit
        LD	A,.WDISK		; "Wrong disk" error
        LD	DE,0FFFFH
        CALL	C36AF			; handle error (ignore not recommended)
        JR	J329A			; check again

J32AC:	POP	IX
J32AE:	POP	BC
J32AF:	POP	DE
        POP	AF
        RET

;	  Subroutine get disk change status
;	     Inputs  ________________________
;	     Outputs Zx set = unchanged, Zx reset = changed, Cx set = disk driver does not know

_MCHECK:
C32B2:	PUSH	BC
        PUSH	DE
        LD	A,2			; function = DSKCHG
        CALL	C34FA			; execute disk driver function
        JR	Z,J32C5			; no error,
        CP	.NRDY			; not ready ?
        LD	DE,0FFFFH
        CALL	Z,C36AF			; yep, handle error (ignore not recommended)
        LD	B,0FFH			; "disk changed"
J32C5:	DEC	B			; disk unchanged ?
        JR	Z,J32D0			; yep, quit with unchanged
        INC	B			; disk changed ?
        JR	NZ,J32D0		; yep, quit with changed
        LD	A,(DSK_CHK)
        INC	A			; if disk check level weak, return unchanged status
        SCF				; if disk check level strong, return changed status
J32D0:	POP	DE
        POP	BC
        RET

;	  Subroutine compare disk serial boot sector and drive table
;	     Inputs  IX = pointer to bootsector, HL = pointer to drive table
;	     Outputs ________________________

TEST_SAME_DISK:
C32D3:	PUSH	HL
        CALL	C32E9			; get pointer to disk serial of bootsector
        EX	DE,HL
        POP	HL
        PUSH	HL
        LD	BC,25
        ADD	HL,BC
        CALL	C3311			; compare disk serials
        JR	NZ,J32E7
        LD	A,(HL)
        CP	(IX+21)
J32E7:	POP	HL
        RET

;	  Subroutine get pointer to disk serial
;	     Inputs  IX = pointer to bootsector
;	     Outputs HL = pointer to disk serial

GET_VOLID:
C32E9:	PUSH	IX
        POP	HL
        LD	DE,32
        ADD	HL,DE
        LD	DE,I3306
        LD	B,6
J32F5:	LD	A,(DE)
        CP	(HL)
        JR	NZ,J3300
        INC	HL
        INC	DE
        DJNZ	J32F5
        INC	HL
        XOR	A
        RET

J3300:	LD	HL,I330D
        XOR	A
        DEC	A
        RET

I3306:	defb	"VOL_ID",0

I330D:	defw	0FFFFH,0FFFFH

;	  Subroutine compare disk serials
;	     Inputs  ________________________
;	     Outputs ________________________

CP_VOLID:
C3311:	LD	B,4
J3313:	LD	A,(DE)
        SUB	(HL)
        RET	NZ
        INC	DE
        INC	HL
        DJNZ	J3313
        RET

;	  Subroutine read bootsector and make valid
;	     Inputs  ________________________
;	     Outputs ________________________

BUILD_UPD:
C331B:	PUSH	BC
        PUSH	DE
        LD	IX,IB6D4
J3321:	LD	DE,0			; sector = 0
        LD	B,1			; number of sectors = 1
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,0			; function = DSKIO read
        CALL	C34FA			; execute disk driver function
        JR	NZ,J3364		; error,
        CALL	C336C			; validate bootsector and update BPB
        JR	Z,J335F			; valid, quit
        LD	DE,1			; sector = 1
        LD	B,1			; number of sectors = 1
        LD	A,(DATA_S)
        LD	C,A			; BDOS datasegment
        LD	A,0			; function = DSKIO read
        CALL	C34FA			; execute disk driver function
        JR	NZ,J3364		; error,
        LD	A,(IX+1)
        AND	(IX+2)
        INC	A			; byte 1 and 2 must be 0FFH
        JR	NZ,J3362		; invalid FAT, not a dos disk and quit
        LD	A,(IX+0)
        CP	0F8H			; media descriptor must be 0F8H-0FFH
        JR	C,J3362			; invalid mediadescriptor, not a dos disk and quit
        CALL	C33A8			; update BPB boot sector from DPB
        JR	NZ,J3364		; error,
        LD	(IX+32),00H
J335F:	POP	DE
        POP	BC
        RET

J3362:	LD	A,.NDOS
J3364:	LD	DE,0FFFFH
        CALL	C36AF			; handle error (ignore not recommended)
        JR	J3321			; try again

;	  Subroutine validate boot sector and update DPB
;	     Inputs  IX = pointer to boot sector, HL = pointer to DPB
;	     Outputs ________________________

FIND_UPB:
C336C:	PUSH	IX			; store pointer to boot sector
        EX	(SP),HL			; store pointer to DPB, restore pointer to boot sector
        LD	DE,11
        ADD	HL,DE
        LD	D,(HL)
        INC	HL
        LD	A,(HL)
        INC	HL
        SUB	02H
        OR	D			; sectorsize 512 ?
        JR	NZ,J33A5		; nope, quit with error
        OR	(HL)
        JR	Z,J33A5			; cluster size 0, quit with error
        NEG
        AND	(HL)
        CP	(HL)			; cluster size a power of 2 ?
        INC	HL
        JR	NZ,J33A5		; nope, quit with error
        INC	HL
        INC	HL
        LD	A,(HL)			; number of FAT copies
        DEC	A
        CP	7
        JR	NC,J33A5		; not 1-7, quit with error
        LD	DE,6
        ADD	HL,DE
        LD	A,(HL)			; number of FAT sectors
        INC	HL
        DEC	A
        CP	0CH
        JR	NC,J33A5		; low byte not 1-12, quit with error
        LD	A,(HL)
        OR	A
        POP	HL
        LD	B,(IX+21)		; media descriptor
        LD	A,3			; function = GETDPB

	IF	OPTM EQ 0
        CALL	Z,C34FA			; high byte zero (ok), execute disk driver function
        RET
	ELSE
	RET	NZ			; high byte not zero, quit with error
	JP	C34FA			; execute disk driver function
	ENDIF

J33A5:	POP	HL
        OR	H
        RET

;	  Subroutine update BPB boot sector from DPB 
;	     Inputs  HL = pointer to drive table, IX = pointer to boot sector buffer
;	     Outputs ________________________

C33A8:	LD	B,A			; media descriptor
        LD	A,3			; function = GETDPB
        CALL	C34FA			; execute disk driver function
        RET	NZ			; error, quit
        PUSH	HL			; store pointer to drive table
        LD	DE,2
        ADD	HL,DE			; +2
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to DPB
        PUSH	DE			; store pointer to DPB
        EX	(SP),IX			; store pointer to boot sector buffer, restore pointer to DPB
        POP	HL			; restore pointer to boot sector buffer
        PUSH	HL			; store pointer to boot sector buffer
        LD	DE,11
        ADD	HL,DE			; +11
        LD	C,(IX+2)
        LD	B,(IX+3)		; sector size (DPB)
        LD	(HL),C
        INC	HL
        LD	(HL),B			; update sector size (BPB)
        INC	HL
        LD	A,(IX+6)		; cluster mask (DPB)
        INC	A
        LD	(HL),A			; update sectors per cluster (BPB)
        INC	HL
        LD	C,(IX+8)
        LD	B,(IX+9)		; first FAT sector (DPB)
        LD	(HL),C
        INC	HL
        LD	(HL),B			; first FAT sector (BPB)
        INC	HL
        LD	A,(IX+10)		; number of FAT copies (DPB)
        LD	(HL),A			; number of FATs (BPB)
        INC	HL
        EX	DE,HL
        LD	L,(IX+12)
        LD	H,(IX+13)		; first data sector (DPB)
        PUSH	HL			; store first data sector
        LD	C,(IX+17)
        LD	B,(IX+18)		; first root directory sector (DPB)
        OR	A
        SBC	HL,BC			; number of root directory sectors = first data sector - first root directory sector
        LD	B,(IX+5)		; directory shift
J33F3:	ADD	HL,HL
        DJNZ	J33F3
        DEC	HL
        LD	L,(IX+11)		; number of root directory entries (DPB)
        DEC	L
        INC	HL
        EX	DE,HL
        LD	(HL),E
        INC	HL
        LD	(HL),D			; number of root directory entries (BPB)
        INC	HL
        EX	DE,HL
        LD	L,(IX+14)
        LD	H,(IX+15)		; maximum cluster (DPB)
        DEC	HL			; number of clusters
        LD	B,(IX+7)		; cluster shift (DPB)
        DEFB	00EH			; LD C,xx : trick to skip next instruction

J340D:	ADD	HL,HL
        DJNZ	J340D
        POP	BC			; restore first data sector
        ADD	HL,BC			; total number of sectors = first data sector + number of clusters * sectors per cluster
        EX	DE,HL
        LD	(HL),E
        INC	HL
        LD	(HL),D			; update number of sectors (BPB)
        INC	HL
        LD	A,(IX+1)		; media descriptor (DPB)
        LD	(HL),A
        INC	HL			; update media descriptor (BPB)
        LD	A,(IX+16)		; number of sectors per FAT (DPB)
        LD	(HL),A
        INC	HL
        XOR	A
        LD	(HL),A			; update number of sectors per FAT (BPB)
        POP	IX			; restore pointer to boot sector buffer
        POP	HL			; restore pointer to drive table
        RET

;	  Subroutine update drive table and DPB from BPB boot sector
;	     Inputs  HL = pointer to drive table, IX = pointer to boot sector
;	     Outputs ________________________

C3427:	PUSH	HL			; store pointer to drive table
        LD	BC,10
        ADD	HL,BC			; +10
        LD	A,(IX+13)		; logical sectors per cluster
        DEC	A
        LD	(HL),A			; cluster mask
        INC	HL
        LD	C,1-1
J3434:	INC	C
        RRCA
        JR	C,J3434
        LD	(HL),C			; update cluster shift
        INC	HL
        LD	E,(IX+14)
        LD	(HL),E
        INC	HL
        LD	D,(IX+15)
        LD	(HL),D			; first FAT sector = number of reserved sectors
        INC	HL
        PUSH	DE			; store first FAT sector
        LD	B,(IX+16)		; number of FATs
        LD	(HL),B			; update number of FATs
        INC	HL
        LD	E,(IX+17)
        LD	D,(IX+18)		; first root directory sector
        LD	A,E			; low byte first root directory sector
        AND	0FH			; directory mask
        LD	(HL),A			; number of directory entries in remainder sector
	LD	A,4			; directory shift
J3456:	SRL	D
        RR	E
        DEC	A
        JR	NZ,J3456		; number of directory sectors (complete sectors)
        CP	(HL)			; incomplete directory sector ?
        INC	HL
        LD	(HL),E			; update number of complete directory sectors
        INC	HL
        JR	NC,J3464
        INC	DE			; incomplete sector, directory sectors +1
J3464:	LD	A,(IX+22)		; sectors per FAT
        LD	(HL),A			; update number of sectors per FAT
        INC	HL
        EX	(SP),HL			; store pointer, restore first FAT sector
        PUSH	DE			; store number of directory sectors
        LD	E,A			; number of sectors per FAT
        XOR	A			; low byte = 0
        LD	D,A			; high byte = 0
J346E:	ADD	A,E
        JR	NC,J3472
        INC	D
J3472:	DJNZ	J346E
        LD	E,A			; number of FAT sectors = number of sectors per FAT * number of FATs
        ADD	HL,DE			; first directory sector = first FAT sector + number of FAT sectors
        EX	DE,HL
        POP	HL			; restore number of directory sectors
        ADD	HL,DE			; first data sector = number of directory sectors + first directory sector
        EX	(SP),HL			; store first data sector, restore pointer
        LD	(HL),E
        INC	HL
        LD	(HL),D			; update first directory sector
        INC	HL
        POP	DE			; restore first data sector
        LD	(HL),E
        INC	HL
        LD	(HL),D			; update first data sector
        INC	HL
        PUSH	HL			; store pointer
        LD	L,(IX+19)
        LD	H,(IX+20)		; total logical sectors
        OR	A
        SBC	HL,DE			; number of data sectors = total logical sectors - first data sector
J348D:	DEC	C			; cluster shift done ?
        JR	Z,J3496			; yep, continue
        SRL	H
        RR	L			; shift right
        JR	J348D			; next

J3496:	INC	HL			; maximum cluster number = number of clusters +1
        EX	DE,HL
        POP	HL			; restore pointer
        LD	(HL),E
        INC	HL
        LD	(HL),D			; update maximum cluster number
        INC	HL
        PUSH	HL			; store pointer
        CALL	C32E9			; get pointer to disk serial of bootsector
        POP	DE			; restore pointer
        DEC	HL
        LD	BC,5
        LDIR				; update disk serial
        EX	DE,HL
        LD	A,(IX+21)		; media descriptor
        LD	(HL),A			; update media descriptor
        POP	HL			; restore pointer to drive table
        PUSH	HL			; store pointer to drive table
        INC	HL
        INC	HL			; +2
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to DPB
        EX	DE,HL
        INC	HL
        LD	(HL),A			; update DPB media sescriptor
        INC	HL
        LD	(HL),LOW 512
        INC	HL
        LD	(HL),HIGH 512		; update DPB sector size
        INC	HL
        LD	(HL),0FH
        INC	HL			; update DPB directory mask
        LD	(HL),04H
        INC	HL			; update DPB directory shift
        EX	DE,HL
        LD	BC,7
        ADD	HL,BC			; +10
        LD	BC,5
        LDIR				; update DPB cluster mask, cluster shift, first FAT sector, number of FATs
        LD	C,(HL)			; number of directory entries in incomplete sector
        INC	HL
        LD	A,(HL)			; number of complete directory sectors
        INC	HL
        ADD	A,A
        ADD	A,A
        ADD	A,A
        ADD	A,A			; *16
        OR	C			; number of root directory entries = 16* number of complete sectors + number of directory entries incomplete sector
        LD	(DE),A			; update DPB number of root directory entries
        INC	DE
        PUSH	HL			; store pointer
        INC	HL
        INC	HL
        INC	HL
        LD	BC,4
        LDIR				; update DPB first data sector, maximum cluster number
        POP	HL			; restore pointer
        LD	BC,3
        LDIR				; update DPB number of sectors per FAT, first root directory sector
        POP	HL			; restore pointer to drive table

;	  Subroutine current subdirectory invalid
;	     Inputs  HL = pointer to drive table
;	     Outputs ________________________

C34E9:	PUSH	HL			; store pointer to drive table
        PUSH	BC			; store BC
        LD	BC,30+1
        ADD	HL,BC			; +31
        POP	BC			; restore BC
        XOR	A
        BIT	7,(HL)			; current directory = root directory ?
        JR	NZ,J34F8		; yep, quit
        LD	(HL),A
        DEC	HL
        LD	(HL),A			; current directory = invalid
J34F8:	POP	HL			; restore pointer to drive table
        RET

;	  Subroutine execute disk driver function
;	     Inputs  A = function, HL = pointer to drive table, B= disk driver B, C= segment, DE= disk driver DE, IX = disk driver HL
;	     Outputs ________________________

CALL_UNIT:
C34FA:	CP	6
        JR	NC,J3543		; unknown function, quit with "Internal Error"
        PUSH	IY			; store IY
        PUSH	HL			; store pointer to drive table
        PUSH	HL			; store pointer to drive table
        EX	(SP),IX			; store disk driver HL, restore pointer to drive table
        POP	HL			; restore disk driver HL
        PUSH	HL			; store disk driver HL
        EXX
        PUSH	HL			; store HL'
        PUSH	DE			; store DE'
        PUSH	BC			; store BC'
        EX	AF,AF'
        PUSH	AF			; store AF'
        LD	A,(IX+8)		; drive id (1 based)
        DEC	A
        LD	(TARGET),A		; setup drive id for prompt routine
        LD	A,(IX+6)		; drive id for disk driver
        EX	AF,AF'
        LD	C,A			; store function
        CP	1			; function = DSKIO write ?
        LD	A,0FFH
        JR	Z,J351F			; yep, flag write operation
        INC	A			;
J351F:	LD	(DBBEA),A		; disk operation
        LD	HL,I3548		; table with function handlers
        LD	B,0
        ADD	HL,BC
        ADD	HL,BC
        LD	A,(HL)
        INC	HL
        LD	H,(HL)
        LD	L,A			; address function handler
        LD	A,(P2_TPA)		; saved DOS page 2 segment
        EX	AF,AF'
        CALL	C3547			; CALL HL
        EX	AF,AF'
        POP	AF			; restore AF'
        EX	AF,AF'
        EXX
        POP	BC			; restore BC'
        POP	DE			; restore DE'
        POP	HL			; restore HL'
        EXX
        POP	IX			; restore disk driver HL
        POP	HL			; restore pointer to drive table
        POP	IY			; restore IY
        OR	A			; Zx = error flag
        RET

J3543:	LD	A,.INTER
        OR	A
        RET

;	  Subroutine execute
;	     Inputs  ________________________
;	     Outputs ________________________

C3547:	JP	(HL)

I3548:	defw	A3554			; function 0, DKSIO read
        defw	A3557			; function 1, DSKIO write
        defw	A3571			; function 2, DSKCHG
        defw	A358C			; function 3, GETDPB
        defw	A35A2			; function 4, CHOICE
        defw	A35AD			; function 5, DSKFMT

;	  Subroutine function DSKIO read
;	     Inputs  ________________________
;	     Outputs ________________________

A3554:	OR	A			; reset Cx
        JR	J3558

;	  Subroutine function DSKIO write
;	     Inputs  ________________________
;	     Outputs ________________________

A3557:	SCF				; set Cx

J3558:	EX	AF,AF'
        LD	HL,04000H		; DSKIO
        EXX
        LD	A,C
        LD	C,(IX+29)		; media descriptor
        PUSH	BC			; store number of sectors, media descriptor
        CALL	C35EC			; execute disk driver function
        JR	C,J356A			; error,
        POP	BC			; restore number of sectors, media descriptor
        XOR	A			; no error
        RET

J356A:	EX	AF,AF'
        POP	AF			; restore number of sectors
        SUB	B
        LD	B,A			; number of succesfull sectors = number of sectors requested - number of sectors left
        EX	AF,AF'
        JR	J35C3			; translate driver error code to DOS error code and quit

;	  Subroutine function DSKCHG
;	     Inputs  ________________________
;	     Outputs ________________________

A3571:	EX	AF,AF'
        LD	HL,04003H		; DSKCHG
        EXX
        LD	B,0
        LD	C,(IX+29)		; media descriptor
        LD	L,(IX+2)
        LD	H,(IX+3)		; pointer to DPB
        CALL	C35EC			; execute disk driver function
        JR	C,J3588			; error,
        XOR	A			; no error
        RET

J3588:	LD	B,0
        JR	J35C3			; translate driver error code to DOS error code and quit

;	  Subroutine function GETDPB
;	     Inputs  ________________________
;	     Outputs ________________________

A358C:	EX	AF,AF'
        LD	HL,04006H		; GETDPB
        EXX
        LD	C,(IX+29)		; media descriptor
        LD	L,(IX+2)
        LD	H,(IX+3)		; pointer to DPB
        CALL	C35EC			; execute disk driver function
        LD	A,0FFH
        RET	C			; error,
        XOR	A			; no error
        RET				; quit with no error

;	  Subroutine function CHOICE
;	     Inputs  ________________________
;	     Outputs ________________________

A35A2:	EX	AF,AF'
        LD	HL,04009H		; CHOICE
        EXX
        CALL	C35EC			; execute disk driver function
        EX	DE,HL
        XOR	A			; no error
        RET				; quit with no error

;	  Subroutine function DSKFMT
;	     Inputs  ________________________
;	     Outputs ________________________

A35AD:	LD	HL,0400CH		; DSKFMT
        EXX
        PUSH	DE
        LD	D,A
        LD	A,B
        EX	AF,AF'
        LD	A,C
        POP	BC
        CALL	C35EC			; execute disk driver function
        JR	C,J35BE			; error, translate DSKFMT error code to DOS error code and quit
        XOR	A			; no error
        RET

J35BE:	LD	HL,I35E2
        JR	J35C6

J35C3:	LD	HL,I35D4
J35C6:	RRCA
        CP	(HL)
        JR	NC,J35D1
        INC	HL
        LD	E,A
        LD	D,0
        ADD	HL,DE
        LD	A,(HL)
        RET

J35D1:	LD	A,.DISK
        RET

I35D4:	defb	13+1
        defb	.WPROT			; 0, write protect
	defb	.NRDY			; 2, drive not ready
	defb	.DATA			; 4, data (CRC) error
	defb	.SEEK			; 6, seek error
        defb	.RNF			; 8, record not found
	defb	.WRERR			; 10, write fault (verify error)
	defb	.DISK			; 12, other error
	defb	.DISK			; 14, (undefined error)
        defb	.DISK			; 16, (undefined error)
	defb	.NDOS			; 18, not a DOS disk
	defb	.NCOMP			; 20, incompatible disk
	defb	.UFORM			; 22, unformatted disk
        defb	.NOUPB			; 24, unexpected disk change

I35E2:	defb	9+1
        defb	.WPROT			; 0, write protect
	defb	.NRDY			; 2, drive not ready
	defb	.DATA			; 4, data (CRC) error
	defb	.SEEK			; 6, seek error
        defb	.RNF			; 8, record not found
	defb	.WRERR			; 10, write fault (verify error)
	defb	.IPARM			; 12, bad choice parameter
	defb	.NORAM			; 14, insufficient memory
        defb	.DISK			; 16, other error

;	  Subroutine execute disk driver function
;	     Inputs  IX = pointer to drive table
;	     Outputs ________________________

C35EC:	CALL	C0AB9			; flush screen output buffer (if any)
        EXX
        LD	E,(IX+1)		; driver jump table offset
        LD	D,0
        ADD	HL,DE
        LD	B,(IX+0)		; disk interface slot id
        CALL	PUT_P2			; PUT_P2
        PUSH	BC
        POP	IY			; IYH = disk interface slot id
        PUSH	HL
        POP	IX			; IX = disk driver entry
        EXX
        EX	AF,AF'
        CALL	GO_DRV			; interslot call with prompt handler
        EI
        EX	AF,AF'
        LD	A,(DATA_S)		; BDOS datasegment
        CALL	PUT_P2			; PUT_P2
        EX	AF,AF'
        RET

;	  Subroutine disk change status of all drives to flushed
;	     Inputs  ________________________
;	     Outputs ________________________

C3611:	LD	B,8			; drives counter = 8
J3613:	LD	A,B
        CALL	C362C			; translate drive assigment and get pointer to drive tabel
        LD	E,(HL)
        INC	HL
        LD	D,(HL)
        LD	A,D
        OR	E			; drive table in use ?
        JR	Z,J3628			; nope, next drive
        LD	HL,9
        ADD	HL,DE			; +9
        LD	A,(HL)			; disk change counter
        OR	A
        JR	Z,J3628			; initialize, leave it alone
        LD	(HL),1			; disk change counter = invalid
J3628:	DJNZ	J3613
        XOR	A
        RET

;	  Subroutine translate drive assigment and get pointer to drive tabel
;	     Inputs  ________________________
;	     Outputs HL = pointer to drive table, A = physical drive id

C362C:	PUSH	DE
        OR	A			; default drive id ?
        JR	NZ,J3633		; nope,
        LD	A,(CUR_DRV)		; default drive id
J3633:	LD	C,.IDRV
        CP	8+1			; valid drive id ?
        JR	C,J363A			; yep,
        XOR	A
J363A:	LD	HL,IBA1A		; drive assignment table
        LD	E,A
        LD	D,0
        ADD	HL,DE			; assignment entry
        LD	A,(HL)			; physical drive id
        LD	E,A
        LD	D,0
        LD	HL,IBA23
        ADD	HL,DE
        ADD	HL,DE			; pointer to drive table
        POP	DE
        OR	A
        RET

;	  Subroutine update disk change counter of all drives
;	     Inputs  ________________________
;	     Outputs ________________________

UD_TICK:
C364D:	PUSH	AF
        PUSH	HL
        LD	HL,($SECBUF)		; pointer to disk driver sector buffer
        DEC	HL
        LD	A,(HL)			; FAT buffer status flag
        INC	A			; FAT buffer invalid ?
        JR	NZ,J3673		; nope, skip
	LD	(HL),0			; FAT buffer clean
        LD	A,(TARGET)
        PUSH	DE
        LD	E,A
        LD	D,0
        LD	HL,IBA23+2
        ADD	HL,DE
        ADD	HL,DE
        LD	E,(HL)
        INC	HL
        LD	D,(HL)			; pointer to drive table
        LD	HL,9
        ADD	HL,DE			; +9
        POP	DE
        LD	A,(HL)			; disk change counter
        OR	A
        JR	Z,J3673			; initialize, skip
        LD	(HL),1			; disk change counter = invalid
J3673:	LD	HL,TIM_TI
        DI
        LD	A,(HL)			; counter already reset ?
        EI
        LD	(HL),0			; reset counter
        OR	A
        JR	Z,J36A9			; was already reset, quit
        PUSH	BC
        PUSH	DE
        PUSH	IX
        LD	C,A			; counter value
        LD	HL,IBA23+2
        LD	B,8			; all 8 possible drives
J3688:	LD	E,(HL)
        INC	HL
        LD	D,(HL)			; drive table
        INC	HL
        LD	A,D
        OR	E
        JR	Z,J36A3			; drive does not exists, next
        PUSH	DE
        POP	IX
        LD	A,(IX+9)		; disk change counter
        SUB	2
        JR	C,J36A3			; initialize or invalid, leave the counter unchanged
        SUB	C			; adjust counter
        JR	NC,J369E
        XOR	A			; bottom value counter of drive
J369E:	ADD	A,2
        LD	(IX+9),A		; update disk change counter
J36A3:	DJNZ	J3688
        POP	IX
        POP	DE
        POP	BC
J36A9:	POP	HL
        POP	AF
        RET

;	  Subroutine handle error (ignore is valid)
;	     Inputs  ________________________
;	     Outputs ________________________

C36AC:	OR	A			; reset Cx
        JR	C36B0

;	  Subroutine handle error (ignore not recommended)
;	     Inputs  ________________________
;	     Outputs ________________________

C36AF:	SCF				; set Cx

;	  Subroutine handle error
;	     Inputs  HL = pointer to drive table
;	     Outputs A = result (0=retry,1=ignore), Zx set if retry

C36B0:	PUSH	BC
        PUSH	DE
        PUSH	HL
        EXX
        PUSH	HL
        PUSH	DE
        PUSH	BC
        EXX
        EX	AF,AF'
        PUSH	AF
        EX	AF,AF'
        PUSH	IX
        PUSH	AF
        LD	C,0			; no flags set
        JR	NC,J36C4
        SET	1,C			; flag ignore not recommended
J36C4:	LD	A,(DBBEA)
        OR	A
        JR	Z,J36CC			; read operation,
        SET	0,C			; write operation, flag a write diskoperation
J36CC:	LD	A,D
        AND	E
        INC	A
        JR	Z,J36D3			; sector number 0FFFFH, no sector number
        SET	3,C			; flag sector number valid
J36D3:	PUSH	HL
        PUSH	BC
        LD	BC,8
        ADD	HL,BC
        POP	BC
        LD	B,(HL)			; physical drive id
        INC	HL
        LD	A,(HL)
        OR	A
        JR	Z,J36E2			; special value 0 (INIT), leave it alone
        LD	(HL),1			; special value 1 (ERROR)
J36E2:	POP	HL
        POP	AF
        CP	.STOP
        JR	Z,J3744			; CTRL-STOP, go to abort handler
        CP	.NOUPB			; unexpected disk change ?
        JR	Z,J372E			; yep, fake an abort
        CP	.IFAT			; bad file allocation table ?
        JR	NZ,J36F2		; nope,
        SET	2,C			; invalid FAT, flag auto-abort suggested
J36F2:	PUSH	AF
        LD	HL,I3755-1		; error table
J36F6:	INC	HL
        CP	(HL)
        INC	HL
        JR	Z,J36FF
        BIT	7,(HL)
        JR	Z,J36F6			; not end of table, next entry
J36FF:	LD	A,(HL)
        ADD	A,A			; remove b7
        BIT	0,C
        JR	Z,J3706
        INC	A			; b0 = 1 for write operation, 0 for read operation
J3706:	BIT	2,C
        JR	Z,J370C
        SET	7,A			; b7 = 1 for auto-abort suggested, 0 if not
J370C:	EX	AF,AF'
        POP	AF
        LD	H,(IY+DBB89-DBB80)	; store current console redirection status
        PUSH	HL
        LD	(IY+DBB89-DBB80),0	; temperarly no console redirection
        PUSH	AF
        PUSH	IY
        LD	HL,(KDSK_V)		; address disk error handler
        CALL	C374C			; call diskerror handler with TPA segments active
        POP	IY
        POP	BC
        POP	HL
        LD	(IY+DBB89-DBB80),H	; restore console redirection status
        DEC	A
        CP	3
        JR	C,J3730			; resultcode 1-3
        XOR	A
        JR	J3730			; resultcode 0 or 4-255, call system error routine

J372E:	LD	A,1			; abort
J3730:	POP	IX
        EX	AF,AF'
        POP	AF
        EX	AF,AF'
        EXX
        POP	BC
        POP	DE
        POP	HL
        EXX
        POP	HL
        OR	A
        JR	Z,J3742			; call system error routine (abort program)
        POP	DE
        POP	BC
        DEC	A			; result
        RET

J3742:	LD	A,.ABORT
J3744:	PUSH	AF
        CALL	C2C77			; mark sector buffers of drive table unused
        POP	AF

;	  Subroutine call program abort routine with TPA segments active
;	     Inputs  ________________________
;	     Outputs ________________________

C3749:	LD	HL,(KAB_VE)		; address abort handler

;	  Subroutine call routine with TPA segments active
;	     Inputs  ________________________
;	     Outputs ________________________

C374C:	PUSH	HL
        LD	HL,PUT_BD
        EX	(SP),HL			; enable BDOS segments afterwards
        PUSH	HL			; call HL
        JP	PUT_US			; enable TPA segments

I3755:	defb	.WPROT,0
        defb	.NRDY,1
        defb	.DATA,2
        defb	.SEEK,3
        defb	.RNF,4
        defb	.WRERR,5
        defb	.DISK,6
        defb	.DISK,7
        defb	.DISK,8
        defb	.NDOS,9
        defb	.NCOMP,10
        defb	.UFORM,11
        defb	.NOUPB,12
        defb	0,6+128

;	  Subroutine _FOPEN
;	     Inputs  ________________________
;	     Outputs ________________________

A3771:	LD	(IY+DBBAF-DBB80),4	; search directory entry
        LD	A,02H			; normal and hidden files
        LD	C,1			; allow APPEND environment
J3779:	CALL	C3A59			; get directory entry and setup FIB
        JR	NZ,J37B1		; error, quit with error
        XOR	A
        PUSH	DE			; store pointer to FCB (with APPEND)
        CALL	C228E			; setup FIB for open
        POP	DE			; restore pointer to FCB (with APPEND)
        LD	HL,(DBB96)		; restore pointer to FCB
        PUSH	HL			; store pointer to FCB
        LD	A,(DBB98)
        OR	A			; APPEND used ?
        JR	Z,J3792			; nope,
        LD	A,(IB9DA+25)		; logical drive id
        LD	(HL),A			; yep, update DR byte FCB
J3792:	CALL	C3D28			; copy file name back to FCB
        INC	HL
        LD	A,(DE)			; file attribute
        LD	(HL),A			; in S1 byte FCB
        INC	HL
        LD	(HL),0			; reset high byte extent FCB
        POP	IX			; restore pointer to FCB
        CALL	C3CDA			; setup DOS2 specific FCB fields
        XOR	A			; record in extent = 0
        CALL	C3CAE			; setup random record from current extent FCB
        CALL	C3C74			; update record count in current extent FCB
        LD	A,(IB9DA+25)		; logical drive id
        CALL	C2C5F			; flush sector buffers of logical drive
J37AD:	XOR	A
        LD	L,A
        LD	H,A			; quit with ok
        RET

J37B1:	LD	HL,00FFH
        RET

;	  Subroutine _FCLOSE
;	     Inputs  DE = pointer to FCB
;	     Outputs ________________________

A37B5:	CALL	C39C3			; rebuild FIB from FCB
        JR	NZ,J37B1		; error, quit with error
        LD	DE,(DBB96)		; restore pointer to FCB
        CALL	C3A3B			; update FIB with file name from FCB
        CALL	C2244			; ensure directory entry (when file is modified)
        OR	A			; error ?
        JR	NZ,J37B1		; yep,
        LD	A,(IX+25)		; logical drive id
        CALL	C2C5F			; flush sector buffers of logical drive
        JR	J37AD			; quit with ok

;	  Subroutine _SFIRST
;	     Inputs  ________________________
;	     Outputs ________________________

A37CF:	LD	HL,12
        ADD	HL,DE
        LD	A,(HL)
        LD	(DBB95),A		; store requested extent
        LD	(IY+DBBAF-DBB80),4	; search directory entry
        LD	A,(DE)
        ADD	A,A
        SBC	A,A
        AND	10H			; search for normal files, but if b7 of DR is set also for subdirectories
        LD	C,0			; disallow APPEND environment
        CALL	C3A59			; get directory entry and setup FIB
        JR	NZ,J37B1		; error, quit with error
        JR	J3802

;	  Subroutine _SNEXT
;	     Inputs  ________________________
;	     Outputs ________________________

A37E9:	LD	DE,IB9DA		; buffer
        LD	HL,IB99A
        LD	BC,64
        LD	A,(HL)
        CP	0FFH
        LD	A,.NOFIL
        JP	NZ,J37B1		; no saved FIB, quit with "File not found" error
        LDIR				; copy saved FIB back
        CALL	C3B1D			; try to get next directory entry
        JP	NZ,J37B1		; error, quit with error
J3802:	PUSH	DE
        LD	HL,IB9DA		; buffer
        LD	DE,IB99A
        LD	BC,64
        LDIR				; save FIB for search next
        POP	DE
        LD	HL,IB975
        LD	A,(IB9DA+25)		; logical drive id
        LD	(HL),A			; DR byte FCB = drive id
        CALL	C3D28			; copy file name back to FCB
        LD	A,(DBB95)
        LD	(HL),A			; EX byte FCB = requested extent
        INC	HL
        LD	A,(DE)
        LD	(HL),A			; S1 byte FCB = fileattribute
        INC	HL
        INC	DE
        INC	DE
        LD	(HL),0			; clear S2 byte FCB
        INC	HL
        INC	DE
        EX	DE,HL
        LD	BC,18
        LDIR				; setup RC, AL and CR bytes
        LD	IX,IB975
        XOR	A			; record in extent = 0
        CALL	C3CAE			; setup random record from current extent FCB
        CALL	C3C74			; update record count of current extent FCB
        JR	C,A37E9			; file does not have the requested extent, search for next
        LD	HL,IB975
        LD	DE,(DTA_AD)		; transfer address
        LD	BC,33
        LD	A,1			; segment type = TPA, transfer to
        CALL	C2711			; segment LDIR
        JP	J37AD			; quit without error

;	  Subroutine _RDSEQ
;	     Inputs  DE = pointer to FCB
;	     Outputs ________________________

A384C:	CALL	C39C3			; rebuild FIB from FCB
        JR	NZ,J388F		; error, quit with error
        LD	IX,(DBB96)		; restore pointer to FCB
        CALL	C3CAB			; setup random record from current recordnumber FCB
        LD	A,(IB9DA+30)
        BIT	7,A			; device ?
        JR	Z,J3876			; nope,
        LD	BC,128			; size = 128
        LD	DE,(DTA_AD)		; transfer address
        LD	IX,IB9DA		; buffer (has FIB)
        XOR	A			; segment type = TPA
        CALL	C2775			; read from FIB
        JR	NZ,J388F		; error, quit with error
        LD	IX,(DBB96)		; restore pointer to FCB
        JR	J3886

J3876:	CALL	C3B74			; get pointer to record if it is in the sequential read buffer
        JR	Z,J3883			; record is in buffer, no need to read it
        CALL	C3BC1			; fill sequential read buffer
        JR	NZ,J388F		; error, quit with error
        LD	HL,IB2D4
J3883:	CALL	C3A4C			; transfer record from sequential read buffer
J3886:	CALL	C3C56			; increase recordnumber FCB
        CALL	C3CDA			; setup DOS2 specific FCB fields
        JP	J37AD			; quit with ok

J388F:	LD	HL,1
        RET

;	  Subroutine _WRSEQ
;	     Inputs  DE = pointer to FCB
;	     Outputs ________________________

A3893:	CALL	C39C3			; rebuild FIB from FCB
        JR	NZ,J388F		; error, quit with error
        LD	IX,(DBB96)		; restore pointer to FCB
        CALL	C3CAB			; setup random record from current recordnumber FCB
        CALL	C3BA1			; if random record is in sequential read buffer then invalidate sequential read buffer
        LD	IX,IB9DA		; buffer (has FIB)
        LD	BC,128			; record size = 128
        LD	DE,(DTA_AD)		; transfer address
        XOR	A			; segment type = TPA
        CALL	C2771			; write to FIB
        JR	NZ,J388F		; error, quit with error
        LD	IX,(DBB96)		; restore pointer to FCB
        CALL	C3C56			; increase recordnumber FCB
        CALL	C3CDA			; setup DOS2 specific FCB fields
        LD	A,(IX+32)
        LD	HL,(DBB96)		; restore pointer to FCB
        LD	BC,15
        ADD	HL,BC
        CP	(HL)
        JR	C,J38CB
        LD	(HL),A
J38CB:	JP	J37AD			; quit with ok

;	  Subroutine _FMAKE
;	     Inputs  ________________________
;	     Outputs ________________________

A38CE:	LD	HL,12
        ADD	HL,DE
        LD	A,(HL)			; extend (low byte)
        OR	A			; extend = 0 ?
        JR	Z,J38DD			; yep, create file
        CALL	A3771			; try to open file
        OR	A			; error ?
        JP	Z,J37AD			; nope, quit without error
J38DD:	LD	(IY+DBBAF-DBB80),0	; create directory entry
        XOR	A			; normal file
        LD	C,A			; do not use APPEND
        JP	J3779			; create file

;	  Subroutine _FDEL
;	     Inputs  ________________________
;	     Outputs ________________________

A38E6:	LD	A,0FFH
        LD	(DBB90),A		; invalidate sequential read buffer
        LD	BC,00FFH		; flag no files deleted
        PUSH	BC
        LD	(IY+DBBAF-DBB80),4	; search directory entry
        XOR	A			; search for normal files
        LD	C,A			; disallow APPEND environment
        CALL	C3A59			; get directory entry and setup FIB
        JR	J3901

J38FA:	POP	BC
        LD	C,0			; flag file(s) deleted
        PUSH	BC
J38FE:	CALL	C3B1D			; try to get next directory entry
J3901:	JR	NZ,J3946		; error or not found,
        BIT	0,(IX+14)
        JR	NZ,J38FE		; read-only file, skip it
        LD	A,1			; delete is recoverable by UNDEL
        CALL	C2350			; mark current directory entry deleted and remove FAT chain
        OR	A
        JR	Z,J38FA			; no error, try next
        JR	J3946			; finish

;	  Subroutine _FREN
;	     Inputs  ________________________
;	     Outputs ________________________

A3913:	LD	BC,00FFH
        PUSH	BC			; flag no files renamed
        PUSH	DE
        LD	IX,IB9DA		; buffer
        LD	(IX+31),00H		; request attribute =
        LD	HL,17
        ADD	HL,DE
        LD	DE,IB975
        EX	DE,HL
        LD	A,(DE)
        CALL	C173A			; make ASCIIZ string of name
        POP	DE
        XOR	A			; search for normal files
        LD	C,A			; disallow APPEND environment
        CALL	C3A59			; get directory entry and setup FIB
        JR	J393B

J3934:	POP	BC
        LD	C,0			; flag file(s) renamed
        PUSH	BC
        CALL	C3B1D			; try to get next directory entry
J393B:	JR	NZ,J3946		; error or not found, finish
        LD	BC,IB975
        CALL	C23B6			; rename current directory entry
        OR	A
        JR	Z,J3934			; no error, try next
J3946:	LD	B,A			; store error code
        LD	A,(IB9DA+25)		; logical drive id
        CALL	C2C5F			; flush sector buffers of logical drive
        POP	HL
        LD	A,L
        OR	A			; done something ?
        RET	Z			; yep, quit without error
        LD	A,B			; restore error code
        RET

;	  Subroutine _RDRND
;	     Inputs  ________________________
;	     Outputs ________________________

A3953:	LD	A,1			; operation = read, segment type = TPA
        CALL	C3B35			; do random record operation
        JR	NZ,J397D
        LD	A,C
        NEG
        AND	7FH
        LD	C,A
        LD	A,0			; segment type = TPA
        CALL	NZ,C3C2B		; clear record leftover
        JR	J3970

;	  Subroutine _WRRND
;	     Inputs  ________________________
;	     Outputs ________________________

A3967:	XOR	A			; operation = write
        DEFB	021H			; LD HL,xxxx : trick to skip next instruction

;	  Subroutine _WRZER
;	     Inputs  ________________________
;	     Outputs ________________________

A3969:	LD	A,2			; operation = write with zero fill, segment type = TPA
        CALL	C3B35			; do random record operation
        JR	NZ,J397D		; error, quit with error
J3970:	LD	IX,(DBB96)		; restore pointer to FCB
        CALL	C3C74			; update record count in current extent FCB
        CALL	C3CDA			; setup DOS2 specific FCB fields
        JP	J37AD			; quit with ok

J397D:	LD	HL,1
        RET

;	  Subroutine _FSIZE
;	     Inputs  ________________________
;	     Outputs ________________________

A3981:	LD	(IY+DBBAF-DBB80),4	; search directory entry
        LD	A,02H			; search for normal and hidden files
        LD	C,0			; disallow APPEND environment
        CALL	C3A59			; get directory entry and setup FIB
        JP	NZ,J37B1
        LD	C,(IX+21)
        LD	B,(IX+22)
        LD	E,(IX+23)
        LD	D,(IX+24)		; file size
        XOR	A
        LD	H,A
        SUB	C
        AND	7FH
        LD	L,A
        ADD	HL,BC
        JR	NC,J39A5
        INC	DE
J39A5:	ADD	HL,HL
        LD	A,H
        EX	DE,HL
        ADC	HL,HL
        LD	IX,(DBB96)		; restore pointer to FCB
        LD	(IX+33),A
        LD	(IX+34),L
        LD	(IX+35),H
        JP	J37AD			; quit with ok

;	  Subroutine _SETRND
;	     Inputs  ________________________
;	     Outputs ________________________

A39BA:	PUSH	DE
        POP	IX
        CALL	C3CAB			; setup random record from current record FCB
        JP	J37AD			; quit with ok

;	  Subroutine rebuild FIB from FCB
;	     Inputs  DE = pointer to FCB
;	     Outputs ________________________

C39C3:	EX	DE,HL
        LD	(DBB96),HL		; store pointer to FCB
        LD	IX,IB9DA		; buffer (for FIB)
        LD	(IX+0),0FFH		; FIB identifier
        LD	A,(HL)
        AND	0FH			; only B3-B0 of DR byte FCB
        LD	(IX+25),A		; update logical drive id of FIB
        LD	DE,IB9DA+21		; FIB: file size
        LD	BC,16
        ADD	HL,BC
        LD	BC,4
        LDIR				; copy file size to FIB
        LD	DE,IB9DA+26		; FIB: serial number
        LD	BC,4
        LDIR				; copy serial number disk to FIB
        LD	DE,IB9DA+37
        LD	BC,8
        LDIR				; copy cluster number of parent directory, start cluster of file, current cluster of file, current relative cluster of file to FIB
        LD	A,(IX+42)
        LD	B,0
        BIT	6,A
        JR	Z,J39FC
        LD	B,1
J39FC:	LD	(IX+14),B
        LD	B,0
        BIT	5,A
        JR	Z,J3A07
        LD	B,0A4H
J3A07:	BIT	4,A
        JR	Z,J3A0D
        SET	6,B			; set EOF flag
J3A0D:	LD	(IX+30),B		; update device flag
        LD	B,0			; file not modified
        BIT	7,A
        JR	Z,J3A18
        LD	B,80H			; file modified
J3A18:	LD	(IX+49),B
        AND	0FH
        LD	(IX+42),A
        XOR	A
        BIT	7,(IX+30)		; device ?
        RET	Z			; nope, quit
        LD	L,(IX+26)
        LD	H,(IX+27)
        LD	E,(HL)
        INC	HL
        LD	D,(HL)
        LD	L,(IX+28)
        LD	H,(IX+29)
        SBC	HL,DE
        RET	Z
        LD	A,0B7H
        RET

;	  Subroutine update FIB with file name from FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C3A3B:	LD	IX,IB9DA		; buffer
        LD	HL,IB9DA+1		; file name FIB
        INC	DE
        LD	A,(DE)			; file name FCB
        LD	(IX+31),02H		; request attributes = system

	IF	OPTM EQ 0
        CALL	C173A			; make ASCIIZ string of name
        RET
	ELSE
	JP	C173A			; make ASCIIZ string of name
	ENDIF

;	  Subroutine transfer record from sequential read buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C3A4C:	LD	DE,(DTA_AD)		; transfer address
        LD	BC,128
        LD	A,1			; segment type = TPA, transfer to

	IF	OPTM EQ 0
        CALL	C2711			; segment LDIR
        RET
	ELSE
	JP	C2711			; segment LDIR
	ENDIF

;	  Subroutine get directory entry and setup FIB
;	     Inputs  DE = pointer to FCB
;	     Outputs ________________________

C3A59:	PUSH	AF
        XOR	A
        LD	(DBB98),A		; flag APPEND not used
        POP	AF
        LD	B,A			; attribute
        PUSH	BC			; store attribute, append flag
        LD	(DBB96),DE		; store pointer to FCB
        LD	IX,IB9DA		; buffer
        LD	(IX+31),A		; store request attribute
        PUSH	AF			; store attribute
        PUSH	DE			; store pointer to FCB
        INC	DE
        LD	HL,IB8F4
        LD	A,(DE)
        CALL	C173A			; make ASCIIZ string of name
        POP	DE			; restore pointer to FCB
        POP	AF			; restore attribute
        LD	B,A			; store attribute
        LD	A,(DE)
        AND	0FH			; b3-b0 of DR byte (drive id)
        LD	DE,IB8F4
J3A7F:	LD	C,08H			; parse flags =
        CALL	C12C3			; parse path
        JR	NZ,J3AB0		; error, try append
        OR	C
        LD	A,.IPATH
        JR	NZ,J3AB0		; not end of parse string, try append
        PUSH	HL
        LD	HL,IB926		; file name buffer
        LD	DE,IB9DA+32
        LD	BC,11
        PUSH	DE
        LDIR
        POP	DE
        POP	HL
        CALL	C1A53			; get directory entry
J3A9D:	OR	A			; error ?
        JR	NZ,J3AB0		; yep, try append
        PUSH	DE
        PUSH	HL
        CALL	C1999			; update FIB with directory entry info
        CALL	C1A45			; get pointer to directory entry locators
        EX	DE,HL
        LDIR				; update FIB with directory entry locator info
        POP	HL
        POP	DE
        POP	BC			; restore attribute, append flag
        XOR	A			; ok
        RET

J3AB0:	POP	BC			; restore attribute, append flag
        BIT	0,C			; append allowed ?
        JR	NZ,J3ABD		; yep,
        PUSH	AF			; store error
	XOR	A
        LD	(DBB98),A		; flag APPEND not used
        POP	AF			; restore error
        OR	A
        RET

J3ABD:	LD	(IB2D4+300),A
        PUSH	BC
        LD	HL,I3B16		; APPEND
        LD	DE,IB2D4
        LD	A,0FFH
        LD	(DBB90),A		; invalidate sequential read buffer
        LD	B,0FFH
        LD	A,1			; segment type = current
        CALL	C0EDF			; get environment
        OR	A
        POP	BC
        RET	NZ			; error, quit
        PUSH	BC
        LD	C,04H			; parse flags =
        LD	DE,IB2D4
        LD	IX,IB9DA		; buffer
        XOR	A			; default drive id
        CALL	C12C3			; parse path
        POP	DE
        RET	NZ			; error, quit
        LD	A,B
        AND	05H
        JR	Z,J3B11
        LD	A,0FFH
        LD	(DBB98),A		; flag APPEND used
        PUSH	DE
        LD	HL,(DBB9E)		; pointer in parse string
        LD	A,B
        AND	18H
        JR	Z,J3AFC
        LD	(HL),"\"
        INC	HL
J3AFC:	LD	DE,IB8F4
J3AFF:	LD	A,(DE)
        LD	(HL),A
        INC	HL
        INC	DE
        OR	A
        JR	NZ,J3AFF
        POP	BC
        XOR	A
        LD	C,00H
        PUSH	BC
        LD	DE,IB2D4
        JP	J3A7F

J3B11:	LD	A,(IB2D4+300)
        OR	A
        RET

I3B16:	defb	"APPEND",0

;	  Subroutine try to get next directory entry
;	     Inputs  ________________________
;	     Outputs ________________________

C3B1D:	LD	IX,IB9DA		; buffer
        LD	(IY+DBBAF-DBB80),4	; search directory entry
        CALL	C1A02			; get directory entry from FIB info with disk change check
        RET	NZ			; error, quit
        LD	DE,IB9DA+32		; pointer to directory entry locator
        CALL	C1A91			; get next directory entry
        LD	C,0			; do not use append
        PUSH	BC
        JP	J3A9D			; update FIB directory entry info if no error

;	  Subroutine do random record operation
;	     Inputs  A = operation code, DE = pointer to FCB
;	     Outputs ________________________

C3B35:	EX	AF,AF'
        CALL	C39C3			; rebuild FIB from FCB
        RET	NZ
        LD	IX,(DBB96)		; restore pointer to FCB
        LD	A,(IX+33)
        LD	C,(IX+34)
        LD	B,(IX+35)		; random record from FCB
        PUSH	AF
        PUSH	BC			; store random record
        CALL	C3CC7			; update current file position from random record number
        CALL	C3BA1			; if random record is in sequential read buffer then invalidate sequential read buffer
        POP	HL
        POP	AF			; restore random record
        LD	B,A			; store random record low byte
        ADD	A,A
        ADC	HL,HL			; extend = random record / 128
        LD	A,L
        LD	(IX+12),A		; update extent (low byte) in FCB
        LD	A,H
        LD	(IX+14),A		; update extent high byte in FCB
        LD	A,B			; restore random record low byte
        AND	7FH			; record = random record mod 128
        LD	(IX+32),A		; update record in FCB
        XOR	A
        EX	AF,AF'
        LD	BC,128			; 128 bytes
        LD	IX,IB9DA		; buffer
        LD	DE,(DTA_AD)		; transfer address

	IF	OPTM EQ 0
        CALL	C2779			; read/write from FIB
        RET
	ELSE
	JP	C2779			; read/write from FIB
	ENDIF

;	  Subroutine get pointer to record if it is in the sequential read buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C3B74:	CALL	C3BAB			; check sequential read buffer has drive and starting cluster of file
        RET	NZ			; nope, quit
        LD	A,(DBB92+0)
        LD	B,A
        LD	DE,(DBB92+1)
        LD	A,(IX+33)
        LD	L,(IX+34)
        LD	H,(IX+35)		; random record
        SUB	B
        SBC	HL,DE
        RET	NZ			; not this record, quit
        LD	B,A
        LD	A,(DBB91)
        SUB	01H
        RET	C
        CP	B
        RET	C
        XOR	A
        SRL	B
        RRA
        LD	C,A
        LD	HL,IB2D4
        ADD	HL,BC
        XOR	A
        RET

;	  Subroutine if random record is in sequential read buffer then invalidate sequential read buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C3BA1:	CALL	C3BAB			; check sequential read buffer has drive and starting cluster of file
        RET	NZ
        LD	A,0FFH
        LD	(DBB90),A		; invalidate sequential read buffer
        RET

;	  Subroutine check sequential read buffer has drive and startcluster of file
;	     Inputs  ________________________
;	     Outputs ________________________

C3BAB:	LD	A,(IX+0)
        LD	B,A			; drive id FCB
        LD	A,(DBB90)
        CP	B
        RET	NZ
        LD	L,(IX+26)
        LD	H,(IX+27)		; start cluster of file in FCB
        LD	DE,(DBB8E)
        SBC	HL,DE
        RET

;	  Subroutine fill sequential read buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C3BC1:	LD	A,0FFH
        LD	(DBB90),A		; invalidate sequential read buffer
        LD	A,(IX+33)
        AND	03H			; record mod 3
        LD	B,A
        LD	A,8
        SUB	B
        LD	B,A
        XOR	A
        SRL	B
        RR	A
        LD	C,A			; /2
        PUSH	IX
        LD	IX,IB9DA		; buffer
        LD	DE,IB2D4
        LD	A,0FFH			; segment type = current
        CALL	C2775			; read from FIB
        POP	IX
        JR	Z,J3BEC			; no error,
        CP	.EOF			; end of file ?
        JR	NZ,J3C27		; other error,
J3BEC:	LD	A,B
        OR	C
        JR	Z,J3C27			; nothing read,
        LD	HL,127
        ADD	HL,BC
        ADD	HL,HL
        LD	A,H
        LD	(DBB91),A		; number of records read
        XOR	A
        LD	B,A
        SUB	C
        AND	7FH
        LD	C,A
        LD	A,0FFH			; segment type = current
        CALL	NZ,C3C2B		; clear record remainer
        PUSH	IX
        POP	HL
        LD	BC,33
        ADD	HL,BC
        LD	DE,DBB92
        LD	BC,3
        LDIR				; save current random record FCB
        LD	A,(IX+26)
        LD	(DBB8E+0),A
        LD	A,(IX+27)
        LD	(DBB8E+1),A		; save start cluster of file FCB
        LD	A,(IX+0)
        LD	(DBB90),A		; save drive id FCB
        XOR	A
        RET

J3C27:	XOR	A
        LD	B,A
        INC	A
        RET

;	  Subroutine clear space
;	     Inputs  A = segment type (b2 set BDOS, b2 reset DOS), DE = address, BC = size
;	     Outputs ________________________

C3C2B:	PUSH	AF
        PUSH	DE
        AND	04H			; segment type
        CALL	C274F			; get segment number
        SET	7,D			; make address page 2 based
        CALL	PUT_P2			; PUT_P2
J3C37:	XOR	A
        LD	(DE),A
        INC	DE
        DEC	BC
        LD	A,B
        OR	C
        JR	Z,J3C4E			; restore BDOS data segment and quit
        BIT	6,D
        JR	Z,J3C37
        POP	AF
        AND	0C0H
        ADD	A,40H
        LD	D,A
        LD	E,00H
        POP	AF
        JR	C3C2B

J3C4E:	POP	AF
        POP	AF
        LD	A,(DATA_S)		; BDOS datasegment
        JP	PUT_P2			; PUT_P2

;	  Subroutine increase record number FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C3C56:	LD	A,(IX+12)
        LD	L,A			; extent (low byte) from FCB
        LD	A,(IX+14)
        LD	H,A			; extent high byte from FCB
        LD	A,(IX+32)		; current record in extent from FCB
        INC	A			; increase record
        JP	P,J3C68			; record < 128, skip next extent
        INC	HL			; increase extent
        LD	A,0			; record = 0
J3C68:	LD	(IX+32),A		; update record in FCB
        LD	A,L
        LD	(IX+12),A		; update extend (low byte) in FCB
        LD	A,H
        LD	(IX+14),A		; update extend high byte in FCB
        RET	P			; no next extent, quit

;	  Subroutine update record count in current extent FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C3C74:	LD	HL,(IB9DA+21+0)		; low word file size
        XOR	A
        LD	B,A
        SUB	L
        AND	7FH
        LD	C,A
        ADD	HL,BC			; round up to a multiply of 128
        LD	BC,(IB9DA+21+2)		; high word file size
        JR	NC,J3C85		; no carry,
        INC	BC			; carry to high word
J3C85:	LD	A,(IB9DA+45+1)
        AND	0C0H
        LD	D,A
        XOR	A
        LD	E,A
        SBC	HL,DE
        PUSH	BC
        EX	(SP),HL
        LD	BC,(IB9DA+45+2)
        SBC	HL,BC			; check if filepos (FIB) is in last extent
        POP	HL
        LD	B,A
        JR	C,J3CA6			; past last extent, record 0
        LD	B,80H
        JR	NZ,J3CA6		; before last extent, special record 128 (extent is full)
        LD	A,H
        AND	0C0H
        JR	NZ,J3CA6
        ADD	HL,HL
        LD	B,H
J3CA6:	LD	A,B
        LD	(IX+15),A		; update record count in current extent
        RET

;	  Subroutine setup random record from current extent FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C3CAB:	LD	A,(IX+32)		; record in extent from FCB

;	  Subroutine setup random record from current extent FCB
;	     Inputs  A = record in extent
;	     Outputs ________________________

C3CAE:	PUSH	AF			; store record in extent
        LD	A,(IX+14)
        LD	B,A			; extent high byte from FCB
        LD	A,(IX+12)
        LD	C,A			; extent (low byte) from FCB
        POP	AF			; record in extent
        ADD	A,A
        SRL	B
        RR	C
        RRA
        LD	(IX+33),A
        LD	(IX+34),C
        LD	(IX+35),B		; update random record number

;	  Subroutine update current file position from random record number
;	     Inputs  BCA = random record number
;	     Outputs ________________________

C3CC7:	LD	HL,IB9DA+45
        LD	(HL),0
        SRL	B
        RR	C
        RRA
        RR	(HL)
        INC	HL
        LD	(HL),A
        INC	HL
        LD	(HL),C
        INC	HL
        LD	(HL),B			; update current file position in FIB
        RET

;	  Subroutine setup DOS2 specific FCB fields
;	     Inputs  IX = pointer to FCB
;	     Outputs ________________________

C3CDA:	PUSH	IX
        POP	HL			; pointer to FCB
        LD	BC,16
        ADD	HL,BC			; pointer in FCB, file size
        EX	DE,HL
        LD	HL,IB9DA+21
        LD	BC,4
        LDIR				; update file size
        LD	HL,IB9DA+26
        LD	BC,4
        LDIR				; update volume-id
        LD	HL,IB9DA+37
        LD	BC,8
        LDIR				; update cluster number of parent directory, start cluster of file, current cluster of file, current relative cluster of file
        LD	A,(IX+29)
        AND	0FH
        LD	B,A
        LD	A,(IB9DA+14)		; attribute
        BIT	0,A			; read-only ?
        JR	Z,J3D09			; nope,
        SET	6,B			; read-only
J3D09:	LD	A,(IB9DA+30)
        BIT	7,A			; device ?
        JR	Z,J3D12			; nope,
        SET	5,B
J3D12:	LD	A,(IB9DA+30)
        BIT	6,A			; EOF ?
        JR	Z,J3D1B			; nope,
        SET	4,B
J3D1B:	LD	A,(IB9DA+49)
        BIT	7,A			; file modified ?
        JR	Z,J3D24			; nope,
        SET	7,B
J3D24:	LD	(IX+29),B
        RET

;	  Subroutine copy file name back to FCB
;	     Inputs  HL = pointer to FCB
;	     Outputs ________________________

C3D28:	INC	HL
        LD	A,(DE)
        CP	05H
        JR	NZ,J3D30
        LD	A,0E5H
J3D30:	LD	(HL),A
        INC	HL
        INC	DE
        LD	BC,10
        EX	DE,HL
        LDIR
        EX	DE,HL
        RET

;	  Subroutine _RDBLK
;	     Inputs  DE = pointer to FCB, HL = number of records
;	     Outputs ________________________

A3D3B:	LD	A,1			; read, segment type = TPA
        JR	J3D40

;	  Subroutine _WRBLK
;	     Inputs  DE = pointer to FCB, HL = number of records
;	     Outputs ________________________

A3D3F:	XOR	A			; write, segment type = TPA
J3D40:	EX	AF,AF'
        LD	A,.OV64K
        LD	(DB976),A		; assume 64K overflow error
        PUSH	HL			; store number of records
        CALL	C39C3			; rebuild FIB from FCB
        JP	NZ,J3E13		; error,
        LD	IX,(DBB96)		; saved pointer to FCB
        CALL	C3BA1			; if random record is in sequential read buffer then invalidate sequential read buffer
        LD	C,(IX+14)
        LD	B,(IX+15)		; user record size
        LD	HL,63
        XOR	A
        SBC	HL,BC
        LD	E,(IX+35)
        LD	D,(IX+36)
        JR	NC,J3D69		; <64, use 32 bits random record
        LD	D,A			; >63, use 24 bits random record
J3D69:	CALL	C3E3A			; multiply (random record * record size, high word part)
        LD	A,H
        OR	L
        JP	NZ,J3E16		; filepos larger then 4 Gb, error
        PUSH	DE
        LD	E,(IX+33)
        LD	D,(IX+34)
        CALL	C3E3A			; multiply (random record * record size, low word part)
        POP	BC
        ADD	HL,BC
        JP	C,J3E16			; filepos larger then 4 Gb, error
        LD	(IB9DA+45),DE
        LD	(IB9DA+47),HL		; setup filepos (FIB)
        POP	DE
        PUSH	DE			; number of records
        LD	C,(IX+14)
        LD	B,(IX+15)		; user record size
        CALL	C3E3A			; multiply
        LD	A,H
        OR	L			; size of data >= 64 Kb ?
        JP	NZ,J3E16		; yep, error
        LD	C,E
        LD	B,D			; size of data
        PUSH	BC
        EX	AF,AF'
        PUSH	AF
        LD	IX,IB9DA		; buffer
        LD	DE,(DTA_AD)		; transfer address
        BIT	0,A
        JR	NZ,J3DB0		; read, go reading
        LD	A,B
        OR	C
        LD	A,0			; segment type = TPA
        JR	NZ,J3DB0		; data size<>0, go writing
        SET	4,A			; data size=0, alter file size
J3DB0:	CALL	C2779			; read/write from FIB
        LD	(DB976),A		; store error code
        LD	IX,(DBB96)		; pointer to FCB
        POP	AF
        EX	AF,AF'
        XOR	A
        POP	HL			; datasize
        SBC	HL,BC
        JR	Z,J3DEF			; all done, finish
        LD	(DB977),DE		; current transfer address
        LD	E,(IX+14)
        LD	D,(IX+15)		; user record size
        CALL	C3E24			; divide
        LD	A,H
        OR	L
        PUSH	BC
        JR	Z,J3DE6			; no record leftover,
        POP	BC
        INC	BC
        PUSH	BC
        EX	DE,HL
        SBC	HL,DE
        LD	B,H
        LD	C,L
        LD	DE,(DB977)		; current transfer address
        EX	AF,AF'
        BIT	0,A
        CALL	NZ,C3C2B		; read, clear record leftover
J3DE6:	POP	BC
        POP	HL
        PUSH	BC
        XOR	A
        SBC	HL,BC
        JR	Z,J3DEF
        INC	A
J3DEF:	EX	AF,AF'
        CALL	C3CDA			; setup DOS2 specific FCB fields
        POP	DE
        LD	L,(IX+33)
        LD	H,(IX+34)
        ADD	HL,DE
        LD	(IX+33),L
        LD	(IX+34),H
        JR	NC,J3E10
        LD	L,(IX+35)
        LD	H,(IX+36)
        INC	HL
        LD	(IX+35),L
        LD	(IX+36),H
J3E10:	EX	AF,AF'
        JR	J3E1B

J3E13:	LD	(DB976),A		; store error code
J3E16:	POP	HL
        XOR	A
        LD	D,A
        LD	E,A
        INC	A
J3E1B:	LD	L,A
        LD	H,00H
        OR	A
        RET	Z
        LD	A,(DB976)		; error code
        RET

;	  Subroutine divide
;	     Inputs  ________________________
;	     Outputs ________________________

C3E24:	XOR	A
        LD	H,A
        LD	L,A
        LD	A,16
J3E29:	CCF
J3E2A:	RL	C
        RL	B
        DEC	A
        RET	M
        ADC	HL,HL
        SBC	HL,DE
        JR	NC,J3E29
        ADD	HL,DE
        OR	A
        JR	J3E2A

;	  Subroutine multiply
;	     Inputs  ________________________
;	     Outputs ________________________

C3E3A:	PUSH	BC
        LD	A,B
        LD	HL,0
        LD	B,16
J3E41:	ADD	HL,HL
        RL	C
        RLA
        JR	NC,J3E4E
        ADD	HL,DE
        JR	NC,J3E4E
        INC	C
        JR	NZ,J3E4E
        INC	A
J3E4E:	DJNZ	J3E41
        EX	DE,HL
        LD	L,C
        LD	H,A
        POP	BC
        RET

        .DEPHASE


        DEFS	07FD0H-$,0

L7FD0:
	BNKCHG
        RET


; disk driver interrupt handler

L7FD4:	EX	AF,AF'
        LD	A,(L40FF)
        PUSH	AF		; Save DOS2 mapper block
        XOR	A
        CALL	L7FD0		; Set block 0
        EX	AF,AF'
        CALL	0		; interrupt handler (never executed here)
        EX	AF,AF'
        POP	AF
        CALL	L7FD0		; Set old block
        EX	AF,AF'
        RET

        DEFS	08000H-$,0

        END
