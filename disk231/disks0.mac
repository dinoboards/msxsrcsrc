; DISK-S0.MAC
;
; DOS 2.31 kernel bank 0
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders
;

DOS2	EQU	1			; DOS2 flag for diskdriver

        .Z80
        ASEG
        ORG	04000H


BOT16K	EQU	0C000H			; lower of 16 KB RAM
BOT32K	EQU	08000H			; lower of 32 KB RAM
BOOTSZ	EQU	256			; maximum size of MSX bootloader in bootsector
TMPSTK	EQU	BOT16K+BOOTSZ+256	; location of temporary stack

;	EXTRN	INIHRD
;	EXTRN	DRIVES
;	EXTRN	INIENV
;	EXTRN	DSKIO
;	EXTRN	DSKCHG
;	EXTRN	GETDPB
;	EXTRN	CHOICE
;	EXTRN	DSKFMT
;	EXTRN	MTOFF
;	EXTRN	OEMSTA
;	EXTRN	MYSIZE
;	EXTRN	SECLEN
;	EXTRN	DEFDPB

;	PUBLIC	PROMPT
;	PUBLIC	SETINT
;	PUBLIC	PRVINT
;	PUBLIC	GETSLT
;	PUBLIC	GETWRK
;	PUBLIC	DIV16
;	PUBLIC	ENASLT
;	PUBLIC	XFER


_RST    MACRO   X
        IFIDN   <X>,<SYNCHR>
        RST     08H
        ENDIF
        IFIDN   <X>,<CHRGTR>
        RST     10H
        ENDIF
        IFIDN   <X>,<OUTDO>
        RST     18H
        ENDIF
        IFIDN   <X>,<DCOMPR>
        RST     20H
        ENDIF
        IFIDN   <X>,<GETYPR>
        RST     28H
        ENDIF
        IFIDN   <X>,<CALLF>
        RST     30H
        ENDIF
        ENDM

_DOSCP	MACRO	X
	IF2
	IF	($ NE X)
	.PRINTX	"ERROR: MSXDOS incompatible, subroutine not aligned to &X"
	ENDIF
	ENDIF
	ENDM


WBOOT	EQU	00000H
DBUF	EQU	00080H
X003B	EQU	0003BH			; start of the slot switching helpers for MSX-DOS environment
S003B	EQU	26			; size of the slot switching helpers for MSX-DOS environment
X004B	EQU	X003B+16		; helper routine in DOS memoryspace: restore secundairy slotregister (CALSLT/CALLF)
TBASE	EQU	00100H			; start of MSX-DOS

RDSLT	EQU	0000CH
WRSLT	EQU	00014H
CALSLT	EQU	0001CH
OUTDO	EQU	00018H
DCOMPR	EQU	00020H
ENASLT	EQU	00024H
IDBYT0	EQU	0002BH
IDBYT2	EQU	0002DH
CALLF	EQU	00030H
M0034	EQU	00034H			; double byte header char table
KEYINT	EQU	00038H
CHGET	EQU	0009FH
CHPUT	EQU	000A2H
CALBAS	EQU	00159H
LDIRMV	EQU	00059H
LDIRVM	EQU	0005CH
TOTEXT	EQU	000D2H
ERAFNK	EQU	000CCH
CKCNTC	EQU	000BDH
SNSMAT	EQU	00141H
KILBUF	EQU	00156H
CHGCPU	EQU	00180H

LBC00	EQU	0BC00H			; ramdisk bootsector
LBE00	EQU	0BE00H			; number of ramdisk segments
LBE02	EQU	0BE02H			; ramdisk segment table

LF1C9	EQU	0F1C9H			; BDOS _STROUT
LF1D3	EQU	0F1D3H			; transfer to/from page 1
LF1DF	EQU	0F1DFH			; interslot call with prompt handler
LF1E2	EQU	0F1E2H			; start DOS1 style handler
LF1E5	EQU	0F1E5H			; KEYINT handler
LF1E8	EQU	0F1E8H			; RDSLT handler
LF1EB	EQU	0F1EBH			; WRSLT handler
LF1EE	EQU	0F1EEH			; CALSLT handler
LF1F1	EQU	0F1F1H			; ENASLT handler
LF1F4	EQU	0F1F4H			; CALLF handler
LF1FD	EQU	0F1FDH			; enable DOS RAM on page 0
LF206	EQU	0F206H			; RD_SEG handler
LF218	EQU	0F218H			; PUT_P0 handler
LF21B	EQU	0F21BH			; GET_P0 handler
LF21E	EQU	0F21EH			; PUT_P1 handler
LF221	EQU	0F221H			; GET_P1 handler
LF224	EQU	0F224H			; PUT_P2 handler
LF227	EQU	0F227H			; GET_P2 handler
LF23C	EQU	0F23CH			; default drive
LF24F	EQU	0F24FH			; PROMPT hook, also start of DSK hooks
LF2B8	EQU	0F2B8H			; number of interrupts per 100 ms
LF2B9	EQU	0F2B9H			; interrupt counter
LF2BA	EQU	0F2BAH			; random number, used for compose a random diskserial
LF2BD	EQU	0F2BDH			; no keyboard check counter
LF2BE	EQU	0F2BEH			; screenoutput buffer counter
LF2BF	EQU	0F2BFH			; disk unchanged counter
LF2C0	EQU	0F2C0H			; saved H.TIMI hook
LF2CF	EQU	0F2CFH			; BDOS data segment
LF2D0	EQU	0F2D0H			; BDOS code segment
LF2D5	EQU	0F2D5H			; saved EXTBIO hook
LF2DA	EQU	0F2DAH			; adres message handler
LF2DC	EQU	0F2DCH			; adres prompt handler
LF2DE	EQU	0F2DEH			; adres BDOS handler
LF2E1	EQU	0F2E1H			; temporary save for transferadres ramdisk DSKIO
LF2E3	EQU	0F2E3H			; temporary save for sectornumber ramdisk DSKIO
LF2E5	EQU	0F2E5H			; temporary save for number of sectors ramdisk DSKIO
LF2E6	EQU	0F2E6H			; temporary save for IX parameter BDOS
LF2E8	EQU	0F2E8H			; temporary save for SP BDOS
LF2F1	EQU	0F2F1H			; adres BLOAD handler
LF2F3	EQU	0F2F3H			; adres BSAVE handler
LF2F5	EQU	0F2F5H			; pointer to buffer for transfering BDOS structures
LF2F7	EQU	0F2F7H			; pointer to buffer for transfering BDOS FIB
LF2F9	EQU	0F2F9H			; pointer to buffer for transfering BDOS FIB or Path
LF2FB	EQU	0F2FBH			; pointer to buffer for transfering BDOS errorstrings
LF2FD	EQU	0F2FDH			; bootdrive
LF2FE	EQU	0F2FEH			; pointer to temporary stack for BDOS
LF300	EQU	0F300H			; pointer to diskerror handler
LF302	EQU	0F302H			; pointer to abort handler
LF306	EQU	0F306H			; CP/M BDOS call flag, used by MSXDOS1
RAWFLG	EQU	0F30DH			; verify flag
LF30E	EQU	0F30EH			; date format
LF30F	EQU	0F30FH			; double byte header table
LF313	EQU	0F313H			; DOS2 version
LF314	EQU	0F314H			; TPA segment page 0
LF315	EQU	0F315H			; TPA segment page 1
LF316	EQU	0F316H			; TPA segment page 2
LF323	EQU	0F323H			; DOS1 style diskerror handler pointer
LF325	EQU	0F325H			; DOS1 style abort handler pointer
LF327	EQU	0F327H			; AUX input hook
LF333	EQU	0F333H			; pointer to BDOS handler
LF338	EQU	0F338H			; clockchip available flag (always 0FFH with DOS2)
LF33B	EQU	0F33BH			; pointer to BASIC pathbuffer
LF33D	EQU	0F33DH			; recordsize random filemode basic
LF33F	EQU	0F33FH			; driveid (used in PROMPT), CTRL key status in DISK init
LF340	EQU	0F340H			; first start DiskBASIC flag
RAMAD0	EQU	0F341H			; slotid DOS ram page 0
RAMAD1	equ	0F342H			; slotid DOS ram page 1
RAMAD2	equ	0F343H			; slotid DOS ram page 2
RAMAD3	EQU	0F344H			; slotid DOS ram page 3
LF346	EQU	0F346H			; MSXDOS started flag
LF347	EQU	0F347H			; number of drives
LF348	EQU	0F348H			; slotid disksystem ROM
LF349	EQU	0F349H			; bottom of basic disksystem
LF34B	EQU	0F34BH			; bottom of msxdos disksystem
$SECBUF	EQU	0F34DH			; pointer to sector buffer for diskdriver
LF34F	EQU	0F34FH			; biggest sectorsize in disksystem
LF351	EQU	0F351H			; pointer to sector buffer for BASIC
LF353	EQU	0F353H			; pointer to DPB for RAMDISK
LF355	EQU	0F355H			; DPB pointertable
LF365	EQU	0F365H			; read primary slotregister
XF368	EQU	0F368H			; enable disksystem ROM on page 1
XF36B	EQU	0F36BH			; enable TPA RAM on page 2
XFER	EQU	0F36EH			; transfer to/fram TPA RAM on page 2
XF36E	EQU	0F36EH
LF377	EQU	0F377H			; interslot call to BDOS code segment
LF37A	EQU	0F37AH			; interslot call to BDOS handler in BDOS code segment
BDOS	EQU	0F37DH			; BDOS entry


DECSUB	EQU	0268CH			; subtract double
DECADD	EQU	0269AH			; add double
DECDIV	EQU	0289FH			; divide double
VMOVE	EQU	02EF3H			; copy to HL
VMOVFM	EQU	02F08H			; copy variable content to DAC
VMOVMF	EQU	02F10H			; copy variable content from DAC
MAKINT	EQU	02F99H			; integer to DAC
CONDS	EQU	03042H			; convert DAC from sgn to dbl
INT	EQU	030D1H			; dbl to integer
SGNMUL	EQU	0325CH			; sgn multiply
NULSTR	EQU	03FD6H			; empty string
ERROR   equ     0406FH          	; BASIC error
READYR  equ     0409BH          	; restart BASIC
NTSTOP  equ     04173H          	; execute statement
LINKER  equ     04253H          	; recalculate linepointers
NEWSTT  equ     04601H          	; execution loop
CHRGTR  equ     04666H          	; CHRGTR
FLTLIN  equ     046FFH          	; convert to SNG
INTID2  equ     04756H          	; evaluate word operand and check for 0-32767 range
FCERR	EQU	0475AH			; illegal function call
FINPRT  equ     04AFFH          	; output back to screen
FRMEQL  equ     04C5FH          	; evaluate =expression
FRMEVL  equ     04C64H          	; evaluate expression
DOCNVF  equ     0517AH          	; convert DAC to other type
GETIN2  EQU     0520FH          	; evaluate integer operand
GTBYTC  equ     0521BH          	; evaluate next byte operand
GETBYT  equ     0521CH          	; evaluate byte operand
CONINT  equ     0521FH          	; convert to byte
JPFOUT  EQU     0537BH           	; convert DAC to text, unformatted (JPFOUT is not an offical name)
GETUIN  equ     0542FH          	; evaluate address operand
GETUI   equ     05432H          	; convert address to integer
SCCPTR  equ     054F7H          	; convert pointers to linenumbers
GETYPR  equ     05597H          	; GETYPR
PTRGET  equ     05EA4H          	; get address of variable
STRINI  equ     06627H          	; allocate temp string
GETSPA  equ     0668EH          	; allocate stringspace
FRESTR  equ     067D0H          	; free temporary string
FILEVL  equ     06A0EH          	; evaluate filespecification
FILIDX  equ     06A6DH          	; get i/o channel pointer
OPNFIL  equ     06AFAH          	; open i/o channel
CLSFIL  equ     06B24H          	; close i/o channel
CLSALL  equ     06C1CH          	; close all i/o channels
NOSKCR  equ     06E41H          	; resume character putback routine
BSAVE   equ     06E92H          	; start of BSAVE routine
BLOAD   equ     06EC6H          	; start of BLOAD routine
BLDFIN  equ     06EF4H          	; finish BLOAD
ADRGET  equ     06F0BH          	; evaluate address operand (BLOAD/SAVE)
PARDEV  equ     06F15H          	; skip strong cassette devicecheck
CRDONZ  equ     07323H          	; newline to OUTDO if not at start of line
CRDO    equ     07328H          	; newline to OUTDO
M739A   equ     0739AH          	; quit loading & start (headloop/executing)
M7D17   equ     07D17H          	; continue start of MSX-BASIC without executing BASIC programs in ROM
M7D2F   equ     07D2FH        		; address initialize BASIC screen
M7D31   equ     07D31H          	; BASIC initscreen (without INITXT & CNSDFG)
M7DE9   EQU     7DE9H    	       	; start MSX-BASIC program in ROM


A58A8	EQU	058A8H			; continue to disksystem 1.x init

RETRTN	EQU	WRPRIM + 6		; on this adres is a simple RET instruction

VARWRK	EQU	0F380H
WRPRIM	EQU	0F385H
USRTAB	EQU	0F39AH
LINLEN	EQU	0F3B0H
CNSDFG	EQU	0F3DEH
LPTPOS	EQU	0F415H
PRTFLG	EQU	0F416H
CURLIN	EQU	0F41CH
KBUF	EQU	0F41FH
BUF	EQU	0F55EH
TTYPOS	EQU	0F661H
VALTYP	EQU	0F663H
MEMSIZ	EQU	0F672H
STKTOP	EQU	0F674H
TXTTAB	EQU	0F676H
TEMPPT	EQU	0F678H
DSCTMP	EQU	0F698H
FRETOP	EQU	0F69BH
AUTLIN	EQU	0F6ABH			; used for bigest sectorsize during disksystem init
SAVSTK	EQU	0F6B1H
VARTAB	EQU	0F6C2H
STREND	EQU	0F6C6H
DAC	EQU	0F7F6H
ARG	EQU	0F847H
MAXFIL	EQU	0F85FH
FILTAB	EQU	0F860H
NULBUF	EQU	0F862H
PTRFIL	EQU	0F864H
FILNAM	EQU	0F866H
NLONLY	EQU	0F87CH
SAVEND	EQU	0F87DH
HOKVLD	EQU	0FB20H			; EXTBIO valid flag (b0)
DRVTBL	EQU	0FB21H			; disk interface table
HOOKSA	EQU	0FB29H			; disk interface interrupt table
BASROM	EQU	0FBB1H
BOTTOM	EQU	0FC48H
HIMEM	EQU	0FC4AH
FLBMEM	EQU	0FCAEH
RUNBNF	EQU	0FCBEH
SAVENT	EQU	0FCBFH
EXPTBL	EQU	0FCC1H
SLTTBL	EQU	0FCC5H
SLTWRK	EQU	0FD09H
PROCNM	EQU	0FD89H
DEVICE	EQU	0FD99H			; used temp for disk interface count
H.TIMI	EQU	0FD9FH
H.DSKO	EQU	0FDEFH
H.NAME	EQU	0FDF9H
H.KILL	EQU	0FDFEH
H.COPY	EQU	0FE08H
H.DSKF	EQU	0FE12H
H.DSKI	EQU	0FE17H
H.LSET	EQU	0FE21H
H.RSET	EQU	0FE26H
H.FIEL	EQU	0FE2BH
H.MKI$	EQU	0FE30H
H.MKS$	EQU	0FE35H
H.MKD$	EQU	0FE3AH
H.CVI	EQU	0FE3FH
H.CVS	EQU	0FE44H
H.CVD	EQU	0FE49H
H.GETP	EQU	0FE4EH
H.NOFO	EQU	0FE58H
H.NULO	EQU	0FE5DH
H.NTFL	EQU	0FE62H
H.BINS	EQU	0FE71H
H.BINL	EQU	0FE76H
H.FILE	EQU	0FE7BH
H.DGET	EQU	0FE80H
H.FILO	EQU	0FE85H
H.INDS	EQU	0FE8AH
H.LOC	EQU	0FE99H
H.LOF	EQU	0FE9EH
H.EOF	EQU	0FEA3H
H.BAKU	EQU	0FEADH
H.PARD	EQU	0FEB2H
H.NODE	EQU	0FEB7H
H.POSD	EQU	0FEBCH
H.RUNC	EQU	0FECBH
H.CLEA	EQU	0FED0H
H.LOPD	EQU	0FED5H
H.STKE	EQU	0FEDAH
H.ERRP	EQU	0FEFDH
H.PHYD	EQU	0FFA7H
H.FORM	EQU	0FFACH
EXTBIO	EQU	0FFCAH		; extended BIOS entry
DISINT	equ	0FFCFH
ENAINT	equ	0FFD4H
LFFFF	EQU	0FFFFH


        INCLUDE	DISK.INC

	IF ROMVER EQ 1
CLRSIZ	EQU	LF325+1-LF313
	ENDIF

	IF ROMVER GE 2
CLRSIZ	EQU	LF325+1-LF2B8
	ENDIF

        
        DEFB	"AB"
        DEFW	C403C			; extension ROM initialization
        DEFW	C575C			; extension ROM BASIC CALL statement handler
        DEFW	0			; extension ROM BASIC device handler (none)
        DEFW	0			; extension ROM BASIC program (none)
        DEFS	6,0			; extension ROM further use

;	  Subroutine DRIVER: DSKIO
;	     Inputs  ________________________
;	     Outputs ________________________

DKRWEN:
C4010:	JP	DSKIO

;	  Subroutine DRIVER: DSKCHG
;	     Inputs  ________________________
;	     Outputs ________________________

DKCHGE:
C4013:	JP	DSKCHG

;	  Subroutine DRIVER: GETDPB
;	     Inputs  ________________________
;	     Outputs ________________________

GTDPBE:
C4016:	JP	GETDPB

;	  Subroutine DRIVER: CHOICE
;	     Inputs  ________________________
;	     Outputs ________________________

CHOIEN:
C4019:	JP	CHOICE

;	  Subroutine DRIVER: DSKFMT
;	     Inputs  ________________________
;	     Outputs ________________________

DKFMTE:
C401C:	JP	DSKFMT

;	  Subroutine DRIVER: MTOFF
;	     Inputs  ________________________
;	     Outputs ________________________

MTOFFE:
C401F:	JP	MTOFF

;	  Subroutine start DiskBASIC
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

BASENT:
C4022:	JP	J4B43

;	  Subroutine format disk
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

FORENT:
C4025:	SCF			; workarea specified
        JP	J4E8F		; format disk

;	  Subroutine stop motor of all floppy drives
;	     Inputs  ________________________
;	     Outputs ________________________

C4029:	JP	J4CFB
        NOP

;	  Subroutine get my slotid
;	     Inputs  ________________________
;	     Outputs ________________________

GETSLT:
C402D:	JP	C4E2D

;	  Subroutine get top of MSXDOS disksystem
;	     Inputs  ________________________
;	     Outputs ________________________

	_DOSCP	4030H

$INIT:
C4030:	LD	HL,(LF34B)
        RET

;	  Subroutine CP/M BIOS CONST entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4034H

$$BIOS:
C4034:	JP	J417C

        DEFS	04038H-$,0

; 04038H
; DOS2: pointer to kernel version ASCIIZ string

C4038:	DEFW	I411E

        DEFS	0403CH-$,0

C403C:	XOR	A
        CALL	C7FD0			; select bank 0
        JP	J47D6			; start initialization

C4043:	CALL	C410C			; EXTBIO handler memory mapper
        JP	LF2D5			; continue EXTBIO

;	  Subroutine DOS2 timer routine
;	     Inputs  ________________________
;	     Outputs ________________________

C4049:	PUSH	AF
        LD	A,(D40FF)
        PUSH	AF			; store current bank
        XOR	A
        CALL	C7FD0			; select bank 0
        CALL	C4D1B			; timer routine DOS2
        POP	AF
        CALL	C7FD0			; restore bank
        POP	AF
        RET

;	  Subroutine invoke routine in bank
;	     Inputs  A = banknumber, IX = routine
;	     Outputs ________________________

J405B:	CALL	C7FD0			; select bank
        EX	AF,AF'
        CALL	C4069			; call routine
        EX	AF,AF'
        XOR	A
        CALL	C7FD0			; select bank 0
        EX	AF,AF'
        RET

C4069:	JP	(IX)

        DEFS	04078H-$,0

;	  Subroutine CP/M BIOS CONIN entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4078H

$IN:
C4078:	JP	J4181

        DEFS	04080H-$,0

; DOS2: RAMDISK driver jumpentries

C4080:	JP	R_DSKIO			; RAMDISK: DSKIO routine
C4083:	JP	R_DSKCHG		; RAMDISK: DSKCHG routine
C4086:	JP	R_GETDPB		; RAMDISK: GETDPB routine
C4089:	JP	R_CHOICE		; RAMDISK: CHOICE routine
C408C:	JP	R_DSKFMT		; RAMDISK: DSKFMT routine

        DEFS	0408FH-$,0

;	  Subroutine CP/M BIOS CONOUT entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	408FH

$OUT:
C408F:	JP	J4186

        DEFS	040FFH-$,0

D40FF:	DEFB	0			; present bank number register

; The following routines call a routine in ROM bank 1
; the routine called depends from the call adress
; for example C4100 calls C4100 on bank 1, so add 00h to the caller

;	  Subroutine check and invoke preferred memory mapper (6 or more segments)
;	     Inputs  A = current slot id page 2
;	     Outputs ________________________

C4100:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine install disk system routines
;	     Inputs  ________________________
;	     Outputs ________________________

C4103:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine copy message to buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C4106:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine copy errorstring to buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C4109:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine EXTBIO handler memory mapper
;	     Inputs  ________________________
;	     Outputs ________________________

C410C:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine call subroutine in ROM bank 1 and quit
;	     Inputs  ________________________
;	     Outputs ________________________

C410F:	POP	IX			; return address
	PUSH	BC			; store
	LD	BC,-3			; offset adjust
	EX	AF,AF'
	LD	A,1			; ROM bank 1
	ADD	IX,BC
	POP	BC			; restore
	JP	J405B			; invoke routine in bank

        IF ROMVER LE 2

I411E:	DEFB	"MSX-DOS kernel version 2.30"
        DEFB	0

I413A:	DEFB	"Disk BASIC version 2.01"
        DEFB	0
        DEFB	"Copyright (C) 1990 ASCII Corporation"
        DEFB	0

        ELSE

I411E:	DEFB	"MSX-DOS kernel version 2.31"
        DEFB	0

I413A:	DEFB	"Disk BASIC version 2.01"
        DEFB	0
        DEFB	"Copyright (C) 1991 ASCII Corporation"
        DEFB	0

        ENDIF

?4177: 

; look like a MMDD string

	IF ROMVER EQ 1

        DEFB	"0912"
        DEFB	0

	ENDIF

	IF ROMVER EQ 2

        DEFB	"1205"
        DEFB	0

	ENDIF

	IF ROMVER EQ 3

        DEFB	"0618"
        DEFB	0

	ENDIF

J417C:	LD	HL,0086H		; CP/M BIOS CONST entry in BDOS code segment
        JR	J418A

J4181:	LD	HL,0080H		; CP/M BIOS CONIN entry in BDOS code segment
        JR	J418A

J4186:	LD	C,A
        LD	HL,0083H		; CP/M BIOS CONOUT entry in BDOS code segment
J418A:	JP	LF377			; invoke routine in BDOS code segment

        DEFS	041EFH-$,201

;	  Subroutine MSXDOS1 BDOS 00CH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	41EFH

CPMVER:
C41EF:	LD	C,00CH
        JP	J4F7C

        DEFS	0436CH-$,201

;	  Subroutine MSXDOS1 BDOS 013H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	436CH

DELETE:
C436C:	LD	C,013H
        JP	J4F7C

        DEFS	04392H-$,201

;	  Subroutine MSXDOS1 BDOS 017H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4392H

RENAME:
C4392:	LD	C,017H
        JP	J4F7C

        DEFS	04462H-$,201

;	  Subroutine MSXDOS1 BDOS 00FH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4462H

OPEN:
C4462:	LD	C,00FH
        JP	J4F7C

        DEFS	0456FH-$,201

;	  Subroutine MSXDOS1 BDOS 010H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	456FH

CLOSE:
C456F:	LD	C,010H
        JP	J4F7C

        DEFS	0461DH-$,201

;	  Subroutine MSXDOS1 BDOS 016H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	461DH

CREATE:
C461D:	LD	C,016H
        JP	J4F7C

        DEFS	046BAH-$,201

;	  Subroutine MSXDOS1 BDOS 02FH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	46BAH

ABSREA:
C46BA:	LD	C,02FH
        JP	J4F7C

        DEFS	04720H-$,201

;	  Subroutine MSXDOS1 BDOS 030H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4720H

ABSWRI:
C4720:	LD	C,030H
        JP	J4F7C

        DEFS	04775H-$,201

;	  Subroutine MSXDOS1 BDOS 014H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4775H

SEQRD:
C4775:	LD	C,014H
        JP	J4F7C

        DEFS	0477DH-$,201

;	  Subroutine MSXDOS1 BDOS 015H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	477DH

SEQWRT:
C477D:	LD	C,015H
        JP	J4F7C

        DEFS	04788H-$,201

;	  Subroutine MSXDOS1 BDOS 021H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4788H

RNDRD:
C4788:	LD	C,021H
        JP	J4F7C

        DEFS	04793H-$,201

;	  Subroutine MSXDOS1 BDOS 022H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4793H

RNDWRT:
C4793:	LD	C,022H
        JP	J4F7C

        DEFS	047B2H-$,201

;	  Subroutine MSXDOS1 BDOS 027H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	47B2H

BLKRD:
C47B2:	LD	C,027H
        JP	J4F7C

        DEFS	047BEH-$,201

;	  Subroutine MSXDOS1 BDOS 026H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	47BEH

BLKWRT:
C47BE:	LD	C,026H
        JP	J4F7C

        DEFS	047D1H-$,201

;	  Subroutine MSXDOS1 BDOS 028H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	47D1H

ZWRITE:
C47D1:	LD	C,028H
        JP	J4F7C
;
; SPACE 047D6H - 04FB7 USED OTHERWISE IN DOS1 ROM
;

J47D6:	CALL	INIHRD			; driver: initialize hardware
	DI
	LD	A,(IDBYT2)
	OR	A			; MSX1 ?
	RET	Z			; yep, quit
	LD	A,(DEVICE)
	OR	A			; disksystem initialization status

	IF	TURBOR
	JP	M,J481A			; disksystem initialization canceled, select R800 DRAM when DOS1 key was not pressed and quit
	ELSE
	RET	M			; disksystem initialization canceled, quit
	ENDIF

	JP	NZ,J4873		; not the first disk interface, skip
	LD	HL,HOKVLD
	BIT	0,(HL)			; extended BIOS initialized ?
	JR	NZ,J47FC		; yep, skip
	SET	0,(HL)
	LD	HL,EXTBIO
	LD	B,3*5
J47F7:	LD	(HL),0C9H
	INC	HL
	DJNZ	J47F7			; initialize extended BIOS
J47FC:	LD	HL,(BOTTOM)
	LD	DE,BOT16K+1
	RST	DCOMPR			; at least 16KB RAM ?
	JR	NC,J481A		; nope, cancel disksystem initialization and quit
	LD	HL,(HIMEM)
	LD	DE,VARWRK
	RST	DCOMPR			; memory allocated below VARWRK ?
	JR	NZ,J481A		; yep, cancel disksystem initialization and quit
	LD	A,6
	CALL	SNSMAT
	DI
	RRCA				; SHIFT key pressed ?
	JR	C,J482B			; nope, continue
	LD	A,7
	RST	OUTDO			; beep
J481A:	LD	A,0FFH
	LD	(DEVICE),A

        IF	TURBOR EQ 1
	XOR	A
	CALL	SNSMAT
	BIT	1,A			; 1 key pressed ?
	LD	A,82H
	CALL	NZ,CHGCPU		; nope, select R800 DRAM mode
	ENDIF

	RET

J482B:	CALL	C4938			; select system memory mapper with at least 6 segments
	RET	C			; error, quit
	LD	HL,VARWRK-LF1C9
	CALL	C5604			; allocate static workarea disksystem
	RET	C			; error, quit
	LD	BC,VARWRK-LF1C9
J4839:	XOR	A
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J4839		; clear static workarea disksystem
	LD	(AUTLIN),BC		; bigest sectorsize sofar = 0
	LD	B,4*2+4*3
	LD	HL,DRVTBL
J484A:	LD	(HL),A
	INC	HL
	DJNZ	J484A			; clear disk interface tables
	LD	HL,LF24F
	LD	B,69H
J4853:	LD	(HL),0C9H
	INC	HL
	DJNZ	J4853			; initialize DOS1 disksystem hooks
	LD	HL,LF365
	LD	(HL),0DBH
	INC	HL
	LD	(HL),0A8H
	INC	HL
	LD	(HL),0C9H		; initialize disk system read primairy slotregister routine
	LD	A,6
	CALL	SNSMAT
	DI
	AND	02H			; CTRL key status
	LD	(LF33F),A		; save for later (phantom mode)
	LD	A,7
	RST	OUTDO			; beep
	JR	J487E			; continue init
;
; other disksystem rom has already started disksystem init
;
J4873:	LD	A,(LF313)
	CP	23H			; other disksystem at least version 2.3x ?
	JR	NC,J4896		; yep, leave init at other disksystem
	CALL	C4938			; select system memory mapper with at least 6 segments
	RET	C			; error, quit
;
; I am doing the disksystem init
;
J487E:	LD	A,23H
	LD	(LF313),A		; disksystem 2.3x is doing the init
	CALL	C402D			; get my slotid
	LD	HL,H.RUNC
	LD	(HL),0F7H
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),LOW J4969
	INC	HL
	LD	(HL),HIGH J4969
	INC	HL
	LD	(HL),0C9H		; hook H.RUNC for further disksystem init
;
; intialize for drives supported by this disk interface
;
J4896:	CALL	C4914			; check DRVTBL
	RET	Z			; no entries or drives left, quit
	LD	HL,MYSIZE
	CALL	C5604			; allocate driver workarea
	JR	C,J490C			; error,
	EX	DE,HL
	CALL	C4DE3			; get SLTWRK entry
	LD	(HL),E
	INC	HL
	LD	(HL),D			; register driver workarea
	LD	HL,(AUTLIN)
	LD	DE,SECLEN
	RST	DCOMPR			; sector size driver bigger then sofar ?
	JR	NC,J48B6
	LD	(AUTLIN),DE		; yep, update bigest sector size sofar
J48B6:	CALL	C4914			; check DRVTBL
	LD	HL,DRVTBL
	LD	D,0
	ADD	HL,DE
	ADD	HL,DE
	EX	DE,HL			; free DRVTBL entry
	LD	A,(LF33F)
	OR	A			; phantom drive flag
	LD	A,C			; total drives sofar
	CALL	DRIVES			; driver: get number of drives
	ADD	A,L			; update total drives
	CP	8+1			; total more as 8 drives ?
	JR	C,J48D0			; nope, continue
	LD	A,8
J48D0:	SUB	C			; as much drives as possible
	JR	Z,J490C			; no drives from this interface,
	LD	(DE),A			; register drives in DRVTBL 
	INC	DE
	CALL	C402D			; get my slotid
	LD	(DE),A			; register slotid in DRVTBL
	LD	B,0
	LD	HL,LF355
	ADD	HL,BC
	ADD	HL,BC			; DPB entry
	PUSH	HL
	DEC	DE
	LD	A,(DE)			; number of drives
	PUSH	AF
	LD	C,A
	ADD	A,A
	ADD	A,A
	ADD	A,C
	ADD	A,A
	ADD	A,A
	ADD	A,C			; *21
	LD	L,A
	LD	H,B
	CALL	C4C78			; allocate DPBs
	EX	DE,HL
	POP	AF
	POP	HL
J48F3:	LD	(HL),E
	INC	HL
	LD	(HL),D			; register DPB area in table
	INC	HL
	PUSH	HL
	LD	HL,DEFDPB
	LD	BC,21
	LDIR				; initialize DPB with driver default
	POP	HL
	DEC	A			; done all drives ?
	JR	NZ,J48F3		; nope, next drive
	CALL	INIENV			; driver: initialize workarea
	LD	HL,DEVICE
	INC	(HL)			; update number of disksystems
	RET

; set number of disk interfaces to 1 if this is the first disk interface but memory allocation for diskdriver fails or number of drives = 0
; by doing this, this disk interface can still work as a (standalone) DOS2

J490C:	LD	HL,DEVICE
	INC	(HL)
	DEC	(HL)
	RET	NZ
	INC	(HL)
	RET

;	  Subroutine check DRVTBL
;	     Inputs  ________________________
;	     Outputs ________________________

C4914:	LD	HL,DRVTBL
	LD	B,4
	XOR	A			; total drives = 0
	LD	E,A			; entry 0
J491B:	LD	C,A
	ADD	A,(HL)			; update total drives
	JR	C,J4935			; should not happen (DRVTBL corrupt), halt system
	CP	C			; empty entry (drives = 0) ?
	JR	Z,J4929			; yep,
	INC	E
	INC	HL
	INC	HL			; next entry
	DJNZ	J491B			; next disk interface
	CP	A			; Zx set, Cx reset
	RET

J4929:	ADD	A,(HL)
	CP	C			; empty entry (drives = 0) ?
	JR	NZ,J4935		; nope, should not happen (DRVTBL corrupt), halt system
	INC	HL
	INC	HL			; next entry
	DJNZ	J4929			; next disk interface
	CP	8			; maximum number of drives ?
	RET	Z			; yep, quit with Zx set, Cx reset
	RET	C			; nope, quit with Zx reset, Cx set
J4935:	JP	J4C7C			; halt system

;	  Subroutine select system memory mapper with at least 6 segments
;	     Inputs  ________________________
;	     Outputs ________________________

;       This is what the stack looks like at entry:
;
;       prim    exp
;       +0      +0      returnaddress C4938 caller
;       +2      +2      callf BIOS registers
;       +6      +14     returnaddress CALLF caller

C4938:	CALL	C4E3A			; get current slotid page 2
	CALL	C4100			; check and invoke preferred memory mapper (6 or more segments)
	RET	C			; error, quit
	LD	HL,5			; offset stored primairy slot register (before CALLF)
	ADD	HL,SP
	IN	A,(0A8H)
	RRD
	LD	(HL),A			; update primairy slot page 3 and 2 on stack (otherwise memory mapper slot change will be rolled back)
	CALL	C4E2D			; get slotid page 1 (slot id of this disk ROM)
	BIT	7,A			; in secundairy slot ?
	RET	Z			; nope, quit
	LD	HL,12			; offset stored secundairy slot register (before CALLF)
	ADD	HL,SP
	LD	C,A			; store slot id
	CALL	C4E49			; get slotid page 3 (slot id of system memory mapper)
	XOR	C
	AND	03H			; this disk ROM in the same primairy slot as system memory mapper ?
	JR	NZ,J4962		; nope, skip update on secundairy slot
	LD	A,(LFFFF)
	CPL
	RRD
	LD	(HL),A			; update secundairy slot page 3 and 2 on stack (otherwise memory mapper change will be rolled back)
J4962:	DEC	HL
	IN	A,(0A8H)
	RRD
	LD	(HL),A			; update primairy slot page 3 and 2 on stack (otherwise memory mapper slot change will be rolled back)
	RET

;	  Subroutine H.RUNC handler
;	     Inputs  -
;	     Outputs -
;         Remark     Control is passed to this routine when the BASIC interpreter is initialized
;                    There are two ways: a BASIC program in ROM is started OR at the start of MSX-BASIC

J4969:	LD	HL,H.RUNC
	LD	B,5
J496E:	LD	(HL),0C9H
	INC	HL
	DJNZ	J496E			; clear H.RUNC
	LD	HL,DEVICE
	LD	A,(HL)
	LD	(HL),B			; clear DEVICE
	OR	A			; disksystem initialization flag
	RET	M			; disksystem initialization aborted, quit
	LD	D,A			; save number of disk interfaces
	CALL	C4914			; check DRVTBL
	LD	(LF347),A		; register total number of drives
	LD	A,D
	SUB	E			; number of used DRVTBL entries same as number of interfaces ?
	JR	Z,J4994			; yep, continue
	DEC	A			; 1 extra (standalone DOS2) ?
	JP	NZ,J4C7C		; nope (DRVTBL corrupted?), halt system
	LD	DE,HOOKSA+0
	LD	HL,HOOKSA+3
	LD	BC,4*3			; BUG: should be 3*3
	LDIR				; remove entry from HOOKSA
J4994:	CALL	C402D			; get my slotid
	LD	(LF348),A		; master disksystem slotid
	LD	HL,M0034
	LD	DE,LF30F
	LD	BC,4
	LDIR				; initialize double byte header char table
	LD	A,(IDBYT0)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	07H
	LD	(LF30E),A		; store data format
	LD	HL,LF327
	LD	(HL),3EH
	INC	HL
	LD	(HL),1AH
	INC	HL
	LD	B,2*5-2
J49BC:	LD	(HL),0C9H
	INC	HL
	DJNZ	J49BC			; initialize AUX device hooks
	LD	A,0CDH
	LD	HL,XF368		; ENAKRN
	LD	(LF1C9+0),A
	LD	(LF1C9+1),HL
	LD	A,0C3H
	LD	HL,J53AC
	LD	(LF1C9+3),A
	LD	(LF1C9+4),HL		; initialize print string routine
	LD	HL,C4109
	LD	(LF2DA),HL		; address copy errorstring to buffer routine
	LD	HL,I4D5A
	LD	(LF2DC),HL		; address prompt routine
	LD	HL,I6AD8
	LD	(LF2DE),HL		; address BDOS handler
	LD	HL,J6ADC
	LD	(LF333),HL		; address DiskBASIC BDOS handler
	LD	A,0FFH
	LD	(LF338),A		; clockchip detected
	LD	HL,21
	CALL	C4C78			; allocate DPB for ramdisk
	LD	(LF353),HL		; save DPB ramdisk
	LD	HL,(AUTLIN)
	LD	DE,512
	RST	DCOMPR			; bigest sector size at least 512 bytes ?
	JR	NC,J4A07
	EX	DE,HL			; nope, use 512 bytes
J4A07:	LD	(LF34F),HL		; save bigest sector size
	INC	HL			; 1 extra for FAT valid flag
	CALL	C4C78			; allocate for sector buffer and FAT flag
	LD	(HL),0			; FAT buffer flag = unchanged
	INC	HL
	LD	($SECBUF),HL		; sector buffer
	LD	HL,LF353
	LD	BC,256*(8+1)+0FFH
J4A1A:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	A,E
	OR	D			; DPB used ?
	JR	Z,J4A32			; nope, next entry
	EX	DE,HL
	LD	(HL),C			; set drivenumber in DPB
	PUSH	BC
	LD	BC,19
	ADD	HL,BC
	LD	BC,($SECBUF)
	LD	(HL),C
	INC	HL
	LD	(HL),B			; set pointer to FAT to sector buffer (some sort of compatibility)
	POP	BC
	EX	DE,HL
J4A32:	INC	C
	DJNZ	J4A1A			; next DPB
	CALL	C4E3A			; get current slotid page 2
	CALL	C4103			; install disksystem routines
	JP	C,J4C7C			; error, halt system
	LD	HL,100+64+100+64
	CALL	C4C78			; allocate buffers
	LD	(LF2F5),HL		; buffer for transfering BDOS structures
	LD	DE,100
	ADD	HL,DE
	LD	(LF2F7),HL		; buffer for transfering BDOS FIB
	LD	DE,64
	ADD	HL,DE
	LD	(LF2F9),HL		; buffer for transfering BDOS FIB or Path
	LD	DE,100
	ADD	HL,DE
	LD	(LF2FB),HL		; buffer for transfering BDOS errorstring
	LD	HL,(HIMEM)
	LD	(LF349),HL		; register highest memory used by basic disksystem
	LD	HL,H.TIMI
	PUSH	HL
	LD	DE,LF2C0
	LD	BC,5
	LDIR
	POP	HL
	LD	DE,C4049
	CALL	C4C9B			; install H.TIMI handler
	LD	HL,EXTBIO
	LD	DE,LF2D5
	LD	BC,5
	PUSH	HL
	LDIR
	POP	HL
	LD	DE,C4043
	CALL	C4C9B			; install EXTBIO handler
	CALL	C56A5			; setup hooks for disksystem handlers
	LD	HL,M7D2F+1
	LD	A,(EXPTBL+0)
	CALL	RDSLT
	PUSH	AF
	INC	SP
	DEC	HL
	LD	A,(EXPTBL+0)
	CALL	RDSLT
	PUSH	AF
	INC	SP
	POP	IX			; get address of BASIC screen init
	LD	IY,(EXPTBL+0-1)
	CALL	CALSLT			; execute SCREEN INIT
	CALL	C4C8E			; check H.CLEA and take action
	LD	SP,TMPSTK

	IF	DOS1 EQ 1
	CALL	C518D			; invoke DOS1 kernel if DOS1 key pressed
	ENDIF

	LD	A,(H.STKE+0)
	CP	0C9H			; H.STKE setup for interception (by ROM) ?
	LD	IX,M7D17
	JR	NZ,J4AD1		; yep, initialize and start DiskBASIC (allow interception by ROM)
	LD	A,(BASROM)
	OR	A			; about to start BASIC program in ROM ?
	LD	IX,M7DE9
	JR	NZ,J4AD1		; yep,  initialize and start DiskBASIC (starts BASIC program in ROM)
	CALL	C4C3E			; disable XFER, SetRamPg1, SetRomPg1

	IF	DOS1 EQ 1
	LD	A,(RAMAD3)
	LD	(RAMAD2),A		; RAM slotid page 2 = slotid RAM memory mapper
	ENDIF

	JR	J4ADA

J4AD1:
	IF	DOS1 EQ 1
	CALL	C519A			; invoke DOS1 kernel if DEFUSR0 is defined
	ENDIF

	CALL	C4C10			; initialize DiskBASIC
	JP	CALBAS			; start DiskBASIC

J4ADA:	LD	HL,J4B43
	PUSH	HL			; start DiskBASIC when returned

        IF ROMVER GE 3
	LD	A,(LF2FD)
	OR	A			; bootdrive specified by driver ?
	JR	NZ,J4AF6		; yep, start MSX-DOS2 from specified drive
	ENDIF

	CALL	C6952			; try to load bootsector from any drive
	RET	Z			; no valid bootdrive, quit to DiskBASIC

	IF	DOS1 EQ 1
	CALL	C51A9			; if disk has no volid, invoke DOS1 kernel. Otherwise start bootloader with Cx reset
	ELSE
	CALL	J4B23			; start bootloader with Cx reset
	ENDIF

	LD	HL,(BOTTOM)
	LD	DE,BOT32K
	RST	DCOMPR			; at least 32 KB RAM ?
	RET	NZ			; nope, quit to DiskBASIC
	LD	A,(LF23C)		; start MSX-DOS2 from default drive

J4AF6:	LD	HL,I4B40		; empty commandline
	JR	J4AFE			; start MSX-DOS2

J4AFB:	LD	A,(LF2FD)		; bootdrive
J4AFE:	LD	SP,TMPSTK
	PUSH	HL
	LD	HL,J4B43
	EX	(SP),HL			; start DiskBASIC when returned
	PUSH	AF
	LD	A,0FFH
	LD	(LF346),A		; MSXDOS was started
	POP	AF

	IF (ROMVER EQ 0) OR (ROMVER GE 3)
	CALL	C68BB			; prepare for DOS, try to load and start MSXDOS2.SYS
	ELSE
	JP	J5254			; prepare for DOS, try to load and start MSXDOS2.SYS patched
J4B0A:
	ENDIF

        IF ROMVER GE 3
	LD	A,(LF340)
	OR	A			; first start of DiskBASIC ?
	RET	NZ			; nope, abort DOS1 start, start DiskBASIC
	ENDIF

	CALL	C6952			; try to load bootsector from any drive
	RET	Z			; no valid bootdrive, start DiskBASIC

	IF	DOS1 EQ 1
	CALL	C5243			; check if disk has a volumeid
	RET	NZ			; nope, start DiskBASIC
	ENDIF

	LD	A,0C3H
	CALL	C4C40			; enable XFER, SetRamPg1, SetRomPg1
	SCF				; start bootloader with Cx set (MSXDOS disk system)

;	  Subroutine start bootloader
;	     Inputs  Cx = bootflag (Cx reset = start basic disk system, Cx set = start MSXDOS disk system)
;	     Outputs ________________________

J4B23:	LD	HL,LF323		; address DOS1 disk error handler
	LD	DE,XF368		; ENAKRN handler
	LD	A,(LF340)		; DiskBASIC first start flag
	JP	BOT16K+01EH		; start bootloader

I4B2F:	DEFB	'RUN"\AUTOEXEC.BAS'

I4B40:	DEFB	0

S4B2F	EQU	$-I4B2F

; pointer to DOS1 disk error handler

I4B41:	DEFW	J4BA3

;	  Subroutine start DiskBASIC
;	     Inputs  ________________________
;	     Outputs ________________________

J4B43:	LD	SP,TMPSTK		; switch to temporary stack (force page 3 stack)
	CALL	C4C3E			; disable XFER, SetRamPg1, SetRomPg1
	LD	HL,I4B2F
	LD	DE,BUF+10+2
	LD	BC,S4B2F
	LDIR				; prepare RUN command in temporary buffer
	LD	HL,LF340
	LD	A,(HL)
	OR	A			; first start of DiskBASIC ?
	LD	(HL),H			; not anymore
	JR	NZ,J4B78		; nope,
	LD	(LF346),A		; MSXDOS not started yet
	LD	HL,I4B41
	LD	(LF323),HL		; register DOS1 disk error handler
	LD	DE,BUF+10+2+4		; \AUTOEXEC.BAS
	LD	A,1			; no write
	LD	C,43H			; Open file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	NZ,J4BA3		; error, just start BASIC
	LD	C,45H			; Close file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	J4BA7			; start BASIC with running AUTOEXEC.BAS

J4B78:	LD	A,(WBOOT)
	CP	0C3H			; start DiskBASIC from MSXDOS ?
	JR	NZ,J4BA3		; nope, just start BASIC
	LD	HL,DBUF
	LD	B,(HL)
	INC	B
	DEC	B			; commandline argument (BASIC filename) specified ?
	JR	Z,J4BA3			; nope, just start BASIC
J4B87:	INC	HL
	LD	A,(HL)
	CALL	C4B92			; is space character ?
	JR	NZ,J4B98		; nope, copy BASIC filename
	DJNZ	J4B87
	JR	J4BA3			; just start BASIC

;	  Subroutine is space character ?
;	     Inputs  ________________________
;	     Outputs ________________________

C4B92:	CP	9
	RET	Z
	CP	" "
	RET

J4B98:	XOR	A
	LD	C,B
	LD	B,A			; size
	LD	DE,BUF+10+2+4
	LDIR				; copy BASIC file
	LD	(DE),A			; end of line
	JR	J4BA7			; start BASIC with RUN file

;	  Subroutine DOS1 disk error handler
;	     Inputs  ________________________
;	     Outputs ________________________

J4BA3:	XOR	A
	LD	(BUF+10+2+3),A		; BASIC command is just RUN

J4BA7:	LD	SP,TMPSTK		; switch to temporary stack (force page 3 stack)
	LD	A,(RAMAD2)
	LD	H,HIGH 08000H
	CALL	ENASLT			; enable RAM in page 2
	LD	A,(EXPTBL+0)
	LD	H,HIGH 00000H
	CALL	ENASLT			; enable BIOS in page 0
	CALL	C4C10			; initialize DiskBASIC
J4BBD:	LD	BC,0*256+061H		; Rejoin parent process
	CALL	BDOS			; DiskBASIC BDOS call
	JR	NZ,J4BBD		; error, try again
	LD	HL,(BOTTOM)
	XOR	A
	LD	(HL),A			; first byte of BASIC program area must be an end of line marker
	INC	HL
	LD	(TXTTAB),HL		; start of BASIC program area
	LD	(HL),A
	INC	HL
	LD	(HL),A			; end of program marker
	INC	HL
	LD	(VARTAB),HL		; start of BASIC variable area
	LD	HL,0FFFFH
	LD	(CURLIN),HL		; BASIC is not executing a program (direct mode)
	LD	SP,(STKTOP)		; initialize stack for BASIC
	LD	A,0FFH
	LD	(CNSDFG),A		; enable function key display
	LD	IX,M7D31
	CALL	CALBAS			; continue initializing BASIC screen
	CALL	C4D89			; print newline
	LD	DE,I413A		; DiskBASIC version string
	CALL	C4DA5			; print string
	CALL	C4D89			; print newline
	LD	HL,NTSTOP
	PUSH	HL			; execute BASIC statement
	LD	HL,BUF+10+2-1
	PUSH	HL			; BASIC text pointer to prepared RUN statement
	LD	HL,BUF+10
	PUSH	HL			; setup 'routine'
	LD	(HL),0E1H		; POP HL
	INC	HL
	LD	(HL),0C9H		; RET
	LD	A,(EXPTBL+0)
	LD	H,HIGH 04000H
	JP	ENASLT			; BASIC ROM on page 1 and start setup routine

;	  Subroutine initialize DiskBASIC
;	     Inputs  ________________________
;	     Outputs ________________________

C4C10:	LD	HL,(LF349)
	LD	(HIMEM),HL		; top of BASIC = bottom of basic disksystem
	CALL	C6A5C			; select TPA segments
	LD	HL,I6563
	LD	(LF323),HL		; register DOS1 disk error handler
	LD	HL,I6568
	LD	(LF325),HL		; register DOS1 abort handler
	LD	BC,(LF34F)		; bigests sectorsize
	CALL	C4C68			; allocate memory (HIMEM only)
	LD	(LF351),HL		; register BASIC sector buffer (DOS1 compatibility)
	LD	(LF33B),HL		; register BASIC path buffer
	LD	BC,S4C4A		; size BLOAD/BSAVE code
	CALL	C4C68			; allocate memory (HIMEM only)
	CALL	C4C4A			; setup BLOAD/BSAVE code
	CALL	C565C			; intialize BASIC stack and file buffers

;	  Subroutine disable XFER, SetRamPg1, SetRomPg1
;	     Inputs  ________________________
;	     Outputs ________________________

C4C3E:	LD	A,0C9H

;	  Subroutine enable/disable XFER, SetRamPg1, SetRomPg1
;	     Inputs  ________________________
;	     Outputs ________________________

C4C40:	LD	(XF368+0),A
	LD	(XF36B+0),A
	LD	(XF36E+0),A
	RET

;	  Subroutine setup BLOAD/BSAVE code
;	     Inputs  ________________________
;	     Outputs ________________________

C4C4A:	LD	(LF2F1),HL		; register BLOAD code start
	EX	DE,HL
	LD	HL,I4CB8
	LDIR				; install BLOAD/SAVE code
	LD	HL,-S4CC0
	ADD	HL,DE			; size BSAVE code
	LD	(LF2F3),HL		; register BSAVE code start
	LD	A,(LF348)
	LD	HL,-12
	ADD	HL,DE
	LD	(HL),A			; master disksystem slot for BLOAD FCALL
	LD	HL,-4
	ADD	HL,DE
	LD	(HL),A			; master disksystem slot for BSAVE FCALL
	RET

;	  Subroutine allocate memory (HIMEM only)
;	     Inputs  ________________________
;	     Outputs ________________________

C4C68:	LD	HL,(HIMEM)
	OR	A
	SBC	HL,BC
	LD	(HIMEM),HL
	JR	C,J4C7C			; halt system
	LD	A,H
	CP	HIGH 0C200H
	JR	J4C7B

;	  Subroutine allocate memory and halt system when insufficient
;	     Inputs  ________________________
;	     Outputs ________________________

C4C78:	CALL	C5604			; allocate memory

J4C7B:	RET	NC

J4C7C:	LD	A,12			; clear screen
	CALL	C4DBF			; print character
	LD	A,1
	LD	DE,BUF
	CALL	C4106			; copy message to buffer
	CALL	C4DA5			; print string
	DI
	HALT				; halt system

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4C8E:	LD	HL,H.CLEA+0
	LD	A,(HL)
	CP	0C9H			; H.CLEA has hook handler for intercept ?
	RET	Z			; nope, quit
	LD	HL,H.LOPD
	LD	DE,I4CAA		; yep, install H.LOPD handler to regain control after H.CLEA

;	  Subroutine install hook handler
;	     Inputs  HL = hook, DE = hook handler
;	     Outputs ________________________

C4C9B:	LD	(HL),0F7H
	INC	HL
	LD	A,(LF348)
	LD	(HL),A
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),0C9H
	RET

;	  Subroutine H.LOPD handler (regain control after H.CLEA)
;	     Inputs  ________________________
;	     Outputs ________________________

I4CAA:	LD	A,0C9H
	LD	(H.LOPD+0),A		; remove H.LOPD handler
	LD	DE,(HIMEM)
	LD	(LF349),DE		; register bottom of basic diskssystem
	RET

;	  Subroutine BLOAD code
;	     Inputs  ________________________
;	     Outputs ________________________

I4CB8:	RST	CALLF
	DEFB	0			; slotid, setup later
	DEFW	J5DB6			; BLOAD handler
	PUSH	HL
	JP	BLDFIN			; finish BLOAD

;	  Subroutine BSAVE
;	     Inputs  ________________________
;	     Outputs ________________________

I4CC0:	RST	CALLF
	DEFB	0			; slotid, setup later
	DEFW	J5CF2			; BSAVE handler
	RET

S4CC0	EQU	$-I4CC0
S4C4A	EQU	$-I4CB8

;	  Subroutine H.PHYD handler
;	     Inputs  ________________________
;	     Outputs ________________________

C4CC5:	EI
	PUSH	HL
	PUSH	AF
	CALL	C4CE1
	JR	C,J4CD3
	SCF
	LD	A,12
	POP	HL
	POP	HL
	RET

J4CD3:	LD	L,A
	POP	AF
	LD	A,L
	POP	HL
	PUSH	HL
	LD	IX,C4010
	CALL	LF1DF
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4CE1:	PUSH	BC
	LD	(LF33F),A
	LD	HL,DRVTBL
	LD	B,4
J4CEA:	SUB	(HL)
	JR	NC,J4CF5
	ADD	A,(HL)
	INC	HL
	LD	H,(HL)
	PUSH	HL
	POP	IY
	POP	BC
	RET

J4CF5:	INC	HL
	INC	HL
	DJNZ	J4CEA
	POP	BC
	RET

;	  Subroutine stop motor of all floppy drives
;	     Inputs  ________________________
;	     Outputs ________________________

J4CFB:	LD	HL,DRVTBL
	LD	B,4
J4D00:	INC	HL
	LD	A,(HL)			; slotid disk interface
	PUSH	AF
	POP	IY
	INC	HL
	PUSH	HL
	PUSH	BC
	LD	HL,C401F
	PUSH	HL
	POP	IX
	OR	A			; entry used ?
	CALL	NZ,RDSLT		; yep, read MTOFF entry
	OR	A			; disk interface has an MTOFF entry ?
	
	IF	DOS1 EQ 1
	CALL	NZ,LF1DF		; yep, invoke disk interface MTOFF
	ELSE
	CALL	CALSLT
	ENDIF

	POP	BC
	POP	HL
	DJNZ	J4D00			; next entry
	RET

;	  Subroutine timer routine DOS2
;	     Inputs  ________________________
;	     Outputs ________________________

C4D1B:	PUSH	AF			; store VDP statusregister
	CALL	C6A9A			; invoke DOS2 interrupt handler
	CALL	C4D26			; invoke the interrupt handler of all disk interfaces
	POP	AF			; restore VDP statusregister
	JP	LF2C0			; other interrupt handler (old H.TIMI)

;	  Subroutine invoke the interrupt handler of all disk interfaces
;	     Inputs  ________________________
;	     Outputs ________________________

C4D26:	LD	DE,DRVTBL
	LD	HL,HOOKSA
	LD	B,4
J4D2E:	LD	A,(DE)
	AND	A			; DRVTBL entry used ?
	RET	Z			; nope, end of table, quit
	INC	DE
	LD	A,(DE)			; slotid disk interface
	INC	DE
	CP	(HL)			; does disk interface has an interrupt handler ?
	JR	NZ,J4D4F		; nope, next disk interface
	LD	A,(LF348)
	CP	(HL)			; is it the master diskrom ?
	LD	A,(HL)
	PUSH	BC
	PUSH	DE
	PUSH	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; address interrupt routine
	PUSH	AF
	POP	IY
	PUSH	DE
	POP	IX
	CALL	C4D55			; invoke interrupt routine
	POP	HL
	POP	DE
	POP	BC
J4D4F:	INC	HL
	INC	HL
	INC	HL
	DJNZ	J4D2E			; next disk interface
	RET

;	  Subroutine invoke interrupt routine
;	     Inputs  ________________________
;	     Outputs ________________________

C4D55:	JP	NZ,CALSLT		; not in master diskrom, use CALSLT
	JP	(IX)			; in master diskrom, call direct

;	  Subroutine prompt routine (phantom drives)
;	     Inputs  ________________________
;	     Outputs ________________________

PROMPT:
I4D5A:	LD	A,(LF33F)
	ADD	A,"A"
	CALL	LF24F			; prompt hook
	PUSH	AF
	CALL	C4D89			; print newline
	LD	A,7
	CALL	C4D96			; print message
	POP	AF
	CALL	C4DBF			; print character
	LD	A,8
	CALL	C4D96			; print message
	CALL	C4D89			; print newline
	LD	A,9
	CALL	C4D96			; print message
J4D7C:	CALL	C4D83			; get fresh key and check if CTRL-C
	JR	Z,J4D7C			; CTRL-C, try agan
	JR	C4D89			; print newline

;	  Subroutine get fresh key and check if CTRL-C
;	     Inputs  ________________________
;	     Outputs ________________________

C4D83:	CALL	C4DAE			; get fresh key
	CP	3
	RET

;	  Subroutine print newline
;	     Inputs  ________________________
;	     Outputs ________________________

C4D89:	PUSH	AF
	LD	A,13
	CALL	C4DBF			; print character
	LD	A,10
	CALL	C4DBF			; print character
	POP	AF
	RET

;	  Subroutine print message
;	     Inputs  ________________________
;	     Outputs ________________________

C4D96:	PUSH	HL
	PUSH	DE
	LD	DE,($SECBUF)
	CALL	C4106			; copy message to buffer
	CALL	C4DA5			; print string
	POP	DE
	POP	HL
	RET

;	  Subroutine print string
;	     Inputs  ________________________
;	     Outputs ________________________

C4DA5:	LD	A,(DE)
	INC	DE
	OR	A
	RET	Z
	CALL	C4DBF			; print character
	JR	C4DA5

;	  Subroutine get fresh key
;	     Inputs  ________________________
;	     Outputs ________________________

C4DAE:	PUSH	IX
	PUSH	HL
	LD	IX,KILBUF
	CALL	C4DCB			; clear keyboard buffer
	POP	HL
	LD	IX,CHGET
	JR	J4DC5			; get keyboard character

;	  Subroutine print character
;	     Inputs  ________________________
;	     Outputs ________________________

C4DBF:	PUSH	IX
	LD	IX,CHPUT
J4DC5:	CALL	C4DCB
	POP	IX
	RET

;	  Subroutine invoke BIOS routine
;	     Inputs  ________________________
;	     Outputs ________________________

C4DCB:	PUSH	IY
	LD	IY,(EXPTBL+0-1)		; slotid BIOS
	CALL	CALSLT			; invoke BIOS routine
	EI
	POP	IY
	RET

;	  Subroutine get driver workarea
;	     Inputs  ________________________
;	     Outputs HL = IX = driver workarea

GETWRK:
C4DD8:	CALL	C4DE3			; get SLTWRK entry
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; driver workarea
	PUSH	HL
	POP	IX
	RET

;	  Subroutine get SLTWRK entry
;	     Inputs  ________________________
;	     Outputs ________________________

C4DE3:	IN	A,(0A8H)
	AND	0CH
	RRCA
	RRCA
	LD	HL,EXPTBL
	CALL	C4E04
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	INC	A
	LD	C,A
	LD	A,(HL)
	ADD	A,A
	SBC	A,A
	AND	0CH
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	AND	(HL)
	OR	C
	ADD	A,A
	LD	HL,SLTWRK

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4E04:	LD	C,A
	LD	B,0
	ADD	HL,BC
	RET

;	  Subroutine register interrupt handler
;	     Inputs  HL = interrupt handler
;	     Outputs ________________________

SETINT:
C4E09:	EX	DE,HL
	CALL	C402D			; get my slotid
	PUSH	AF
	LD	A,(DEVICE)		; disk interface number
	LD	HL,HOOKSA
	CALL	C4E04
	ADD	HL,BC
	ADD	HL,BC			; HOOKSA entry
	POP	AF
	LD	(HL),A			; slotid disk interface
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; interrupt handler

;	  Subroutine previous interrupt handler
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible, but has no function anymore
;                    driver interrupt are handled differently by the master diskrom

PRVINT:
	RET

;	  Subroutine get slotid page 0
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     not used

?4E20:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	CALL	C4E60
	JR	Z,J4E5D
	RLCA
	RLCA
	JR	J4E58

;	  Subroutine get slotid page 1
;	     Inputs  ________________________
;	     Outputs ________________________

C4E2D:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	RRCA
	RRCA
	CALL	C4E60
	JR	Z,J4E5D
	JR	J4E58

;	  Subroutine get slotid page 2
;	     Inputs  ________________________
;	     Outputs ________________________

C4E3A:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	C4E60
	JR	Z,J4E5D
	JR	J4E56

;	  Subroutine get slotid page 3
;	     Inputs  ________________________
;	     Outputs ________________________

C4E49:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	RLCA
	RLCA
	CALL	C4E60
	JR	Z,J4E5D
	RRCA
	RRCA
J4E56:	RRCA
	RRCA
J4E58:	AND	0CH
	OR	80H
	OR	C
J4E5D:	POP	BC
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4E60:	AND	03H
	LD	C,A
	LD	B,0
	LD	HL,EXPTBL
	ADD	HL,BC
	BIT	7,(HL)
	RET	Z
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

DIV16:
C4E72:	LD	HL,0
	LD	A,17
J4E77:	RL	C
	RL	B
	DEC	A
	RET	Z
	ADC	HL,HL
	JR	NC,J4E86
	OR	A
	SBC	HL,DE
	JR	J4E77

J4E86:	SBC	HL,DE
	JR	NC,J4E8B
	ADD	HL,DE
J4E8B:	CCF
	JR	J4E77

;	  Subroutine H.FORM handler
;	     Inputs  ________________________
;	     Outputs ________________________

C4E8E:	OR	A			; use free BASIC memory as workarea

;	  Subroutine format disk
;	     Inputs  HL = start of workarea, BC = size of workarea
;	     Outputs ________________________

J4E8F:	EI
	JR	C,J4EA4			; workarea is specified, continue
	LD	HL,-256
	ADD	HL,SP			; leave 256 bytes of stackspace
	LD	DE,(STREND)		; end of BASIC variable area
	XOR	A
	SBC	HL,DE
	LD	C,L
	LD	B,H			; size of workarea = size of the free BASIC memory area
	EX	DE,HL			; start of workarea = start of the free BASIC memory area
	JR	NC,J4EA4		; there was room, continue
	LD	C,A
	LD	B,A			; no room, size of workarea = 0 (some drivers do not need a workarea, so lets try)
J4EA4:	PUSH	HL
	PUSH	BC
	LD	L,0
	LD	BC,8*256+067H		; 8 drives, Format a disk
J4EAB:	ADD	HL,HL
	PUSH	HL
	PUSH	BC
	XOR	A			; return choice string
	CALL	BDOS			; DiskBASIC BDOS call
	POP	BC
	POP	HL
	JR	NZ,J4EB7		; error, invalid drive for format
	INC	HL			; valid drive for format
J4EB7:	DJNZ	J4EAB			; next drive
	LD	A,L
	OR	A			; any drives valid for format ?
	JP	Z,J4F6F			; nope,
	DEC	A
	AND	L
	LD	A,L
	JR	Z,J4F06			; only 1 drive, skip drive selection
	PUSH	HL
	LD	A,2
	CALL	C4D96			; print message
	POP	HL
	PUSH	HL
	LD	A,"A"-1
J4ECD:	INC	A
	SRL	L
	JR	NC,J4EDC
	CALL	C4DBF			; print character
	PUSH	AF
	LD	A,","
	CALL	NZ,C4DBF		; print character
	POP	AF
J4EDC:	JR	NZ,J4ECD
	LD	A,3
	CALL	C4D96			; print message
	POP	HL
J4EE4:	CALL	C4D83			; get fresh key and check if CTRL-C
	JP	Z,J4F6F			; CTRL-C,
	AND	0DFH			; to upper
	LD	C,A
	SUB	"A"
	CP	8
	JR	NC,J4EE4
	LD	B,A
	INC	B
	XOR	A
	SCF
J4EF7:	RLA
	DJNZ	J4EF7
	AND	L
	JR	Z,J4EE4
	PUSH	AF
	LD	A,C
	CALL	C4DBF			; print character
	CALL	C4D89			; print newline
	POP	AF
J4F06:	INC	B
	RRCA
	JR	NC,J4F06
	LD	C,67H			; Format a disk
	PUSH	BC
	XOR	A			; return choice string
	CALL	BDOS			; DiskBASIC BDOS call
	LD	A,L
	OR	H			; does the drive have a choice string ?
	JR	Z,J4F44			; nope, skip choice selection
	LD	A,B
J4F16:	PUSH	AF
	CALL	RDSLT
	OR	A
	JR	Z,J4F24
	CALL	C4DBF			; print character
	POP	AF
	INC	HL
	JR	J4F16

J4F24:	POP	AF
	LD	A,"?"
	CALL	C4DBF			; print character
	LD	A," "
	CALL	C4DBF			; print character
J4F2F:	CALL	C4D83			; get fresh key and check if CTRL-C
	JR	Z,J4F6E			; CTRL-C,
	SUB	"1"
	CP	8+1			; valid choice ?
	JR	NC,J4F2F		; nope, ask again
	ADD	A,"1"
	CALL	C4DBF			; print character
	CALL	C4D89			; print newline
	SUB	"1"
J4F44:	INC	A
	PUSH	AF
	LD	A,4
	CALL	C4D96			; print message
	CALL	C4D83			; get fresh key and check if CTRL-C
	JR	Z,J4F6D			; CTRL-C,
	CALL	C4D89			; print newline
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J4F69			; no error,
	LD	B,A
	LD	DE,($SECBUF)
	LD	C,66H			; Explain error code
	CALL	BDOS			; DiskBASIC BDOS call
	JP	C4DA5			; print string

J4F69:	LD	A,6
	JR	J4F76

J4F6D:	POP	AF
J4F6E:	POP	AF
J4F6F:	POP	AF
	POP	AF
	CALL	C4D89			; print newline
	LD	A,5
J4F76:	CALL	C4D96			; print message
	JP	C4D89			; print newline

J4F7C:	XOR	A
	LD	(LF306),A		; not a CP/M call (MSXDOS1)
	JP	J6ADC			; DiskBASIC BDOS handler


        DEFS	04FB8H-$,201

;	  Subroutine MSXDOS1 BDOS 011H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4FB8H

SRCHFR:
C4FB8:	LD	C,011H
        JP	J4F7C

        DEFS	05006H-$,201

;	  Subroutine MSXDOS1 BDOS 012H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5006H

SRCHNX:
C5006:	LD	C,012H
        JP	J4F7C

        DEFS	0501EH-$,201

;	  Subroutine MSXDOS1 BDOS 023H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	501EH

FILESI:
C501E:	LD	C,023H
        JP	J4F7C

        DEFS	0504EH-$,201

;	  Subroutine MSXDOS1 BDOS 018H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	504EH

LOGIN:
C504E:	LD	C,018H
        JP	J4F7C

        DEFS	05058H-$,201

;	  Subroutine MSXDOS1 BDOS 01AH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5058H

SETDMA:
C5058:	LD	C,01AH
        JP	J4F7C

        DEFS	0505DH-$,201

;	  Subroutine MSXDOS1 BDOS 01BH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	505DH

GETEFA:
C505D:	LD	C,01BH
        JP	J4F7C

        DEFS	0509FH-$,201

;	  Subroutine MSXDOS1 BDOS 00DH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	509FH

DSKRES:
C509F:	LD	C,00DH
        JP	J4F7C

        DEFS	050A9H-$,201

;	  Subroutine MSXDOS1 flush buffers
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50A9H

WRTFAT:
C50A9:	LD	BC,0FF5FH
        LD	D,0
        JP	J4F7C

        DEFS	050C4H-$,201

;	  Subroutine MSXDOS1 BDOS 019H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50C4H

GETDRV:
C50C4:	LD	C,019H
        JR	J50CA

        DEFS	050C8H-$,201

;	  Subroutine MSXDOS1 BDOS 024H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50C8H

SETRND:
C50C8:	LD	C,024H
J50CA:	JP	J4F7C

        DEFS	050D5H-$,201

;	  Subroutine MSXDOS1 BDOS 00EH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50D5H

SELDSK:
C50D5:	LD	C,00EH
        JP	J4F7C

        DEFS	050E0H-$,201

;	  Subroutine MSXDOS1 BDOS 00AH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50E0H

BUFIN:
C50E0:	LD	C,00AH
        JP	J4F7C

        DEFS	05183H-$,201

;	  Subroutine MSXDOS1 newline to console
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5183H

CRLF:
C5183:	LD	E,13
	CALL	C53A7			; Console output
	LD	E,10
	JP	C53A7			; Console output

;
; 0518DH - 053A7H USED OTHERWISE IN DOS1 ROM
;

	IF	DOS1 EQ 1

;	  Subroutine invoke DOS1 kernel if DOS1 key pressed
;	     Inputs  ________________________
;	     Outputs ________________________

C518D:	XOR	A
	CALL	SNSMAT
	BIT	1,A			; 1 key pressed ?

	IF	ROMVER GE 3
	IF	TURBOR EQ 1

	LD	A,82H
	JP	NZ,CHGCPU		; nope, select R800 DRAM mode and quit

	ELSE

	RET	NZ			; nope, quit

	ENDIF

	JR	J51AF			; start DOS1 kernel
	ELSE

	JR	Z,J51AF			; yep, start DOS1 kernel

	IF	TURBOR EQ 1
	LD	A,82H
	JP	CHGCPU			; select R800 DRAM mode and quit
	ELSE
	RET

	ENDIF
	ENDIF

;	  Subroutine invoke DOS1 kernel if DEFUSR0 is defined
;	     Inputs  ________________________
;	     Outputs ________________________

C519A:	LD	HL,USRTAB+0*2
	LD	A,(HL)
	CP	LOW FCERR
	RET	NZ
	INC	HL
	LD	A,(HL)
	CP	HIGH FCERR		; DEFUSR0 still illegal function call (default value) ?
	RET	NZ			; nope, quit
	POP	HL

        IF ROMVER GE 3
	JR	J51AF			; start DOS1 kernel

;	  Subroutine if disk has no volid, invoke DOS1 kernel. Otherwise start bootloader with Cx reset
;	     Inputs  ________________________
;	     Outputs ________________________

C51A9:	CALL	C5243			; check if disk has a volumeid
	JP	Z,J4B23			; yep, start bootloader with Cx reset (basic disk system)

        ENDIF

;	  Subroutine start DOS1 kernel
;	     Inputs  ________________________
;	     Outputs ________________________

J51AF:
	IF	TURBOR EQ 1
	LD	A,80H
	CALL	CHGCPU			; select Z80 mode
	ENDIF

	LD	A,(RAMAD2)
	LD	H,HIGH 08000H
	CALL	ENASLT			; select RAM in page 2
	DI
	LD	HL,LF2C0
	LD	DE,H.TIMI
	LD	BC,5
	LDIR				; restore orginal H.TIMI
	LD	HL,LF2D5
	LD	DE,EXTBIO
	LD	BC,5
	LDIR				; restore orginal EXTBIO
	LD	HL,(LF34F)		; bigests sectorsize
	LD	(AUTLIN),HL
	LD	HL,(LF353)
	LD	DE,21
	ADD	HL,DE
	LD	(HIMEM),HL		; deallocate RAMDISK DPB
	CALL	C565C			; intialize BASIC stack and file buffers
	LD	SP,(STKTOP)		; initialize stack
	XOR	A

	IF ROMVER EQ 0
	LD	(LF313),A		; clear DOS2 version
	LD	(LF314),A		; TPA segment page 0 = 0
	ENDIF

	LD	(LF23C),A		; default drive = A:


        IF ROMVER EQ 1
	LD	HL,LF313
	CALL	C525F			; clear DOS1 kernel variables
	ENDIF

	IF ROMVER EQ 2
	LD	HL,LF2B8
	CALL	C525F			; clear DOS1 kernel variables
	ENDIF

        IF ROMVER GE 3
	LD	HL,LF2B8
	LD	(HL),A
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,CLRSIZ
	LDIR				; clear DOS1 kernel variables
	ENDIF

	LD	DE,DRVTBL
	LD	HL,HOOKSA
	LD	B,4
J5202:	LD	A,(DE)
	OR	A			; entry used ?
	JR	Z,J523A			; nope, start DOS1 kernel
	INC	DE
	LD	A,(DE)			; slotid disk interface
	INC	DE
	CP	(HL)			; disk interface has an interrupt handler ?
	JR	NZ,J5235		; nope,
	PUSH	HL
	LD	HL,H.TIMI
	LD	A,(HL)
	SUB	0C9H			; does H.TIMI have a handler ?
	JR	NZ,J5220		; yep,
	LD	(HL),0F7H
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),0C9H		; nope, setup CALLF basics
J5220:	POP	HL
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	B,3
	LD	DE,H.TIMI+1
J5229:	LD	A,(DE)
	LD	C,(HL)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	J5229			; H.TIMI to driver interrupt handler, HOOKSA to current H.TIMI handler
	POP	BC
	POP	DE
	POP	HL
J5235:	INC	HL
	INC	HL
	INC	HL			; next HOOKSA entry
	DJNZ	J5202			; next disk interface
J523A:	LD	HL,A58A8
	PUSH	HL			; start DOS1 kernel entry
	LD	A,3
	JP	C7FD0			; select DOS1 segment

        IF ROMVER LT 3

I5253:	DEFB	"VOL_ID"
S5253	EQU	$-I5253

;	  Subroutine if disk has no volid, invoke DOS1 kernel. Otherwise start bootloader with Cx reset
;	     Inputs  ________________________
;	     Outputs ________________________

C51A9:	CALL	C5243			; check if disk has a volumeid
        JP      NZ,J51AF		; nope, start DOS1 kernel
        JP	J4B23			; start bootloader with Cx reset (basic disk system)
        ENDIF

;	  Subroutine check if disk has a volumeid
;	     Inputs  ________________________
;	     Outputs ________________________

C5243:	LD	HL,BOT16K+32
	LD	DE,I5253
	LD	B,S5253
J524B:	LD	A,(DE)
	CP	(HL)
	RET	NZ
	INC	HL
	INC	DE
	DJNZ	J524B
	RET

        IF ROMVER GE 3
I5253:	DEFB	"VOL_ID"
S5253	EQU	$-I5253
        ENDIF

	ENDIF

	IF (ROMVER EQ 1) OR (ROMVER EQ 2)

;	  Subroutine start MSXDOS patch
;	     Inputs  ________________________
;	     Outputs ________________________

J5254:	CALL	C68BB			; prepare for DOS, try to load and start MSXDOS2.SYS
	LD	A,(LF340)
	OR	A
	RET	NZ
	JP	J4B0A

;	  Subroutine initialize disk variables patch
;	     Inputs  ________________________
;	     Outputs ________________________

C525F:	LD	(HL),A
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,CLRSIZ
	LDIR
	RET

	ENDIF

; end of patch area

        DEFS	0535DH-$,201

;	  Subroutine MSXDOS1 print abort string
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	535DH

BUFOUT:
?535D:	EXX
	PUSH	BC
	EXX
	CALL	C5183			; newline to console
	LD	A,10
	LD	DE,($SECBUF)
	CALL	C4106			; copy message to buffer
	CALL	C5379			; print message
	POP	BC
	LD	DE,($SECBUF)
	LD	C,66H			; Explain error code
	CALL	BDOS			; DiskBASIC BDOS call

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C5379:	LD	A,(DE)
	OR	A
	RET	Z
	PUSH	DE
	LD	E,A
	CALL	C53A7			; Console output
	POP	DE
	INC	DE
	JR	C5379

        DEFS 053A7H-$,201

;	  Subroutine MSXDOS1 BDOS 002H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	53A7H

CONOUT:
C53A7:	LD	C,2
	JP	J4F7C

;
; 053ACH - 0543BH USED OTHERWISE IN DOS1 ROM
;

;	  Subroutine $ terminated string to console (0F1C9H)
;	     Inputs  ________________________
;	     Outputs ________________________

J53AC:	LD	HL,0C91AH
	PUSH	HL			; read byte from string on stack
	CALL	C53C0			; read byte from string (TPA)
	POP	HL
	CP	"$"
	RET	Z
	PUSH	DE
	LD	E,A
	CALL	C53A7			; Console output
	POP	DE
	INC	DE
	JR	J53AC			; next byte from string

;	  Subroutine read byte from string (TPA)
;	     Inputs  ________________________
;	     Outputs ________________________

C53C0:	LD	HL,XF368
	PUSH	HL			; SetRomPg1 on stack
	LD	HL,4
	ADD	HL,SP
	PUSH	HL			; read byte from string on stack
	JP	XF36B			; SetRamPg1
					; read byte from string
					; SetRomPg1

        DEFS	0543CH-$,201

;	  Subroutine MSXDOS1 BDOS 00BH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	543CH

CONSTA:
C543C:	LD	C,00BH
        JP	J4F7C

        DEFS	05445H-$,201

;	  Subroutine MSXDOS1 BDOS 001H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5445H

CONIN:
C5445:	LD	C,1
        JP	J4F7C

        DEFS	0544EH-$,201

;	  Subroutine MSXDOS1 BDOS 008H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	544EH

IN:
C544E:	LD	C,8
        JP	J4F7C

        DEFS	05454H-$,201

;	  Subroutine MSXDOS1 BDOS 006H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5454H

RAWIO:
C5454:	LD	C,6
        JP	J4F7C

        DEFS	05462H-$,201

;	  Subroutine MSXDOS1 BDOS 007H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5462H

RAWINP:
C5462:	LD	C,7
        DEFB	011H		; Pseudo LD DE,nnnn

;	  Subroutine MSXDOS1 BDOS 005H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5465H

LIST:
C5465:	LD	C,5
        JP	J4F7C

        DEFS	0546EH-$,201

;	  Subroutine MSXDOS1 BDOS 003H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	546EH

READER:
C546E:	LD	C,3
        JP	J4F7C

        DEFS	05474H-$,201

;	  Subroutine MSXDOS1 BDOS 004H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5474H

PUNCH:
C5474:	LD	C,4
        JP	J4F7C

        DEFS	0553CH-$,201

;	  Subroutine MSXDOS1 BDOS 02AH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	553CH

GETDAT:
C553C:	LD	C,02AH
        JP	J4F7C

        DEFS	05552H-$,201

;	  Subroutine MSXDOS1 BDOS 02BH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5552H

SETDAT:
C5552:	LD	C,02BH
        JP	J4F7C

        DEFS	055DBH-$,201

;	  Subroutine MSXDOS1 BDOS 02CH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	55DBH

GETTIM:
C55DB:	LD	C,02CH
        JP	J4F7C

        DEFS	055E6H-$,201

;	  Subroutine MSXDOS1 BDOS 02DH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	55E6H

SETTIM:
C55E6:	LD	C,02DH
        JP	J4F7C

        DEFS	055FFH-$,201

;	  Subroutine MSXDOS1 BDOS 02EH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	55FFH

SETRAW:
C55FF:	LD	C,02EH
        JP	J4F7C

;
; 05604H - 07FFFH USED OTHERWISE IN DOS1 ROM
;


;	  Subroutine allocate memory
;	     Inputs  HL = size
;	     Outputs HL = start of area, Cx set if insufficient memory

C5604:	LD	A,L
	OR	H
	RET	Z
	EX	DE,HL
	LD	HL,0
	SBC	HL,DE
	LD	C,L
	LD	B,H
	ADD	HL,SP
	CCF
	RET	C
	LD	A,H
	CP	HIGH 0C200H
	RET	C
	LD	DE,(BOTTOM)
	SBC	HL,DE
	RET	C
	LD	A,H
	CP	HIGH 512
	RET	C
	PUSH	BC
	LD	HL,0
	ADD	HL,SP
	LD	E,L
	LD	D,H
	ADD	HL,BC
	PUSH	HL
	LD	HL,(STKTOP)
	OR	A
	SBC	HL,DE
	LD	C,L
	LD	B,H
	INC	BC
	POP	HL
	LD	SP,HL
	EX	DE,HL
	LDIR
	POP	BC
	LD	HL,(HIMEM)
	ADD	HL,BC
	LD	(HIMEM),HL
	LD	DE,-(2*256 + 2*9 + 2*2)
	ADD	HL,DE
	LD	(FILTAB),HL
	EX	DE,HL
	LD	HL,(MEMSIZ)
	ADD	HL,BC
	LD	(MEMSIZ),HL
	LD	HL,(NULBUF)
	ADD	HL,BC
	LD	(NULBUF),HL
	LD	HL,(STKTOP)
	ADD	HL,BC
	JR	J5681

;	  Subroutine intialize BASIC stack and file buffers
;	     Inputs  ________________________
;	     Outputs ________________________

C565C:	LD	A,1
	LD	(MAXFIL),A
	LD	HL,(HIMEM)
	LD	DE,-(2*256 + 2*9 + 2*2)
	ADD	HL,DE
	LD	(FILTAB),HL
	LD	E,L
	LD	D,H
	DEC	HL
	DEC	HL
	LD	(MEMSIZ),HL
	LD	BC,200
	OR	A
	SBC	HL,BC
	PUSH	HL
	LD	HL,13
	ADD	HL,DE
	LD	(NULBUF),HL
	POP	HL
J5681:	LD	(STKTOP),HL
	DEC	HL
	DEC	HL
	LD	(SAVSTK),HL
	LD	L,E
	LD	H,D
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,1+1
J5691:	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	EX	DE,HL
	LD	BC,7
	LD	(HL),B
	ADD	HL,BC
	LD	(HL),B
	LD	BC,256+9-7
	ADD	HL,BC
	DEC	A
	JR	NZ,J5691
	RET

;	  Subroutine setup hooks for disksystem handlers
;	     Inputs  ________________________
;	     Outputs ________________________

C56A5:	LD	HL,I5757
	LD	DE,H.POSD
	LD	BC,5
	LDIR				; install H.POSD code
	LD	HL,I56CD		; table with hooks
J56B3:	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; address hook
	INC	HL
	LD	A,E
	OR	D			; end of table ?
	RET	Z			; yep, quit
	EX	DE,HL
	LD	(HL),0F7H		; RST CALLF
	INC	HL
	LD	A,(LF348)
	LD	(HL),A			; slotid master disksystem
	INC	HL
	EX	DE,HL
	LDI
	LDI				; address hook handler
	LD	A,0C9H
	LD	(DE),A			; RET
	JR	J56B3			; next hook

I56CD:	DEFW	H.DSKO,C5EDC
        DEFW	H.DSKI,C5EBB
        DEFW	H.NAME,C6315
        DEFW	H.KILL,C6303
        DEFW	H.COPY,C6424
        DEFW	H.DSKF,C640D
        DEFW	H.LSET,C6026
        DEFW	H.RSET,C6025
        DEFW	H.FIEL,C5F9F
        DEFW	H.MKI$,C60E6
        DEFW	H.MKS$,C60E9
        DEFW	H.MKD$,C60EC
        DEFW	H.CVI,C6123
        DEFW	H.CVS,C6126
        DEFW	H.CVD,C6129
        DEFW	H.GETP,C5A2A
        DEFW	H.NOFO,C5A39
        DEFW	H.NULO,C5A82
        DEFW	H.NTFL,C5BEF
        DEFW	H.BINS,C5C51
        DEFW	H.BINL,C5C79
        DEFW	H.FILE,C61E0
        DEFW	H.DGET,C5F1E
        DEFW	H.FILO,C5BD6
        DEFW	H.INDS,C5B4F
        DEFW	H.LOC,C6361
        DEFW	H.LOF,C635E
        DEFW	H.EOF,C61C8
        DEFW	H.BAKU,C5BBD
        DEFW	H.PARD,C6665
        DEFW	H.NODE,C6757
        DEFW	H.ERRP,C675B
        DEFW	H.PHYD,C4CC5
        DEFW	H.FORM,C4E8E
I5755:	DEFW	0

;	  Subroutine H.POSD handler (possible disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

I5757:	INC	SP
	INC	SP			; remove return address from stack
	JP	PARDEV+8		; continue with devicename parser

;	  Subroutine CALL statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C575C:	EI
	LD	A,(H.PHYD+0)
	CP	0C9H			; disksystem available ?
	SCF
	RET	Z			; nope, quit with statement not recognized
	PUSH	HL
	CALL	C402D			; get my slotid
	LD	HL,LF348
	CP	(HL)			; is this disk interface the master disksystem ?
	JR	NZ,J5795		; nope, skip DOS2 CALL statements and try interface CALL statements
	LD	HL,I5799
J5771:	LD	DE,PROCNM
J5774:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J578B
	INC	DE
	INC	HL
	AND	A			; end of statement ?
	JR	NZ,J5774		; nope, next
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; statement handler
	POP	HL
	CALL	C665E			; end of BASIC statement ?
	CALL	C5789			; invoke statement handler
	AND	A
	RET				; quit with statement recognized (handled)

;	  Subroutine invoke statement handler
;	     Inputs  DE = statement handler
;	     Outputs ________________________

C5789:	PUSH	DE
	RET

J578B:	LD	C,0FFH
	XOR	A
	CPIR				; skip to end of statement
	INC	HL
	INC	HL			; skip handler address
	CP	(HL)			; end of statement table ?
	JR	NZ,J5771		; nope, try next statement
J5795:	POP	HL
	JP	OEMSTA			; invoke driver CALL statement handler

I5799:	DEFB	"SYSTEM"
        DEFB	0
        DEFW	C57D6

        DEFB	"FORMAT"
        DEFB	0
        DEFW	C581A

        DEFB	"CHDRV"
        DEFB	0
        DEFW	C5821

        DEFB	"CHDIR"
        DEFB	0
        DEFW	C585A

        DEFB	"MKDIR"
        DEFB	0
        DEFW	C5869

        DEFB	"RMDIR"
        DEFB	0
        DEFW	C587D

        DEFB	"RAMDISK"
        DEFB	0
        DEFW	C58AF

        DEFB	0

;	  Subroutine _SYSTEM statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C57D6:	LD	DE,BUF+10
	JR	Z,J5805			; end of statement, skip MSXDOS command parameter
	CALL	C6654			; check for BASIC character
	DEFB	"("
	LD	IX,FRMEVL
	CALL	C664F			; evaluate expression
	PUSH	HL
	LD	IX,FRESTR
	CALL	C664F			; free temporary stringdescriptor
	LD	C,(HL)
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	DE,BUF+10
	INC	C
	DEC	C
	JR	Z,J57FF
	LD	B,0
	LDIR
J57FF:	POP	HL
	CALL	C6654			; check for BASIC character
	DEFB	")"
	RET	NZ
J5805:	XOR	A
	LD	(DE),A
	LD	IX,CLSALL
	CALL	C664F			; close all i/o channels
	CALL	TOTEXT			; force textmode
	CALL	ERAFNK			; display functionkey display
	LD	HL,BUF+10
	JP	J4AFB			; start MSXDOS2 from bootdrive with commandline

;	  Subroutine _FORMAT statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C581A:	RET	NZ			; not end of statement, quit (generates error later)
	PUSH	HL
	CALL	C4E8E			; invoke format
	POP	HL
	RET

;	  Subroutine _CHDRV statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5821:	CALL	C634C			; check for ("filename" and diskdevice
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	BC,0*256+05BH		; filepath, Parse pathname
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	EX	DE,HL
	LD	A,B
	AND	05H			; any characters parsed other than drive name + drive name specified
	XOR	04H			; only drive name specified
	OR	(HL)			; and at end of string
	JP	NZ,J65ED		; nope, bad drive name BASIC error
	LD	A,C
	CALL	C5846			; check if valid diskdrive
	DEC	A
	LD	E,A
	LD	C,0EH			; Select disk
	CALL	BDOS			; DiskBASIC BDOS call
	POP	HL
	RET

;	  Subroutine check if valid diskdrive
;	     Inputs  A = driveid (1 based)
;	     Outputs ________________________

C5846:	PUSH	AF
	LD	C,18H			; Get login vector
	CALL	BDOS			; DiskBASIC BDOS call
	POP	AF
	PUSH	AF
J584E:	SRL	H
	RR	L
	DEC	A
	JR	NZ,J584E
	JP	NC,J65ED		; drive not online, bad drive name BASIC error
	POP	AF
	RET

;	  Subroutine _CHDIR statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C585A:	CALL	C634C			; check for ("filename" and diskdevice
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	C,5AH			; Change current directory
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	POP	HL
	RET

;	  Subroutine _MKDIR statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5869:	CALL	C634C			; check for ("filename" and diskdevice
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	B,10H			; directory attribute
	LD	C,44H			; Create file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	CALL	C6343			; flush buffers of all drives
	POP	HL
	RET

;	  Subroutine _RMDIR statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C587D:	CALL	C634C			; check for ("filename" and diskdevice
	CALL	C6654			; check for BASIC character
	DEFB	")"
	RET	NZ
	PUSH	HL
	LD	B,10H			; directory attribute
	CALL	C59D3			; DiskBASIC BDOS find first entry path buffer and temp buffer with BASIC error
	XOR	A
	PUSH	AF
J588D:	LD	A,(BUF+10+14)
	AND	10H
	JR	Z,J589F
	LD	DE,BUF+10
	LD	C,4DH			; Delete file or subdirectory
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	AF
	SCF
	PUSH	AF
J589F:	CALL	C59D8			; DiskBASIC BDOS find next entry (allow file not found) temp buffer with BASIC error
	JR	NC,J588D
	POP	AF
	LD	A,0D6H			; directory not found
	JP	NC,J65C3		; generate appropriate BASIC error
	CALL	C6343			; flush buffers of all drives
	POP	HL
	RET

;	  Subroutine _RAMDISK statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C58AF:	CALL	C6654			; check for BASIC character
	DEFB	"("
	CP	","
	LD	A,0FFH
	JR	Z,J58DB
	LD	IX,GETIN2
	CALL	C664F			; evaluate expression and convert to positive integer
	INC	D
	DEC	D
	JP	M,J662D			; illegal function call BASIC error
	LD	B,4
J58C7:	SRL	D
	RR	E
	JR	NC,J58CE
	INC	DE
J58CE:	DJNZ	J58C7
	LD	A,E
	INC	D
	DEC	D
	JR	NZ,J58D9
	CP	0FFH
	JR	NZ,J58DB
J58D9:	LD	A,0FEH
J58DB:	PUSH	AF
	LD	A,(HL)
	CP	","
	LD	DE,0
	JR	NZ,J58EE
	CALL	C665F			; get next BASIC character
	LD	IX,PTRGET
	CALL	C664F			; get address of variable
J58EE:	POP	BC
	CALL	C6654			; check for BASIC character
	DEFB	")"
	RET	NZ
	LD	A,(VALTYP)
	CP	3
	JP	Z,J6627			; type mismatch BASIC error
	PUSH	HL
	PUSH	DE
	PUSH	AF
	LD	C,68H			; Create or destroy RAM disk
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	L,B
	LD	H,00H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(DAC+2),HL
	POP	AF
	LD	(VALTYP),A
	POP	DE
	LD	A,E
	OR	D
	CALL	NZ,C591A
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C591A:	PUSH	DE
	LD	HL,VALTYP
	LD	A,(HL)
	LD	C,A
	LD	(HL),2
	LD	HL,DAC+2
	CP	2
	JR	Z,J593E
	CP	4
	JR	Z,J5932
	CP	8
	JP	NZ,J6627		; type mismatch BASIC error

J5932:	PUSH	BC
	LD	IX,DOCNVF
	CALL	C664F			; convert DAC to other type
	POP	BC
	LD	HL,DAC
J593E:	LD	B,0
	POP	DE
	LDIR
	RET

;	  Subroutine check if file is open in i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5944:	PUSH	HL
	PUSH	DE
	PUSH	BC
	XOR	A
	LD	(BUF+10),A		; no file found
	LD	HL,(FILTAB)
	LD	A,(MAXFIL)
J5951:	PUSH	AF
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	PUSH	HL
	EX	DE,HL
	LD	A,(HL)
	AND	A			; i/o channel open ?
	JR	Z,J598F			; nope, check next
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	CP	9			; diskdevice ?
	JR	NC,J598F		; nope, check next
	LD	A,(BUF+10)
	AND	A			; file found ?
	JR	NZ,J597E		; yep, skip search
	PUSH	HL
	LD	DE,(LF33B)		; BASIC path buffer
	LD	B,06H			; include system + hidden files
	LD	IX,BUF+10
	LD	C,40H			; Find first entry
	CALL	C59DE			; DiskBASIC BDOS call (allow file not found) with BASIC error
	POP	HL
	JR	C,J5998			; file not found, quit
J597E:	DEC	HL
	DEC	HL
	DEC	HL
	LD	B,(HL)			; file handle
	LD	DE,BUF+10		; FIB
	LD	C,4CH			; Test file handle
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	A,B
	AND	A			; same file ?
	JP	NZ,J663C		; yep, file already open BASIC error
J598F:	POP	HL
	POP	AF
	DEC	A			; done all i/o channels ?
	JP	P,J5951			; nope, next i/o channel
	JP	J5A26			; restore and quit

J5998:	POP	HL
	POP	HL
	JP	J5A26			; restore and quit

;	  Subroutine __________________________
;	     Inputs  A = attribute
;	     Outputs ________________________

C599D:	PUSH	AF
	LD	B,0			; pathname
	LD	C,5BH			; Parse pathname
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	POP	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF
	LD	B,A			; attribute
	CALL	C59D3			; DiskBASIC BDOS find first entry path buffer and temp buffer with BASIC error
	POP	AF
	POP	HL
	POP	DE
	POP	BC
	BIT	5,B
	RET	NZ
	LD	D,A
	LD	A,(BUF+10+14)
	AND	10H
	RET	Z
	LD	A,L
	CP	E
	RET	Z
	PUSH	BC
	LD	B,D
	LD	DE,BUF+10
	PUSH	DE
	POP	IX
	LD	HL,I5755
	LD	C,40H			; Find first entry
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	BC
	RET

;	  Subroutine DiskBASIC BDOS find first entry (file) path buffer and temp buffer with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

C59D1:	LD	B,0			; file attribute

;	  Subroutine DiskBASIC BDOS find first entry path buffer and temp buffer with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

C59D3:	LD	C,40H			; Find first entry
	JP	J6555			; DiskBASIC BDOS call BASIC path buffer and temp buffer with BASIC error

;	  Subroutine DiskBASIC BDOS find next entry (allow file not found) temp buffer with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

C59D8:	LD	IX,BUF+10
	LD	C,41H			; Find next entry

;	  Subroutine DiskBASIC BDOS call (allow file not found) with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

C59DE:	CALL	BDOS			; DiskBASIC BDOS call
	RET	Z			; no error, quit
	CP	0D7H			; File not found ?
	SCF
	RET	Z			; yep, quit
	JP	J65C3			; generate appropriate BASIC error

;	  Subroutine take control from hook caller (move parameters on stack)
;	     Inputs  IX = replace return address, IYH = parameter block size
;	     Outputs ________________________

;       This is what the stack looks like at entry:
;
;       prim    exp
;       +0      +0      returnaddress C59E9 caller
;       +2      +2      callf BIOS registers
;       +6      +14     returnaddress CALLF caller
;       +8      +16     returnaddress hook caller

C59E9:	EI
	PUSH	HL			; store
	PUSH	DE			; store
	PUSH	BC			; store
	PUSH	AF			; store
	LD	A,(LF348)
	ADD	A,A			; MASTER disk ROM in expanded slot ?
	LD	HL,16			; offset return address HOOK caller when primairy slot
	JR	NC,J59F9		; nope,
	LD	L,16+8			; offset return address HOOK caller when secundairy slot
J59F9:	ADD	HL,SP
	PUSH	IX
	POP	BC			; return address replacement
	LD	(HL),C
	INC	HL
	LD	(HL),B			; replace return address
	LD	HL,10
	ADD	HL,SP
	EX	DE,HL			; pointer to new parameter block
	JR	J5A13

J5A07:	PUSH	IY
	POP	BC			; parameter block size
J5A0A:	LD	C,(HL)
	LD	A,(DE)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	HL
	INC	DE
	DJNZ	J5A0A			; exchange parameter block
J5A13:	LD	A,(LF348)
	ADD	A,A			; MASTER disk ROM in expanded slot ?
	LD	HL,18			; offset parameter block when primairy slot
	JR	NC,J5A1E		; nope,
	LD	L,18+8			; offset parameter block when secundairy slot
J5A1E:	ADD	HL,SP			; pointer to parameter block
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H			; parameter block moved ?
	JR	C,J5A07			; nope, move
J5A25:	POP	AF			; restore
J5A26:	POP	BC			; restore
	POP	DE			; restore
	POP	HL			; restore
	RET

;	  Subroutine H.GETP handler (get i/o channel control block if device is diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C5A2A:	LD	IX,RETRTN
	LD	IY,2*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	POP	HL			; i/o channel
	LD	A,(HL)
	AND	A			; i/o channel open ?
	RET

;	  Subroutine H.NOFO handler (OPEN statement)
;	     Inputs  ________________________
;	     Outputs ________________________

C5A39:	EI
	LD	BC,256
	LD	(LF33D),BC		; assume random recordsize of 256 bytes
	CALL	C665E			; end of BASIC statement ?
	LD	A,E			; i/o channel number
	RET	Z			; yep, quit
	PUSH	AF
	PUSH	HL
	LD	A,(LF348)
	ADD	A,A
	LD	HL,12
	JR	NC,J5A53
	LD	L,12+8
J5A53:	ADD	HL,SP
	LD	A,(HL)			; filemode
	CP	4			; random filemode ?
	JP	NZ,J6630		; nope, syntax error BASIC error
	INC	HL
	LD	A,(HL)			; devicecode
	CP	9			; diskdevice ?
	JP	NC,J6630		; nope, syntax error BASIC error
	POP	HL
	CALL	C6654
	DEFB	0FFH
	CALL	C6654
	DEFB	092H
	CALL	C6654
	DEFB	0EFH			; check for LEN=
	LD	IX,INTID2
	CALL	C664F			; evaluate word operand
	DEC	DE
	INC	D
	DEC	D			; random recordsize > 256 ?
	JP	NZ,J662D		; yep, illegal function call BASIC error
	INC	DE
	LD	(LF33D),DE		; save random recordsize
	POP	AF
	RET

;	  Subroutine H.NULO handler (open i/o channel)
;	     Inputs  ________________________
;	     Outputs ________________________

C5A82:	EI
	RET	NC			; not a diskdevice, quit
	LD	IX,RETRTN
	LD	IY,4*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	CALL	C5944			; check if file is open in i/o channel (generate BASIC error)
	LD	(PTRFIL),HL		; interpreter input/output device = i/o channel pointer
	INC	HL
	INC	HL
	XOR	A
	LD	(HL),A			; clear random record size
	INC	HL
	LD	(HL),A			; clear backup character
	INC	HL
	LD	(HL),D			; devicecode
	INC	HL
	INC	HL
	LD	(HL),A			; position in buffer = 0
	LD	A,E
	PUSH	AF
	AND	82H			; binairy save or sequential output filemode ?
	JR	Z,J5AB7			; nope,
J5AA6:	XOR	A
	LD	B,A			; normal file attribute
	LD	C,44H			; Create file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
J5AAD:	POP	AF
	LD	HL,(PTRFIL)
	LD	(HL),A			; filemode, i/o channel open
	INC	HL
	LD	(HL),B			; file handle
	POP	AF
	POP	HL
	RET

J5AB7:	LD	A,E
	CP	4			; random filemode ?
	JR	NZ,J5AD4		; nope,
	LD	HL,(PTRFIL)
	INC	HL
	INC	HL
	LD	A,(LF33D+0)
	DEC	A
	LD	(HL),A			; random record size - 1
	LD	DE,(LF33B)		; BASIC path buffer
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C59DE			; DiskBASIC BDOS call (allow file not found) with BASIC error
	JR	C,J5AA6			; file not found, create file and quit
	JR	J5AAD

J5AD4:	CP	1			; sequential input file mode ?
	JR	NZ,J5B0B		; nope, must be append
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	LD	HL,FLBMEM
	XOR	A
	CP	(HL)			; FLBMEM <> 0 ?
	LD	(HL),A			; FLBMEM = 0
	JR	NZ,J5AAD		; yep,
	POP	AF
	LD	HL,(PTRFIL)
	LD	(HL),A			; filemode, i/o channel open
	INC	HL
	LD	(HL),B			; file handle
	DEC	HL
	EX	DE,HL
	LD	HL,6
	ADD	HL,DE
	LD	(HL),0FFH		; position in buffer = 255 (force fill of buffer)
	PUSH	HL
	EX	DE,HL
	CALL	C5B60			; read character from i/o channel
	POP	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(HL),A			; save character as backup character
	INC	A			; binairy save indicator ?
	JR	NZ,J5B08		; nope, quit
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),80H		; flag
J5B08:	POP	AF
	POP	HL
	RET

J5B0B:	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	POP	AF
	LD	HL,(PTRFIL)
	LD	(HL),1			; filemode = sequential input, i/o channel is open
	INC	HL
	LD	(HL),B			; file handle
	DEC	HL
	EX	DE,HL
	LD	HL,6
	ADD	HL,DE
	LD	(HL),0FFH		; position in buffer = 255 (force fill of buffer)
	EX	DE,HL
	LD	BC,0
	LD	E,C
	LD	D,B			; filepointer offset = 0
J5B27:	PUSH	HL
	PUSH	DE
	PUSH	BC
	CALL	C5B60			; read character from i/o channel
	POP	BC
	POP	DE
	POP	HL
	JR	C,J5B3A			; at end of file, now continue in sequential output mode
	INC	BC
	LD	A,C
	OR	B
	JR	NZ,J5B27
	INC	DE			; update filepointer offset
	JR	J5B27			; next

J5B3A:	PUSH	BC
	LD	(HL),2			; filemode = sequential output, i/o channel is open
	INC	HL
	LD	B,(HL)			; file handle
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	XOR	A
	LD	(HL),A			; position in buffer = 0
	POP	HL
					; A=0, move relative to begin of file
	LD	C,4AH			; Move file handle pointer
	CALL	BDOS			; DiskBASIC BDOS call
	POP	AF
	POP	HL
	RET

;	  Subroutine H.INDS handler (get sequential input diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C5B4F:	LD	IX,RETRTN
	LD	IY,6*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	CALL	C5B60			; read character from i/o channel
	JP	J5A26			; restore and quit

;	  Subroutine read character from i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5B60:	PUSH	HL
	LD	A,(HL)
	CP	1			; filemode sequential input ?
	JP	NZ,J65EA		; nope, quit with bad file mode BASIC error
	LD	E,L
	LD	D,H
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	AND	A			; backup character ?
	JR	NZ,J5BAF		; yep,
	INC	HL
	INC	HL
	INC	HL
	INC	(HL)			; increase position in buffer
	LD	A,(HL)			; position in buffer
	INC	HL
	INC	HL
	INC	HL
	JR	NZ,J5BAA		; no need to fill the buffer, continue
	PUSH	HL
	EX	DE,HL
	INC	HL
	LD	B,(HL)			; file handle
	LD	HL,256
	LD	C,48H			; Read from file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J5B92			; no error, continue
	CP	0C7H			; End of file ?
	JP	NZ,J65C3		; nope, generate appropriate BASIC error
	POP	HL
	LD	(HL),1AH		; put EOF in buffer
	JR	J5BAE			; continue

J5B92:	LD	C,L
	LD	B,H			; bytes read
	DEC	H
	LD	A,L
	OR	H			; 256 bytes read ?
	POP	HL
	JR	Z,J5BAA			; yep, read from position 0
	PUSH	HL
	LD	E,L
	LD	D,H
	INC	D
	DEC	DE
	ADD	HL,BC
	LD	A,C
	DEC	HL
	LDDR
	DEC	HL
	DEC	HL
	NEG
	LD	(HL),A
	POP	HL
J5BAA:	LD	C,A
	LD	B,0
	ADD	HL,BC
J5BAE:	LD	A,(HL)
J5BAF:	SUB	1AH
	SUB	01H			; EOF character ?
	LD	A,(HL)			; get character
	POP	HL
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),0			; no backup character
	RET	NC			; not EOF, quit
	LD	(HL),A
	RET

;	  Subroutine H.BAKU handler (backup character diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C5BBD:	EI
	PUSH	HL
	LD	A,(LF348)
	ADD	A,A
	LD	HL,8
	JR	NC,J5BCA
	LD	L,8+8
J5BCA:	ADD	HL,SP
	LD	(HL),LOW NOSKCR
	INC	HL
	LD	(HL),HIGH NOSKCR	; resume point character putback routine
	POP	HL
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),C			; save backup character
	RET

;	  Subroutine H.FILO handler (sequential output diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C5BD6:	LD	IX,RETRTN
	LD	IY,8*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	LD	A,(HL)
	CP	2			; sequential output filemode ?
	JP	NZ,J65EA		; nope, bad file mode BASIC error
	POP	AF
	PUSH	AF
	CALL	C5C2B			; write character to i/o channel
	JP	J5A25			; restore and quit

;	  Subroutine H.NTFL handler (close i/o channel for diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C5BEF:	LD	IX,RETRTN
	LD	IY,4*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	POP	HL
	LD	A,(HL)
	SUB	2			; sequential output filemode ?
	JR	NZ,J5C13		; nope,
	PUSH	HL
	LD	HL,FLBMEM
	CP	(HL)			; FLBMEM <> 0 ?
	LD	(HL),A			; FLBMEM = 0
	POP	HL
	JR	NZ,J5C13		; yep,
	LD	(HL),4			; random filemode
	LD	A,1AH			; EOF character
	CALL	C5C2B			; write character to i/o channel
	CALL	NZ,C5C39		; buffer not empty, write buffer to i/o channel
J5C13:	XOR	A
	CP	(HL)			; i/o channel open ?
	LD	(HL),A			; i/o channel closed
	PUSH	AF
	INC	HL
	LD	B,(HL)			; file handle
	LD	DE,6
	ADD	HL,DE
	LD	(HL),A			; clear flag
	LD	L,A
	LD	H,A
	LD	(PTRFIL),HL		; interpreter input/output device = screen
	LD	C,45H			; Close file handle
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	AF
	POP	HL
	RET

;	  Subroutine write character to i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5C2B:	PUSH	HL
	LD	BC,6
	ADD	HL,BC
	LD	C,(HL)			; position in buffer
	INC	(HL)			; update position in buffer
	INC	HL
	INC	HL
	INC	HL
	ADD	HL,BC
	LD	(HL),A			; put character in buffer
	POP	HL
	RET	NZ			; buffer not full, quit

;	  Subroutine write buffer to i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5C39:	PUSH	HL
	INC	HL
	LD	B,(HL)			; file handle
	LD	DE,5
	ADD	HL,DE
	LD	A,(HL)			; position in buffer
	INC	HL
	INC	HL
	INC	HL
	EX	DE,HL
	DEC	A
	LD	L,A
	LD	H,0
	INC	HL
	LD	C,49H			; Write to file handle
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	HL
	RET

;	  Subroutine H.BINS handler (binairy SAVE)
;	     Inputs  ________________________
;	     Outputs ________________________

C5C51:	CALL	C6890			; take control from hook caller
	PUSH	HL
	LD	IX,SCCPTR
	CALL	C664F			; convert pointers to linenumbers
	LD	A,0FFH			; fileid = binary SAVE file
	CALL	C5E8F			; write byte to file handle
	LD	DE,(TXTTAB)		; start of BASIC program
	LD	HL,(VARTAB)		; start of BASIC variables
	AND	A
	SBC	HL,DE			; = size BASIC program
	CALL	C5EA7			; write to system i/o channel
	LD	(NLONLY),A
	POP	HL
					; A=0, i/o channel 0
	LD	IX,CLSFIL
	JP	C664F			; close i/o channel and quit

;	  Subroutine H.BINL handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5C79:	LD	IX,M739A		; quit loading and start
	LD	IY,2*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	POP	AF
	JP	Z,J65EA			; MERGE statement, bad file mode BASIC error
	LD	IX,CLSALL
	CALL	C664F                   ; close all i/o channels
	LD	HL,-200+1
	ADD	HL,SP
	LD	DE,(TXTTAB)
	SBC	HL,DE
	JP	C,J662A			; out of memory BASIC error
	PUSH	HL
	CALL	C5EAF			; get file handle of system i/o channel
	PUSH	BC
	XOR	A			; Relative to the beginning of the file
	LD	DE,0
	LD	HL,1			; offset = 1
	LD	C,4AH			; Move file handle pointer
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	BC
	LD	DE,(TXTTAB)		; start of BASIC program
	POP	HL
	PUSH	HL
	LD	C,48H			; Read from file handle
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	DE
	PUSH	HL
	AND	A
	SBC	HL,DE
	POP	HL
	JP	NC,J662A		; out of memory BASIC error
	LD	DE,(TXTTAB)
	ADD	HL,DE
	LD	(VARTAB),HL
	LD	IX,LINKER
	CALL	C664F			; convert linenumbers to pointers
	LD	A,(FILNAM+0)
	AND	A
	RET	NZ
	LD	(NLONLY),A
	LD	HL,I5CED
	LD	DE,BUF+10
	LD	BC,5
	PUSH	DE
	LDIR
	POP	HL
	LD	IX,NEWSTT
	JP	C664F			; execute BASIC statement

I5CED:	DEFB	03AH,092H,0		; :RUN
	DEFW	0

;	  Subroutine BSAVE handler
;	     Inputs  ________________________
;	     Outputs ________________________

J5CF2:	PUSH	DE
	CALL	C5E7E			; check for , and evaluate BLOAD/BSAVE adres operand
	LD	(SAVENT),DE
	PUSH	DE
	CALL	C5E7E			; check for , and evaluate BLOAD/BSAVE adres operand
	LD	(SAVEND),DE
	EX	(SP),HL
	EX	DE,HL
	RST	DCOMPR
	JP	C,J662D			; illegal function call BASIC error
	EX	DE,HL
	EX	(SP),HL
	CALL	C665E			; end of BASIC statement ?
	SCF				; assume RAM save
	JR	Z,J5D26			; yep,
	CALL	C6654			; check for BASIC character
	DEFB	","
	CP	"S"
	JR	NZ,J5D1E
	CALL	C665F			; get next BASIC character
	AND	A			; VRAM save
	JR	J5D26

J5D1E:	CALL	C5E82			; evaluate BLOAD/BSAVE adres operand
	LD	(SAVENT),DE
	SCF				; RAM save
J5D26:	POP	BC
	JR	NC,J5D2E
	INC	B
	DEC	B
	JP	P,J662D			; illegal function call BASIC error

J5D2E:	POP	DE
	PUSH	HL
	PUSH	BC
	PUSH	AF
	XOR	A			; i/o channel 0
	LD	E,2			; filemode = sequential output
	LD	IX,OPNFIL
	CALL	C664F			; open i/o channel
	LD	A,0FEH			; fileid = BSAVE file
	CALL	C5E8F			; write byte to file handle
	POP	AF
	POP	HL
	PUSH	HL
	PUSH	AF
	CALL	C5E89			; write word to file handle
	LD	HL,(SAVEND)
	CALL	C5E89			; write word to file handle
	LD	HL,(SAVENT)
	CALL	C5E89			; write word to file handle
	POP	AF
	POP	BC
	PUSH	AF
	LD	HL,(SAVEND)
	AND	A
	SBC	HL,BC
	INC	HL
	POP	AF
	JR	NC,J5D76
	LD	E,C
	LD	D,B
	CALL	C5EA7			; write to system i/o channel

J5D66:	LD	A,0FFH
	LD	(FLBMEM),A
	XOR	A			; i/o channel 0
	LD	IX,CLSFIL
	CALL	C664F			; close i/o channel
	JP	J627A

J5D76:	CALL	C6511			; save start and end, determine maximium sized temporary buffer
J5D79:	PUSH	HL
	LD	DE,(SAVENT)
	RST	DCOMPR
	PUSH	AF
	PUSH	BC
	LD	C,L
	LD	B,H
	LD	HL,(SAVEND)
	PUSH	HL
	ADD	HL,BC
	LD	(SAVEND),HL
	POP	HL
	POP	DE
	PUSH	DE
	CALL	LDIRMV
	POP	BC
	POP	AF
	JR	NC,J5DAB
	POP	HL
	PUSH	HL
	PUSH	BC
	LD	E,C
	LD	D,B
	CALL	C5EA7			; write to system i/o channel
	POP	BC
	POP	DE
	LD	HL,(SAVENT)
	AND	A
	SBC	HL,DE
	LD	(SAVENT),HL
	EX	DE,HL
	JR	J5D79

J5DAB:	POP	HL
	LD	HL,(SAVENT)
	LD	E,C
	LD	D,B
	CALL	C5EA7			; write to system i/o channel
	JR	J5D66

;	  Subroutine BLOAD handler
;	     Inputs  ________________________
;	     Outputs ________________________

J5DB6:	PUSH	DE
	XOR	A
	LD	(RUNBNF),A		; assume no run or vram
	LD	C,A
	LD	B,A			; assume offset = 0
	CALL	C665E			; end of BASIC statement ?
	JR	Z,J5DDF			; yep,
	CALL	C6654			; check for BASIC character
	DEFB	","
	CP	"R"
	JR	Z,J5DCE
	CP	"S"
	JR	NZ,J5DDA
J5DCE:	LD	(RUNBNF),A		; save flag
	CALL	C665F			; get next BASIC character
	JR	Z,J5DDF
	CALL	C6654			; check for BASIC character
	DEFB	","
J5DDA:	CALL	C5E82			; evaluate BLOAD/BSAVE adres operand
	LD	B,D
	LD	C,E
J5DDF:	POP	DE
	PUSH	HL
	PUSH	BC
	LD	A,0FFH
	LD	(FLBMEM),A
	XOR	A			; i/o channel 0
	LD	E,1			; filemode = sequential input
	LD	IX,OPNFIL
	CALL	C664F			; open i/o channel
	CALL	C5E92			; read byte from file handle
	CP	0FEH
	JP	NZ,J65EA		; bad file mode BASIC error
	POP	BC
	CALL	C5E70			; read word from file handle and add offset
	PUSH	HL
	CALL	C5E70			; read word from file handle and add offset
	PUSH	HL
	CALL	C5E70			; read word from file handle and add offset
	LD	(SAVENT),HL
	POP	HL
	POP	BC
	AND	A
	SBC	HL,BC
	INC	HL
	LD	A,(RUNBNF)
	CP	"S"			; BLOAD VRAM ?
	JR	Z,J5E28			; yep,
	LD	E,C
	LD	D,B
	CALL	C5EAF			; get file handle of system i/o channel
	LD	C,48H			; Read from file handle
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
J5E1F:	LD	IX,FINPRT
	CALL	C664F			; return interpreter output to screen
	POP	HL
	RET

J5E28:	CALL	C6511			; save start and end, determine maximium sized temporary buffer
J5E2B:	PUSH	HL
	PUSH	BC
	LD	DE,(SAVENT)
	RST	DCOMPR
	PUSH	AF
	LD	E,C
	LD	D,B
	CALL	C5EAF			; get file handle of system i/o channel
	LD	C,48H			; Read from file handle
	CALL	BDOS			; DiskBASIC BDOS call
	POP	AF
	POP	HL
	POP	BC
	PUSH	BC
	PUSH	HL
	PUSH	AF
	LD	HL,(SAVEND)
	PUSH	HL
	ADD	HL,BC
	LD	(SAVEND),HL
	POP	DE
	POP	AF
	POP	HL
	JR	NC,J5E62
	PUSH	HL
	CALL	LDIRVM
	POP	BC
	POP	DE
	LD	HL,(SAVENT)
	AND	A
	SBC	HL,DE
	LD	(SAVENT),HL
	EX	DE,HL
	JR	J5E2B

J5E62:	POP	BC
	LD	BC,(SAVENT)
	CALL	LDIRVM
	XOR	A
	LD	(RUNBNF),A
	JR	J5E1F

;	  Subroutine read word from file handle and add offset
;	     Inputs  ________________________
;	     Outputs ________________________

C5E70:	PUSH	BC
	CALL	C5E92			; read byte from file handle
	PUSH	AF
	CALL	C5E92			; read byte from file handle
	LD	H,A
	POP	AF
	LD	L,A
	POP	BC
	ADD	HL,BC
	RET

;	  Subroutine check for , and evaluate BLOAD/BSAVE adres operand
;	     Inputs  ________________________
;	     Outputs ________________________

C5E7E:	CALL	C6654			; check for BASIC character
	DEFB	","

;	  Subroutine evaluate BLOAD/BSAVE adres operand
;	     Inputs  ________________________
;	     Outputs ________________________

C5E82:	LD	IX,ADRGET
	JP	C664F

;	  Subroutine write word to file handle
;	     Inputs  HL = word
;	     Outputs ________________________

C5E89:	PUSH	HL
	LD	A,L
	CALL	C5E8F			; write byte to file handle
	POP	AF

;	  Subroutine write byte to file handle
;	     Inputs  A = byte
;	     Outputs ________________________

C5E8F:	LD	C,49H			; Write to file handle
	DEFB	021H

;	  Subroutine read byte from file handle
;	     Inputs  ________________________
;	     Outputs A = byte

C5E92:	LD	C,48H			; Read from file handle
	CALL	C5EAF			; get file handle of system i/o channel
	PUSH	AF
	LD	HL,1
	ADD	HL,SP
	EX	DE,HL
	LD	HL,1
	PUSH	BC
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	BC
	POP	AF
	RET

;	  Subroutine write to system i/o channel
;	     Inputs  DE = start address, HL = size
;	     Outputs ________________________

C5EA7:	CALL	C5EAF			; get file handle of system i/o channel
	LD	C,49H			; Write to file handle
	JP	C655D			; DiskBASIC BDOS call with BASIC error

;	  Subroutine get file handle of system i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5EAF:	PUSH	HL
	LD	HL,(FILTAB)
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	INC	HL
	LD	B,(HL)			; file handle
	POP	HL
	RET

;	  Subroutine H.DSKI handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5EBB:	CALL	C6890			; take control from hook caller
	CALL	C665F			; get next BASIC character
	CALL	C6654			; check for BASIC character
	DEFB	"("
	CALL	C5F09			; evaluate byte operand, evaluate adres operand
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	HL,NULSTR		; empty string
	LD	(DAC+2),HL
	LD	A,3
	LD	(VALTYP),A
	LD	L,2FH			; Absolute sector read
	JR	J5EE9

;	  Subroutine H.DSKO handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5EDC:	CALL	C6890			; take control from hook caller
	CALL	C5F09			; evaluate byte operand, evaluate adres operand
	CALL	C665E			; end of BASIC statement ?
	RET	NZ			; nope, quit (generates error later)
	PUSH	HL
	LD	L,30H			; Absolute sector write
J5EE9:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,BUF+10
	LD	L,C
	LD	C,31H			; Get disk parameters
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	DE,(LF351)
	LD	C,1AH			; Set disk transfer address
	CALL	BDOS			; DiskBASIC BDOS call
	POP	HL
	DEC	L
	LD	H,1
	POP	DE
	POP	BC
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	HL
	RET

;	  Subroutine evaluate byte operand, evaluate adres operand
;	     Inputs  ________________________
;	     Outputs ________________________

C5F09:	LD	IX,GETBYT
	CALL	C664F			; evaluate byte operand
	PUSH	DE
	CALL	C6654			; check for BASIC character
	DEFB	","
	LD	IX,GETUIN
	CALL	C664F			; evaluate adres operand
	POP	BC
	RET

;	  Subroutine H.DGET handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5F1E:	LD	IX,RETRTN
	LD	IY,4*256
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	LD	A,(HL)
	CP	4
	JP	NZ,J65EA		; bad file mode BASIC error
	EX	(SP),HL
	CALL	C665E			; end of BASIC statement ?
	JR	Z,J5F7D			; yep,
	CALL	C6654			; check for BASIC character
	DEFB	","
	LD	IX,FRMEVL
	CALL	C664F			; evaluate expression
	PUSH	HL
	CALL	C6147
	LD	A,C
	OR	B
	OR	L
	OR	H
	JP	Z,J662D			; illegal function call BASIC error
	LD	A,C
	OR	B
	DEC	BC
	JR	NZ,J5F51
	DEC	HL
J5F51:	EX	DE,HL
	POP	HL
	EX	(SP),HL
	PUSH	HL
	PUSH	DE
	INC	HL
	INC	HL
	LD	E,(HL)
	LD	D,00H
	INC	DE
	CALL	C68A7			; multiply
	POP	IX
	PUSH	BC
	PUSH	IX
	POP	BC
	CALL	C68AA			; multiply high word
	LD	A,L
	OR	H
	JP	NZ,J662D		; illegal function call BASIC error
	LD	E,C
	LD	D,B
	POP	HL
	POP	BC
	PUSH	BC
	INC	BC
	LD	A,(BC)
	LD	B,A
	XOR	A
	LD	C,4AH			; Move file handle pointer
	CALL	BDOS			; DiskBASIC BDOS call
	POP	HL
	EX	(SP),HL
J5F7D:	EX	(SP),HL
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	LD	D,00H
	INC	DE
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	EX	DE,HL
	POP	IX
	POP	AF
	PUSH	IX
	AND	A
	LD	C,48H			; Read from file handle
	JR	Z,J5F99
	LD	C,49H			; Write to file handle
J5F99:	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	JP	J627A

;	  Subroutine H.FIEL handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5F9F:	CALL	C6890			; take control from hook caller
	CP	"#"
	CALL	Z,C665F			; get next BASIC character
	LD	IX,GETBYT
	CALL	C664F			; evaluate byte operand
	JP	Z,J6630			; syntax error BASIC error
	PUSH	HL
	LD	IX,FILIDX
	CALL	C664F			; get i/o channel pointer
	LD	E,L
	LD	D,H
	JP	Z,J6645			; i/o channel not open, file not OPEN BASIC error
	JP	C,J662D			; no diskdevice, illegal function call BASIC error
	LD	A,(HL)
	CP	4			; random filemode ?
	JP	NZ,J65EA		; nope, bad file mode BASIC error
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	H,0
	INC	HL			; random recordsize
	LD	(BUF+10),HL
	LD	HL,0
	LD	(BUF+12),HL
	LD	BC,9
	POP	HL
J5FDA:	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL
	LD	A,(HL)
	CP	","
	RET	NZ
	PUSH	DE
	LD	IX,GTBYTC
	CALL	C664F			; evaluate ,byte operand
	PUSH	AF
	CALL	C6654			; check for BASIC character
	DEFB	"A"
	CALL	C6654			; check for BASIC character
	DEFB	"S"
	LD	IX,PTRGET
	CALL	C664F			; get address of variable
	LD	IX,GETYPR
	CALL	C664F			; get DAC type
	JP	NZ,J6627		; not a string, type mismatch BASIC error
	POP	AF
	EX	(SP),HL
	PUSH	DE
	PUSH	HL
	LD	HL,(BUF+12)
	LD	C,A
	LD	B,00H
	ADD	HL,BC
	LD	(BUF+12),HL
	EX	DE,HL
	LD	HL,(BUF+10)
	RST	DCOMPR
	JP	C,J6633			; FIELD overflow BASIC error
	POP	DE
	POP	HL
	LD	(HL),C
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	B,00H
	POP	HL
	JR	J5FDA

;	  Subroutine H.RSET handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6025:	DEFB	0F6H

;	  Subroutine H.LSET handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6026:	SCF
	CALL	C6890			; take control from hook caller
	PUSH	AF
	LD	IX,PTRGET
	CALL	C664F			; get address of variable
	LD	IX,GETYPR
	CALL	C664F			; get DAC type
	JP	NZ,J6627		; not a string, type mismatch BASIC error
	PUSH	DE
	LD	IX,FRMEQL
	CALL	C664F			; evaluate =expression
	POP	BC
	EX	(SP),HL
	PUSH	HL
	PUSH	BC
	LD	IX,FRESTR
	CALL	C664F			; free temporary stringdescriptor
	LD	B,(HL)
	EX	(SP),HL
	LD	A,(HL)
	LD	C,A
I6053:	PUSH	BC
	PUSH	HL
	PUSH	AF
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	OR	A
	JR	Z,J60B9
	LD	HL,(NULBUF)
	DEC	HL
	RST	DCOMPR
	JR	C,J6097
	LD	HL,(VARTAB)
	RST	DCOMPR
	JR	C,J6097
	LD	E,C
	LD	D,00H
	LD	HL,(STKTOP)
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(FRETOP)
	RST	DCOMPR
	JR	C,J60CC
	POP	AF
J6079:	LD	A,C
	LD	IX,GETSPA
	CALL	C664F			; allocate stringspace
	POP	HL
	POP	BC
	EX	(SP),HL
	PUSH	DE
	PUSH	BC
	LD	IX,FRESTR
	CALL	C664F			; free temporary stringdescriptor
	POP	BC
	POP	DE
	EX	(SP),HL
	PUSH	BC
	PUSH	HL
	INC	HL
	PUSH	AF
	LD	(HL),E
	INC	HL
	LD	(HL),D
J6097:	POP	AF
	POP	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	POP	BC
	POP	HL
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	A,C
	CP	B
	JR	NC,J60A9
	LD	B,A
J60A9:	SUB	B
	LD	C,A
	POP	AF
	CALL	NC,C60C3
	INC	B
J60B0:	DEC	B
	JR	Z,J60BE
	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE
	JR	J60B0

J60B9:	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
J60BE:	CALL	C,C60C3
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C60C3:	LD	A,20H	; " "
	INC	C
J60C6:	DEC	C
	RET	Z
	LD	(DE),A
	INC	DE
	JR	J60C6

J60CC:	POP	AF
	POP	HL
	POP	BC
	EX	(SP),HL
	EX	DE,HL
	JR	NZ,J60E0
	PUSH	BC
	LD	A,B
	LD	IX,STRINI
	CALL	C664F			; allocate temp string
	CALL	C6107
	POP	BC
J60E0:	EX	(SP),HL
	PUSH	BC
	PUSH	HL
	JP	J6079

;	  Subroutine H.MKI$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C60E6:	LD	A,2
	DEFB	001H

;	  Subroutine H.MKS$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C60E9:	LD	A,4
	DEFB	001H

;	  Subroutine H.MKD$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C60EC:	LD	A,8
	CALL	C6890			; take control from hook caller
	PUSH	AF
	LD	IX,DOCNVF
	CALL	C664F			; convert DAC to other type
	POP	AF
	LD	IX,STRINI
	CALL	C664F			; allocate temp string
	LD	HL,(DSCTMP+1)
	CALL	VMOVMF			; copy variable content from DAC

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C6107:	LD	DE,DSCTMP
	LD	HL,(TEMPPT)
	LD	(DAC+2),HL
	LD	A,3
	LD	(VALTYP),A
	CALL	VMOVE			; copy stringdescriptor
	LD	DE,FRETOP
	RST	DCOMPR
	LD	(TEMPPT),HL
	JP	Z,J6624			; string formular too complex BASIC error
	RET

;	  Subroutine H.CVI handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6123:	LD	A,1
	DEFB	001H

;	  Subroutine H.CVS handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6126:	LD	A,3
	DEFB	001H

;	  Subroutine H.CVD handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6129:	LD	A,7
	CALL	C6890			; take control from hook caller
	PUSH	AF
	LD	IX,FRESTR
	CALL	C664F			; free temporary stringdescriptor
	POP	AF
	CP	(HL)
	JP	NC,J662D		; illegal function call BASIC error
	INC	A
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,C
	LD	(VALTYP),A
	JP	VMOVFM			; copy variable content to DAC

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C6147:	LD	IX,GETYPR
	CALL	C664F			; get DAC type
	JP	M,J61B3			; integer,
	JP	Z,J6627			; string, type mismatch BASIC error
	LD	HL,DAC
	LD	A,(HL)
	AND	A
	JP	M,J662D			; illegal function call BASIC error
	LD	DE,BUF+10
	LD	BC,8
	LDIR
	LD	HL,I61C0
	LD	DE,ARG
	LD	C,8
	LDIR
	CALL	DECDIV			; divide double
	AND	A
	CALL	INT			; dbl to integer
	LD	IX,GETUI
	CALL	C664F			; convert to address
	PUSH	DE
	EX	DE,HL
	LD	IX,FLTLIN
	CALL	C664F			; convert unsigned integer to single
	CALL	CONDS			; convert DAC from sgn to dbl
	LD	BC,06545H
	LD	DE,06053H		; 65536
	CALL	SGNMUL			; sgn multiply
	LD	HL,DAC
	PUSH	HL
	LD	DE,ARG
	LD	BC,8
	LDIR				; copy DAC to ARG
	LD	HL,BUF+10
	POP	DE
	LD	C,8
	LDIR
	CALL	DECSUB			; subtract double
	LD	IX,GETUI
	CALL	C664F			; convert to address
	LD	C,E
	LD	B,D
	POP	HL
	RET

J61B3:	LD	BC,(DAC+2)
	INC	B
	DEC	B
	JP	M,J662D			; illegal function call BASIC error
	LD	HL,0
	RET

I61C0:	DEFB	045H,065H,053H,060H,0,0,0,0

;	  Subroutine H.EOF handler (EOF for diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C61C8:	CALL	C6890			; take control from hook caller
	PUSH	HL
	CALL	C5B60			; read character from i/o channel
	LD	HL,0			; assume no end of file
	JR	NC,J61D5		; not at end of file, continue
	DEC	HL			; end of file
J61D5:	PUSH	AF
	CALL	MAKINT			; integer to DAC
	POP	AF
	POP	HL
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A			; save character as backup character
	RET

;	  Subroutine H.FILE handler
;	     Inputs  ________________________
;	     Outputs ________________________

C61E0:	CALL	C6890			; take control from hook caller
	CALL	C665E			; end of BASIC statement ?
	JR	Z,J61F1			; yep,
	CP	","
	JR	Z,J61F1
	CALL	C6350			; check for "filename" and diskdevice
	JR	J61F7

J61F1:	XOR	A
	LD	DE,(LF33B)		; BASIC path buffer
	LD	(DE),A
J61F7:	CALL	C665E			; end of BASIC statement ?
	SCF
	JR	Z,J6206			; yep,
	CALL	C6654			; check for BASIC character
	DEFB	","
	CALL	C6654			; check for BASIC character
	DEFB	"L"
	AND	A
J6206:	PUSH	HL
	LD	A,(PRTFLG)
	INC	A
	DEC	A
	PUSH	AF
	LD	IX,CRDONZ
	CALL	C664F			; newline to OUTDO if not at start of line
	POP	AF
	PUSH	AF
	LD	A,16H			; directory + system + hidden attribute
	JR	NC,J621C
	LD	A,10H			; directory attribute
J621C:	CALL	C599D
	LD	A,C
	ADD	A,40H
	RST	OUTDO
	LD	A,":"
	RST	OUTDO
	LD	A,"\"
	RST	OUTDO
	LD	DE,BUF+75
	PUSH	DE
	LD	C,5EH			; Get whole path string
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	(HL),A
	DEC	HL
	LD	(HL),A
	POP	HL
	CALL	C62FC
	LD	IX,CRDO
	CALL	C664F			; newline to OUTDO

J6240:	POP	AF
	PUSH	AF
	CALL	C6282
	CALL	CKCNTC
	POP	AF
	PUSH	AF
	JR	NC,J6267
	LD	A,(LINLEN)
	LD	B,A
	LD	A,(TTYPOS)
	JR	Z,J625A
	LD	B,80
	LD	A,(LPTPOS)
J625A:	AND	A
	JR	Z,J626E
	ADD	A,0DH	; 13 
	CP	B
	JR	NC,J6267
	LD	A," "
	RST	OUTDO
	JR	J626E

J6267:	LD	IX,CRDO
	CALL	C664F			; newline to OUTDO

J626E:	LD	IX,BUF+10
	LD	C,41H			; Find next entry
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J6240
	POP	AF
J627A:	POP	HL
	LD	IX,FINPRT
	JP	C664F			; return interpreter output to screen

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C6282:	JR	NC,J62A4

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C6284:	LD	DE,BUF+11
	LD	HL,(LF33B)		; BASIC path buffer
	LD	C,5CH			; Parse filename
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	B,8
	CALL	C629E
	LD	A,(HL)
	CP	" "
	JR	Z,J629B
	LD	A,"."
J629B:	RST	OUTDO
	LD	B,3

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C629E:	LD	A,(HL)
	RST	OUTDO
	INC	HL
	DJNZ	C629E
	RET

J62A4:	CALL	C6284
	LD	A," "
	RST	OUTDO
	LD	A,(BUF+10+14)
	LD	C,A
	BIT	4,C
	LD	A,"d"
	CALL	C62F6
	BIT	0,C
	LD	A,"r"
	CALL	C62F6
	BIT	1,C
	LD	A,"h"
	CALL	C62F6
	BIT	2,C
	LD	A,"s"
	CALL	C62F6
	BIT	5,C
	LD	A,"a"
	CALL	C62F6
	LD	BC,(BUF+10+21)
	LD	HL,(BUF+10+23)
	CALL	C63BA
	LD	IX,JPFOUT
	CALL	C664F			; convert DAC to text, unformatted
	INC	HL
	PUSH	HL
	LD	B,12
J62E6:	LD	A,(HL)
	INC	HL
	DEC	B
	AND	A
	JR	NZ,J62E6
	LD	A," "
J62EE:	RST	OUTDO
	DJNZ	J62EE
	POP	HL
	CALL	C62FC
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C62F6:	JR	NZ,J62FA
	LD	A,"-"
J62FA:	RST	OUTDO
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C62FC:	LD	A,(HL)
	AND	A
	INC	HL
	RET	Z
	RST	OUTDO
	JR	C62FC

;	  Subroutine H.KILL handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6303:	CALL	C6890			; take control from hook caller
	CALL	C6350			; check for "filename" and diskdevice
	CALL	C665E			; end of BASIC statement ?
	RET	NZ			; nope, quit (generates error later)
	PUSH	HL
	CALL	C59D1			; DiskBASIC BDOS find first entry (file) path buffer and temp buffer with BASIC error
	LD	C,4DH			; Delete file or subdirectory
	JR	J632E

;	  Subroutine H.NAME handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6315:	CALL	C6890			; take control from hook caller
	CALL	C6350			; check for "filename" and diskdevice
	PUSH	HL
	CALL	C59D1			; DiskBASIC BDOS find first entry (file) path buffer and temp buffer with BASIC error
	POP	HL
	CALL	C6654			; check for BASIC character
	DEFB	"A"
	CALL	C6654			; check for BASIC character
	DEFB	"S"
	CALL	C6350			; check for "filename" and diskdevice
	PUSH	HL
	LD	C,4EH			; Rename file or subdirectory
J632E:	PUSH	BC
	LD	DE,BUF+10
	LD	HL,(LF33B)		; BASIC path buffer
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	CALL	C59D8			; DiskBASIC BDOS find next entry (allow file not found) temp buffer with BASIC error
	POP	BC
	JR	NC,J632E		; file found, next file
	CALL	C6343			; flush buffers of all drives
	POP	HL
	RET

;	  Subroutine flush buffers of all drives
;	     Inputs  ________________________
;	     Outputs ________________________

C6343:	LD	B,0FFH			; all drives
	LD	D,0			; flush only
	LD	C,5FH			; Flush disk buffers
	JP	C655D			; DiskBASIC BDOS call with BASIC error

;	  Subroutine check for ("filename" and diskdevice
;	     Inputs  ________________________
;	     Outputs ________________________

C634C:	CALL	C6654			; check for BASIC character
	DEFB	"("

;	  Subroutine check for "filename" and diskdevice
;	     Inputs  ________________________
;	     Outputs ________________________

C6350:	LD	IX,FILEVL
	CALL	C664F			; evaluate filename
	LD	A,D
	CP	9			; device = diskdrive ?
	RET	C			; yep, quit
	JP	J65ED			; bad drive name BASIC error

;	  Subroutine H.LOF handler (LOF diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C635E:	LD	A,2
	DEFB	011H

;	  Subroutine H.LOC handler (LOC diskdevice)
;	     Inputs  ________________________
;	     Outputs ________________________

C6361:	LD	A,1
	CALL	C6890			; take control from hook caller
	PUSH	AF
	LD	IX,CONINT
	CALL	C664F			; convert to byte
	LD	IX,FILIDX
	CALL	C664F			; get i/o channel pointer
	JP	C,J662D			; illegal function call BASIC error
	JP	Z,J6645			; file not OPEN BASIC error
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	C,(HL)
	LD	A,1			; relative to current filepointer
	LD	DE,0
	LD	HL,0			; offset = 0
	PUSH	BC
	LD	C,4AH			; Move file handle pointer
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	BC
	POP	AF
	DEC	A			; LOF ?
	JR	NZ,J6399		; yep,
	PUSH	BC
	CALL	C63E4
	POP	BC
	JR	J63B7

J6399:	PUSH	HL
	PUSH	DE
	LD	A,2			; relative to end of file
	LD	DE,0
	LD	HL,0			; offset = 0
	LD	C,4AH			; Move file handle pointer
	PUSH	BC
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	BC
	POP	IX
	EX	(SP),HL
	PUSH	DE
	PUSH	IX
	POP	DE
	XOR	A			; relative to begin of file
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	DE
	POP	HL
J63B7:	LD	C,L
	LD	B,H
	EX	DE,HL

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C63BA:	PUSH	BC
	LD	IX,FLTLIN
	CALL	C664F			; convert unsigned integer to single
	LD	BC,06545H
	LD	DE,06053H		; 65536
	CALL	SGNMUL			; sgn multiply
	LD	HL,DAC
	LD	DE,ARG
	LD	BC,8
	LDIR				; copy DAC to ARG
	POP	HL
	LD	IX,FLTLIN
	CALL	C664F			; convert unsigned integer to single
	CALL	CONDS			; convert DAC from sgn to dbl
	JP	DECADD			; add double

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C63E4:	INC	C
	JR	NZ,J63EF
	LD	A,L
	LD	L,H
	LD	H,E
	LD	E,D
	LD	D,00H
	JR	J6403

J63EF:	XOR	A
	LD	B,21H	; "!"
J63F2:	ADC	A,A
	JR	C,J63F9
	CP	C
	CCF
	JR	NC,J63FB

J63F9:	SUB	C
	SCF
J63FB:	ADC	HL,HL
	EX	DE,HL
	ADC	HL,HL
	EX	DE,HL
	DJNZ	J63F2

J6403:	OR	A
	RET	Z
	INC	L
	RET	NZ
	INC	H
	RET	NZ
	INC	E
	RET	NZ
	INC	D
	RET

;	  Subroutine H.DSKF
;	     Inputs  ________________________
;	     Outputs ________________________

C640D:	CALL	C6890			; take control from hook caller
	LD	IX,CONINT
	CALL	C664F			; convert to byte
	AND	A			; default drive ?
	CALL	NZ,C5846		; nope, check if valid diskdrive
	LD	E,A
	LD	C,1BH			; Get allocation information
	CALL	BDOS			; DiskBASIC BDOS call
	JP	MAKINT			; integer to DAC

;	  Subroutine H.COPY handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6424:	CALL	C6890			; take control from hook caller
	CALL	C6350			; check for "filename" and diskdevice
	PUSH	HL
	CALL	C59D1			; DiskBASIC BDOS find first entry (file) path buffer and temp buffer with BASIC error
	POP	HL
	CALL	C665E			; end of BASIC statement ?
	LD	A,0
	PUSH	HL
	LD	HL,(LF33B)		; BASIC path buffer
	LD	(HL),A
	POP	HL
	JR	Z,J6447			; yep,
	CALL	C6654			; check for BASIC character
	DEFB	0D9H			; TO
	CALL	C6350			; check for "filename" and diskdevice
	CALL	C665E			; end of BASIC statement ?
	RET	NZ			; nope, quit
J6447:	PUSH	HL
J6448:	CALL	CKCNTC
	LD	DE,BUF+10
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	A,B
	LD	(BUF+138),A
	XOR	A
	LD	C,56H			; Get/set file handle date and time
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	LD	(BUF+140),DE
	LD	(BUF+142),HL
	LD	A,0FFH
	LD	(BUF+139),A
	LD	HL,I6532
	LD	(LF325),HL		; register DOS1 abort handler
	CALL	C6518			; determine maximium sized temporary buffer
	LD	E,C
	LD	D,B
J6475:	PUSH	HL
	PUSH	DE
J6477:	LD	A,L
	OR	H
	JR	Z,J6498
	PUSH	HL
	PUSH	DE
	LD	A,(BUF+138)
	LD	B,A
	LD	C,48H			; Read from file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J648A			; no error,
	CP	0C7H			; End of file ?
J648A:	JP	NZ,J6538		; nope,
	EX	DE,HL
	POP	HL
	ADD	HL,DE
	EX	(SP),HL
	SBC	HL,DE
	LD	A,E
	OR	D
	POP	DE
	JR	NZ,J6477

J6498:	EX	DE,HL
	POP	DE
	PUSH	DE
	SBC	HL,DE
	LD	A,(BUF+139)
	INC	A
	JR	NZ,J64CC
	PUSH	HL
	LD	HL,BUF+11
	LD	DE,BUF+11+64
	LD	BC,13
	LDIR
	LD	DE,(LF33B)		; BASIC path buffer
	LD	B,00H
	LD	IX,BUF+10+64
	LD	C,42H			; Find new entry
	CALL	C6534
	LD	DE,BUF+10+64
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6534
	LD	A,B
	LD	(BUF+139),A
	POP	HL
J64CC:	POP	DE
	LD	A,(BUF+139)
	LD	B,A
	PUSH	DE
	LD	C,49H			; Write to file handle
	CALL	C6534
	POP	DE
	POP	BC
	SBC	HL,BC
	LD	L,C
	LD	H,B
	JR	NC,J6475
	LD	A,(BUF+139)
	LD	B,A
	LD	A,01H	; 1 
	LD	IX,(BUF+140)
	LD	HL,(BUF+142)
	LD	C,56H			; Get/set file handle date and time
	CALL	C6534
	LD	A,(BUF+138)
	LD	B,A
	LD	C,45H			; Close file handle
	CALL	C6534
	LD	A,(BUF+139)
	LD	B,A
	LD	C,45H			; Close file handle
	CALL	C6534
	LD	HL,I6568
	LD	(LF325),HL		; register DOS1 abort handler
	CALL	C59D8			; DiskBASIC BDOS find next entry (allow file not found) temp buffer with BASIC error
	JP	NC,J6448
	POP	HL
	RET

;	  Subroutine save start and end, determine maximium sized temporary buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6511:	LD	(SAVENT),HL
	LD	(SAVEND),BC

;	  Subroutine determine maximium sized temporary buffer
;	     Inputs  ________________________
;	     Outputs BC = start address of buffer, HL = size of buffer

C6518:	LD	HL,-512
	ADD	HL,SP
	JR	NC,J652A
	LD	BC,(STREND)
	AND	A
	SBC	HL,BC
	JR	C,J652A
	LD	A,H
	AND	A
	RET	NZ
J652A:	LD	BC,(NULBUF)
	LD	HL,256
	RET

; pointer to DOS1 abort handler

I6532:	DEFW	C656A

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C6534:	CALL	BDOS			; DiskBASIC BDOS call
	RET	Z

J6538:	PUSH	AF
	LD	HL,I6568
	LD	(LF325),HL		; register DOS1 abort handler
	LD	A,(BUF+138)
	LD	B,A
	LD	C,45H			; Close file handle
I6545:	CALL	BDOS			; DiskBASIC BDOS call
	LD	A,(BUF+139)
	LD	B,A
	INC	A
	LD	C,45H			; Close file handle
	CALL	NZ,BDOS			; DiskBASIC BDOS call
	POP	AF
	JR	J65C3			; generate appropriate BASIC error

;	  Subroutine DiskBASIC BDOS call BASIC path buffer and temp buffer with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

J6555:	LD	IX,BUF+10

;	  Subroutine DiskBASIC BDOS call BASIC path buffer with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

C6559:	LD	DE,(LF33B)		; BASIC path buffer

;	  Subroutine DiskBASIC BDOS call with BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

C655D:	CALL	BDOS			; DiskBASIC BDOS call
	RET	Z			; no error, quit
	JR	J65C3			; generate appropriate BASIC error

; pointer to DOS1 disk error handler

I6563:	DEFW	C6565

;	  Subroutine DOS1 disk error handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6565:	LD	C,2			; action = abort
	RET

; pointer to DOS1 abort handler

I6568:	DEFW	C6571

;	  Subroutine DOS1 abort handler
;	     Inputs  ________________________
;	     Outputs ________________________

C656A:	CP	9DH			; diskoperation aborted ?
	JR	NZ,J656F		; nope, quit
	LD	A,B			; orginal error of the aborted diskoperation
J656F:	OR	A
	RET

;	  Subroutine DOS1 abort handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6571:	CALL	C656A
	JR	NZ,J65C3		; generate appropriate BASIC error
	LD	IX,READYR
	JP	C664F			; (re)start BASIC

I657D:	DEFB	0BAH
        DEFB	03EH			; .NRAMD -> Bad drive name
        DEFB	04BH			; .RAMDX -> RAM disk already exists
        DEFB	0BDH
        DEFB	0BEH
        DEFB	0BFH
        DEFB	0C0H
        DEFB	0C1H
        DEFB	0C2H
        DEFB	0C3H
        DEFB	0C4H
        DEFB	0C5H
        DEFB	0C6H
        DEFB	037H			; .EOF -> Input past end
        DEFB	03CH			; .FILE -> Bad allocation table
        DEFB	0C9H
        DEFB	040H			; .FOPEN -> File still open
        DEFB	041H			; .FILEX -> File already exists
        DEFB	049H			; .DIRX -> Directory already exists
        DEFB	041H			; .SYSX -> File already exists
        DEFB	038H			; .DOT -> Bad file name
        DEFB	0CFH
        DEFB	041H			; .DIRNE -> File already exists
        DEFB	048H			; .FILRO -> File write protected
        DEFB	0D2H
        DEFB	041H			; .DUPF -> File already exists
        DEFB	042H			; .DKFUL -> Disk full
        DEFB	043H			; .DRFUL -> Too many files
        DEFB	04AH			; .NODIR -> Directory not found
        DEFB	035H			; .NOFIL -> File not found
        DEFB	038H			; .PLONG -> Bad filename
        DEFB	038H			; .IPATH -> Bad filename
        DEFB	038H			; .IFNM -> Bad filename
        DEFB	03EH			; .IDRV -> Bad drivename
        DEFB	0DCH
        DEFB	0DDH
        DEFB	0DEH
        DEFB	0DFH
        DEFB	0E0H
        DEFB	0E1H
        DEFB	0E2H
        DEFB	0E3H
        DEFB	0E4H
        DEFB	0E5H
        DEFB	0E6H
        DEFB	0E7H
        DEFB	0E8H
        DEFB	0E9H
        DEFB	0EAH
        DEFB	0EBH
        DEFB	0ECH
        DEFB	0EDH
        DEFB	0EEH
        DEFB	0EFH
        DEFB	0F0H
        DEFB	0F1H
        DEFB	03CH			; .IFAT -> Bad allocation table
        DEFB	045H			; .SEEK -> Disk I/O error
        DEFB	045H			; .WFILE -> Disk I/O error
        DEFB	045H			; .WDISK -> Disk I/O error
        DEFB	045H			; .NDOS -> Disk I/O error
        DEFB	045H			; .UFORM -> Disk I/O error
        DEFB	044H			; .WPROT -> Disk write protected
        DEFB	045H			; .RNF -> Disk I/O error
        DEFB	045H			; .DATA -> Disk I/O error
        DEFB	045H			; .VERFY -> Disk I/O error
        DEFB	046H			; .NRDY -> Disk offline
        DEFB	045H			; .DISK -> Disk I/O error
        DEFB	045H			; .WRERR -> Disk I/O error
        DEFB	045H			; .NCOMP -> Disk I/O error

;	  Subroutine generate appropriate BASIC error
;	     Inputs  A = BDOS error
;	     Outputs ________________________

J65C3:	PUSH	AF
	CALL	C6343			; flush buffers of all drives
	POP	AF
	CP	9FH			; CTRL-STOP pressed ?
	JR	Z,J65CE			; yep,
	CP	9EH			; CTRL-C pressed ?
J65CE:	LD	IX,READYR
	JR	Z,C664F			; yep, (re)start BASIC
	LD	E,A
J65D5:	CP	0BAH
	JR	C,J65E6
	LD	C,A
	LD	B,0
	LD	HL,I657D-0BAH
	ADD	HL,BC
	LD	A,(HL)
	LD	E,A
	CP	3CH
	JR	C,J6623
J65E6:	DEFB	001H
	LD	E,03CH
	DEFB	001H
J65EA:	LD	E,03DH
	DEFB	001H
J65ED:	LD	E,03EH
	DEFB	001H
        LD	E,03FH
	DEFB	001H
        LD	E,040H
	DEFB	001H
        LD	E,041H
	DEFB	001H
        LD	E,042H
	DEFB	001H
        LD	E,043H
	DEFB	001H
        LD	E,044H
	DEFB	001H
        LD	E,045H
	DEFB	001H
        LD	E,046H
	DEFB	001H
        LD	E,047H
	DEFB	001H
        LD	E,048H
	DEFB	001H
        LD	E,049H
	DEFB	001H
        LD	E,04AH
	DEFB	001H
        LD	E,04BH
	XOR	A
	LD	(NLONLY),A
	PUSH	DE
					; A=0, i/o channel 0
	LD	IX,CLSFIL		; close i/o channel
	CALL	C664F
	POP	DE
J6623:	DEFB	001H			; Pseudo LD BC,nnnn (begin errorjump table)
J6624:	LD	E,16
	DEFB	001H
J6627:	LD	E,13
	DEFB	001H
J662A:	LD	E,7
	DEFB	001H
J662D:	LD	E,5
	DEFB	001H
J6630:	LD	E,2
	DEFB	001H
J6633:	LD	E,032H
	DEFB	001H
        LD	E,034H
	DEFB	001H
        LD	E,035H
	DEFB	001H
J663C:	LD	E,036H
	DEFB	001H
        LD	E,037H
	DEFB	001H
J6642:	LD	E,038H
	DEFB	001H
J6645:	LD	E,03BH

	XOR	A
	LD	(FLBMEM),A
	LD	IX,ERROR		; BASIC error

;	  Subroutine call BASIC routine
;	     Inputs  ________________________
;	     Outputs ________________________

C664F:	CALL	CALBAS
	EI
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C6654:	CALL	C665E			; get BASIC character
	EX	(SP),HL
	CP	(HL)
	JR	NZ,J6630		; syntax error BASIC error
	INC	HL
	EX	(SP),HL
	INC	HL

;	  Subroutine get BASIC character
;	     Inputs  ________________________
;	     Outputs Zx set if end of BASIC statement

C665E:	DEC	HL

;	  Subroutine get next BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C665F:	LD	IX,CHRGTR
	JR	C664F

;	  Subroutine H.PARD handler (devicename parser)
;	     Inputs  ________________________
;	     Outputs ________________________

C6665:	EI
	LD	A,":"
	CP	(HL)			; empty devicename ?
	JR	Z,J6642			; yep, bad file name BASIC error
	PUSH	HL
	PUSH	DE
	LD	A,E
	CP	63+1			; size of filespecification > 63 ?
	JR	NC,J6642		; yep, bad file name BASIC error
	LD	C,E
	LD	B,0			; size of filespecification
	LD	DE,(LF33B)		; BASIC path buffer
	PUSH	BC
	PUSH	DE
	LDIR				; copy to BASIC path buffer
	XOR	A
	LD	(DE),A			; end of string
	POP	HL
	POP	BC
	CPIR				; null character in string ?
	JR	Z,J6642			; yep, bad file name BASIC error
	LD	C,5BH			; Parse pathname
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with BASIC error
	LD	A,(DE)
	CP	":"
	JR	NZ,J6692
	POP	DE
	POP	HL
	RET

J6692:	BIT	2,B
	JR	NZ,J6698
	LD	C,00H
J6698:	LD	A,B
	AND	0C2H
	JR	Z,J66A7
	LD	A,(DE)
	OR	A
	JR	NZ,J6642		; bad file name BASIC error
	POP	DE
	LD	E,A
	PUSH	DE
	PUSH	BC
	JR	J66F4

J66A7:	POP	DE
	POP	HL
	LD	IX,(LF33B)		; BASIC path buffer
	BIT	2,B
	JR	Z,J66B9
	INC	HL
	INC	HL
	DEC	E
	DEC	E
	INC	IX
	INC	IX
J66B9:	PUSH	HL
	PUSH	DE
	PUSH	BC
	INC	E
	DEC	E
	JR	Z,J66F4
	LD	C,E
	LD	A,(HL)
	CP	" "
	JP	Z,J6642			; bad file name BASIC error
	LD	B,8
	CALL	C6731
	JR	Z,J66F1			; end of string,
	BIT	1,D			; start of double byte character ?
	JR	Z,J66D4
	DEC	IX			; yep, dispose character
J66D4:	LD	A,"."
	LD	(IX+0),A		; filename seperator
	INC	IX
	CP	(HL)			; source at filename seperator ?
	JR	NZ,J66E2		; nope,
	INC	HL
	DEC	C			; skip
	JR	Z,J66F1			; end of string,
J66E2:	LD	B,3
	CALL	C6731
	JR	Z,J66F1			; end of string,
	LD	A,(HL)
	CP	" "			; trailing space ?
	JP	NZ,J6642		; nope, bad file name BASIC error
	LD	C,0
J66F1:	LD	(IX+0),C		; end of string
J66F4:	LD	A,(LF348)
	ADD	A,A
	LD	HL,12
	JR	NC,J66FF
	LD	L,12+8
J66FF:	ADD	HL,SP
	LD	(HL),LOW RETRTN
	INC	HL
	LD	(HL),HIGH RETRTN
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	HL
	LD	HL,BSAVE+3
	RST	DCOMPR			; called by BSAVE statement ?
	LD	BC,(LF2F3)		; BSAVE handler
	JR	Z,J6724			; yep,
	LD	HL,BLOAD+3
	RST	DCOMPR			; called by BLOAD statement ?
	LD	BC,(LF2F1)		; BLOAD handler
	JR	Z,J6724			; yep,
	LD	C,E
	LD	B,D			; handler = orginal caller
J6724:	POP	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C			; replace caller by handler
	POP	BC
	LD	A,C
	OR	A			; default drive ?
	CALL	NZ,C5846		; nope, check if valid diskdrive
	POP	DE
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  C = length of string, B = maximum size element
;	     Outputs ________________________

C6731:	LD	D,1			; character flags, supress upper casing
J6733:	PUSH	HL
	PUSH	BC
	LD	E,(HL)			; character
	LD	C,5DH			; Check character
	CALL	C655D			; DiskBASIC BDOS call with BASIC error
	POP	BC
	POP	HL
	LD	A,E
	BIT	4,D			; valid filename character ?
	JR	NZ,J674E		; nope, check if trailing spaces
	LD	(IX+0),A
	INC	IX
	INC	HL
	DEC	C			; end of string ?
	RET	Z			; yep, quit
	DJNZ	J6733			; next
	RET

J674D:	LD	A,(HL)
J674E:	CP	" "			; space ?
	RET	NZ			; nope, quit
	INC	HL
	DEC	C			; end of string ?
	RET	Z			; yep, quit
	DJNZ	J674D			; next
	RET

;	  Subroutine H.NODE handler (no device specified)
;	     Inputs  ________________________
;	     Outputs ________________________

C6757:	EI
	LD	A,0			; devicecode 0 (default diskdrive)
	RET

;	  Subroutine H.ERRP handler (error print)
;	     Inputs  ________________________
;	     Outputs ________________________

C675B:	EI
	LD	A,E
	SUB	60			; errorcode basic system ?
	RET	C			; yep, handled by the default errortext handler
	CP	76-60			; DOS2 kernel errorcode ?
	RET	NC			; nope, handled by the default errortext handler
	INC	A
	LD	B,A
	LD	HL,I677D
J6768:	LD	A,(HL)
	AND	A			; end of errortext ?
	INC	HL
	JR	NZ,J6768		; nope, again
	DJNZ	J6768			; next errortext
	DEC	HL			; extra endmarker at begin
	LD	DE,BUF+10
	PUSH	DE
	LD	BC,26			; maximium errortext length
	LDIR				; copy errortext to temporary buffer
	LD	E,1			; adjust errorcode to 1 (because buffer contains only 1 errortext)
	POP	HL
	RET

I677D:	DEFB	0
        DEFB	"Bad FAT",0
        DEFB	"Bad file mode",0
        DEFB	"Bad drive name",0
        DEFB	"Bad sector number",0
        DEFB	"File still open",0
        DEFB	"File already exists",0
        DEFB	"Disk full",0
        DEFB	"Too many files",0
        DEFB	"Disk write protected",0
        DEFB	"Disk I/O error",0
        DEFB	"Disk offline",0
        DEFB	"Rename across disk",0
        DEFB	"File write protected",0
        DEFB	"Directory already exists",0
        DEFB	"Directory not found",0
        DEFB	"RAM disk already exists",0

;	  Subroutine take control from hook caller
;	     Inputs  ________________________
;	     Outputs ________________________

C6890:	EI
	PUSH	HL
	PUSH	AF
	LD	A,(LF348)
J6896:	ADD	A,A
	LD	HL,12
	JR	NC,J689E
	LD	L,12+8
J689E:	ADD	HL,SP
	LD	(HL),LOW RETRTN
	INC	HL
	LD	(HL),HIGH RETRTN	; replace return address with RET routine
	POP	AF
	POP	HL
	RET

;	  Subroutine multiply
;	     Inputs  ________________________
;	     Outputs ________________________

C68A7:	LD	HL,0

;	  Subroutine multiply high word
;	     Inputs  ________________________
;	     Outputs ________________________

C68AA:	LD	A,17
J68AC:	RR	B
	RR	C
	DEC	A
	RET	Z

J68B2:	JR	NC,J68B5
	ADD	HL,DE
J68B5:	RR	H
J68B7:	RR	L
	JR	J68AC

;	  Subroutine prepare for DOS, try to load and start MSXDOS2.SYS
;	     Inputs  ________________________
;	     Outputs ________________________

C68BB:	LD	B,A			; boot drive
	LD	A,(LF23C)		; default drive
	PUSH	AF
	PUSH	BC
	PUSH	HL
	LD	HL,(LF349)
	LD	(LF34B),HL		; bottom of MSXDOS disksystem = bottom of basic diskssystem
	DI
	LD	A,(LF314)		; TPA segment page 0
	CALL	LF218			; PUT_P0
	LD	A,(LF315)		; TPA segment page 1
	CALL	LF21E			; PUT_P1
	LD	A,(LF316)		; TPA segment page 2
	CALL	LF224			; PUT_P2
	LD	A,(RAMAD3)
	LD	H,HIGH 08000H
	CALL	ENASLT			; enable RAM on page 2
	CALL	LF1FD			; enable RAM on page 0
	LD	HL,0
J68E9:	LD	(HL),H
	INC	L
	JR	NZ,J68E9		; clear CP/M zero page
	LD	HL,I6938		; table with slot jump entries in CP/M zero page
J68F0:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	A,D
	OR	E
	JR	Z,J6902
	LD	A,0C3H
	LD	(DE),A
	INC	DE
	LDI
	LDI				; setup jump entry
	JR	J68F0

J6902:	CALL	LF227			; GET_P2
	EX	AF,AF'
	LD	A,(LF2D0)		; BDOS code segment
	CALL	LF224			; PUT_P2
	LD	HL,X003B+08000H
	LD	DE,X003B
	LD	BC,S003B
	LDIR				; install secundairy slot helper routines
	EX	AF,AF'
	CALL	LF224			; PUT_P2
	EI
	POP	HL
	LD	DE,DBUF+1
	LD	B,0FFH
J6922:	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE
	INC	B
	OR	A
	JR	NZ,J6922
	LD	A,B
	LD	(DBUF+0),A
	POP	AF
	OR	A			; boot drive specified ?
	CALL	NZ,C69F1		; yep, load and start MSXDOS2.SYS
	POP	AF			; default drive
	CALL	C69F1			; load and start MSXDOS2.SYS
	RET

I6938:	DEFW	RDSLT,LF1E8
        DEFW	WRSLT,LF1EB
        DEFW	CALSLT,LF1EE
        DEFW	ENASLT,LF1F1
        DEFW	CALLF,LF1F4
        DEFW	KEYINT,LF1E5
        DEFW	0

;	  Subroutine try to load bootsector from any drive
;	     Inputs  ________________________
;	     Outputs ________________________

C6952:	LD	HL,I6A58
	LD	(LF323),HL		; register DOS1 disk error handler
	LD	HL,I6A5A
	LD	(LF325),HL		; register DOS1 abort handler
	LD	DE,($SECBUF)
	LD	C,1AH			; Set disk transfer address
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	LD	C,1

	IF ROMVER GE 3

	LD	B,8			; 8 drives
J696B:	PUSH	BC
	LD	L,C
	DEC	L
	LD	H,1			; 1 sector
	LD	DE,0			; bootsector
	LD	C,2FH			; Absolute sector read
	CALL	C69A1			; install PROMPT interceptor (for phantom drives)
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	CALL	C69B8			; check PROMPT interceptor status
	POP	BC
	JR	NZ,J698B		; error, next drive
	LD	HL,($SECBUF)
	LD	A,(HL)
	OR	02H
	CP	0EBH			; JMP x86 ?
	JR	Z,J6990			; yep, valid boot drive
J698B:	INC	C
	DJNZ	J696B			; next drive
	XOR	A			; no valid bootdrive found

	ELSE

	LD	DE,DRVTBL
J696C:	PUSH	BC
	PUSH	DE
	LD	L,C
	DEC	L
	LD	H,1			; 1 sector
	LD	DE,0			; bootsector
	LD	C,2FH			; Absolute sector read
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	DE
	POP	BC
	JR	NZ,J6988		; error,
	LD	HL,($SECBUF)
	LD	A,(HL)
	OR	02H
	CP	0EBH			; JMP x86 ?
	JR	Z,J6990			; yep, valid boot drive
J6988:	LD	A,(DE)
	ADD	A,C
	LD	C,A			; update driveid to drive of next disk interface
	INC	DE
	INC	DE			; next disk interface
	LD	A,(DE)			; entry used ?
	AND	A
	JR	NZ,J696C		; yep, try disk interface
					; no valid bootdrive found

	ENDIF

	RET

J6990:	LD	A,C
	LD	(LF23C),A		; select as default drive
	LD	HL,($SECBUF)
	LD	DE,BOT16K
	LD	BC,BOOTSZ
	LDIR				; transfer bootsector to bootlocation
	OR	A			; valid bootdrive found
	RET

	
	IF ROMVER GE 3

;	  Subroutine install PROMPT interceptor
;	     Inputs  ________________________
;	     Outputs ________________________

C69A1:	PUSH	HL
	LD	HL,LF24F
	LD	(HL),0C3H
	INC	HL
	LD	(HL),LOW C69B0
	INC	HL
	LD	(HL),HIGH C69B0
	INC	HL
	POP	HL
	RET

;	  Subroutine PROMPT interceptor
;	     Inputs  ________________________
;	     Outputs ________________________

C69B0:	EX	(SP),HL
	LD	HL,LF24F
	LD	(HL),0C9H		; disable PROMPT interceptor
	POP	HL
	RET

;	  Subroutine check PROMPT interceptor status
;	     Inputs  ________________________
;	     Outputs ________________________

C69B8:	PUSH	AF
	PUSH	HL
	LD	HL,LF24F
	LD	A,(HL)
	CP	0C9H			; PROMPT intercepted (phantom drive) ?
	JR	NZ,J69E6		; nope, remove PROMPT interceptor and quit
	LD	(HL),0C3H		; reenable PROMPT interceptor
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	HL,DRVTBL
	LD	A,(LF33F)
	LD	B,A			; driveid used by PROMPT
	XOR	A
J69CF:	ADD	A,(HL)
	CP	B			; driveid handled by this disk interface ?
	JR	NC,J69D7		; yep,
	INC	HL
	INC	HL
	JR	J69CF			; next disk interface

J69D7:	SUB	(HL)
	LD	L,A			; first drive of the disk interface
	LD	H,1			; 1 sector
	LD	DE,0			; bootsector
	LD	C,2FH			; Absolute sector read
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	BC
	POP	DE
	POP	HL
J69E6:	LD	(HL),0C9H
	INC	HL
	LD	(HL),0C9H
	INC	HL
	LD	(HL),0C9H		; remove PROMPT interceptor
	POP	HL
	POP	AF
	RET

	ENDIF

;	  Subroutine load and start MSXDOS2.SYS
;	     Inputs  A = bootdrive
;	     Outputs ________________________

C69F1:	LD	(LF23C),A		; default drive
	LD	HL,I6A58
	LD	(LF323),HL		; register DOS1 disk error handler
	LD	HL,I6A5A
	LD	(LF325),HL		; register DOS1 abort handler
	LD	B,0
	LD	D,B			; cancel all drive assignments
	LD	C,6AH			; Logical drive assignment
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	LD	DE,I6A3E
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	JR	NZ,J6A3D		; error, quit
	LD	DE,TBASE
	LD	HL,04000H-TBASE
	LD	C,48H			; Read from file handle
	PUSH	BC
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	BC
	PUSH	AF
	LD	C,45H			; Close file handle
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	AF
	JR	NZ,J6A3D		; error reading, quit
	LD	A,(LF23C)		; default drive
	LD	(LF2FD),A		; boot drive
	LD	A,0C3H
	LD	(XF368+0),A
	LD	(XF36B+0),A
	LD	(XF36E+0),A		; enable XFER, SetRamPg1, SetRomPg1
	JP	TBASE			; start MSXDOS2

J6A3D:	RET

I6A3E:	DEFB	"\MSXDOS2.SYS"
        DEFB	0

;	  Subroutine invoke DiskBASIC BDOS call
;	     Inputs  ________________________
;	     Outputs ________________________

C6A4B:	CALL	BDOS			; DiskBASIC BDOS call
	CP	9DH			; diskoperation aborted error ?
	JR	NZ,J6A53		; nope, quit
	LD	A,B			; orginal error of the aborted diskoperation
J6A53:	OR	A
	RET

;	  Subroutine DOS1 disk error handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6A55:	LD	C,2			; action = abort

;	  Subroutine DOS1 abort handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6A57:	RET

; pointer to DOS1 disk error handler

I6A58:	DEFW	C6A55

; pointer to DOS1 abort handler

I6A5A:	DEFW	C6A57

;	  Subroutine select TPA segments
;	     Inputs  ________________________
;	     Outputs ________________________

C6A5C:	LD	A,(LF314)		; TPA segment page 0
	CALL	LF218			; PUT_P0
	LD	A,(LF315)		; TPA segment page 1
	CALL	LF21E			; PUT_P1
	LD	A,(LF316)		; TPA segment page 2
	CALL	LF224			; PUT_P2
	RET

;	  Subroutine DOS2 abort handler in BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

I6A6F:	EXX
	LD	B,A			; errorcode
	EXX
	LD	SP,(LF2E8)
	LD	HL,(LF325)		; DOS1 abort handler
	JP	J6A92			; invoke DOS1 style handler

;	  Subroutine DOS2 disk error handler in BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

I6A7C:	EX	AF,AF'
	LD	L,C
	LD	C,A			; flag
	LD	A,B
	DEC	A			; driveid (0 based)
	LD	B,L			; flags
	LD	HL,(LF323)		; DOS1 disk error handler
	CALL	C6A8D			; invoke DOS1 style disk error handler
	LD	A,3
	SUB	C			; DOS2 return code
	EI
	RET

;	  Subroutine invoke DOS1 style disk error handler
;	     Inputs  HL = disk error handler
;	     Outputs ________________________

C6A8D:	PUSH	HL
	LD	HL,XF368
	EX	(SP),HL
J6A92:	PUSH	HL
	LD	HL,LF1E2
	EX	(SP),HL
	JP	XF36B

;	  Subroutine DOS2 interrupt handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6A9A:	DI
	LD	A,1
	LD	(LF2BD),A		; reset no keyboard check counter (because keyboard is scanned as part of this interrupt)
	LD	HL,LF2B9
	INC	(HL)			; increase interrupt count
	LD	A,(LF2B8)
	CP	(HL)			; has 100 ms passed since last ?
	JR	NZ,J6AC0		; nope, do not update counters
	LD	(HL),0			; reset interrupt count
	LD	A,(LF2BE)		; screenoutput buffer counter
	CP	2
	ADC	A,-1			; decrease only if >1 (counts down from any value until 1 is reached)
	LD	(LF2BE),A
	LD	A,(LF2BF)		; disk unchanged counter
	CP	7
	ADC	A,0			; increase only if <7 (counts up from 0 until 7 is reached)
	LD	(LF2BF),A
J6AC0:	LD	HL,(LF2BA+0)
	LD	A,(LF2BA+2)
	LD	C,A
	RRCA
	RRCA
	RRCA
	XOR	C
	RLA
	RLA
	ADC	HL,HL
	LD	A,C
	ADC	A,A
	LD	(LF2BA+2),A
	LD	(LF2BA+0),HL		; update random seed
	RET

;	  Subroutine DiskBASIC BDOS handler with IX parameter
;	     Inputs  ________________________
;	     Outputs ________________________

I6AD8:	LD	IX,(LF2E6)

;	  Subroutine DiskBASIC BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

J6ADC:	EX	AF,AF'
	EXX
	LD	HL,I6A6F
	LD	(LF302),HL		; setup abort handler
	LD	HL,I6A7C
	LD	(LF300),HL		; setup disk error handler
	LD	HL,(LF2FE)
	OR	A
	SBC	HL,SP			; already using the BDOS temp stack ?
	JR	C,J6AF9			; nope, use BDOS temp stack
	LD	BC,300
	SBC	HL,BC			; already using the BDOS temp stack ?
	JR	C,J6B0A			; yep, go
J6AF9:	LD	(LF2E8),SP
	LD	SP,(LF2FE)		; switch to temporary BDOS stack
	CALL	C6B0F			; BDOS handler
	LD	SP,(LF2E8)		; switch to orginal stack
	OR	A
	RET

J6B0A:	CALL	C6B0F			; BDOS handler
	OR	A
	RET

;	  Subroutine BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6B0F:	EXX
	PUSH	HL
	LD	A,C
	CP	71H			; valid BDOS function ?
	JR	C,J6B18			; yep, continue
	LD	A,1CH			; illegal BDOS function
J6B18:	LD	HL,I6B28
	ADD	A,A
	ADD	A,L
	LD	L,A
	JR	NC,J6B21
	INC	H
J6B21:	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	EX	(SP),HL
	EX	AF,AF'
	RET				; invoke BDOS wrapper routine

I6B28:	DEFW	C6CEE			; BDOS 00: execute BDOS function
	DEFW	C6C0A			; BDOS 01: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 02: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 03: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 04: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 05: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 06: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 07: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 08: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C10			; BDOS 09: wrapper for string output BDOS function
	DEFW	C6C20			; BDOS 0A: wrapper for line input BDOS function
	DEFW	C6C0A			; BDOS 0B: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 0C: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 0D: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 0E: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C44			; BDOS 0F: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 10: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 11: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C0A			; BDOS 12: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C44			; BDOS 13: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 14: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 15: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 16: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 17: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C0A			; BDOS 18: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 19: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C0A			; BDOS 1A: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6C3C			; BDOS 1B: wrapper for get allocation information BDOS function
	DEFW	C6CEE			; BDOS 1C: execute BDOS function
	DEFW	C6CEE			; BDOS 1D: execute BDOS function
	DEFW	C6CEE			; BDOS 1E: execute BDOS function
	DEFW	C6CEE			; BDOS 1F: execute BDOS function
	DEFW	C6CEE			; BDOS 20: execute BDOS function
	DEFW	C6C47			; BDOS 21: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6C47			; BDOS 22: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6C47			; BDOS 23: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6C47			; BDOS 24: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6CEE			; BDOS 25: execute BDOS function
	DEFW	C6C68			; BDOS 26: wrapper for BDOS functions with FCB (custom recordsize)
	DEFW	C6C68			; BDOS 27: wrapper for BDOS functions with FCB (custom recordsize)
	DEFW	C6C47			; BDOS 28: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6CEE			; BDOS 29: execute BDOS function
	DEFW	C6C83			; BDOS 2A: wrapper for simple BDOS functions A=C
	DEFW	C6C83			; BDOS 2B: wrapper for simple BDOS functions A=C
	DEFW	C6C83			; BDOS 2C: wrapper for simple BDOS functions A=C
	DEFW	C6C83			; BDOS 2D: wrapper for simple BDOS functions A=C
	DEFW	C6C0A			; BDOS 2E: wrapper for simple BDOS functions A=L, B=H
	DEFW	C6CEE			; BDOS 2F: execute BDOS function
	DEFW	C6CEE			; BDOS 30: execute BDOS function
	DEFW	C6C88			; BDOS 31: wrapper for get disk parameters BDOS functions
	DEFW	C6CEE			; BDOS 32: execute BDOS function
	DEFW	C6CEE			; BDOS 33: execute BDOS function
	DEFW	C6CEE			; BDOS 34: execute BDOS function
	DEFW	C6CEE			; BDOS 35: execute BDOS function
	DEFW	C6CEE			; BDOS 36: execute BDOS function
	DEFW	C6CEE			; BDOS 37: execute BDOS function
	DEFW	C6CEE			; BDOS 38: execute BDOS function
	DEFW	C6CEE			; BDOS 39: execute BDOS function
	DEFW	C6CEE			; BDOS 3A: execute BDOS function
	DEFW	C6CEE			; BDOS 3B: execute BDOS function
	DEFW	C6CEE			; BDOS 3C: execute BDOS function
	DEFW	C6CEE			; BDOS 3D: execute BDOS function
	DEFW	C6CEE			; BDOS 3E: execute BDOS function
	DEFW	C6CEE			; BDOS 3F: execute BDOS function
	DEFW	C6C9A			; BDOS 40: wrapper for BDOS functions with FIB + ASCIIZ or ASCIIZ input parameter
	DEFW	C6CA1			; BDOS 41: wrapper for BDOS functions with FIB
	DEFW	C6C9A			; BDOS 42: wrapper for BDOS functions with FIB + ASCIIZ or ASCIIZ input parameter
	DEFW	C6CC3			; BDOS 43: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 44: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CEE			; BDOS 45: execute BDOS function
	DEFW	C6CEE			; BDOS 46: execute BDOS function
	DEFW	C6CEE			; BDOS 47: execute BDOS function
	DEFW	C6CEE			; BDOS 48: execute BDOS function
	DEFW	C6CEE			; BDOS 49: execute BDOS function
	DEFW	C6CEE			; BDOS 4A: execute BDOS function
	DEFW	C6CEE			; BDOS 4B: execute BDOS function
	DEFW	C6CC3			; BDOS 4C: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 4D: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CBD			; BDOS 4E: wrapper for BDOS functions with ASCIIZ + ASCIIZ or FIB parameter
	DEFW	C6CBD			; BDOS 4F: wrapper for BDOS functions with ASCIIZ + ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 50: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 51: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CEE			; BDOS 52: execute BDOS function
	DEFW	C6CDE			; BDOS 53: wrapper for BDOS functions with second ASCIIZ parameter
	DEFW	C6CDE			; BDOS 54: wrapper for BDOS functions with second ASCIIZ parameter
	DEFW	C6CEE			; BDOS 55: execute BDOS function
	DEFW	C6CEE			; BDOS 56: execute BDOS function
	DEFW	C6CEE			; BDOS 57: execute BDOS function
	DEFW	C6CEE			; BDOS 58: execute BDOS function
	DEFW	C6CF6			; BDOS 59: wrapper for BDOS functions with 64 byte buffer result
	DEFW	C6D39			; BDOS 5A: wrapper for BDOS functions with FIB input
	DEFW	C6CF1			; BDOS 5B: wrapper for BDOS functions with FIB input and output
	DEFW	C6D16			; BDOS 5C: wrapper for BDOS function parse filename
	DEFW	C6CEE			; BDOS 5D: execute BDOS function
	DEFW	C6CF6			; BDOS 5E: wrapper for BDOS functions with 64 byte buffer result
	DEFW	C6CEE			; BDOS 5F: execute BDOS function
	DEFW	C6CEE			; BDOS 60: execute BDOS function
	DEFW	C6CEE			; BDOS 61: execute BDOS function
	DEFW	C6CEE			; BDOS 62: execute BDOS function
	DEFW	C6CEE			; BDOS 63: execute BDOS function
	DEFW	C6CEE			; BDOS 64: execute BDOS function
	DEFW	C6CEE			; BDOS 65: execute BDOS function
	DEFW	C6D3F			; BDOS 66: wrapper for BDOS function explain error code
	DEFW	C6CEE			; BDOS 67: execute BDOS function
	DEFW	C6CEE			; BDOS 68: execute BDOS function
	DEFW	C6CEE			; BDOS 69: execute BDOS function
	DEFW	C6CEE			; BDOS 6A: execute BDOS function
	DEFW	C6CEE			; BDOS 6B: execute BDOS function
	DEFW	C6CEE			; BDOS 6C: execute BDOS function
	DEFW	C6CEE			; BDOS 6D: execute BDOS function
	DEFW	C6CEE			; BDOS 6E: execute BDOS function
	DEFW	C6CEE			; BDOS 6F: execute BDOS function
	DEFW	C6CEE			; BDOS 70: execute BDOS function

;	  Subroutine wrapper for simple BDOS functions A=L, B=H
;	     Inputs  ________________________
;	     Outputs ________________________

C6C0A:	CALL	C6CEE			; execute BDOS function
	LD	A,L
	LD	B,H
	RET

;	  Subroutine wrapper for string output BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6C10:	LD	A,(DE)
	INC	DE
	CP	"$"			; end of string ?
	JR	Z,J6C37			; yep, quit
	PUSH	DE
	LD	E,A
	LD	C,2			; _CONOUT
	CALL	C6CEE			; execute BDOS function
	POP	DE
	JR	C6C10

;	  Subroutine wrapper for line input BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6C20:	PUSH	DE
	LD	A,(DE)			; size of input buffer
	LD	DE,(LF2F5)		; BDOS temp buffer
	LD	(DE),A			; same input buffer size
	CALL	C6CEE			; execute BDOS function
	POP	DE
	LD	A,(DE)			; size of input buffer
	INC	DE
	LD	HL,(LF2F5)		; BDOS temp buffer
	INC	HL
	LD	C,A
	LD	B,0
	INC	BC			; count extra CR
	LDIR
J6C37:	XOR	A
	LD	B,A
	LD	L,A
	LD	H,A
	RET

;	  Subroutine wrapper for get allocation information BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6C3C:	CALL	C6CEE			; execute BDOS function
	LD	A,C			; sectors per cluster
	LD	BC,512			; sectorsize = 512
	RET

;	  Subroutine wrapper for BDOS functions with 33 bytes FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C6C44:	LD	A,33			; FCB size 33 bytes
	DEFB	021H

;	  Subroutine wrapper for BDOS functions with 36 bytes FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C6C47:	LD	A,36			; FCB size 36 bytes (random record)
	PUSH	DE
	EXX
	POP	HL
	LD	C,A
	LD	B,0

;	  Subroutine wrapper BDOS functions with FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C6C4F:	PUSH	HL
	PUSH	BC
	LD	DE,(LF2F5)		; BDOS temp buffer
	PUSH	DE
	LDIR				; copy FCB to temp buffer
	EXX
	POP	DE
	PUSH	DE
	CALL	C6CEE			; execute BDOS function
	EXX
	POP	HL
	POP	BC
	POP	DE
	LDIR				; copy temp buffer to FCB
	EXX
	LD	A,L
	LD	B,H
	RET

;	  Subroutine wrapper for BDOS functions with FCB (custom recordsize)
;	     Inputs  ________________________
;	     Outputs ________________________

C6C68:	PUSH	DE
	EXX
	POP	HL
	PUSH	HL
	LD	BC,15
	ADD	HL,BC
	LD	C,36			; assume FCB of 36 bytes
	LD	A,(HL)
	OR	A			; high byte recordsize <> 0 ?
	JR	NZ,J6C7D		; yep, record size > 255, FCB is 36 bytes
	DEC	HL
	LD	A,(HL)
	CP	64			; record size < 64 ?
	JR	NC,J6C7D		; nope,
	INC	C			; FCB is 37 bytes
J6C7D:	POP	HL
	CALL	C6C4F			; wrapper BDOS functions with FCB
	EX	DE,HL
	RET

;	  Subroutine wrapper for simple BDOS functions A=C
;	     Inputs  ________________________
;	     Outputs ________________________

C6C83:	CALL	C6CEE			; execute BDOS function
	LD	A,C
	RET

;	  Subroutine wrapper for get disk parameters BDOS functions
;	     Inputs  ________________________
;	     Outputs ________________________

C6C88:	PUSH	DE
	LD	DE,(LF2F5)		; BDOS temp buffer
	CALL	C6CEE			; execute BDOS function
	EX	DE,HL
	POP	DE
	PUSH	DE
	LD	BC,32
	LDIR
	POP	DE
	RET

;	  Subroutine wrapper for BDOS functions with FIB + ASCIIZ or ASCIIZ input parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6C9A:	CALL	C6D53			; copy FIB or ASCIIZ string to BDOS temp buffer
	CALL	C,C6D76			; was FIB, copy ASCIIZ string to BDOS second temp buffer
	RET	NZ			; error, quit

;	  Subroutine wrapper for BDOS functions with FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C6CA1:	PUSH	IX
	POP	HL
	PUSH	HL
	LD	DE,(LF2F7)
	PUSH	BC
	LD	BC,64
	LDIR				; copy FIB to BDOS FIB buffer
	POP	BC
	CALL	C6CE3			; execute BDOS function with 1 FIB buffer and 2 temp buffer parameters
	POP	DE
	LD	HL,(LF2F7)
	LD	BC,64
	LDIR				; copy BDOS FIB buffer back to FIB
	RET

;	  Subroutine wrapper for BDOS functions with ASCIIZ + ASCIIZ or FIB parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CBD:	CALL	C6D76			; copy ASCIIZ string to BDOS second temp buffer
	LD	HL,(LF2F9)		; BDOS second temp buffer

;	  Subroutine wrapper for BDOS functions with ASCIIZ or FIB parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CC3:	EX	AF,AF'
	PUSH	DE
	CALL	C6D53			; copy FIB or ASCIIZ string to BDOS temp buffer
	PUSH	AF
	EX	AF,AF'
	CALL	C6CEA			; execute BDOS function with temp buffer parameter
	EX	AF,AF'
	EXX
	POP	AF
	POP	DE
	JR	NC,J6CDB
	LD	HL,(LF2F5)		; BDOS temp buffer
	LD	BC,64
	LDIR
J6CDB:	EX	AF,AF'
	EXX
	RET

;	  Subroutine wrapper for BDOS functions with second ASCIIZ parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CDE:	EX	AF,AF'
	CALL	C6D76			; copy ASCIIZ string to BDOS second temp buffer
	EX	AF,AF'

;	  Subroutine execute BDOS function with 1 FIB buffer and 2 temp buffer parameters
;	     Inputs  ________________________
;	     Outputs ________________________

C6CE3:	LD	IX,(LF2F7)		; BDOS FIB buffer
	LD	HL,(LF2F9)		; BDOS second temp buffer

;	  Subroutine execute BDOS function with temp buffer parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CEA:	LD	DE,(LF2F5)		; BDOS temp buffer

;	  Subroutine execute BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6CEE:	JP	LF37A

;	  Subroutine wrapper for BDOS functions with FIB input and output
;	     Inputs  ________________________
;	     Outputs ________________________

C6CF1:	PUSH	DE
	CALL	C6D57			; copy FIB to temp buffer
	POP	DE

;	  Subroutine wrapper for BDOS functions with 64 byte buffer result
;	     Inputs  ________________________
;	     Outputs ________________________

C6CF6:	EX	DE,HL
	PUSH	HL
	LD	DE,(LF2F5)		; BDOS temp buffer
	OR	A
	SBC	HL,DE
	PUSH	HL
	PUSH	DE
	CALL	C6CEE			; execute BDOS function
	EXX
	POP	HL
	POP	BC
	POP	DE
	PUSH	BC
	LD	BC,64
	LDIR
	EXX
	EX	(SP),HL
	EX	DE,HL
	ADD	HL,DE
	EX	(SP),HL
	ADD	HL,DE
	POP	DE
	RET

;	  Subroutine wrapper for BDOS function parse filename
;	     Inputs  ________________________
;	     Outputs ________________________

C6D16:	PUSH	HL
	PUSH	HL
	LD	L,E
	LD	H,D
	CALL	C6D57			; copy FIB to temp buffer
	LD	DE,(LF2F5)		; BDOS temp buffer
	OR	A
	SBC	HL,DE
	EX	(SP),HL
	PUSH	HL
	CALL	C6CE3			; execute BDOS function with 1 FIB buffer and 2 temp buffer parameters
	EXX
	POP	DE
	LD	BC,11
	LD	HL,(LF2F9)		; BDOS second temp buffer
	LDIR
	EXX
	POP	HL
	ADD	HL,DE
	EX	DE,HL
	POP	HL
	RET

;	  Subroutine wrapper for BDOS functions with FIB input
;	     Inputs  ________________________
;	     Outputs ________________________

C6D39:	CALL	C6D57			; copy FIB to temp buffer
	JP	C6CEA			; execute BDOS function with temp buffer parameter

;	  Subroutine wrapper for BDOS function explain error code
;	     Inputs  ________________________
;	     Outputs ________________________

C6D3F:	PUSH	DE
	LD	DE,(LF2FB)
	CALL	C6CEE			; execute BDOS function
	EX	DE,HL
	POP	DE
	PUSH	DE
	PUSH	BC
	LD	BC,64
	LDIR
	POP	BC
	POP	DE
	RET

;	  Subroutine copy FIB or ASCIIZ string to BDOS temp buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6D53:	LD	A,(DE)
	INC	A			; FIB ?
	JR	NZ,J6D67		; nope, copy ASCIIZ string to BDOS temp buffer

;	  Subroutine copy FIB to temp buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6D57:	PUSH	HL
	PUSH	BC
	EX	DE,HL
	LD	DE,(LF2F5)		; BDOS temp buffer
	LD	BC,64
	LDIR
	POP	BC
	POP	HL
	SCF
	RET

;	  Subroutine copy ASCIIZ string to BDOS temp buffer
;	     Inputs  ________________________
;	     Outputs ________________________

J6D67:	PUSH	HL
	PUSH	BC
	EX	DE,HL
	LD	DE,(LF2F5)		; BDOS temp buffer
	LD	B,100
	CALL	C6D84			; copy ASCIIZ string
	POP	BC
	POP	HL
	RET

;	  Subroutine copy ASCIIZ string to BDOS second temp buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6D76:	PUSH	DE
	PUSH	BC
	LD	DE,(LF2F9)		; BDOS second temp buffer
	LD	B,100
	CALL	C6D84			; copy ASCIIZ string
	POP	BC
	POP	DE
	RET

;	  Subroutine copy ASCIIZ string
;	     Inputs  HL = source, DE = destination, B = max. length
;	     Outputs ________________________

C6D84:	LD	A,(HL)
	INC	HL
	LD	(DE),A
	INC	DE
	OR	A
	RET	Z
	DJNZ	C6D84
	LD	A,0D8H
	RET

; DSKCHG routine for ramdisk

R_DSKCHG:
C6D8F:	LD	HL,LBC00+32
	LD	A,(LF2CF)		; BDOS data segment
	CALL	LF206			; RD_SEG
	CP	"V"			; check if first letter of VOL_ID
	LD	B,0
	RET	Z			; yep, return DISK CHANGE UNKNOWN
	DEC	B			; return DISK CHANGED
	RET

; DSKIO routine for ramdisk

R_DSKIO:
C6D9F:	EI
	LD	(LF2E3),DE		; save sectornumber
	LD	(LF2E1),HL		; save transferaddress
	LD	A,B
	LD	(LF2E5),A		; save number of sectors
	EX	AF,AF'
	LD	HL,LBC00+32
	LD	A,(LF2CF)		; BDOS data segment
	CALL	LF206			; RD_SEG
	EI
	SUB	"V"			; check if first letter of VOL_ID
	CALL	NZ,C6EB9		; nope, 'format' ramdisk
	RET	C
	LD	HL,(SLTTBL+0)
	PUSH	HL
	LD	HL,(SLTTBL+2)
	PUSH	HL			; save SLTTBL

J6DC4:	LD	DE,(LF2E3)		; starting sectornumber
	CALL	C6E5D			; caculate transfers from segment
	JR	C,J6DFC			; error, quit
	LD	E,A			; sectors in this segment
	LD	A,(LF2E5)
	SUB	E			; check if all sectors can be done
	JR	NC,J6DD7		; nope,
	ADD	A,E
	LD	E,A			; sectors from this segment
	XOR	A			; 0 remaing sectors
J6DD7:	LD	(LF2E5),A
	OR	A
	PUSH	AF
	PUSH	HL
	LD	HL,(LF2E3)
	LD	D,0
	ADD	HL,DE
	LD	(LF2E3),HL		; update sectornumber
	POP	HL
	LD	D,E
	SLA	D
	LD	E,0			; number of bytes
	PUSH	DE
	CALL	C6E28			; transfer sectors
	POP	DE
	LD	HL,(LF2E1)
	ADD	HL,DE
	LD	(LF2E1),HL		; update transferaddress
	POP	AF
	JR	NZ,J6DC4		; sectors remain, again
	XOR	A
J6DFC:	EX	AF,AF'
	DI
	POP	HL
	LD	(SLTTBL+2),HL
	POP	HL
	LD	(SLTTBL+0),HL		; restore SLTTBL
	LD	HL,SLTTBL
	XOR	A
J6E0A:	LD	C,A
	IN	A,(0A8H)
	LD	B,A
	AND	3FH
	OR	C
	LD	E,(HL)
	PUSH	HL
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	BIT	7,(HL)			; slot expanded ?
	POP	HL
	INC	HL
	CALL	NZ,X004B		; yep, update secundairy slotregister
	LD	A,C
	ADD	A,40H
	JR	NZ,J6E0A		; next primairy slot
	EI
	EX	AF,AF'
	LD	B,0
	RET

;	  Subroutine transfer sectors
;	     Inputs  ________________________
;	     Outputs ________________________

C6E28:	DI
	LD	A,(RAMAD3)
	CP	B			; same slot as primairy memmory mapper ?
	JR	Z,J6E42			; yep, direct transfer
	CALL	LF221			; GET_P1
	PUSH	AF
	LD	A,C
	CALL	LF21E			; PUT_P1
	SET	6,H			; address in page 1 range
	CALL	LF1D3			; transfer to/from page 1
	POP	AF
	CALL	LF21E			; PUT_P1
	EI
	RET

J6E42:	CALL	LF21B			; GET_P0
	PUSH	AF
	LD	A,C
	CALL	LF218			; PUT_P0
	LD	B,D
	LD	C,E
	LD	DE,(LF2E1)		; transferaddress
	EX	AF,AF'
	JR	NC,J6E54		; reading, HL = source address
	EX	DE,HL			; writing, swap 
J6E54:	EX	AF,AF'
	LDIR				; transfer from/to memory
	POP	AF
	CALL	LF218			; PUT_P0
	EI
	RET

;	  Subroutine caculate transfers from segment
;	     Inputs  ________________________
;	     Outputs ________________________

C6E5D:	LD	A,D
	OR	E			; bootsector ?
	JR	NZ,J6E6F
	LD	A,(LF2CF)		; BDOS data segment
	LD	C,A			; segment
	LD	A,(RAMAD3)
	LD	B,A			; slot = primairy memory mapper
	LD	HL,03C00H		; base address sector
	LD	A,1			; 1 sector in segment
	RET

J6E6F:	CALL	LF227			; GET_P2
	PUSH	AF
	LD	A,(LF2CF)		; BDOS data segment
	CALL	LF224			; PUT_P2
	LD	HL,(LBE00)
	LD	H,0			; number of ramdisk segments
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *32 (32 sectors in a segment)
	POP	AF
	CALL	LF224			; PUT_P2
	SBC	HL,DE			; is sectornumber valid ?
	LD	A,12
	RET	C			; nope, quit with OTHER error
	LD	H,D
	LD	L,E
	DEC	HL			; without bootsector
	ADD	HL,HL
	LD	A,L
	PUSH	AF
	ADD	HL,HL
	ADD	HL,HL
	LD	E,H
	LD	D,0			; segment of sector
	LD	HL,LBE02
	ADD	HL,DE
	ADD	HL,DE
	CALL	LF227			; GET_P2
	PUSH	AF
	LD	A,(LF2CF)		; BDOS data segment
	CALL	LF224			; PUT_P2
	LD	C,(HL)			; segment
	INC	HL
	LD	B,(HL)			; slotid
	POP	AF
	CALL	LF224			; PUT_P2
	POP	AF
	AND	3EH			; must be a multiply of 512
	LD	H,A
	LD	L,0			; base address sector
	LD	A,40H
	SUB	H
	RRCA				; sectors in segement
	OR	A			; no error
	RET

;	  Subroutine 'format' ramdisk
;	     Inputs  ________________________
;	     Outputs ________________________

C6EB9:	CALL	LF227			; GET_P2
	PUSH	AF			; save current segment
	LD	A,(LF2CF)		; BDOS data segment
	CALL	LF224			; PUT_P2
	LD	A,(LBE00)
	OR	A			; number of ramdisk segments
	JR	NZ,J6ED1		; ramdisk enabled, continue
I6EC9:	POP	AF			; restore current segment
	CALL	LF224			; PUT_P2
	LD	A,12
	SCF				; quit with OTHER error
	RET

J6ED1:	EXX
	LD	HL,LBC00+11
	LD	(HL),LOW 0200H
	INC	HL
	LD	(HL),HIGH 0200H		; Bytes per sector = 512
	INC	HL
	LD	(HL),1			; assume 1 sector per cluster
	CP	129			; less then 129 segments ?
	JR	C,J6EE2			; nope,
	INC	(HL)			; yep, 2 sectors per cluster
J6EE2:	INC	HL
	LD	(HL),LOW 1
	INC	HL
	LD	(HL),HIGH 1		; 1 reserved sector (boot)
	INC	HL
	LD	(HL),2			; 2 FAT's
	INC	HL
	LD	C,A
	SRL	A
	SRL	A
	ADD	A,4			; rootdir. sectors = segments\4 +4
	LD	E,A
	LD	D,0
	PUSH	DE
	EX	DE,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *16 (Entries per sector)
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; number of directory entries
	INC	HL
	LD	E,C
	LD	D,0			; number of ramdisk segments
	EX	DE,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *32 (Sectors in segment)
	INC	HL			; + boot
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; total number of sectors
	INC	HL
	LD	(HL),0FFH		; media descriptor (0FFH)
	INC	HL
	EX	DE,HL
	LD	A,C
	DEC	HL			; - bootsector
	POP	BC
	OR	A
	SBC	HL,BC			; - directory sectors
	CP	129			; number of segments <129 ?
	JR	C,J6F22			; nope, 1 sector per cluster
	SRL	H
	RR	L			; 2 sectors per cluster
J6F22:	LD	B,H
	LD	C,L
	ADD	HL,BC
	ADD	HL,BC			; *3 bytes
	EX	DE,HL
	DEC	DE
	SRL	D
	SRL	D
	INC	D
	LD	(HL),D
	INC	HL
	LD	(HL),0			; number of sectors per FAT
	INC	HL
	LD	HL,I6F44
	LD	DE,LBC00+32
	LD	BC,11
	LDIR				; set volume serial number & id
	EXX
	POP	AF
	CALL	LF224			; PUT_P2
	XOR	A
	RET

I6F44:	DEFB	"VOL_ID"

I6F4A:	DEFB	0
        DEFB	1
        DEFB	2
        DEFB	3
        DEFB	4

; GETDPB routine for ramdisk

R_GETDPB:
C6F4F:	OR	A			; do nothing, no error
	RET

; CHOICE routine for ramdisk

R_CHOICE:
C6F51:	LD	HL,I6F4A		; pointer to null string (FORMAT not supported)
	RET

; DSKFMT routine for ramdisk

R_DSKFMT:
C6F55:	LD	A,12
	SCF				; bad parameter error
	RET


	IF ROMVER GE 3

	DEFS	07000H-$,0		; not sure why this was chosen

	ELSE

	DEFS	07405H-$,0		; to align driver code to the 1.x kernel location

	ENDIF


; DRIVER section starts here

        INCLUDE	DRIVER.MAC

; DRIVER section stops here


        DEFS	07FD0H-$,0

C7FD0:
	BNKCHG
        RET


; diskdriver interrupt handler

BNKINT:
C7FD4:	EX	AF,AF'
        LD	A,(D40FF)
        PUSH	AF		; Save DOS2 mapper block
        XOR	A
        CALL	C7FD0		; Set block 0
        EX	AF,AF'
        CALL	DSKINT		; interrupt handler
        EX	AF,AF'
        POP	AF
        CALL	C7FD0		; Set old block
        EX	AF,AF'
        RET

        DEFS	08000H-$,0

	END
