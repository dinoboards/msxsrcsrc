; DISK-S0.MAC
;
; DOS 2.31 kernel bank 0
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders
;

DOS2	EQU	1			; DOS2 flag for disk driver

        .Z80
        ASEG
        ORG	04000H


BOT16K	EQU	0C000H			; lower of 16 KB RAM
BOT32K	EQU	08000H			; lower of 32 KB RAM
BOOTSZ	EQU	256			; maximum size of MSX bootloader in bootsector
TMPSTK	EQU	BOT16K+BOOTSZ+256	; location of temporary stack
TBASE	EQU	00100H			; start of MSX-DOS

;	EXTRN	INIHRD
;	EXTRN	DRIVES
;	EXTRN	INIENV
;	EXTRN	DSKIO
;	EXTRN	DSKCHG
;	EXTRN	GETDPB
;	EXTRN	CHOICE
;	EXTRN	DSKFMT
;	EXTRN	MTOFF
;	EXTRN	OEMSTA
;	EXTRN	MYSIZE
;	EXTRN	SECLEN
;	EXTRN	DEFDPB

;	PUBLIC	PROMPT
;	PUBLIC	SETINT
;	PUBLIC	PRVINT
;	PUBLIC	GETSLT
;	PUBLIC	GETWRK
;	PUBLIC	DIV16
;	PUBLIC	ENASLT
;	PUBLIC	XFER


_RST    MACRO   X
        IFIDN   <X>,<SYNCHR>
        RST     08H
        ENDIF
        IFIDN   <X>,<CHRGTR>
        RST     10H
        ENDIF
        IFIDN   <X>,<OUTDO>
        RST     18H
        ENDIF
        IFIDN   <X>,<DCOMPR>
        RST     20H
        ENDIF
        IFIDN   <X>,<GETYPR>
        RST     28H
        ENDIF
        IFIDN   <X>,<CALLF>
        RST     30H
        ENDIF
        ENDM

_DOSCP	MACRO	X
	IF2
	IF	($ NE X)
	.PRINTX	"ERROR: MSXDOS incompatible, subroutine not aligned to &X"
	ENDIF
	ENDIF
	ENDM


WBOOT	EQU	00000H
DBUF	EQU	00080H
SSLOT	EQU	0003BH			; start of the slot switching helpers for MSX-DOS environment
SSLOTE	EQU	0004BH			; helper routine in DOS memoryspace: restore secundairy slotregister (CALSLT/CALLF)
SSLSZ	EQU	26			; size of the slot switching helpers for MSX-DOS environment

RDSLT	EQU	0000CH
WRSLT	EQU	00014H
CALSLT	EQU	0001CH
OUTDO	EQU	00018H
DCOMPR	EQU	00020H
ENASLT	EQU	00024H
IDBYT0	EQU	0002BH
IDBYT2	EQU	0002DH
CALLF	EQU	00030H
CHAR_16	EQU	00034H			; double byte header char table
KEYINT	EQU	00038H
CHGET	EQU	0009FH
CHPUT	EQU	000A2H
CALBAS	EQU	00159H
LDIRMV	EQU	00059H
LDIRVM	EQU	0005CH
TOTEXT	EQU	000D2H
ERAFNK	EQU	000CCH
CKCNTC	EQU	000BDH
SNSMAT	EQU	00141H
KILBUF	EQU	00156H
CHGCPU	EQU	00180H

LBC00	EQU	0BC00H			; ramdisk bootsector
LBE00	EQU	0BE00H			; number of ramdisk segments
LBE02	EQU	0BE02H			; ramdisk segment table

DATABA	EQU	0F1C9H			; start of disk system static work area
PRTBUF	EQU	0F1C9H			; BDOS _STROUT
RD_LDI	EQU	0F1D3H			; transfer to/from page 1
GO_DRV	EQU	0F1DFH			; interslot call with prompt handler
JP_VEC	EQU	0F1E2H			; start DOS1 style handler
$IRQ	EQU	0F1E5H			; KEYINT handler
$RDSLT	EQU	0F1E8H			; RDSLT handler
$WRSLT	EQU	0F1EBH			; WRSLT handler
$CALSLT	EQU	0F1EEH			; CALSLT handler
$ENASLT	EQU	0F1F1H			; ENASLT handler
$CALLF	EQU	0F1F4H			; CALLF handler
P0_RAM	EQU	0F1FDH			; enable DOS RAM on page 0
RD_SEG	EQU	0F206H			; RD_SEG handler
PUT_P0	EQU	0F218H			; PUT_P0 handler
GET_P0	EQU	0F21BH			; GET_P0 handler
PUT_P1	EQU	0F21EH			; PUT_P1 handler
GET_P1	EQU	0F221H			; GET_P1 handler
PUT_P2	EQU	0F224H			; PUT_P2 handler
GET_P2	EQU	0F227H			; GET_P2 handler
CUR_DRV	EQU	0F23CH			; default drive
HOOKBE	EQU	0F24FH
H.PROM	EQU	0F24FH			; PROMPT hook, also start of DSK hooks
TIM_RA	EQU	0F2B8H			; number of interrupts per 100 ms
TIM_CO	EQU	0F2B9H			; interrupt counter
RANDOM	EQU	0F2BAH			; random number, used for compose a random diskserial
ST_COU	EQU	0F2BDH			; no keyboard check counter
CH_COU	EQU	0F2BEH			; screenoutput buffer counter
TIM_TI	EQU	0F2BFH			; disk unchanged counter
TIMI_S	EQU	0F2C0H			; saved H.TIMI hook
DATA_S	EQU	0F2CFH			; BDOS data segment
CODE_S	EQU	0F2D0H			; BDOS code segment
FCALSA	EQU	0F2D5H			; saved EXTBIO hook
$ERR_M	EQU	0F2DAH			; adres message handler
$PROMP	EQU	0F2DCH			; adres prompt handler
$BDOS	EQU	0F2DEH			; adres BDOS handler
RD_ADD	EQU	0F2E1H			; temporary save for transferadres ramdisk DSKIO
RD_SNU	EQU	0F2E3H			; temporary save for sectornumber ramdisk DSKIO
RD_SCN	EQU	0F2E5H			; temporary save for number of sectors ramdisk DSKIO
IX_BDO	EQU	0F2E6H			; temporary save for IX parameter BDOS
SP_BDO	EQU	0F2E8H			; temporary save for SP BDOS
BLDCHK	EQU	0F2F1H			; adres BLOAD handler
BSVCHK	EQU	0F2F3H			; adres BSAVE handler
BUF_1	EQU	0F2F5H			; pointer to buffer for transfering BDOS structures
BUF_2	EQU	0F2F7H			; pointer to buffer for transfering BDOS FIB
BUF_3	EQU	0F2F9H			; pointer to buffer for transfering BDOS FIB or Path
ERR_BUF	EQU	0F2FBH			; pointer to buffer for transfering BDOS errorstrings
BOOT_D	EQU	0F2FDH			; bootdrive
BDOS_S	EQU	0F2FEH			; pointer to temporary stack for BDOS
KDSK_V	EQU	0F300H			; pointer to diskerror handler
KAB_VE	EQU	0F302H			; pointer to abort handler
CPMCAL	EQU	0F306H			; CP/M BDOS call flag, used by MSXDOS1
RAWFLG	EQU	0F30DH	                ; verify flag disk driver
COUNTR	EQU	0F30EH			; date format
KANJTA	EQU	0F30FH			; double byte header table
DOS_VER	EQU	0F313H			; DOS2 version
P0_64K	EQU	0F314H			; TPA segment page 0
P1_64K	EQU	0F315H			; TPA segment page 1
P2_64K	EQU	0F316H			; TPA segment page 2
DISKVE	EQU	0F323H			; DOS1 style diskerror handler pointer
BREAKV	EQU	0F325H			; DOS1 style abort handler pointer
AUXBOD	EQU	0F327H			; AUX input hook
$DOS1	EQU	0F333H			; pointer to BDOS handler
TIMFLG	EQU	0F338H			; clockchip available flag (always 0FFH with DOS2)
PATHNAM	EQU	0F33BH			; pointer to BASIC path buffer
RECSIZE	EQU	0F33DH			; recordsize random filemode basic
TARGET	EQU	0F33FH			; driveid (used in PROMPT), CTRL key status in DISK init
NOTFIR	EQU	0F340H			; first start DiskBASIC flag
RAMAD0	EQU	0F341H			; slotid DOS ram page 0
RAMAD1	equ	0F342H			; slotid DOS ram page 1
RAMAD2	equ	0F343H			; slotid DOS ram page 2
RAMAD3	EQU	0F344H			; slotid DOS ram page 3
DOSFLG	EQU	0F346H			; MSXDOS started flag
$NUMDR	EQU	0F347H			; number of drives
MASTER	EQU	0F348H			; slotid disk system ROM
HIMSAV	EQU	0F349H			; bottom of basic disk system
DOSHIM	EQU	0F34BH			; bottom of msxdos disk system
$SECBUF	EQU	0F34DH			; pointer to sector buffer for disk driver
$MAXSEC	EQU	0F34FH			; biggest sector size in disk system
$DIRBUF	EQU	0F351H			; pointer to sector buffer for BASIC
RM_DPB	EQU	0F353H			; pointer to DPB for RAMDISK
$DPBLI	EQU	0F355H			; DPB pointertable
RSLREG	EQU	0F365H			; read primary slotregister
$DOSON	EQU	0F368H			; enable DOS kernel
$DOSOF	EQU	0F36BH			; disable DOS kernel
XFER	EQU	0F36EH			; transfer to/fram TPA RAM on page 2
GO_BIO	EQU	0F377H			; interslot call to BDOS code segment
GO_BDO	EQU	0F37AH			; interslot call to BDOS handler in BDOS code segment
BDOS	EQU	0F37DH			; BDOS entry


DECSUB	EQU	0268CH			; subtract double
DECADD	EQU	0269AH			; add double
DECDIV	EQU	0289FH			; divide double
VMOVE	EQU	02EF3H			; copy to HL
VMOVFM	EQU	02F08H			; copy variable content to DAC
VMOVMF	EQU	02F10H			; copy variable content from DAC
MAKINT	EQU	02F99H			; integer to DAC
CONDS	EQU	03042H			; convert DAC from single float to double float
INT	EQU	030D1H			; integer part of float
SGNMUL	EQU	0325CH			; single float multiply
NULSTR	EQU	03FD6H			; empty string
ERROR   equ     0406FH          	; BASIC error
READYR  equ     0409BH          	; restart BASIC
NTSTOP  equ     04173H          	; execute statement
LINKER  equ     04253H          	; recalculate line pointers
NEWSTT  equ     04601H          	; execution loop
CHRGTR  equ     04666H          	; CHRGTR
FLTLIN  equ     046FFH          	; convert to single float
INTID2  equ     04756H          	; evaluate word operand and check for 0-32767 range
FCERR	EQU	0475AH			; illegal function call
FINPRT  equ     04AFFH          	; output back to screen
FRMEQL  equ     04C5FH          	; evaluate =expression
FRMEVL  equ     04C64H          	; evaluate expression
DOCNVF  equ     0517AH          	; convert DAC to other type
GETIN2  EQU     0520FH          	; evaluate integer operand
GTBYTC  equ     0521BH          	; evaluate next byte operand
GETBYT  equ     0521CH          	; evaluate byte operand
CONINT  equ     0521FH          	; convert to byte
JPFOUT  EQU     0537BH           	; convert DAC to text, unformatted (JPFOUT is not an offical name)
GETUIN  equ     0542FH          	; evaluate unsigned integer operand
GETUI   equ     05432H          	; convert to unsigned integer
SCCPTR  equ     054F7H          	; convert pointers to linenumbers
GETYPR  equ     05597H          	; GETYPR
PTRGET  equ     05EA4H          	; get address of variable
STRINI  equ     06627H          	; allocate temp string
GETSPA  equ     0668EH          	; allocate stringspace
FRESTR  equ     067D0H          	; free temporary string
FILEVL  equ     06A0EH          	; evaluate filespecification
FILIDX  equ     06A6DH          	; get i/o channel pointer
OPNFIL  equ     06AFAH          	; open i/o channel
CLSFIL  equ     06B24H          	; close i/o channel
CLSALL  equ     06C1CH          	; close all i/o channels
NOSKCR  equ     06E41H          	; resume character putback routine
BSAVE   equ     06E92H          	; start of BSAVE routine
BLOAD   equ     06EC6H          	; start of BLOAD routine
BLDFIN  equ     06EF4H          	; finish BLOAD
ADRGET  equ     06F0BH          	; evaluate address operand (BLOAD/SAVE)
PARDEV  equ     06F15H          	; parse device name
CRDONZ  equ     07323H          	; newline to OUTDO if not at start of line
CRDO    equ     07328H          	; newline to OUTDO
M739A   equ     0739AH          	; quit loading & start (headloop/executing)
M7D17   equ     07D17H          	; continue start of MSX-BASIC without executing BASIC programs in ROM
M7D2F   equ     07D2FH        		; address initialize BASIC screen
M7D31   equ     07D31H          	; BASIC initscreen (without INITXT & CNSDFG)
M7DE9   EQU     7DE9H    	       	; start MSX-BASIC program in ROM


A58A8	EQU	058A8H			; continue to disk system 1.x init

RETRTN	EQU	WRPRIM + 6		; on this adres is a simple RET instruction

VARWRK	EQU	0F380H
WRPRIM	EQU	0F385H
USRTAB	EQU	0F39AH
LINLEN	EQU	0F3B0H
CNSDFG	EQU	0F3DEH
LPTPOS	EQU	0F415H
PRTFLG	EQU	0F416H
CURLIN	EQU	0F41CH
KBUF	EQU	0F41FH
BUF	EQU	0F55EH
TMPBUF	EQU	BUF+10			; temporary store in BUF
TTYPOS	EQU	0F661H
VALTYP	EQU	0F663H
MEMSIZ	EQU	0F672H
STKTOP	EQU	0F674H
TXTTAB	EQU	0F676H
TEMPPT	EQU	0F678H
TEMPST  EQU     0F67AH
DSCTMP	EQU	0F698H
FRETOP	EQU	0F69BH
AUTLIN	EQU	0F6ABH			; used for biggest sectorsize during disk system init
SAVSTK	EQU	0F6B1H
VARTAB	EQU	0F6C2H
STREND	EQU	0F6C6H
DAC	EQU	0F7F6H
ARG	EQU	0F847H
MAXFIL	EQU	0F85FH
FILTAB	EQU	0F860H
NULBUF	EQU	0F862H
PTRFIL	EQU	0F864H
FILNAM	EQU	0F866H
NLONLY	EQU	0F87CH
SAVEND	EQU	0F87DH
HOKVLD	EQU	0FB20H			; EXTBIO valid flag (b0)
DRVTBL	EQU	0FB21H			; disk interface table
HOOKSA	EQU	0FB29H			; disk interface interrupt table
BASROM	EQU	0FBB1H
BOTTOM	EQU	0FC48H
HIMEM	EQU	0FC4AH
FLBMEM	EQU	0FCAEH
RUNBNF	EQU	0FCBEH
SAVENT	EQU	0FCBFH
EXPTBL	EQU	0FCC1H
SLTTBL	EQU	0FCC5H
SLTWRK	EQU	0FD09H
PROCNM	EQU	0FD89H
DEVICE	EQU	0FD99H			; used temp for disk interface count
H.TIMI	EQU	0FD9FH
H.DSKO	EQU	0FDEFH
H.NAME	EQU	0FDF9H
H.KILL	EQU	0FDFEH
H.COPY	EQU	0FE08H
H.DSKF	EQU	0FE12H
H.DSKI	EQU	0FE17H
H.LSET	EQU	0FE21H
H.RSET	EQU	0FE26H
H.FIEL	EQU	0FE2BH
H.MKI$	EQU	0FE30H
H.MKS$	EQU	0FE35H
H.MKD$	EQU	0FE3AH
H.CVI	EQU	0FE3FH
H.CVS	EQU	0FE44H
H.CVD	EQU	0FE49H
H.GETP	EQU	0FE4EH
H.NOFO	EQU	0FE58H
H.NULO	EQU	0FE5DH
H.NTFL	EQU	0FE62H
H.BINS	EQU	0FE71H
H.BINL	EQU	0FE76H
H.FILE	EQU	0FE7BH
H.DGET	EQU	0FE80H
H.FILO	EQU	0FE85H
H.INDS	EQU	0FE8AH
H.LOC	EQU	0FE99H
H.LOF	EQU	0FE9EH
H.EOF	EQU	0FEA3H
H.BAKU	EQU	0FEADH
H.PARD	EQU	0FEB2H
H.NODE	EQU	0FEB7H
H.POSD	EQU	0FEBCH
H.RUNC	EQU	0FECBH
H.CLEA	EQU	0FED0H
H.LOPD	EQU	0FED5H
H.STKE	EQU	0FEDAH
H.ERRP	EQU	0FEFDH
H.PHYD	EQU	0FFA7H
H.FORM	EQU	0FFACH
EXTBIO	EQU	0FFCAH		; extended BIOS entry
DISINT	equ	0FFCFH
ENAINT	equ	0FFD4H
LFFFF	EQU	0FFFFH

.BUFUL	EQU	0D8H

        INCLUDE	DISK.INC

	IF ROMVER EQ 1
CLRSIZ	EQU	BREAKV+1-DOS_VER
	ENDIF

	IF ROMVER GE 2
CLRSIZ	EQU	BREAKV+1-TIM_RA
	ENDIF

        
        DEFB	"AB"
        DEFW	C403C			; extension ROM initialization
        DEFW	C575C			; extension ROM BASIC CALL statement handler
        DEFW	0			; extension ROM BASIC device handler (none)
        DEFW	0			; extension ROM BASIC program (none)
        DEFS	6,0			; extension ROM further use

;	  Subroutine DRIVER: DSKIO
;	     Inputs  ________________________
;	     Outputs ________________________

DKRWEN:
C4010:	JP	DSKIO

;	  Subroutine DRIVER: DSKCHG
;	     Inputs  ________________________
;	     Outputs ________________________

DKCHGE:
C4013:	JP	DSKCHG

;	  Subroutine DRIVER: GETDPB
;	     Inputs  ________________________
;	     Outputs ________________________

GTDPBE:
C4016:	JP	GETDPB

;	  Subroutine DRIVER: CHOICE
;	     Inputs  ________________________
;	     Outputs ________________________

CHOIEN:
C4019:	JP	CHOICE

;	  Subroutine DRIVER: DSKFMT
;	     Inputs  ________________________
;	     Outputs ________________________

DKFMTE:
C401C:	JP	DSKFMT

;	  Subroutine DRIVER: MTOFF
;	     Inputs  ________________________
;	     Outputs ________________________

MTOFFE:
C401F:	JP	MTOFF

;	  Subroutine start DiskBASIC
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

BASENT:
C4022:	JP	J4B43

;	  Subroutine format disk
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

FORENT:
C4025:	SCF			; workarea specified
        JP	J4E8F		; format disk

;	  Subroutine stop motor of all floppy drives
;	     Inputs  ________________________
;	     Outputs ________________________

C4029:	JP	J4CFB
        NOP

;	  Subroutine get my slotid
;	     Inputs  ________________________
;	     Outputs ________________________

GETSLT:
C402D:	JP	C4E2D

;	  Subroutine get top of MSXDOS disk system
;	     Inputs  ________________________
;	     Outputs ________________________

	_DOSCP	4030H

$INIT:
C4030:	LD	HL,(DOSHIM)
        RET

;	  Subroutine CP/M BIOS CONST entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4034H

$$BIOS:
C4034:	JP	J417C

        DEFS	04038H-$,0

; 04038H
; DOS2: pointer to kernel version ASCIIZ string

C4038:	DEFW	I411E

        DEFS	0403CH-$,0

C403C:	XOR	A
        CALL	C7FD0			; select bank 0
        JP	J47D6			; start initialization

C4043:	CALL	C410C			; EXTBIO handler memory mapper
        JP	FCALSA			; continue EXTBIO

;	  Subroutine DOS2 timer routine
;	     Inputs  ________________________
;	     Outputs ________________________

C4049:	PUSH	AF			; store VDP status
        LD	A,(D40FF)		; current bank
        PUSH	AF			; store current bank
        XOR	A			; bank = 0
        CALL	C7FD0			; select bank
        CALL	C4D1B			; timer routine DOS2
        POP	AF			; restore current bank
        CALL	C7FD0			; select bank
        POP	AF			; restore VDP status
        RET

;	  Subroutine invoke routine in bank
;	     Inputs  A = banknumber, IX = routine
;	     Outputs ________________________

J405B:	CALL	C7FD0			; select bank
        EX	AF,AF'
        CALL	C4069			; call routine
        EX	AF,AF'
        XOR	A			; bank = 0
        CALL	C7FD0			; select bank
        EX	AF,AF'
        RET

C4069:	JP	(IX)

        DEFS	04078H-$,0

;	  Subroutine CP/M BIOS CONIN entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4078H

$IN:
C4078:	JP	J4181

        DEFS	04080H-$,0

; DOS2: RAMDISK driver jumpentries

C4080:	JP	R_DSKIO			; RAMDISK: DSKIO routine
C4083:	JP	R_DSKCHG		; RAMDISK: DSKCHG routine
C4086:	JP	R_GETDPB		; RAMDISK: GETDPB routine
C4089:	JP	R_CHOICE		; RAMDISK: CHOICE routine
C408C:	JP	R_DSKFMT		; RAMDISK: DSKFMT routine

        DEFS	0408FH-$,0

;	  Subroutine CP/M BIOS CONOUT entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	408FH

$OUT:
C408F:	JP	J4186

        DEFS	040FFH-$,0

D40FF:	DEFB	0			; present bank number register

; The following routines call a routine in ROM bank 1
; the routine called depends from the call adress
; for example C4100 calls C4100 on bank 1, so add 00h to the caller

;	  Subroutine check and invoke preferred memory mapper (6 or more segments)
;	     Inputs  A = current slot id page 2
;	     Outputs ________________________

C4100:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine install disk system routines
;	     Inputs  ________________________
;	     Outputs ________________________

C4103:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine copy message to buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C4106:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine copy errorstring to buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C4109:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine EXTBIO handler memory mapper
;	     Inputs  ________________________
;	     Outputs ________________________

C410C:	CALL	C410F			; call subroutine in ROM bank 1 and quit

;	  Subroutine call subroutine in ROM bank 1 and quit
;	     Inputs  ________________________
;	     Outputs ________________________

C410F:	POP	IX			; return address
	PUSH	BC			; store
	LD	BC,-3			; offset adjust
	EX	AF,AF'
	LD	A,1			; bank = 1
	ADD	IX,BC
	POP	BC			; restore
	JP	J405B			; invoke routine in bank

        IF ROMVER LE 2

I411E:	DEFB	"MSX-DOS kernel version 2.30"
        DEFB	0

I413A:	DEFB	"Disk BASIC version 2.01"
        DEFB	0
        DEFB	"Copyright (C) 1990 ASCII Corporation"
        DEFB	0

        ELSE

I411E:	DEFB	"MSX-DOS kernel version 2.31"
        DEFB	0

I413A:	DEFB	"Disk BASIC version 2.01"
        DEFB	0
        DEFB	"Copyright (C) 1991 ASCII Corporation"
        DEFB	0

        ENDIF

?4177: 

; look like a MMDD string

	IF ROMVER EQ 1

        DEFB	"0912"
        DEFB	0

	ENDIF

	IF ROMVER EQ 2

        DEFB	"1205"
        DEFB	0

	ENDIF

	IF ROMVER EQ 3

        DEFB	"0618"
        DEFB	0

	ENDIF

J417C:	LD	HL,0086H		; CP/M BIOS CONST entry in BDOS code segment
        JR	J418A

J4181:	LD	HL,0080H		; CP/M BIOS CONIN entry in BDOS code segment
        JR	J418A

J4186:	LD	C,A
        LD	HL,0083H		; CP/M BIOS CONOUT entry in BDOS code segment
J418A:	JP	GO_BIO			; invoke routine in BDOS code segment

        DEFS	041EFH-$,201

;	  Subroutine MSXDOS1 BDOS 00CH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	41EFH

CPMVER:
C41EF:	LD	C,00CH
        JP	J4F7C

        DEFS	0436CH-$,201

;	  Subroutine MSXDOS1 BDOS 013H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	436CH

DELETE:
C436C:	LD	C,013H
        JP	J4F7C

        DEFS	04392H-$,201

;	  Subroutine MSXDOS1 BDOS 017H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4392H

RENAME:
C4392:	LD	C,017H
        JP	J4F7C

        DEFS	04462H-$,201

;	  Subroutine MSXDOS1 BDOS 00FH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4462H

OPEN:
C4462:	LD	C,00FH
        JP	J4F7C

        DEFS	0456FH-$,201

;	  Subroutine MSXDOS1 BDOS 010H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	456FH

CLOSE:
C456F:	LD	C,010H
        JP	J4F7C

        DEFS	0461DH-$,201

;	  Subroutine MSXDOS1 BDOS 016H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	461DH

CREATE:
C461D:	LD	C,016H
        JP	J4F7C

        DEFS	046BAH-$,201

;	  Subroutine MSXDOS1 BDOS 02FH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	46BAH

ABSREA:
C46BA:	LD	C,02FH
        JP	J4F7C

        DEFS	04720H-$,201

;	  Subroutine MSXDOS1 BDOS 030H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4720H

ABSWRI:
C4720:	LD	C,030H
        JP	J4F7C

        DEFS	04775H-$,201

;	  Subroutine MSXDOS1 BDOS 014H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4775H

SEQRD:
C4775:	LD	C,014H
        JP	J4F7C

        DEFS	0477DH-$,201

;	  Subroutine MSXDOS1 BDOS 015H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	477DH

SEQWRT:
C477D:	LD	C,015H
        JP	J4F7C

        DEFS	04788H-$,201

;	  Subroutine MSXDOS1 BDOS 021H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4788H

RNDRD:
C4788:	LD	C,021H
        JP	J4F7C

        DEFS	04793H-$,201

;	  Subroutine MSXDOS1 BDOS 022H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4793H

RNDWRT:
C4793:	LD	C,022H
        JP	J4F7C

        DEFS	047B2H-$,201

;	  Subroutine MSXDOS1 BDOS 027H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	47B2H

BLKRD:
C47B2:	LD	C,027H
        JP	J4F7C

        DEFS	047BEH-$,201

;	  Subroutine MSXDOS1 BDOS 026H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	47BEH

BLKWRT:
C47BE:	LD	C,026H
        JP	J4F7C

        DEFS	047D1H-$,201

;	  Subroutine MSXDOS1 BDOS 028H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	47D1H

ZWRITE:
C47D1:	LD	C,028H
        JP	J4F7C
;
; SPACE 047D6H - 04FB7 USED OTHERWISE IN DOS1 ROM
;

J47D6:	CALL	INIHRD			; driver: initialize hardware
	DI
	LD	A,(IDBYT2)
	OR	A			; MSX1 ?
	RET	Z			; yep, quit
	LD	A,(DEVICE)		; disk interface count
	OR	A			; set flags

	IF	TURBOR
	JP	M,J481A			; disk system initialization canceled, select R800 DRAM when DOS1 key was not pressed and quit
	ELSE
	RET	M			; disk system initialization canceled, quit
	ENDIF

	JP	NZ,J4873		; not the first disk interface, skip
	LD	HL,HOKVLD
	BIT	0,(HL)			; extended BIOS initialized ?
	JR	NZ,J47FC		; yep, skip
	SET	0,(HL)
	LD	HL,EXTBIO
	LD	B,3*5
J47F7:	LD	(HL),0C9H
	INC	HL
	DJNZ	J47F7			; initialize EXTBIO, DISINT and ENAINT
J47FC:	LD	HL,(BOTTOM)
	LD	DE,BOT16K+1
	RST	DCOMPR			; at least 16KB RAM ?
	JR	NC,J481A		; nope, cancel disk system initialization and quit
	LD	HL,(HIMEM)
	LD	DE,VARWRK
	RST	DCOMPR			; memory allocated below VARWRK ?
	JR	NZ,J481A		; yep, cancel disk system initialization and quit
	LD	A,6			; row = 6
	CALL	SNSMAT			; read keyboard row
	DI
	RRCA				; SHIFT key pressed ?
	JR	C,J482B			; nope, continue
	LD	A,7
	RST	OUTDO			; beep
J481A:	LD	A,0FFH
	LD	(DEVICE),A		; disk system initialization canceled

        IF	TURBOR EQ 1
	XOR	A			; row = 0
	CALL	SNSMAT			; read keyboard row
	BIT	1,A			; 1 key pressed ?
	LD	A,82H			; change CPU led, CPU mode = R800 DRAM
	CALL	NZ,CHGCPU		; nope, change CPU mode
	ENDIF

	RET

J482B:	CALL	C4938			; select system memory mapper with at least 6 segments
	RET	C			; error, quit
	LD	HL,VARWRK-DATABA	; number of bytes = size of static work area
	CALL	C5604			; allocate memory (static work area disk system)
	RET	C			; error, quit
	LD	BC,VARWRK-DATABA
J4839:	XOR	A
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J4839		; clear static workarea disk system
	LD	(AUTLIN),BC		; biggest sector size sofar = 0
	LD	B,4*2+4*3
	LD	HL,DRVTBL
J484A:	LD	(HL),A
	INC	HL
	DJNZ	J484A			; clear DRVTBL, HOOKSA
	LD	HL,HOOKBE
	LD	B,69H
J4853:	LD	(HL),0C9H
	INC	HL
	DJNZ	J4853			; initialize DOS1 disk system hooks
	LD	HL,RSLREG
	LD	(HL),0DBH
	INC	HL
	LD	(HL),0A8H
	INC	HL
	LD	(HL),0C9H		; initialize disk system read primairy slot register routine
	LD	A,6			; row = 6
	CALL	SNSMAT			; read keyboard row
	DI
	AND	02H			; CTRL key status
	LD	(TARGET),A		; save for later (phantom mode)
	LD	A,7
	RST	OUTDO			; beep
	JR	J487E			; continue init
;
; other disk system rom has already started disk system init
;
J4873:	LD	A,(DOS_VER)
	CP	23H			; other disk system at least version 2.3x ?
	JR	NC,J4896		; yep, leave init at other disk system
	CALL	C4938			; select system memory mapper with at least 6 segments
	RET	C			; error, quit
;
; I am doing the disk system init
;
J487E:	LD	A,23H
	LD	(DOS_VER),A		; disk system 2.3x is doing the init
	CALL	C402D			; get my slotid
	LD	HL,H.RUNC
	LD	(HL),0F7H
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),LOW J4969
	INC	HL
	LD	(HL),HIGH J4969
	INC	HL
	LD	(HL),0C9H		; hook H.RUNC for further disk system init
;
; intialize for drives supported by this disk interface
;
J4896:	CALL	C4914			; check DRVTBL
	RET	Z			; no entries or drives left, quit
	LD	HL,MYSIZE		; size of the driver workarea
	CALL	C5604			; allocate memory (driver workarea)
	JR	C,J490C			; out of memory, update disk interface count for standalone DOS2
	EX	DE,HL
	CALL	C4DE3			; get SLTWRK entry
	LD	(HL),E
	INC	HL
	LD	(HL),D			; register driver workarea
	LD	HL,(AUTLIN)
	LD	DE,SECLEN		; biggest sector size driver
	RST	DCOMPR			; sector size driver bigger then sofar ?
	JR	NC,J48B6
	LD	(AUTLIN),DE		; yep, update biggest sector size sofar
J48B6:	CALL	C4914			; check DRVTBL
	LD	HL,DRVTBL
	LD	D,0
	ADD	HL,DE
	ADD	HL,DE
	EX	DE,HL			; free DRVTBL entry
	LD	A,(TARGET)
	OR	A			; phantom drive flag
	LD	A,C			; total drives sofar
	CALL	DRIVES			; driver: get number of drives
	ADD	A,L			; update total drives
	CP	8+1			; total more as 8 drives ?
	JR	C,J48D0			; nope, continue
	LD	A,8
J48D0:	SUB	C			; as much drives as possible
	JR	Z,J490C			; no drives from this interface,
	LD	(DE),A			; register drives in DRVTBL 
	INC	DE
	CALL	C402D			; get my slotid
	LD	(DE),A			; register slotid in DRVTBL
	LD	B,0
	LD	HL,$DPBLI
	ADD	HL,BC
	ADD	HL,BC			; DPB entry
	PUSH	HL			; store pointer to $DPBLI entry
	DEC	DE
	LD	A,(DE)			; number of drives
	PUSH	AF			; store number of drives
	LD	C,A
	ADD	A,A
	ADD	A,A
	ADD	A,C
	ADD	A,A
	ADD	A,A
	ADD	A,C			; *21
	LD	L,A
	LD	H,B			; number of bytes = number of drives *21
	CALL	C4C78			; allocate memory (DPBs)
	EX	DE,HL
	POP	AF			; restore number of drives
	POP	HL			; restore pointer to $DPBLI entry
J48F3:	LD	(HL),E
	INC	HL
	LD	(HL),D			; register DPB area in table
	INC	HL
	PUSH	HL			; store pointer to $DPBLI entry
	LD	HL,DEFDPB
	LD	BC,21
	LDIR				; initialize DPB with driver default
	POP	HL			; restore pointer to $DPBLI entry
	DEC	A			; done all drives ?
	JR	NZ,J48F3		; nope, next drive
	CALL	INIENV			; driver: initialize workarea
	LD	HL,DEVICE
	INC	(HL)			; update disk interface count
	RET

; set number of disk interfaces to 1 if this is the first disk interface but memory allocation for disk driver fails or number of drives = 0
; by doing this, this disk interface can still work as a (standalone) DOS2

J490C:	LD	HL,DEVICE
	INC	(HL)
	DEC	(HL)			; disk interface count >= 1 ?
	RET	NZ			; yep, quit
	INC	(HL)			; interface count = 1
	RET

;	  Subroutine check DRVTBL
;	     Inputs  ________________________
;	     Outputs ________________________

C4914:	LD	HL,DRVTBL
	LD	B,4
	XOR	A			; total drives = 0
	LD	E,A			; entry 0
J491B:	LD	C,A
	ADD	A,(HL)			; update total drives
	JR	C,J4935			; should not happen (DRVTBL corrupt), out of memory message and halt system
	CP	C			; empty entry (drives = 0) ?
	JR	Z,J4929			; yep,
	INC	E
	INC	HL
	INC	HL			; next entry
	DJNZ	J491B			; next disk interface
	CP	A			; Zx set, Cx reset
	RET

J4929:	ADD	A,(HL)
	CP	C			; empty entry (drives = 0) ?
	JR	NZ,J4935		; nope, should not happen (DRVTBL corrupt), out of memory message and halt system
	INC	HL
	INC	HL			; next entry
	DJNZ	J4929			; next disk interface
	CP	8			; maximum number of drives ?
	RET	Z			; yep, quit with Zx set, Cx reset
	RET	C			; nope, quit with Zx reset, Cx set
J4935:	JP	J4C7C			; out of memory message and halt system

;	  Subroutine select system memory mapper with at least 6 segments
;	     Inputs  ________________________
;	     Outputs ________________________

;       This is what the stack looks like at entry:
;
;       prim    exp
;       +0      +0      return address C4938 caller
;       +2      +2      CALLF BIOS registers
;       +6      +14     return address CALLF caller

C4938:	CALL	C4E3A			; get current slotid page 2
	CALL	C4100			; check and invoke preferred memory mapper (6 or more segments)
	RET	C			; error, quit
	LD	HL,5			; offset stored primairy slot register (before CALLF)
	ADD	HL,SP
	IN	A,(0A8H)
	RRD
	LD	(HL),A			; update primairy slot page 3 and 2 on stack (otherwise memory mapper slot change will be rolled back)
	CALL	C4E2D			; get slotid page 1 (slot id of this disk ROM)
	BIT	7,A			; in secundairy slot ?
	RET	Z			; nope, quit
	LD	HL,12			; offset stored secundairy slot register (before CALLF)
	ADD	HL,SP
	LD	C,A			; store slot id
	CALL	C4E49			; get slotid page 3 (slot id of system memory mapper)
	XOR	C
	AND	03H			; this disk ROM in the same primairy slot as system memory mapper ?
	JR	NZ,J4962		; nope, skip update on secundairy slot
	LD	A,(LFFFF)
	CPL
	RRD
	LD	(HL),A			; update secundairy slot page 3 and 2 on stack (otherwise memory mapper change will be rolled back)
J4962:	DEC	HL
	IN	A,(0A8H)
	RRD
	LD	(HL),A			; update primairy slot page 3 and 2 on stack (otherwise memory mapper slot change will be rolled back)
	RET

;	  Subroutine H.RUNC handler
;	     Inputs  -
;	     Outputs -
;         Remark     Control is passed to this routine when the BASIC interpreter is initialized
;                    There are two ways: a BASIC program in ROM is started OR at the start of MSX-BASIC

J4969:	LD	HL,H.RUNC
	LD	B,5
J496E:	LD	(HL),0C9H
	INC	HL
	DJNZ	J496E			; clear H.RUNC
	LD	HL,DEVICE
	LD	A,(HL)			; disk interface count
	LD	(HL),B			; clear DEVICE
	OR	A			; set flags
	RET	M			; disk system initialization canceled, quit
	LD	D,A			; save disk interface count
	CALL	C4914			; check DRVTBL
	LD	($NUMDR),A		; register total number of drives
	LD	A,D
	SUB	E			; number of used DRVTBL entries same as disk interface count ?
	JR	Z,J4994			; yep, continue
	DEC	A			; 1 extra (standalone DOS2) ?
	JP	NZ,J4C7C		; nope (DRVTBL corrupted?), out of memory message and halt system
	LD	DE,HOOKSA+0
	LD	HL,HOOKSA+3
	LD	BC,4*3			; BUG: should be 3*3
	LDIR				; remove entry from HOOKSA
J4994:	CALL	C402D			; get my slotid
	LD	(MASTER),A		; DOS kernel ROM slot id
	LD	HL,CHAR_16
	LD	DE,KANJTA
	LD	BC,4
	LDIR				; initialize double byte header character table
	LD	A,(IDBYT0)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	07H
	LD	(COUNTR),A		; store data format
	LD	HL,AUXBOD
	LD	(HL),3EH
	INC	HL
	LD	(HL),1AH
	INC	HL
	LD	B,2*5-2
J49BC:	LD	(HL),0C9H
	INC	HL
	DJNZ	J49BC			; initialize AUX device hooks
	LD	A,0CDH
	LD	HL,$DOSON		; enable DOS kernel
	LD	(PRTBUF+0),A
	LD	(PRTBUF+1),HL
	LD	A,0C3H
	LD	HL,J53AC
	LD	(PRTBUF+3),A
	LD	(PRTBUF+4),HL		; initialize print string routine
	LD	HL,C4109
	LD	($ERR_M),HL		; address copy errorstring to buffer routine
	LD	HL,I4D5A
	LD	($PROMP),HL		; address prompt routine
	LD	HL,I6AD8
	LD	($BDOS),HL		; address BDOS handler
	LD	HL,J6ADC
	LD	($DOS1),HL		; address DiskBASIC BDOS handler
	LD	A,0FFH
	LD	(TIMFLG),A		; clockchip detected
	LD	HL,21			; number of bytes = size of DPB
	CALL	C4C78			; allocate memory (DPB for ramdisk)
	LD	(RM_DPB),HL		; save DPB ramdisk
	LD	HL,(AUTLIN)
	LD	DE,512
	RST	DCOMPR			; biggest sector size at least 512 bytes ?
	JR	NC,J4A07
	EX	DE,HL			; nope, use 512 bytes
J4A07:	LD	($MAXSEC),HL		; save biggest sector size
	INC	HL			; 1 extra for FAT valid flag
	CALL	C4C78			; allocate memory (sector buffer and FAT flag)
	LD	(HL),0			; FAT buffer flag = clean
	INC	HL
	LD	($SECBUF),HL		; sector buffer
	LD	HL,RM_DPB
	LD	BC,256*(8+1)+0FFH	; drive count = 9 (RAMDISK + 8 drives), drive id = -1 (RAMDISK)
J4A1A:	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; pointer to DPB
	INC	HL
	LD	A,E
	OR	D			; DPB used ?
	JR	Z,J4A32			; nope, next entry
	EX	DE,HL
	LD	(HL),C			; set drive id in DPB
	PUSH	BC			; store drive counter, drive id
	LD	BC,19
	ADD	HL,BC
	LD	BC,($SECBUF)
	LD	(HL),C
	INC	HL
	LD	(HL),B			; set pointer to FAT to sector buffer (some sort of compatibility)
	POP	BC			; restore drive counter, drive id
	EX	DE,HL
J4A32:	INC	C			; update drive id
	DJNZ	J4A1A			; next DPB
	CALL	C4E3A			; get current slotid page 2
	CALL	C4103			; install disk system routines
	JP	C,J4C7C			; error, out of memory message and halt system
	LD	HL,100+64+100+64	; size of BDOS buffers
	CALL	C4C78			; allocate memory (buffers)
	LD	(BUF_1),HL		; buffer for transfering BDOS structures
	LD	DE,100
	ADD	HL,DE
	LD	(BUF_2),HL		; buffer for transfering BDOS FIB
	LD	DE,64
	ADD	HL,DE
	LD	(BUF_3),HL		; buffer for transfering BDOS FIB or Path
	LD	DE,100
	ADD	HL,DE
	LD	(ERR_BUF),HL		; buffer for transfering BDOS errorstring
	LD	HL,(HIMEM)
	LD	(HIMSAV),HL		; register highest memory used by basic disk system
	LD	HL,H.TIMI
	PUSH	HL
	LD	DE,TIMI_S
	LD	BC,5
	LDIR				; save current H.TIMI handler
	POP	HL
	LD	DE,C4049
	CALL	C4C9B			; install H.TIMI handler
	LD	HL,EXTBIO
	LD	DE,FCALSA
	LD	BC,5
	PUSH	HL
	LDIR				; save current EXTBIO handler
	POP	HL
	LD	DE,C4043
	CALL	C4C9B			; install EXTBIO handler
	CALL	C56A5			; setup hooks for disk system handlers
	LD	HL,M7D2F+1
	LD	A,(EXPTBL+0)
	CALL	RDSLT
	PUSH	AF
	INC	SP
	DEC	HL
	LD	A,(EXPTBL+0)
	CALL	RDSLT
	PUSH	AF
	INC	SP
	POP	IX			; get address of BASIC screen init
	LD	IY,(EXPTBL+0-1)
	CALL	CALSLT			; execute BASIC SCREEN INIT
	CALL	C4C8E			; setup H.LOPD if H.CLEA is hooked
	LD	SP,TMPSTK		; switch to temporary stack

	IF	DOS1 EQ 1
	CALL	C518D			; invoke DOS1 kernel if DOS1 key pressed
	ENDIF

	LD	A,(H.STKE+0)
	CP	0C9H			; H.STKE setup for interception (by ROM) ?
	LD	IX,M7D17
	JR	NZ,J4AD1		; yep, initialize and start DiskBASIC (allow interception by ROM)
	LD	A,(BASROM)
	OR	A			; about to start BASIC program in ROM ?
	LD	IX,M7DE9
	JR	NZ,J4AD1		; yep,  initialize and start DiskBASIC (starts BASIC program in ROM)
	CALL	C4C3E			; disable MSXDOS page 1 support

	IF	DOS1 EQ 1
	LD	A,(RAMAD3)
	LD	(RAMAD2),A		; RAM slotid page 2 = slotid RAM memory mapper
	ENDIF

	JR	J4ADA

J4AD1:
	IF	DOS1 EQ 1
	CALL	C519A			; invoke DOS1 kernel if DEFUSR0 is defined
	ENDIF

	CALL	C4C10			; initialize DiskBASIC
	JP	CALBAS			; start DiskBASIC

J4ADA:	LD	HL,J4B43
	PUSH	HL			; start DiskBASIC when returned

        IF ROMVER GE 3
	LD	A,(BOOT_D)
	OR	A			; bootdrive specified by driver ?
	JR	NZ,J4AF6		; yep, start MSX-DOS2 from specified drive
	ENDIF

	CALL	C6952			; try to load bootsector from any drive
	RET	Z			; no valid bootdrive, quit to DiskBASIC

	IF	DOS1 EQ 1
	CALL	C51A9			; if disk has no volid, invoke DOS1 kernel. Otherwise start bootloader with Cx reset
	ELSE
	CALL	J4B23			; start bootloader with Cx reset
	ENDIF

	LD	HL,(BOTTOM)
	LD	DE,BOT32K
	RST	DCOMPR			; at least 32 KB RAM ?
	RET	NZ			; nope, quit to DiskBASIC
	LD	A,(CUR_DRV)		; start MSX-DOS2 from default drive

J4AF6:	LD	HL,I4B40		; empty commandline
	JR	J4AFE			; start MSX-DOS2

J4AFB:	LD	A,(BOOT_D)		; bootdrive
J4AFE:	LD	SP,TMPSTK		; switch to temporary stack
	PUSH	HL
	LD	HL,J4B43
	EX	(SP),HL			; start DiskBASIC when returned
	PUSH	AF
	LD	A,0FFH
	LD	(DOSFLG),A		; MSXDOS was started
	POP	AF

	IF (ROMVER EQ 0) OR (ROMVER GE 3)
	CALL	C68BB			; prepare for DOS, try to load and start MSXDOS2.SYS
	ELSE
	JP	J5254			; prepare for DOS, try to load and start MSXDOS2.SYS patched
J4B0A:
	ENDIF

        IF ROMVER GE 3
	LD	A,(NOTFIR)
	OR	A			; first start of DiskBASIC ?
	RET	NZ			; nope, abort DOS1 start, start DiskBASIC
	ENDIF

	CALL	C6952			; try to load bootsector from any drive
	RET	Z			; no valid bootdrive, start DiskBASIC

	IF	DOS1 EQ 1
	CALL	C5243			; check if disk has a volumeid
	RET	NZ			; nope, start DiskBASIC
	ENDIF

	LD	A,0C3H			; JP = enable
	CALL	C4C40			; update MSXDOS page 1 support
	SCF				; start bootloader with Cx set (MSXDOS disk system)

;	  Subroutine start bootloader
;	     Inputs  Cx = bootflag (Cx reset = start basic disk system, Cx set = start MSXDOS disk system)
;	     Outputs ________________________

J4B23:	LD	HL,DISKVE		; address DOS1 disk error handler
	LD	DE,$DOSON		; enable DOS kernel
	LD	A,(NOTFIR)		; DiskBASIC first start flag
	JP	BOT16K+01EH		; start bootloader

I4B2F:	DEFB	'RUN"\AUTOEXEC.BAS'

I4B40:	DEFB	0

S4B2F	EQU	$-I4B2F

; pointer to DOS1 disk error handler

I4B41:	DEFW	J4BA3

;	  Subroutine start DiskBASIC
;	     Inputs  ________________________
;	     Outputs ________________________

J4B43:	LD	SP,TMPSTK		; switch to temporary stack (force page 3 stack)
	CALL	C4C3E			; disable MSXDOS page 1 support
	LD	HL,I4B2F
	LD	DE,TMPBUF+2
	LD	BC,S4B2F
	LDIR				; prepare RUN command in temporary buffer
	LD	HL,NOTFIR
	LD	A,(HL)
	OR	A			; first start of DiskBASIC ?
	LD	(HL),H			; not anymore
	JR	NZ,J4B78		; nope,
	LD	(DOSFLG),A		; MSXDOS not started yet
	LD	HL,I4B41
	LD	(DISKVE),HL		; register DOS1 disk error handler
	LD	DE,TMPBUF+2+4		; \AUTOEXEC.BAS
	LD	A,1			; no write
	LD	C,43H			; Open file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	NZ,J4BA3		; error, just start BASIC
	LD	C,45H			; Close file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	J4BA7			; start BASIC with running AUTOEXEC.BAS

J4B78:	LD	A,(WBOOT)
	CP	0C3H			; start DiskBASIC from MSXDOS ?
	JR	NZ,J4BA3		; nope, just start BASIC
	LD	HL,DBUF
	LD	B,(HL)
	INC	B
	DEC	B			; commandline argument (BASIC filename) specified ?
	JR	Z,J4BA3			; nope, just start BASIC
J4B87:	INC	HL
	LD	A,(HL)
	CALL	C4B92			; is space character ?
	JR	NZ,J4B98		; nope, copy BASIC filename
	DJNZ	J4B87
	JR	J4BA3			; just start BASIC

;	  Subroutine is space character ?
;	     Inputs  ________________________
;	     Outputs ________________________

C4B92:	CP	9
	RET	Z
	CP	" "
	RET

J4B98:	XOR	A
	LD	C,B
	LD	B,A			; size
	LD	DE,TMPBUF+2+4
	LDIR				; copy BASIC file
	LD	(DE),A			; end of line
	JR	J4BA7			; start BASIC with RUN file

;	  Subroutine DOS1 disk error handler
;	     Inputs  ________________________
;	     Outputs ________________________

J4BA3:	XOR	A
	LD	(TMPBUF+2+3),A		; BASIC command is just RUN

J4BA7:	LD	SP,TMPSTK		; switch to temporary stack (force page 3 stack)
	LD	A,(RAMAD2)
	LD	H,HIGH 08000H
	CALL	ENASLT			; enable RAM in page 2
	LD	A,(EXPTBL+0)
	LD	H,HIGH 00000H
	CALL	ENASLT			; enable BIOS in page 0
	CALL	C4C10			; initialize DiskBASIC
J4BBD:	LD	BC,0*256+061H		; Rejoin parent process
	CALL	BDOS			; DiskBASIC BDOS call
	JR	NZ,J4BBD		; error, try again
	LD	HL,(BOTTOM)
	XOR	A
	LD	(HL),A			; first byte of BASIC program area must be an end of line marker
	INC	HL
	LD	(TXTTAB),HL		; start of BASIC program area
	LD	(HL),A
	INC	HL
	LD	(HL),A			; end of program marker
	INC	HL
	LD	(VARTAB),HL		; start of BASIC variable area
	LD	HL,0FFFFH
	LD	(CURLIN),HL		; BASIC is not executing a program (direct mode)
	LD	SP,(STKTOP)		; initialize stack for BASIC
	LD	A,0FFH
	LD	(CNSDFG),A		; enable function key display
	LD	IX,M7D31
	CALL	CALBAS			; continue initializing BASIC screen
	CALL	C4D89			; print newline
	LD	DE,I413A		; DiskBASIC version string
	CALL	C4DA5			; print string
	CALL	C4D89			; print newline
	LD	HL,NTSTOP
	PUSH	HL			; execute BASIC statement
	LD	HL,TMPBUF+2-1
	PUSH	HL			; BASIC text pointer to prepared RUN statement
	LD	HL,TMPBUF
	PUSH	HL			; setup 'subroutine'
	LD	(HL),0E1H		; POP HL
	INC	HL
	LD	(HL),0C9H		; RET
	LD	A,(EXPTBL+0)
	LD	H,HIGH 04000H
	JP	ENASLT			; BASIC ROM on page 1 and start setup routine

;	  Subroutine initialize DiskBASIC
;	     Inputs  ________________________
;	     Outputs ________________________

C4C10:	LD	HL,(HIMSAV)
	LD	(HIMEM),HL		; top of BASIC = bottom of basic disk system
	CALL	C6A5C			; select TPA segments
	LD	HL,I6563
	LD	(DISKVE),HL		; register DOS1 disk error handler
	LD	HL,I6568
	LD	(BREAKV),HL		; register DOS1 abort handler
	LD	BC,($MAXSEC)		; biggests sectorsize
	CALL	C4C68			; allocate memory (HIMEM only)
	LD	($DIRBUF),HL		; register BASIC sector buffer (DOS1 compatibility)
	LD	(PATHNAM),HL		; register BASIC path buffer
	LD	BC,S4C4A		; size BLOAD/BSAVE code
	CALL	C4C68			; allocate memory (HIMEM only)
	CALL	C4C4A			; setup BLOAD/BSAVE code
	CALL	C565C			; intialize BASIC stack and i/o channels

;	  Subroutine disable MSXDOS page 1 support
;	     Inputs  ________________________
;	     Outputs ________________________

C4C3E:	LD	A,0C9H			; RET = disable

;	  Subroutine update MSXDOS page 1 support
;	     Inputs  ________________________
;	     Outputs ________________________

C4C40:	LD	($DOSON+0),A
	LD	($DOSOF+0),A
	LD	(XFER+0),A
	RET

;	  Subroutine setup BLOAD/BSAVE code
;	     Inputs  ________________________
;	     Outputs ________________________

C4C4A:	LD	(BLDCHK),HL		; register BLOAD code start
	EX	DE,HL
	LD	HL,I4CB8
	LDIR				; install BLOAD/SAVE code
	LD	HL,-S4CC0
	ADD	HL,DE			; size BSAVE code
	LD	(BSVCHK),HL		; register BSAVE code start
	LD	A,(MASTER)		; DOS kernel ROM slot id
	LD	HL,-12
	ADD	HL,DE
	LD	(HL),A			; DOS kernel ROM slot id for BLOAD FCALL
	LD	HL,-4
	ADD	HL,DE
	LD	(HL),A			; DOS kernel ROM slot id for BSAVE FCALL
	RET

;	  Subroutine allocate memory (HIMEM only)
;	     Inputs  BC = number of bytes
;	     Outputs ________________________

C4C68:	LD	HL,(HIMEM)
	OR	A
	SBC	HL,BC
	LD	(HIMEM),HL		; update HIMEM
	JR	C,J4C7C			; out of memory, out of memory message and halt system
	LD	A,H
	CP	HIGH TMPSTK		; mimium DiskBASIC memory requirement met ?
	JR	J4C7B			; continue

;	  Subroutine allocate memory and halt system when insufficient
;	     Inputs  BC = number of bytes
;	     Outputs ________________________

C4C78:	CALL	C5604			; allocate memory

J4C7B:	RET	NC			; ok, quit

J4C7C:	LD	A,12			; clear screen
	CALL	C4DBF			; print character
	LD	A,1			; message = 1 (out of memory)
	LD	DE,BUF			; message buffer = temporary buffer
	CALL	C4106			; copy message to buffer
	CALL	C4DA5			; print string
	DI
	HALT				; halt system

;	  Subroutine setup H.LOPD if H.CLEA is hooked
;	     Inputs  ________________________
;	     Outputs ________________________

C4C8E:	LD	HL,H.CLEA+0
	LD	A,(HL)
	CP	0C9H			; H.CLEA has hook handler for intercept ?
	RET	Z			; nope, quit
	LD	HL,H.LOPD
	LD	DE,I4CAA		; yep, install H.LOPD handler to regain control after H.CLEA

;	  Subroutine install hook handler
;	     Inputs  HL = hook, DE = hook handler
;	     Outputs ________________________

C4C9B:	LD	(HL),0F7H
	INC	HL
	LD	A,(MASTER)		; DOS kernel ROM slot id
	LD	(HL),A
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),0C9H
	RET

;	  Subroutine H.LOPD handler (regain control after H.CLEA)
;	     Inputs  ________________________
;	     Outputs ________________________

I4CAA:	LD	A,0C9H
	LD	(H.LOPD+0),A		; remove H.LOPD handler
	LD	DE,(HIMEM)
	LD	(HIMSAV),DE		; register bottom of basic diskssystem
	RET

;	  Subroutine BLOAD code
;	     Inputs  ________________________
;	     Outputs ________________________

I4CB8:	RST	CALLF
	DEFB	0			; slotid, setup later
	DEFW	J5DB6			; BLOAD handler
	PUSH	HL
	JP	BLDFIN			; finish BLOAD

;	  Subroutine BSAVE
;	     Inputs  ________________________
;	     Outputs ________________________

I4CC0:	RST	CALLF
	DEFB	0			; slotid, setup later
	DEFW	J5CF2			; BSAVE handler
	RET

S4CC0	EQU	$-I4CC0
S4C4A	EQU	$-I4CB8

;	  Subroutine H.PHYD handler
;	     Inputs  ________________________
;	     Outputs ________________________

C4CC5:	EI
	PUSH	HL			; store transfer address
	PUSH	AF			; store Cx
	CALL	C4CE1			; determine disk interface
	JR	C,J4CD3			; found,
	SCF				; error
	LD	A,12			; error = other
	POP	HL			; discard drive id
	POP	HL			; restore transfer address
	RET

J4CD3:	LD	L,A			; store disk interface drive id
	POP	AF			; restore Cx
	LD	A,L			; restore disk interface drive id
	POP	HL			; restore transfer address
	PUSH	HL			; store transfer address
	LD	IX,C4010		; driver function = DSKIO
	CALL	GO_DRV			; call disk interface driver function with prompt handler
	POP	HL			; restore transfer address
	RET

;	  Subroutine determine disk interface
;	     Inputs  A = drive id
;	     Outputs ________________________

C4CE1:	PUSH	BC
	LD	(TARGET),A		; store drive id
	LD	HL,DRVTBL
	LD	B,4			; disk interface count = 4
J4CEA:	SUB	(HL)			; drive id handled by this interface ?
	JR	NC,J4CF5		; nope, next
	ADD	A,(HL)			; to interface drive id
	INC	HL
	LD	H,(HL)			; slot id
	PUSH	HL
	POP	IY			; IYH = slot id
	POP	BC
	RET

J4CF5:	INC	HL
	INC	HL
	DJNZ	J4CEA			; next disk interface
	POP	BC
	RET

;	  Subroutine stop motor of all floppy drives
;	     Inputs  ________________________
;	     Outputs ________________________

J4CFB:	LD	HL,DRVTBL
	LD	B,4			; disk interface count = 4
J4D00:	INC	HL
	LD	A,(HL)			; slot id disk interface
	PUSH	AF
	POP	IY			; IYH = slot id
	INC	HL
	PUSH	HL			; store pointer in DRVTBL
	PUSH	BC			; store disk interface count
	LD	HL,C401F		; function = MTOFF
	PUSH	HL
	POP	IX			; IX = MTOFF
	OR	A			; entry used ?
	CALL	NZ,RDSLT		; yep, read MTOFF entry
	OR	A			; disk interface has an MTOFF entry ?
	
	IF	DOS1 EQ 1
	CALL	NZ,GO_DRV		; yep, call disk interface driver function with prompt handler
	ELSE
	CALL	NZ,CALSLT		; call disk interface driver function
	ENDIF

	POP	BC
	POP	HL
	DJNZ	J4D00			; next entry
	RET

;	  Subroutine timer routine DOS2
;	     Inputs  ________________________
;	     Outputs ________________________

C4D1B:	PUSH	AF			; store VDP statusregister
	CALL	C6A9A			; invoke DOS2 interrupt handler
	CALL	C4D26			; invoke the interrupt handler of all disk interfaces
	POP	AF			; restore VDP statusregister
	JP	TIMI_S			; other interrupt handler (old H.TIMI)

;	  Subroutine invoke the interrupt handler of all disk interfaces
;	     Inputs  ________________________
;	     Outputs ________________________

C4D26:	LD	DE,DRVTBL
	LD	HL,HOOKSA
	LD	B,4			; disk interface count = 4
J4D2E:	LD	A,(DE)
	AND	A			; DRVTBL entry used ?
	RET	Z			; nope, end of table, quit
	INC	DE
	LD	A,(DE)			; slot id disk interface
	INC	DE
	CP	(HL)			; does disk interface has an interrupt handler ?
	JR	NZ,J4D4F		; nope, next disk interface
	LD	A,(MASTER)
	CP	(HL)			; DOS kernel ROM slot id ?
	LD	A,(HL)			; slot id
	PUSH	BC			; store disk interface count
	PUSH	DE			; store pointer in DRVTBL
	PUSH	HL			; store pointer in HOOKSA
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; address interrupt handler
	PUSH	AF
	POP	IY			; IYH = slot id
	PUSH	DE
	POP	IX			; IX = address interrupt handler
	CALL	C4D55			; invoke interrupt routine
	POP	HL			; restire pointer in HOOKSA
	POP	DE			; restore pointer in DRVTBL
	POP	BC			; restore disk interface count
J4D4F:	INC	HL
	INC	HL
	INC	HL
	DJNZ	J4D2E			; next disk interface
	RET

;	  Subroutine invoke interrupt routine
;	     Inputs  ________________________
;	     Outputs ________________________

C4D55:	JP	NZ,CALSLT		; not in master diskrom, use CALSLT
	JP	(IX)			; in master diskrom, call direct

;	  Subroutine prompt routine (phantom drives)
;	     Inputs  ________________________
;	     Outputs ________________________

PROMPT:
I4D5A:	LD	A,(TARGET)		; restore drive id
	ADD	A,"A"
	CALL	H.PROM			; prompt hook
	PUSH	AF
	CALL	C4D89			; print newline
	LD	A,7
	CALL	C4D96			; print message
	POP	AF
	CALL	C4DBF			; print character
	LD	A,8
	CALL	C4D96			; print message
	CALL	C4D89			; print newline
	LD	A,9
	CALL	C4D96			; print message
J4D7C:	CALL	C4D83			; get fresh key and check if CTRL-C
	JR	Z,J4D7C			; CTRL-C, try agan
	JR	C4D89			; print newline

;	  Subroutine get fresh key and check if CTRL-C
;	     Inputs  ________________________
;	     Outputs ________________________

C4D83:	CALL	C4DAE			; get fresh key
	CP	3
	RET

;	  Subroutine print newline
;	     Inputs  ________________________
;	     Outputs ________________________

C4D89:	PUSH	AF
	LD	A,13
	CALL	C4DBF			; print character
	LD	A,10
	CALL	C4DBF			; print character
	POP	AF
	RET

;	  Subroutine print message
;	     Inputs  ________________________
;	     Outputs ________________________

C4D96:	PUSH	HL
	PUSH	DE
	LD	DE,($SECBUF)
	CALL	C4106			; copy message to buffer
	CALL	C4DA5			; print string
	POP	DE
	POP	HL
	RET

;	  Subroutine print string
;	     Inputs  ________________________
;	     Outputs ________________________

C4DA5:	LD	A,(DE)
	INC	DE
	OR	A
	RET	Z
	CALL	C4DBF			; print character
	JR	C4DA5

;	  Subroutine get fresh key
;	     Inputs  ________________________
;	     Outputs ________________________

C4DAE:	PUSH	IX
	PUSH	HL
	LD	IX,KILBUF
	CALL	C4DCB			; clear keyboard buffer
	POP	HL
	LD	IX,CHGET
	JR	J4DC5			; get keyboard character

;	  Subroutine print character
;	     Inputs  ________________________
;	     Outputs ________________________

C4DBF:	PUSH	IX
	LD	IX,CHPUT
J4DC5:	CALL	C4DCB
	POP	IX
	RET

;	  Subroutine invoke BIOS routine
;	     Inputs  ________________________
;	     Outputs ________________________

C4DCB:	PUSH	IY
	LD	IY,(EXPTBL+0-1)		; slotid BIOS
	CALL	CALSLT			; invoke BIOS routine
	EI
	POP	IY
	RET

;	  Subroutine get driver workarea
;	     Inputs  ________________________
;	     Outputs HL = IX = driver workarea

GETWRK:
C4DD8:	CALL	C4DE3			; get SLTWRK entry
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; driver workarea
	PUSH	HL
	POP	IX
	RET

;	  Subroutine get SLTWRK entry
;	     Inputs  ________________________
;	     Outputs ________________________

C4DE3:	IN	A,(0A8H)
	AND	0CH
	RRCA
	RRCA
	LD	HL,EXPTBL
	CALL	C4E04
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	INC	A
	LD	C,A
	LD	A,(HL)
	ADD	A,A
	SBC	A,A
	AND	0CH
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	AND	(HL)
	OR	C
	ADD	A,A
	LD	HL,SLTWRK

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4E04:	LD	C,A
	LD	B,0
	ADD	HL,BC
	RET

;	  Subroutine register interrupt handler
;	     Inputs  HL = interrupt handler
;	     Outputs ________________________

SETINT:
C4E09:	EX	DE,HL
	CALL	C402D			; get my slotid
	PUSH	AF
	LD	A,(DEVICE)		; disk interface number
	LD	HL,HOOKSA
	CALL	C4E04
	ADD	HL,BC
	ADD	HL,BC			; HOOKSA entry
	POP	AF
	LD	(HL),A			; slotid disk interface
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; interrupt handler

;	  Subroutine previous interrupt handler
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible, but has no function anymore
;                    driver interrupt are handled differently by the master diskrom

PRVINT:
	RET

;	  Subroutine get slotid page 0
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     not used

?4E20:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	CALL	C4E60
	JR	Z,J4E5D
	RLCA
	RLCA
	JR	J4E58

;	  Subroutine get slotid page 1
;	     Inputs  ________________________
;	     Outputs ________________________

C4E2D:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	RRCA
	RRCA
	CALL	C4E60
	JR	Z,J4E5D
	JR	J4E58

;	  Subroutine get slotid page 2
;	     Inputs  ________________________
;	     Outputs ________________________

C4E3A:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	C4E60
	JR	Z,J4E5D
	JR	J4E56

;	  Subroutine get slotid page 3
;	     Inputs  ________________________
;	     Outputs ________________________

C4E49:	PUSH	HL
	PUSH	BC
	IN	A,(0A8H)
	RLCA
	RLCA
	CALL	C4E60
	JR	Z,J4E5D
	RRCA
	RRCA
J4E56:	RRCA
	RRCA
J4E58:	AND	0CH
	OR	80H
	OR	C
J4E5D:	POP	BC
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4E60:	AND	03H
	LD	C,A
	LD	B,0
	LD	HL,EXPTBL
	ADD	HL,BC
	BIT	7,(HL)
	RET	Z
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

DIV16:
C4E72:	LD	HL,0
	LD	A,17
J4E77:	RL	C
	RL	B
	DEC	A
	RET	Z
	ADC	HL,HL
	JR	NC,J4E86
	OR	A
	SBC	HL,DE
	JR	J4E77

J4E86:	SBC	HL,DE
	JR	NC,J4E8B
	ADD	HL,DE
J4E8B:	CCF
	JR	J4E77

;	  Subroutine H.FORM handler
;	     Inputs  ________________________
;	     Outputs ________________________

C4E8E:	OR	A			; use free BASIC memory as workarea

;	  Subroutine format disk
;	     Inputs  HL = start of workarea, BC = size of workarea
;	     Outputs ________________________

J4E8F:	EI
	JR	C,J4EA4			; workarea is specified, continue
	LD	HL,-256
	ADD	HL,SP			; leave 256 bytes of stackspace
	LD	DE,(STREND)		; end of BASIC variable area
	XOR	A
	SBC	HL,DE
	LD	C,L
	LD	B,H			; size of workarea = size of the free BASIC memory area
	EX	DE,HL			; start of workarea = start of the free BASIC memory area
	JR	NC,J4EA4		; there was room, continue
	LD	C,A
	LD	B,A			; no room, size of workarea = 0 (some drivers do not need a workarea, so lets try)
J4EA4:	PUSH	HL
	PUSH	BC
	LD	L,0
	LD	BC,8*256+067H		; 8 drives, Format a disk
J4EAB:	ADD	HL,HL
	PUSH	HL
	PUSH	BC
	XOR	A			; return choice string
	CALL	BDOS			; DiskBASIC BDOS call
	POP	BC
	POP	HL
	JR	NZ,J4EB7		; error, invalid drive for format
	INC	HL			; valid drive for format
J4EB7:	DJNZ	J4EAB			; next drive
	LD	A,L
	OR	A			; any drives valid for format ?
	JP	Z,J4F6F			; nope,
	DEC	A
	AND	L
	LD	A,L
	JR	Z,J4F06			; only 1 drive, skip drive selection
	PUSH	HL
	LD	A,2
	CALL	C4D96			; print message
	POP	HL
	PUSH	HL
	LD	A,"A"-1
J4ECD:	INC	A
	SRL	L
	JR	NC,J4EDC
	CALL	C4DBF			; print character
	PUSH	AF
	LD	A,","
	CALL	NZ,C4DBF		; print character
	POP	AF
J4EDC:	JR	NZ,J4ECD
	LD	A,3
	CALL	C4D96			; print message
	POP	HL
J4EE4:	CALL	C4D83			; get fresh key and check if CTRL-C
	JP	Z,J4F6F			; CTRL-C,
	AND	0DFH			; to upper
	LD	C,A
	SUB	"A"
	CP	8
	JR	NC,J4EE4
	LD	B,A
	INC	B
	XOR	A
	SCF
J4EF7:	RLA
	DJNZ	J4EF7
	AND	L
	JR	Z,J4EE4
	PUSH	AF
	LD	A,C
	CALL	C4DBF			; print character
	CALL	C4D89			; print newline
	POP	AF
J4F06:	INC	B
	RRCA
	JR	NC,J4F06
	LD	C,67H			; Format a disk
	PUSH	BC
	XOR	A			; return choice string
	CALL	BDOS			; DiskBASIC BDOS call
	LD	A,L
	OR	H			; does the drive have a choice string ?
	JR	Z,J4F44			; nope, skip choice selection
	LD	A,B
J4F16:	PUSH	AF
	CALL	RDSLT
	OR	A
	JR	Z,J4F24
	CALL	C4DBF			; print character
	POP	AF
	INC	HL
	JR	J4F16

J4F24:	POP	AF
	LD	A,"?"
	CALL	C4DBF			; print character
	LD	A," "
	CALL	C4DBF			; print character
J4F2F:	CALL	C4D83			; get fresh key and check if CTRL-C
	JR	Z,J4F6E			; CTRL-C,
	SUB	"1"
	CP	8+1			; valid choice ?
	JR	NC,J4F2F		; nope, ask again
	ADD	A,"1"
	CALL	C4DBF			; print character
	CALL	C4D89			; print newline
	SUB	"1"
J4F44:	INC	A
	PUSH	AF
	LD	A,4
	CALL	C4D96			; print message
	CALL	C4D83			; get fresh key and check if CTRL-C
	JR	Z,J4F6D			; CTRL-C,
	CALL	C4D89			; print newline
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J4F69			; no error,
	LD	B,A
	LD	DE,($SECBUF)
	LD	C,66H			; Explain error code
	CALL	BDOS			; DiskBASIC BDOS call
	JP	C4DA5			; print string

J4F69:	LD	A,6
	JR	J4F76

J4F6D:	POP	AF
J4F6E:	POP	AF
J4F6F:	POP	AF
	POP	AF
	CALL	C4D89			; print newline
	LD	A,5
J4F76:	CALL	C4D96			; print message
	JP	C4D89			; print newline

J4F7C:	XOR	A
	LD	(CPMCAL),A		; not a CP/M call (MSXDOS1)
	JP	J6ADC			; DiskBASIC BDOS handler


        DEFS	04FB8H-$,201

;	  Subroutine MSXDOS1 BDOS 011H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	4FB8H

SRCHFR:
C4FB8:	LD	C,011H
        JP	J4F7C

        DEFS	05006H-$,201

;	  Subroutine MSXDOS1 BDOS 012H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5006H

SRCHNX:
C5006:	LD	C,012H
        JP	J4F7C

        DEFS	0501EH-$,201

;	  Subroutine MSXDOS1 BDOS 023H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	501EH

FILESI:
C501E:	LD	C,023H
        JP	J4F7C

        DEFS	0504EH-$,201

;	  Subroutine MSXDOS1 BDOS 018H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	504EH

LOGIN:
C504E:	LD	C,018H
        JP	J4F7C

        DEFS	05058H-$,201

;	  Subroutine MSXDOS1 BDOS 01AH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5058H

SETDMA:
C5058:	LD	C,01AH
        JP	J4F7C

        DEFS	0505DH-$,201

;	  Subroutine MSXDOS1 BDOS 01BH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	505DH

GETEFA:
C505D:	LD	C,01BH
        JP	J4F7C

        DEFS	0509FH-$,201

;	  Subroutine MSXDOS1 BDOS 00DH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	509FH

DSKRES:
C509F:	LD	C,00DH
        JP	J4F7C

        DEFS	050A9H-$,201

;	  Subroutine MSXDOS1 flush buffers
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50A9H

WRTFAT:
C50A9:	LD	BC,0FF5FH
        LD	D,0
        JP	J4F7C

        DEFS	050C4H-$,201

;	  Subroutine MSXDOS1 BDOS 019H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50C4H

GETDRV:
C50C4:	LD	C,019H
        JR	J50CA

        DEFS	050C8H-$,201

;	  Subroutine MSXDOS1 BDOS 024H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50C8H

SETRND:
C50C8:	LD	C,024H
J50CA:	JP	J4F7C

        DEFS	050D5H-$,201

;	  Subroutine MSXDOS1 BDOS 00EH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50D5H

SELDSK:
C50D5:	LD	C,00EH
        JP	J4F7C

        DEFS	050E0H-$,201

;	  Subroutine MSXDOS1 BDOS 00AH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	50E0H

BUFIN:
C50E0:	LD	C,00AH
        JP	J4F7C

        DEFS	05183H-$,201

;	  Subroutine MSXDOS1 newline to console
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5183H

CRLF:
C5183:	LD	E,13
	CALL	C53A7			; Console output
	LD	E,10
	JP	C53A7			; Console output

;
; 0518DH - 053A7H USED OTHERWISE IN DOS1 ROM
;

	IF	DOS1 EQ 1

;	  Subroutine invoke DOS1 kernel if DOS1 key pressed
;	     Inputs  ________________________
;	     Outputs ________________________

C518D:	XOR	A
	CALL	SNSMAT
	BIT	1,A			; 1 key pressed ?

	IF	ROMVER GE 3
	IF	TURBOR EQ 1

	LD	A,82H			; change CPU led, CPU mode = R800 DRAM
	JP	NZ,CHGCPU		; nope, change CPU mode and quit

	ELSE

	RET	NZ			; nope, quit

	ENDIF

	JR	J51AF			; start DOS1 kernel
	ELSE

	JR	Z,J51AF			; yep, start DOS1 kernel

	IF	TURBOR EQ 1
	LD	A,82H			; change CPU led, CPU mode = R800 DRAM
	JP	CHGCPU			; change CPU mode and quit
	ELSE
	RET

	ENDIF
	ENDIF

;	  Subroutine invoke DOS1 kernel if DEFUSR0 is defined
;	     Inputs  ________________________
;	     Outputs ________________________

C519A:	LD	HL,USRTAB+0*2
	LD	A,(HL)
	CP	LOW FCERR
	RET	NZ
	INC	HL
	LD	A,(HL)
	CP	HIGH FCERR		; DEFUSR0 still illegal function call (default value) ?
	RET	NZ			; nope, quit
	POP	HL

        IF ROMVER GE 3
	JR	J51AF			; start DOS1 kernel

;	  Subroutine if disk has no volid, invoke DOS1 kernel. Otherwise start bootloader with Cx reset
;	     Inputs  ________________________
;	     Outputs ________________________

C51A9:	CALL	C5243			; check if disk has a volumeid
	JP	Z,J4B23			; yep, start bootloader with Cx reset (basic disk system)

        ENDIF

;	  Subroutine start DOS1 kernel
;	     Inputs  ________________________
;	     Outputs ________________________

J51AF:
	IF	TURBOR EQ 1
	LD	A,80H			; change CPU led, CPU mode = Z80
	CALL	CHGCPU			; change CPU mode
	ENDIF

	LD	A,(RAMAD2)
	LD	H,HIGH 08000H
	CALL	ENASLT			; select RAM in page 2
	DI
	LD	HL,TIMI_S
	LD	DE,H.TIMI
	LD	BC,5
	LDIR				; restore orginal H.TIMI
	LD	HL,FCALSA
	LD	DE,EXTBIO
	LD	BC,5
	LDIR				; restore orginal EXTBIO
	LD	HL,($MAXSEC)		; biggests sectorsize
	LD	(AUTLIN),HL
	LD	HL,(RM_DPB)
	LD	DE,21
	ADD	HL,DE
	LD	(HIMEM),HL		; deallocate RAMDISK DPB
	CALL	C565C			; intialize BASIC stack and i/o channels
	LD	SP,(STKTOP)		; initialize stack
	XOR	A

	IF ROMVER EQ 0
	LD	(DOS_VER),A		; clear DOS2 version
	LD	(P0_64K),A		; TPA segment page 0 = 0
	ENDIF

	LD	(CUR_DRV),A		; default drive = A:


        IF ROMVER EQ 1
	LD	HL,DOS_VER
	CALL	C525F			; clear DOS1 kernel variables
	ENDIF

	IF ROMVER EQ 2
	LD	HL,TIM_RA
	CALL	C525F			; clear DOS1 kernel variables
	ENDIF

        IF ROMVER GE 3
	LD	HL,TIM_RA
	LD	(HL),A
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,CLRSIZ
	LDIR				; clear DOS1 kernel variables
	ENDIF

	LD	DE,DRVTBL
	LD	HL,HOOKSA
	LD	B,4
J5202:	LD	A,(DE)
	OR	A			; entry used ?
	JR	Z,J523A			; nope, start DOS1 kernel
	INC	DE
	LD	A,(DE)			; slotid disk interface
	INC	DE
	CP	(HL)			; disk interface has an interrupt handler ?
	JR	NZ,J5235		; nope,
	PUSH	HL
	LD	HL,H.TIMI
	LD	A,(HL)
	SUB	0C9H			; does H.TIMI have a handler ?
	JR	NZ,J5220		; yep,
	LD	(HL),0F7H
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),0C9H		; nope, setup CALLF basics
J5220:	POP	HL
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	B,3
	LD	DE,H.TIMI+1
J5229:	LD	A,(DE)
	LD	C,(HL)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	J5229			; H.TIMI to driver interrupt handler, HOOKSA to current H.TIMI handler
	POP	BC
	POP	DE
	POP	HL
J5235:	INC	HL
	INC	HL
	INC	HL			; next HOOKSA entry
	DJNZ	J5202			; next disk interface
J523A:	LD	HL,A58A8
	PUSH	HL			; start DOS1 kernel entry
	LD	A,3
	JP	C7FD0			; select DOS1 segment

        IF ROMVER LT 3

I5253:	DEFB	"VOL_ID"
S5253	EQU	$-I5253

;	  Subroutine if disk has no volid, invoke DOS1 kernel. Otherwise start bootloader with Cx reset
;	     Inputs  ________________________
;	     Outputs ________________________

C51A9:	CALL	C5243			; check if disk has a volumeid
        JP      NZ,J51AF		; nope, start DOS1 kernel
        JP	J4B23			; start bootloader with Cx reset (basic disk system)
        ENDIF

;	  Subroutine check if disk has a volumeid
;	     Inputs  ________________________
;	     Outputs ________________________

C5243:	LD	HL,BOT16K+32
	LD	DE,I5253
	LD	B,S5253
J524B:	LD	A,(DE)
	CP	(HL)
	RET	NZ
	INC	HL
	INC	DE
	DJNZ	J524B
	RET

        IF ROMVER GE 3
I5253:	DEFB	"VOL_ID"
S5253	EQU	$-I5253
        ENDIF

	ENDIF

	IF (ROMVER EQ 1) OR (ROMVER EQ 2)

;	  Subroutine start MSXDOS patch
;	     Inputs  ________________________
;	     Outputs ________________________

J5254:	CALL	C68BB			; prepare for DOS, try to load and start MSXDOS2.SYS
	LD	A,(NOTFIR)
	OR	A
	RET	NZ
	JP	J4B0A

;	  Subroutine initialize disk variables patch
;	     Inputs  ________________________
;	     Outputs ________________________

C525F:	LD	(HL),A
	LD	D,H
	LD	E,L
	INC	DE
	LD	BC,CLRSIZ
	LDIR
	RET

	ENDIF

; end of patch area

        DEFS	0535DH-$,201

;	  Subroutine MSXDOS1 print abort string
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	535DH

BUFOUT:
?535D:	EXX
	PUSH	BC
	EXX
	CALL	C5183			; newline to console
	LD	A,10
	LD	DE,($SECBUF)
	CALL	C4106			; copy message to buffer
	CALL	C5379			; print message
	POP	BC
	LD	DE,($SECBUF)
	LD	C,66H			; Explain error code
	CALL	BDOS			; DiskBASIC BDOS call

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C5379:	LD	A,(DE)
	OR	A
	RET	Z
	PUSH	DE
	LD	E,A
	CALL	C53A7			; Console output
	POP	DE
	INC	DE
	JR	C5379

        DEFS 053A7H-$,201

;	  Subroutine MSXDOS1 BDOS 002H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	53A7H

CONOUT:
C53A7:	LD	C,2
	JP	J4F7C

;
; 053ACH - 0543BH USED OTHERWISE IN DOS1 ROM
;

;	  Subroutine $ terminated string to console (0F1C9H)
;	     Inputs  ________________________
;	     Outputs ________________________

J53AC:	LD	HL,0C91AH
	PUSH	HL			; read byte from string on stack
	CALL	C53C0			; read byte from string (TPA)
	POP	HL
	CP	"$"
	RET	Z
	PUSH	DE
	LD	E,A
	CALL	C53A7			; Console output
	POP	DE
	INC	DE
	JR	J53AC			; next byte from string

;	  Subroutine read byte from string (TPA)
;	     Inputs  ________________________
;	     Outputs ________________________

C53C0:	LD	HL,$DOSON
	PUSH	HL			; enable DOS kernel
	LD	HL,4
	ADD	HL,SP
	PUSH	HL			; read byte from string on stack
	JP	$DOSOF			; disable DOS kernel
					; read byte from string
					; enable DOS kernel

        DEFS	0543CH-$,201

;	  Subroutine MSXDOS1 BDOS 00BH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	543CH

CONSTA:
C543C:	LD	C,00BH
        JP	J4F7C

        DEFS	05445H-$,201

;	  Subroutine MSXDOS1 BDOS 001H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5445H

CONIN:
C5445:	LD	C,1
        JP	J4F7C

        DEFS	0544EH-$,201

;	  Subroutine MSXDOS1 BDOS 008H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	544EH

IN:
C544E:	LD	C,8
        JP	J4F7C

        DEFS	05454H-$,201

;	  Subroutine MSXDOS1 BDOS 006H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5454H

RAWIO:
C5454:	LD	C,6
        JP	J4F7C

        DEFS	05462H-$,201

;	  Subroutine MSXDOS1 BDOS 007H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5462H

RAWINP:
C5462:	LD	C,7
        DEFB	011H			; LD DE,xxxx: skip next instruction

;	  Subroutine MSXDOS1 BDOS 005H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5465H

LIST:
C5465:	LD	C,5
        JP	J4F7C

        DEFS	0546EH-$,201

;	  Subroutine MSXDOS1 BDOS 003H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	546EH

READER:
C546E:	LD	C,3
        JP	J4F7C

        DEFS	05474H-$,201

;	  Subroutine MSXDOS1 BDOS 004H entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5474H

PUNCH:
C5474:	LD	C,4
        JP	J4F7C

        DEFS	0553CH-$,201

;	  Subroutine MSXDOS1 BDOS 02AH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	553CH

GETDAT:
C553C:	LD	C,02AH
        JP	J4F7C

        DEFS	05552H-$,201

;	  Subroutine MSXDOS1 BDOS 02BH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	5552H

SETDAT:
C5552:	LD	C,02BH
        JP	J4F7C

        DEFS	055DBH-$,201

;	  Subroutine MSXDOS1 BDOS 02CH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	55DBH

GETTIM:
C55DB:	LD	C,02CH
        JP	J4F7C

        DEFS	055E6H-$,201

;	  Subroutine MSXDOS1 BDOS 02DH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	55E6H

SETTIM:
C55E6:	LD	C,02DH
        JP	J4F7C

        DEFS	055FFH-$,201

;	  Subroutine MSXDOS1 BDOS 02EH entry
;	     Inputs  ________________________
;	     Outputs ________________________
;         Remark     DOS1 kernel compatible (entry used by MSXDOS.SYS)

	_DOSCP	55FFH

SETRAW:
C55FF:	LD	C,02EH
        JP	J4F7C

;
; 05604H - 07FFFH USED OTHERWISE IN DOS1 ROM
;


;	  Subroutine allocate memory
;	     Inputs  HL = size
;	     Outputs HL = start of area, Cx set if insufficient memory

C5604:	LD	A,L
	OR	H			; size = 0 ?
	RET	Z			; yep, quit
	EX	DE,HL
	LD	HL,0
	SBC	HL,DE			; -size
	LD	C,L
	LD	B,H			; store -size
	ADD	HL,SP			; new bottom of stack
	CCF
	RET	C			; out of memory, quit
	LD	A,H
	CP	HIGH TMPSTK		; mimium DiskBASIC memory requirement met ?
	RET	C			; nope, quit
	LD	DE,(BOTTOM)
	SBC	HL,DE			; size of BASIC memory
	RET	C			; out of memory, quit
	LD	A,H
	CP	HIGH 512		; mimium DiskBASIC memory requirement met ?
	RET	C			; nope, quit
	PUSH	BC			; store -size
	LD	HL,0
	ADD	HL,SP			; bottom of stack
	LD	E,L
	LD	D,H			; store bottom of stack
	ADD	HL,BC			; new bottom of stack
	PUSH	HL			; store new bottom of stack
	LD	HL,(STKTOP)
	OR	A
	SBC	HL,DE			; size of BASIC stack
	LD	C,L
	LD	B,H			; store size of BASIC stack
	INC	BC			; include ?
	POP	HL			; restore new bottom of stack
	LD	SP,HL			; switch to new stack
	EX	DE,HL
	LDIR				; copy BASIC stack to new location
	POP	BC			; restore -size
	LD	HL,(HIMEM)
	ADD	HL,BC
	LD	(HIMEM),HL		; update HIMEM
	LD	DE,-(2*256 + 2*9 + 2*2)	; size of 2 i/o channels (1 system, 1 user)
	ADD	HL,DE
	LD	(FILTAB),HL		; update FILTAB
	EX	DE,HL
	LD	HL,(MEMSIZ)
	ADD	HL,BC
	LD	(MEMSIZ),HL		; update MEMSIZ
	LD	HL,(NULBUF)
	ADD	HL,BC
	LD	(NULBUF),HL		; update NULBUF
	LD	HL,(STKTOP)
	ADD	HL,BC
	JR	J5681			; update STKTOP, initialize i/o channels

;	  Subroutine intialize BASIC stack and i/o channels
;	     Inputs  ________________________
;	     Outputs ________________________

C565C:	LD	A,1
	LD	(MAXFIL),A		; number of user i/o channels = 1
	LD	HL,(HIMEM)
	LD	DE,-(2*256 + 2*9 + 2*2)
	ADD	HL,DE
	LD	(FILTAB),HL		; update FILTAB
	LD	E,L
	LD	D,H			; store FILTAB
	DEC	HL
	DEC	HL
	LD	(MEMSIZ),HL		; update MEMSIZ
	LD	BC,200
	OR	A
	SBC	HL,BC			; start of string heap
	PUSH	HL			; store start of string heap
	LD	HL,9+4
	ADD	HL,DE
	LD	(NULBUF),HL		; update pointer to buffer of the system i/o channel
	POP	HL			; restore start of string heap
J5681:	LD	(STKTOP),HL		; update top of BASIC stack
	DEC	HL
	DEC	HL
	LD	(SAVSTK),HL		; update current BASIC stack pointer
	LD	L,E
	LD	H,D			; restore FILTAB
	INC	HL
	INC	HL
	INC	HL
	INC	HL			; pointer to i/o channel 0 (system)
	LD	A,1+1			; number of i/o channels = 2 (system + user)
J5691:	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	EX	DE,HL			; update pointer to i/o channel
	LD	BC,7
	LD	(HL),B			; i/o channel closed
	ADD	HL,BC
	LD	(HL),B			; clear i/o channel flags
	LD	BC,256+9-7
	ADD	HL,BC			; update pointer to next i/o channel
	DEC	A
	JR	NZ,J5691		; next i/o channel
	RET

;	  Subroutine setup hooks for disk system handlers
;	     Inputs  ________________________
;	     Outputs ________________________

C56A5:	LD	HL,I5757
	LD	DE,H.POSD
	LD	BC,5
	LDIR				; install H.POSD code
	LD	HL,I56CD		; table with hooks
J56B3:	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; address hook
	INC	HL
	LD	A,E
	OR	D			; end of table ?
	RET	Z			; yep, quit
	EX	DE,HL
	LD	(HL),0F7H		; RST CALLF
	INC	HL
	LD	A,(MASTER)
	LD	(HL),A			; DOS kernel ROM slot id
	INC	HL
	EX	DE,HL
	LDI
	LDI				; address hook handler
	LD	A,0C9H
	LD	(DE),A			; RET
	JR	J56B3			; next hook

I56CD:	DEFW	H.DSKO,C5EDC
        DEFW	H.DSKI,C5EBB
        DEFW	H.NAME,C6315
        DEFW	H.KILL,C6303
        DEFW	H.COPY,C6424
        DEFW	H.DSKF,C640D
        DEFW	H.LSET,C6026
        DEFW	H.RSET,C6025
        DEFW	H.FIEL,C5F9F
        DEFW	H.MKI$,C60E6
        DEFW	H.MKS$,C60E9
        DEFW	H.MKD$,C60EC
        DEFW	H.CVI,C6123
        DEFW	H.CVS,C6126
        DEFW	H.CVD,C6129
        DEFW	H.GETP,C5A2A
        DEFW	H.NOFO,C5A39
        DEFW	H.NULO,C5A82
        DEFW	H.NTFL,C5BEF
        DEFW	H.BINS,C5C51
        DEFW	H.BINL,C5C79
        DEFW	H.FILE,C61E0
        DEFW	H.DGET,C5F1E
        DEFW	H.FILO,C5BD6
        DEFW	H.INDS,C5B4F
        DEFW	H.LOC,C6361
        DEFW	H.LOF,C635E
        DEFW	H.EOF,C61C8
        DEFW	H.BAKU,C5BBD
        DEFW	H.PARD,C6665
        DEFW	H.NODE,C6757
        DEFW	H.ERRP,C675B
        DEFW	H.PHYD,C4CC5
        DEFW	H.FORM,C4E8E
I5755:	DEFW	0

;	  Subroutine H.POSD handler (parse device name)
;	     Inputs  ________________________
;	     Outputs ________________________

I5757:	INC	SP
	INC	SP			; remove return address from stack
	JP	PARDEV+8		; continue with device name parser without first character check

;	  Subroutine CALL statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C575C:	EI
	LD	A,(H.PHYD+0)
	CP	0C9H			; disk system available ?
	SCF
	RET	Z			; nope, quit with statement not recognized
	PUSH	HL
	CALL	C402D			; get my slotid
	LD	HL,MASTER
	CP	(HL)			; is this disk interface the master disk system ?
	JR	NZ,J5795		; nope, skip DOS2 CALL statements and try interface CALL statements
	LD	HL,I5799
J5771:	LD	DE,PROCNM
J5774:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J578B
	INC	DE
	INC	HL
	AND	A			; end of statement ?
	JR	NZ,J5774		; nope, next
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; statement handler
	POP	HL
	CALL	C665E			; end of BASIC statement ?
	CALL	C5789			; invoke statement handler
	AND	A
	RET				; quit with statement recognized (handled)

;	  Subroutine invoke statement handler
;	     Inputs  DE = statement handler
;	     Outputs ________________________

C5789:	PUSH	DE
	RET

J578B:	LD	C,0FFH
	XOR	A
	CPIR				; skip to end of statement
	INC	HL
	INC	HL			; skip handler address
	CP	(HL)			; end of statement table ?
	JR	NZ,J5771		; nope, try next statement
J5795:	POP	HL
	JP	OEMSTA			; invoke driver CALL statement handler

I5799:	DEFB	"SYSTEM"
        DEFB	0
        DEFW	C57D6

        DEFB	"FORMAT"
        DEFB	0
        DEFW	C581A

        DEFB	"CHDRV"
        DEFB	0
        DEFW	C5821

        DEFB	"CHDIR"
        DEFB	0
        DEFW	C585A

        DEFB	"MKDIR"
        DEFB	0
        DEFW	C5869

        DEFB	"RMDIR"
        DEFB	0
        DEFW	C587D

        DEFB	"RAMDISK"
        DEFB	0
        DEFW	C58AF

        DEFB	0

;	  Subroutine _SYSTEM statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C57D6:	LD	DE,TMPBUF
	JR	Z,J5805			; end of statement, skip MSXDOS command parameter
	CALL	C6654			; check for BASIC character
	DEFB	"("
	LD	IX,FRMEVL
	CALL	C664F			; evaluate expression
	PUSH	HL
	LD	IX,FRESTR
	CALL	C664F			; free temporary stringdescriptor
	LD	C,(HL)
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	DE,TMPBUF
	INC	C
	DEC	C
	JR	Z,J57FF
	LD	B,0
	LDIR
J57FF:	POP	HL
	CALL	C6654			; check for BASIC character
	DEFB	")"
	RET	NZ
J5805:	XOR	A
	LD	(DE),A
	LD	IX,CLSALL
	CALL	C664F			; close all i/o channels
	CALL	TOTEXT			; force textmode
	CALL	ERAFNK			; display functionkey display
	LD	HL,TMPBUF
	JP	J4AFB			; start MSXDOS2 from bootdrive with commandline

;	  Subroutine _FORMAT statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C581A:	RET	NZ			; not end of statement, quit (generates error later)
	PUSH	HL
	CALL	C4E8E			; invoke format
	POP	HL
	RET

;	  Subroutine _CHDRV statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5821:	CALL	C634C			; check for ("filename" and disk device
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	BC,0*256+05BH		; filepath, Parse path name
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	EX	DE,HL
	LD	A,B
	AND	05H			; any characters parsed other than drive name + drive name specified
	XOR	04H			; only drive name specified
	OR	(HL)			; and at end of string
	JP	NZ,J65ED		; nope, bad drive name error
	LD	A,C
	CALL	C5846			; check if valid disk drive
	DEC	A
	LD	E,A
	LD	C,0EH			; Select disk
	CALL	BDOS			; DiskBASIC BDOS call
	POP	HL
	RET

;	  Subroutine check if valid disk drive
;	     Inputs  A = driveid (1 based)
;	     Outputs ________________________

C5846:	PUSH	AF
	LD	C,18H			; Get login vector
	CALL	BDOS			; DiskBASIC BDOS call
	POP	AF
	PUSH	AF
J584E:	SRL	H
	RR	L
	DEC	A
	JR	NZ,J584E
	JP	NC,J65ED		; drive not online, bad drive name error
	POP	AF
	RET

;	  Subroutine _CHDIR statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C585A:	CALL	C634C			; check for ("filename" and disk device
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	C,5AH			; Change current directory
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	POP	HL
	RET

;	  Subroutine _MKDIR statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5869:	CALL	C634C			; check for ("filename" and disk device
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL
	LD	B,10H			; directory attribute
	LD	C,44H			; Create file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	CALL	C6343			; flush buffers of all drives
	POP	HL
	RET

;	  Subroutine _RMDIR statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C587D:	CALL	C634C			; check for ("filename" and disk device
	CALL	C6654			; check for BASIC character
	DEFB	")"
	RET	NZ
	PUSH	HL
	LD	B,10H			; attribute = directory
	CALL	C59D3			; DiskBASIC BDOS find first entry with error handling
	XOR	A			; directory deleted = false
	PUSH	AF			; store directory deleted
J588D:	LD	A,(TMPBUF+14)
	AND	10H			; directory attribute ?
	JR	Z,J589F			; nope, skip
	LD	DE,TMPBUF
	LD	C,4DH			; Delete file or subdirectory
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	AF			; restore directory deleted
	SCF				; directory deleted = true
	PUSH	AF			; store directory deleted
J589F:	CALL	C59D8			; DiskBASIC BDOS find next entry with error handling
	JR	NC,J588D		; directory found, next
	POP	AF			; restore directory deleted
	LD	A,0D6H			; directory not found
	JP	NC,J65C3		; no directory deleted, generate appropriate error
	CALL	C6343			; flush buffers of all drives
	POP	HL
	RET

;	  Subroutine _RAMDISK statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C58AF:	CALL	C6654			; check for BASIC character
	DEFB	"("
	CP	","
	LD	A,0FFH
	JR	Z,J58DB
	LD	IX,GETIN2
	CALL	C664F			; evaluate expression and convert to positive integer
	INC	D
	DEC	D
	JP	M,J662D			; illegal function call error
	LD	B,4
J58C7:	SRL	D
	RR	E
	JR	NC,J58CE
	INC	DE
J58CE:	DJNZ	J58C7
	LD	A,E
	INC	D
	DEC	D
	JR	NZ,J58D9
	CP	0FFH
	JR	NZ,J58DB
J58D9:	LD	A,0FEH
J58DB:	PUSH	AF
	LD	A,(HL)
	CP	","
	LD	DE,0
	JR	NZ,J58EE
	CALL	C665F			; get next BASIC character
	LD	IX,PTRGET
	CALL	C664F			; get address of variable
J58EE:	POP	BC
	CALL	C6654			; check for BASIC character
	DEFB	")"
	RET	NZ
	LD	A,(VALTYP)
	CP	3
	JP	Z,J6627			; type mismatch error
	PUSH	HL
	PUSH	DE
	PUSH	AF
	LD	C,68H			; Create or destroy RAM disk
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	L,B
	LD	H,00H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(DAC+2),HL
	POP	AF
	LD	(VALTYP),A
	POP	DE
	LD	A,E
	OR	D
	CALL	NZ,C591A
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C591A:	PUSH	DE
	LD	HL,VALTYP
	LD	A,(HL)
	LD	C,A
	LD	(HL),2
	LD	HL,DAC+2
	CP	2
	JR	Z,J593E
	CP	4
	JR	Z,J5932
	CP	8
	JP	NZ,J6627		; type mismatch error

J5932:	PUSH	BC
	LD	IX,DOCNVF
	CALL	C664F			; convert DAC to other type
	POP	BC
	LD	HL,DAC
J593E:	LD	B,0
	POP	DE
	LDIR
	RET

;	  Subroutine check if file is open in i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5944:	PUSH	HL
	PUSH	DE
	PUSH	BC
	XOR	A
	LD	(TMPBUF+0),A		; no file found
	LD	HL,(FILTAB)
	LD	A,(MAXFIL)
J5951:	PUSH	AF
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	PUSH	HL
	EX	DE,HL
	LD	A,(HL)
	AND	A			; i/o channel open ?
	JR	Z,J598F			; nope, check next
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	CP	9			; disk device ?
	JR	NC,J598F		; nope, check next
	LD	A,(TMPBUF+0)
	AND	A			; file found ?
	JR	NZ,J597E		; yep, skip search
	PUSH	HL
	LD	DE,(PATHNAM)		; BASIC path buffer
	LD	B,06H			; include system + hidden files
	LD	IX,TMPBUF
	LD	C,40H			; Find first entry
	CALL	C59DE			; DiskBASIC BDOS call with error handling
	POP	HL
	JR	C,J5998			; file not found, quit
J597E:	DEC	HL
	DEC	HL
	DEC	HL
	LD	B,(HL)			; file handle
	LD	DE,TMPBUF		; FIB
	LD	C,4CH			; Test file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	A,B
	AND	A			; same file ?
	JP	NZ,J663C		; yep, file already open error
J598F:	POP	HL
	POP	AF
	DEC	A			; done all i/o channels ?
	JP	P,J5951			; nope, next i/o channel
	JP	J5A26			; restore and quit

J5998:	POP	HL
	POP	HL
	JP	J5A26			; restore and quit

;	  Subroutine find first directory entry
;	     Inputs  A = attribute
;	     Outputs ________________________

C599D:	PUSH	AF			; store attribute
	LD	B,0			; path name
	LD	C,5BH			; Parse pathname
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	POP	AF			; restore attribute
	PUSH	BC			; store parse flags, logical drive id
	PUSH	DE			; store pointer to termination character
	PUSH	HL			; store pointer to start of last element
	PUSH	AF			; store attribute
	LD	B,A			; attribute
	CALL	C59D3			; DiskBASIC BDOS find first entry with error handling
	POP	AF			; restore attribute
	POP	HL			; restore pointer to start of last element
	POP	DE			; restore pointer to termination character
	POP	BC			; restore parse flags, logical drive id
	BIT	5,B			; last item is ambiguous ?
	RET	NZ			; yep, quit
	LD	D,A			; store attribute
	LD	A,(TMPBUF+14)
	AND	10H			; directory attribute ?
	RET	Z			; nope, quit
	LD	A,L
	CP	E			; pointer to start of last element = pointer to termination character ?
	RET	Z			; yep, quit
	PUSH	BC			; store parse flags, logical drive id
	LD	B,D			; search attributes = attributes
	LD	DE,TMPBUF		; pointer to FIB
	PUSH	DE
	POP	IX			; = pointer to new FIB
	LD	HL,I5755		; pointer to empty ASCIIZ string
	LD	C,40H			; Find first entry
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	BC			; restore parse flags, logical drive id
	RET

;	  Subroutine DiskBASIC BDOS find first entry normal file with error handling
;	     Inputs  ________________________
;	     Outputs TMPBUF = FIB

C59D1:	LD	B,0			; attribute = normal file

;	  Subroutine DiskBASIC BDOS find first entry with error handling
;	     Inputs  B = attribute, BASIC path buffer = file specification
;	     Outputs TMPBUF = FIB

C59D3:	LD	C,40H			; Find first entry
	JP	J6555			; DiskBASIC BDOS call with error handling, file specification in BASIC path buffer, temporary buffer for FIB

;	  Subroutine DiskBASIC BDOS find next entry with error handling
;	     Inputs  TMPBUF = FIB
;	     Outputs ________________________

C59D8:	LD	IX,TMPBUF
	LD	C,41H			; Find next entry

;	  Subroutine DiskBASIC BDOS call with error handling
;	     Inputs  ________________________
;	     Outputs ________________________

C59DE:	CALL	BDOS			; DiskBASIC BDOS call
	RET	Z			; no error, quit
	CP	0D7H			; File not found ?
	SCF
	RET	Z			; yep, quit
	JP	J65C3			; generate appropriate error

;	  Subroutine take control from hook caller (move parameters on stack)
;	     Inputs  IX = replace return address, IYH = parameter block size
;	     Outputs ________________________

;       This is what the stack looks like at entry:
;
;       prim    exp
;       +0      +0      returnaddress C59E9 caller
;       +2      +2      callf BIOS registers
;       +6      +14     returnaddress CALLF caller
;       +8      +16     returnaddress hook caller

C59E9:	EI
	PUSH	HL			; store HL
	PUSH	DE			; store DE
	PUSH	BC			; store BC
	PUSH	AF			; store AF
	LD	A,(MASTER)
	ADD	A,A			; DOS kernel ROM in expanded slot ?
	LD	HL,16			; offset return address HOOK caller when primairy slot
	JR	NC,J59F9		; nope,
	LD	L,16+8			; offset return address HOOK caller when secundairy slot
J59F9:	ADD	HL,SP
	PUSH	IX
	POP	BC			; return address replacement
	LD	(HL),C
	INC	HL
	LD	(HL),B			; replace return address
	LD	HL,10
	ADD	HL,SP
	EX	DE,HL			; pointer to new parameter block
	JR	J5A13

J5A07:	PUSH	IY
	POP	BC			; parameter block size
J5A0A:	LD	C,(HL)
	LD	A,(DE)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	HL
	INC	DE
	DJNZ	J5A0A			; exchange parameter block
J5A13:	LD	A,(MASTER)
	ADD	A,A			; DOS kernel ROM in expanded slot ?
	LD	HL,18			; offset parameter block when primairy slot
	JR	NC,J5A1E		; nope,
	LD	L,18+8			; offset parameter block when secundairy slot
J5A1E:	ADD	HL,SP			; pointer to parameter block
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H			; parameter block moved ?
	JR	C,J5A07			; nope, move
J5A25:	POP	AF			; restore AF
J5A26:	POP	BC			; restore BC
	POP	DE			; restore DE
	POP	HL			; restore HL
	RET

;	  Subroutine H.GETP handler (get i/o channel control block if device is disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C5A2A:	LD	IX,RETRTN		; subroutine = empty subroutine
	LD	IY,2*256		; parameter block offset = 2
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	POP	HL			; restore pointer to i/o channel
	LD	A,(HL)			; file mode
	AND	A			; i/o channel open ?
	RET

;	  Subroutine H.NOFO handler (OPEN statement)
;	     Inputs  ________________________
;	     Outputs ________________________

C5A39:	EI
	LD	BC,256
	LD	(RECSIZE),BC		; assume random record size = 256 bytes
	CALL	C665E			; end of BASIC statement ?
	LD	A,E			; i/o channel number
	RET	Z			; yep, quit
	PUSH	AF			; store i/o channel number
	PUSH	HL			; store BASIC pointer
	LD	A,(MASTER)
	ADD	A,A			; DOS kernel ROM in expanded slot ?
	LD	HL,12
	JR	NC,J5A53		; nope,
	LD	L,12+8
J5A53:	ADD	HL,SP
	LD	A,(HL)			; file mode
	CP	4			; random filemode ?
	JP	NZ,J6630		; nope, syntax error error
	INC	HL
	LD	A,(HL)			; devicecode
	CP	9			; disk device ?
	JP	NC,J6630		; nope, syntax error error
	POP	HL			; restore BASIC pointer
	CALL	C6654
	DEFB	0FFH
	CALL	C6654
	DEFB	092H
	CALL	C6654
	DEFB	0EFH			; check for LEN=
	LD	IX,INTID2
	CALL	C664F			; evaluate word operand
	DEC	DE			; record size -1
	INC	D
	DEC	D			; random recordsize > 256 ?
	JP	NZ,J662D		; yep, illegal function call error
	INC	DE			; record size
	LD	(RECSIZE),DE		; store random record size
	POP	AF			; restore i/o channel number
	RET

;	  Subroutine H.NULO handler (open i/o channel)
;	     Inputs  HL = pointer to i/o channel, D = device code, E = file mode
;	     Outputs ________________________

C5A82:	EI
	RET	NC			; not a disk device, quit
	LD	IX,RETRTN		; subroutine = empty subroutine
	LD	IY,4*256		; parameter block offset = 4
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	CALL	C5944			; check if file is open in i/o channel (generate error)
	LD	(PTRFIL),HL		; interpreter input/output device = i/o channel pointer
	INC	HL
	INC	HL			; +2
	XOR	A
	LD	(HL),A			; random record size = 1
	INC	HL			; +3
	LD	(HL),A			; clear backup character
	INC	HL			; +4
	LD	(HL),D			; device code
	INC	HL
	INC	HL			; +6
	LD	(HL),A			; position in buffer = 0
	LD	A,E			; file mode
	PUSH	AF			; store file mode
	AND	82H			; binairy BASIC file OR sequential output filemode ?
	JR	Z,J5AB7			; nope,

; create file

J5AA6:	XOR	A
	LD	B,A			; normal file attribute
	LD	C,44H			; Create file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
J5AAD:	POP	AF			; restore file mode
	LD	HL,(PTRFIL)		; pointer to current i/o channel
	LD	(HL),A			; update file mode, i/o channel open
	INC	HL			; +1
	LD	(HL),B			; update file handle
	POP	AF			; restore file mode
	POP	HL			; restore BASIC pointer
	RET

J5AB7:	LD	A,E			; file mode
	CP	4			; random i/o ?
	JR	NZ,J5AD4		; nope,

; random i/o

	LD	HL,(PTRFIL)		; pointer to current i/o channel
	INC	HL
	INC	HL			; +2
	LD	A,(RECSIZE+0)
	DEC	A
	LD	(HL),A			; update random record size - 1
	LD	DE,(PATHNAM)		; BASIC path buffer
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C59DE			; DiskBASIC BDOS call with error handling
	JR	C,J5AA6			; file not found, create file and quit
	JR	J5AAD			; update i/o channel file handle and mode and quit

J5AD4:	CP	1			; sequential input ?
	JR	NZ,J5B0B		; nope, must be append

; sequential input

	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	LD	HL,FLBMEM
	XOR	A
	CP	(HL)			; load binairy file ?
	LD	(HL),A			; end load binairy file
	JR	NZ,J5AAD		; yep, update i/o channel file handle and mode and quit
	POP	AF			; file mode
	LD	HL,(PTRFIL)		; pointer to current i/o channel
	LD	(HL),A			; update file mode, i/o channel open
	INC	HL			; +1
	LD	(HL),B			; update file handle
	DEC	HL
	EX	DE,HL
	LD	HL,6
	ADD	HL,DE			; +6
	LD	(HL),0FFH		; position in buffer = 255 (force fill of buffer)
	PUSH	HL			; store pointer to i/o channel +6
	EX	DE,HL			; pointer to i/o channel
	CALL	C5B60			; read character from i/o channel
	POP	HL			; restore pointer to i/o channel +6
	DEC	HL
	DEC	HL
	DEC	HL			; +3
	LD	(HL),A			; save character as backup character
	INC	A			; binairy BASIC file id ?
	JR	NZ,J5B08		; nope, quit
	INC	HL
	INC	HL
	INC	HL
	INC	HL			; +7
	LD	(HL),80H		; binairy BASIC load = on
J5B08:	POP	AF			; restore file mode
	POP	HL			; restore BASIC pointer
	RET

; sequential append

J5B0B:	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	POP	AF			; file mode
	LD	HL,(PTRFIL)		; pointer to current i/o channel
	LD	(HL),1			; file mode = sequential input, i/o channel is open
	INC	HL			; +1
	LD	(HL),B			; file handle
	DEC	HL
	EX	DE,HL
	LD	HL,6
	ADD	HL,DE			; +6
	LD	(HL),0FFH		; position in buffer = 255 (force fill of buffer)
	EX	DE,HL			; pointer to i/o channel
	LD	BC,0
	LD	E,C
	LD	D,B			; file pointer offset = 0
J5B27:	PUSH	HL			; store pointer to i/o channel
	PUSH	DE
	PUSH	BC			; store file pointer offset
	CALL	C5B60			; read character from i/o channel
	POP	BC
	POP	DE
	POP	HL
	JR	C,J5B3A			; at end of file, now continue in sequential output mode
	INC	BC
	LD	A,C
	OR	B
	JR	NZ,J5B27
	INC	DE			; update filepointer offset
	JR	J5B27			; next

J5B3A:	PUSH	BC			; store low word file pointer offset
	LD	(HL),2			; file mode = sequential output, i/o channel is open
	INC	HL			; +1
	LD	B,(HL)			; file handle
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL			; +6
	XOR	A
	LD	(HL),A			; position in buffer = 0
	POP	HL			; restore low word file pointer offset
					; A=0, move relative to begin of file
	LD	C,4AH			; Move file handle pointer
	CALL	BDOS			; DiskBASIC BDOS call
	POP	AF			; restore file mode
	POP	HL			; restoe BASIC pointer
	RET

;	  Subroutine H.INDS handler (get sequential input disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C5B4F:	LD	IX,RETRTN		; subroutine = empty subroutine
	LD	IY,6*256		; parameter block offset = 6
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	CALL	C5B60			; read character from i/o channel
	JP	J5A26			; restore and quit

;	  Subroutine read character from i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5B60:	PUSH	HL			; store pointer to i/o channel
	LD	A,(HL)
	CP	1			; filemode sequential input ?
	JP	NZ,J65EA		; nope, quit with bad file mode error
	LD	E,L
	LD	D,H
	INC	HL
	INC	HL
	INC	HL			; +3
	LD	A,(HL)
	AND	A			; backup character ?
	JR	NZ,J5BAF		; yep,
	INC	HL
	INC	HL
	INC	HL			; +6
	INC	(HL)			; increase position in buffer
	LD	A,(HL)			; position in buffer
	INC	HL
	INC	HL
	INC	HL			; +9
	JR	NZ,J5BAA		; no need to fill the buffer, continue
	PUSH	HL			; store pointer to i/o channel buffer
	EX	DE,HL
	INC	HL			; +1
	LD	B,(HL)			; file handle
	LD	HL,256
	LD	C,48H			; Read from file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J5B92			; no error, continue
	CP	0C7H			; End of file ?
	JP	NZ,J65C3		; nope, generate appropriate error
	POP	HL			; restore pointer to i/o channel buffer
	LD	(HL),1AH		; put EOF in buffer
	JR	J5BAE			; continue

J5B92:	LD	C,L
	LD	B,H			; bytes read
	DEC	H
	LD	A,L
	OR	H			; 256 bytes read ?
	POP	HL			; restore pointer to i/o channel buffer
	JR	Z,J5BAA			; yep, read from position 0
	PUSH	HL			; store pointer to i/o channel buffer
	LD	E,L
	LD	D,H
	INC	D
	DEC	DE			; pointer to end of i/o channel buffer
	ADD	HL,BC
	LD	A,C			; low byte bytes read
	DEC	HL			; pointer to end of bytes read in i/o channel buffer
	LDDR				; move to end of i/o channel buffer
	DEC	HL
	DEC	HL			; +6
	NEG
	LD	(HL),A			; update position in buffer
	POP	HL			; restore pointer to i/o channel buffer
J5BAA:	LD	C,A
	LD	B,0
	ADD	HL,BC			; pointer to start of bytes read in i/o channel buffer
J5BAE:	LD	A,(HL)			; character from i/o channel buffer
J5BAF:	SUB	1AH
	SUB	01H			; EOF character ?
	LD	A,(HL)			; get character from i/o channel buffer
	POP	HL			; restore pointer to i/o channel
	INC	HL
	INC	HL
	INC	HL			; +3
	LD	(HL),0			; no backup character
	RET	NC			; not EOF, quit
	LD	(HL),A			; backup character = EOF
	RET

;	  Subroutine H.BAKU handler (backup character disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C5BBD:	EI
	PUSH	HL			; store pointer to i/o channel
	LD	A,(MASTER)
	ADD	A,A			; DOS kernel ROM in expanded slot ?
	LD	HL,8
	JR	NC,J5BCA		; nope,
	LD	L,8+8
J5BCA:	ADD	HL,SP
	LD	(HL),LOW NOSKCR
	INC	HL
	LD	(HL),HIGH NOSKCR	; resume point character putback routine
	POP	HL			; restore pointer to i/o channel
	INC	HL
	INC	HL
	INC	HL			; +3
	LD	(HL),C			; save backup character
	RET

;	  Subroutine H.FILO handler (sequential output disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C5BD6:	LD	IX,RETRTN		; subroutine = empty subroutine
	LD	IY,8*256		; parameter block offset = 8
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	LD	A,(HL)
	CP	2			; sequential output filemode ?
	JP	NZ,J65EA		; nope, bad file mode error
	POP	AF			; restore character
	PUSH	AF			; store character
	CALL	C5C2B			; write character to i/o channel
	JP	J5A25			; restore and quit

;	  Subroutine H.NTFL handler (close i/o channel for disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C5BEF:	LD	IX,RETRTN		; subroutine = rempty subroutine
	LD	IY,4*256		; parameter block offset = 4
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	POP	HL			; restore pointer to i/o channel
	LD	A,(HL)			; file mode
	SUB	2			; sequential output ?
	JR	NZ,J5C13		; nope,
	PUSH	HL			; store pointer to i/o channel
	LD	HL,FLBMEM
	CP	(HL)			; save binairy file ?
	LD	(HL),A			; end save binairy file
	POP	HL			; restore pointer to i/o channel
	JR	NZ,J5C13		; yep, skip EOF character at end of file
	LD	(HL),4			; random filemode
	LD	A,1AH			; EOF character
	CALL	C5C2B			; write character to i/o channel
	CALL	NZ,C5C39		; buffer not empty, write buffer to i/o channel
J5C13:	XOR	A
	CP	(HL)			; i/o channel open ?
	LD	(HL),A			; i/o channel closed
	PUSH	AF			; store file mode
	INC	HL			; +1
	LD	B,(HL)			; file handle
	LD	DE,7-1
	ADD	HL,DE			; +7
	LD	(HL),A			; binairy BASIC load = off
	LD	L,A
	LD	H,A
	LD	(PTRFIL),HL		; interpreter input/output device = screen
	LD	C,45H			; Close file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	AF			; restore file mode
	POP	HL			; restore HL
	RET

;	  Subroutine write character to i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5C2B:	PUSH	HL			; store pointer to i/o channel
	LD	BC,6
	ADD	HL,BC			; +6
	LD	C,(HL)			; position in buffer
	INC	(HL)			; update position in buffer
	INC	HL
	INC	HL
	INC	HL			; +9
	ADD	HL,BC
	LD	(HL),A			; put character in buffer
	POP	HL			; restore pointer to i/o channel
	RET	NZ			; buffer not full, quit

;	  Subroutine write buffer to i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5C39:	PUSH	HL			; store pointer to i/o channel
	INC	HL			; +1
	LD	B,(HL)			; file handle
	LD	DE,6-1
	ADD	HL,DE			; +6
	LD	A,(HL)			; position in buffer
	INC	HL
	INC	HL
	INC	HL			; +9
	EX	DE,HL
	DEC	A
	LD	L,A
	LD	H,0
	INC	HL			; number of bytes
	LD	C,49H			; Write to file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	HL			; restore pointer to i/o channel
	RET

;	  Subroutine H.BINS handler (save BASIC program binary)
;	     Inputs  ________________________
;	     Outputs ________________________

C5C51:	CALL	C6890			; take control from hook caller
	PUSH	HL			; store BASIC pointer
	LD	IX,SCCPTR
	CALL	C664F			; convert pointers to linenumbers
	LD	A,0FFH			; fileid = binary SAVE file
	CALL	C5E8F			; write byte to file handle
	LD	DE,(TXTTAB)		; start of BASIC program
	LD	HL,(VARTAB)		; start of BASIC variables
	AND	A
	SBC	HL,DE			; = size BASIC program
	CALL	C5EA7			; write to system i/o channel
	LD	(NLONLY),A		; close i/o channels, no BASIC program loading
	POP	HL			; restore BASIC pointer
					; A=0, i/o channel 0
	LD	IX,CLSFIL
	JP	C664F			; close i/o channel and quit

;	  Subroutine H.BINL handler (load binary saved BASIC program)
;	     Inputs  ________________________
;	     Outputs ________________________

C5C79:	LD	IX,M739A		; quit loading and start
	LD	IY,2*256		; parameter block offset = 2
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	POP	AF			; restore load flag
	JP	Z,J65EA			; MERGE statement, bad file mode error
	LD	IX,CLSALL
	CALL	C664F                   ; close all i/o channels (except the system i/o channel)
	LD	HL,-200+1
	ADD	HL,SP			; maximum address BASIC program
	LD	DE,(TXTTAB)		; minimum address BASIC program
	SBC	HL,DE			; maximum size BASIC program
	JP	C,J662A			; out of memory error
	PUSH	HL			; store maximum size BASIC program
	CALL	C5EAF			; get file handle of system i/o channel
	PUSH	BC			; store file handle
	XOR	A			; Relative to the beginning of the file
	LD	DE,0
	LD	HL,1			; offset = 1 (skip file id)
	LD	C,4AH			; Move file handle pointer
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	BC			; restore file handle
	LD	DE,(TXTTAB)		; start of BASIC program
	POP	HL			; restore maximum size BASIC program
	PUSH	HL			; store maximum size BASIC program
	LD	C,48H			; Read from file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	DE			; restore maximum size BASIC program
	PUSH	HL			; store bytes read
	AND	A
	SBC	HL,DE			; bytes read - maximum size BASIC program
	POP	HL			; restore bytes read
	JP	NC,J662A		; BASIC program does not fit, out of memory error
	LD	DE,(TXTTAB)
	ADD	HL,DE
	LD	(VARTAB),HL		; update start of BASIC variable area
	LD	IX,LINKER
	CALL	C664F			; convert line numbers to pointers
	LD	A,(FILNAM+0)
	AND	A			; load program only ?
	RET	NZ			; yep, quit
	LD	(NLONLY),A		; close i/o channels, no BASIC program loading
	LD	HL,I5CED
	LD	DE,TMPBUF
	LD	BC,5
	PUSH	DE
	LDIR				; copy RUN statement in temporary buffer
	POP	HL			; BASIC pointer
	LD	IX,NEWSTT
	JP	C664F			; execute BASIC statement

I5CED:	DEFB	03AH,092H,0		; :RUN
	DEFW	0

;	  Subroutine BSAVE handler
;	     Inputs  ________________________
;	     Outputs ________________________

J5CF2:	PUSH	DE			; store device code
	CALL	C5E7E			; check for , and evaluate BLOAD/BSAVE address operand
	LD	(SAVENT),DE		; update start address
	PUSH	DE			; store start address
	CALL	C5E7E			; check for , and evaluate BLOAD/BSAVE address operand
	LD	(SAVEND),DE		; update end address
	EX	(SP),HL			; store BASIC pointer, restore start address
	EX	DE,HL
	RST	DCOMPR			; compare end and start address
	JP	C,J662D			; start address > end address, illegal function call error
	EX	DE,HL
	EX	(SP),HL			; store start address, restore BASIC pointer
	CALL	C665E			; end of BASIC statement ?
	SCF				; assume BSAVE type = RAM
	JR	Z,J5D26			; yep, continue
	CALL	C6654			; check for BASIC character
	DEFB	","
	CP	"S"			; VRAM save ?
	JR	NZ,J5D1E		; nope, handle execute address operand
	CALL	C665F			; get next BASIC character
	AND	A			; BSAVE type = VRAM
	JR	J5D26			; continue

J5D1E:	CALL	C5E82			; evaluate BLOAD/BSAVE address operand
	LD	(SAVENT),DE		; update execute address
	SCF				; BSAVE type = RAM
J5D26:	POP	BC			; restore start address
	JR	NC,J5D2E		; VRAM save, skip check
	INC	B
	DEC	B			; start address in page 2 or 3 ?
	JP	P,J662D			; nope, illegal function call error

J5D2E:	POP	DE			; restore device code
	PUSH	HL			; store BASIC pointer
	PUSH	BC			; store start address
	PUSH	AF			; store BSAVE type
	XOR	A			; i/o channel 0
	LD	E,2			; filemode = sequential output
	LD	IX,OPNFIL
	CALL	C664F			; open i/o channel
	LD	A,0FEH			; file id = BSAVE file
	CALL	C5E8F			; write byte to file handle
	POP	AF			; restore BSAVE type
	POP	HL			; restore start address
	PUSH	HL			; store start address
	PUSH	AF			; store BSAVE type
	CALL	C5E89			; write word to file handle
	LD	HL,(SAVEND)		; restore end address
	CALL	C5E89			; write word to file handle
	LD	HL,(SAVENT)		; restore execute address
	CALL	C5E89			; write word to file handle
	POP	AF			; restore BSAVE type
	POP	BC			; restore start address
	PUSH	AF			; store BSAVE type
	LD	HL,(SAVEND)		; end address
	AND	A
	SBC	HL,BC
	INC	HL			; number of bytes = end - start +1
	POP	AF			; restore BSAVE type
	JR	NC,J5D76		; BSAVE type = VRAM,
	LD	E,C
	LD	D,B			; start address
	CALL	C5EA7			; write to system i/o channel

J5D66:	LD	A,0FFH
	LD	(FLBMEM),A		; save binairy file (no EOF at end of file)
	XOR	A			; i/o channel 0
	LD	IX,CLSFIL
	CALL	C664F			; close i/o channel
	JP	J627A			; restore BASIC pointer and output back to screen

J5D76:	CALL	C6511			; save start and end, determine maximium sized temporary buffer
J5D79:	PUSH	HL			; store size of buffer
	LD	DE,(SAVENT)		; size left
	RST	DCOMPR			; compare size of buffer with size left
	PUSH	AF			; store last transfer flag
	PUSH	BC			; store start address buffer
	LD	C,L
	LD	B,H			; size of buffer
	LD	HL,(SAVEND)
	PUSH	HL			; store current VRAM address
	ADD	HL,BC
	LD	(SAVEND),HL		; update current VRAM address
	POP	HL			; restore start of VRAM transfer
	POP	DE			; restore start of buffer
	PUSH	DE			; store start of buffer
	CALL	LDIRMV			; copy VRAM to RAM (buffer)
	POP	BC			; restore start of buffer
	POP	AF			; restore last transfer flag
	JR	NC,J5DAB		; last transfer, save last transfer
	POP	HL			; restore size of buffer
	PUSH	HL			; store size of buffer
	PUSH	BC			; store start of buffer
	LD	E,C
	LD	D,B			; buffer = start of buffer
	CALL	C5EA7			; write to system i/o channel
	POP	BC			; restore start of buffer
	POP	DE			; restore size of buffer
	LD	HL,(SAVENT)
	AND	A
	SBC	HL,DE
	LD	(SAVENT),HL		; update size left
	EX	DE,HL
	JR	J5D79			; next transfer

J5DAB:	POP	HL			; restore size of buffer
	LD	HL,(SAVENT)		; number of bytes = size left
	LD	E,C
	LD	D,B			; buffer = start of buffer
	CALL	C5EA7			; write to system i/o channel
	JR	J5D66			; finish BSAVE

;	  Subroutine BLOAD handler
;	     Inputs  ________________________
;	     Outputs ________________________

J5DB6:	PUSH	DE			; store device code
	XOR	A
	LD	(RUNBNF),A		; assume no run or vram
	LD	C,A
	LD	B,A			; assume offset = 0
	CALL	C665E			; end of BASIC statement ?
	JR	Z,J5DDF			; yep, continue
	CALL	C6654			; check for BASIC character
	DEFB	","
	CP	"R"			; execute ?
	JR	Z,J5DCE			; yep,
	CP	"S"			; BLOAD VRAM ?
	JR	NZ,J5DDA		; nope, handle offset address operand
J5DCE:	LD	(RUNBNF),A		; save flag
	CALL	C665F			; get next BASIC character
	JR	Z,J5DDF
	CALL	C6654			; check for BASIC character
	DEFB	","
J5DDA:	CALL	C5E82			; evaluate BLOAD/BSAVE address operand
	LD	B,D
	LD	C,E			; offset
J5DDF:	POP	DE			; restore device code
	PUSH	HL			; store BASIC pointer
	PUSH	BC			; store offset
	LD	A,0FFH
	LD	(FLBMEM),A		; load binairy file
	XOR	A			; i/o channel 0
	LD	E,1			; filemode = sequential input
	LD	IX,OPNFIL
	CALL	C664F			; open i/o channel
	CALL	C5E92			; read byte from file handle
	CP	0FEH			; BSAVE file id ?
	JP	NZ,J65EA		; nope, bad file mode error
	POP	BC			; restore offset
	CALL	C5E70			; read word from file handle and add offset
	PUSH	HL			; store start address
	CALL	C5E70			; read word from file handle and add offset
	PUSH	HL			; store end address
	CALL	C5E70			; read word from file handle and add offset
	LD	(SAVENT),HL		; store execute address
	POP	HL			; restore end address
	POP	BC			; restore start address
	AND	A
	SBC	HL,BC
	INC	HL			; size = end -start +1
	LD	A,(RUNBNF)
	CP	"S"			; BLOAD VRAM ?
	JR	Z,J5E28			; yep,
	LD	E,C
	LD	D,B			; start address
	CALL	C5EAF			; get file handle of system i/o channel
	LD	C,48H			; Read from file handle
	CALL	C655D			; DiskBASIC BDOS call with error
J5E1F:	LD	IX,FINPRT
	CALL	C664F			; return interpreter output to screen
	POP	HL			; restore BASIC pointer
	RET

J5E28:	CALL	C6511			; save start and end, determine maximium sized temporary buffer
J5E2B:	PUSH	HL			; store size of buffer
	PUSH	BC			; store start address buffer
	LD	DE,(SAVENT)		; size left
	RST	DCOMPR			; compare size of buffer with size left
	PUSH	AF			; store last transfer flag
	LD	E,C
	LD	D,B			; start address buffer
	CALL	C5EAF			; get file handle of system i/o channel
	LD	C,48H			; Read from file handle
	CALL	BDOS			; DiskBASIC BDOS call
	POP	AF			; restore last transfer flag
	POP	HL			; restore start address buffer
	POP	BC			; restore size of buffer
	PUSH	BC			; store size of buffer
	PUSH	HL			; store start address buffer
	PUSH	AF			; store last transfer flag
	LD	HL,(SAVEND)
	PUSH	HL			; store current VRAM address
	ADD	HL,BC
	LD	(SAVEND),HL		; update current VRAM address
	POP	DE			; restore start of VRAM transfer
	POP	AF			; restore last transfer flag
	POP	HL			; restore start address buffer
	JR	NC,J5E62		; last transfer, finish last transfer
	PUSH	HL			; store start address buffer
	CALL	LDIRVM			; copy RAM (buffer) to VRAM
	POP	BC			; restore start address buffer
	POP	DE			; restore size of buffer
	LD	HL,(SAVENT)
	AND	A
	SBC	HL,DE
	LD	(SAVENT),HL		; update size left
	EX	DE,HL
	JR	J5E2B			; next transfer

J5E62:	POP	BC			; discard size of buffer
	LD	BC,(SAVENT)		; size left
	CALL	LDIRVM			; copy RAM (buffer) to VRAM
	XOR	A
	LD	(RUNBNF),A		; clear run flag
	JR	J5E1F			; finish BLOAD

;	  Subroutine read word from file handle and add offset
;	     Inputs  BC = offset
;	     Outputs ________________________

C5E70:	PUSH	BC			; store offset
	CALL	C5E92			; read byte from file handle
	PUSH	AF			; store low byte
	CALL	C5E92			; read byte from file handle
	LD	H,A			; store high byte
	POP	AF			; restore low byte
	LD	L,A
	POP	BC			; restore offset
	ADD	HL,BC			; word + offset
	RET

;	  Subroutine check for , and evaluate BLOAD/BSAVE address operand
;	     Inputs  ________________________
;	     Outputs ________________________

C5E7E:	CALL	C6654			; check for BASIC character
	DEFB	","

;	  Subroutine evaluate BLOAD/BSAVE address operand
;	     Inputs  ________________________
;	     Outputs ________________________

C5E82:	LD	IX,ADRGET
	JP	C664F			; evaluate address operand

;	  Subroutine write word to file handle
;	     Inputs  HL = word
;	     Outputs ________________________

C5E89:	PUSH	HL			; store high byte
	LD	A,L			; low byte
	CALL	C5E8F			; write byte to file handle
	POP	AF			; restore high byte

;	  Subroutine write byte to file handle
;	     Inputs  A = byte
;	     Outputs ________________________

C5E8F:	LD	C,49H			; Write to file handle
	DEFB	021H			; LD HL,xxxx: skip next instruction

;	  Subroutine read byte from file handle
;	     Inputs  ________________________
;	     Outputs A = byte

C5E92:	LD	C,48H			; Read from file handle
	CALL	C5EAF			; get file handle of system i/o channel
	PUSH	AF			; store value
	LD	HL,1
	ADD	HL,SP			; pointer to value on stack
	EX	DE,HL
	LD	HL,1			; number of bytes = 1
	PUSH	BC			; store file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	BC			; restore file handle
	POP	AF			; restore value
	RET

;	  Subroutine write to system i/o channel
;	     Inputs  DE = start address, HL = size
;	     Outputs ________________________

C5EA7:	CALL	C5EAF			; get file handle of system i/o channel
	LD	C,49H			; Write to file handle
	JP	C655D			; DiskBASIC BDOS call with error

;	  Subroutine get file handle of system i/o channel
;	     Inputs  ________________________
;	     Outputs ________________________

C5EAF:	PUSH	HL			; store HL
	LD	HL,(FILTAB)
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B			; pointer to i/o channel 0
	INC	HL			; +1
	LD	B,(HL)			; file handle
	POP	HL			; restore HL
	RET

;	  Subroutine H.DSKI handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5EBB:	CALL	C6890			; take control from hook caller
	CALL	C665F			; get next BASIC character
	CALL	C6654			; check for BASIC character
	DEFB	"("
	CALL	C5F09			; evaluate byte operand, evaluate unsigned integer operand
	CALL	C6654			; check for BASIC character
	DEFB	")"
	PUSH	HL			; store BASIC pointer
	LD	HL,NULSTR		; empty string
	LD	(DAC+2),HL
	LD	A,3
	LD	(VALTYP),A		; DAC type = string
	LD	L,2FH			; Absolute sector read
	JR	J5EE9

;	  Subroutine H.DSKO handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5EDC:	CALL	C6890			; take control from hook caller
	CALL	C5F09			; evaluate byte operand, evaluate unsigned integer operand
	CALL	C665E			; end of BASIC statement ?
	RET	NZ			; nope, quit (generates error later)
	PUSH	HL			; store BASIC pointer
	LD	L,30H			; Absolute sector write
J5EE9:	PUSH	HL			; store BDOS function
	PUSH	DE			; store sector number
	PUSH	BC			; store drive id
	LD	DE,TMPBUF
	LD	L,C			; drive id
	LD	C,31H			; Get disk parameters
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	DE,($DIRBUF)
	LD	C,1AH			; Set disk transfer address
	CALL	BDOS			; DiskBASIC BDOS call
	POP	HL			; restore id
	DEC	L			; drive id (0 based)
	LD	H,1			; number of sectors = 1
	POP	DE			; restore sector number
	POP	BC			; restore BDOS function
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	HL			; restore BASIC pointer
	RET

;	  Subroutine evaluate byte operand, evaluate unsigned integer operand
;	     Inputs  ________________________
;	     Outputs ________________________

C5F09:	LD	IX,GETBYT
	CALL	C664F			; evaluate byte operand
	PUSH	DE			; store byte
	CALL	C6654			; check for BASIC character
	DEFB	","
	LD	IX,GETUIN
	CALL	C664F			; evaluate unsigned integer operand
	POP	BC			; restore byte
	RET

;	  Subroutine H.DGET handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5F1E:	LD	IX,RETRTN		; subroutine = empty subroutine
	LD	IY,4*256		; parameter block offset = 4
	CALL	C59E9			; take control from hook caller (move parameters on stack)
	LD	A,(HL)			; i/o channel mode
	CP	4			; random i/o ?
	JP	NZ,J65EA		; nope, bad file mode error
	EX	(SP),HL			; store pointer to i/o channel, restore BASIC pointer
	CALL	C665E			; end of BASIC statement ?
	JR	Z,J5F7D			; yep,
	CALL	C6654			; check for BASIC character
	DEFB	","
	LD	IX,FRMEVL
	CALL	C664F			; evaluate expression
	PUSH	HL			; store BASIC pointer
	CALL	C6147			; convert DAC to 32 bit integer
	LD	A,C
	OR	B
	OR	L
	OR	H			; record number = 0 ?
	JP	Z,J662D			; yep, illegal function call error
	LD	A,C
	OR	B
	DEC	BC
	JR	NZ,J5F51
	DEC	HL			; record number zero based
J5F51:	EX	DE,HL
	POP	HL			; restore BASIC pointer
	EX	(SP),HL			; store BASIC pointer, restore pointer to i/o channel
	PUSH	HL			; store pointer to i/o channel
	PUSH	DE			; store high word record number
	INC	HL
	INC	HL			; +2
	LD	E,(HL)
	LD	D,0
	INC	DE			; record size
	CALL	C68A7			; multiply
	POP	IX
	PUSH	BC
	PUSH	IX
	POP	BC			; store low word result, restore high word record number
	CALL	C68AA			; multiply high word
	LD	A,L
	OR	H			; record within 32 bit limit ?
	JP	NZ,J662D		; nope, illegal function call error
	LD	E,C
	LD	D,B
	POP	HL			; restore low word result
	POP	BC			; restore pointer to i/o channel
	PUSH	BC			; store pointer to i/o channel
	INC	BC			; +1
	LD	A,(BC)
	LD	B,A			; file handle
	XOR	A			; relative to the beginning of the file
	LD	C,4AH			; Move file handle pointer
	CALL	BDOS			; DiskBASIC BDOS call
	POP	HL			; restore pointer to i/o channel
	EX	(SP),HL			; store pointer to i/o channel, restore BASIC pointer
J5F7D:	EX	(SP),HL			; store BASIC pointer, restore pointer to i/o channel
	INC	HL			; +1
	LD	B,(HL)			; file handle
	INC	HL
	LD	E,(HL)
	LD	D,0
	INC	DE			; record size
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL			; +9
	EX	DE,HL
	POP	IX			; restore BASIC pointer
	POP	AF			; restore GET/PUT flag
	PUSH	IX			; store BASIC pointer
	AND	A			; PUT ?
	LD	C,48H			; Read from file handle
	JR	Z,J5F99			; nope,
	LD	C,49H			; Write to file handle
J5F99:	CALL	C655D			; DiskBASIC BDOS call with error
	JP	J627A			; restore BASIC pointer and output back to screen

;	  Subroutine H.FIEL handler
;	     Inputs  ________________________
;	     Outputs ________________________

C5F9F:	CALL	C6890			; take control from hook caller
	CP	"#"
	CALL	Z,C665F			; get next BASIC character
	LD	IX,GETBYT
	CALL	C664F			; evaluate byte operand
	JP	Z,J6630			; end of statement, syntax error error
	PUSH	HL			; store BASIC pointer
	LD	IX,FILIDX
	CALL	C664F			; get pointer to i/o channel
	LD	E,L
	LD	D,H			; store pointer to i/o channel
	JP	Z,J6645			; i/o channel closed, file not OPEN error
	JP	C,J662D			; not a disk drive device, illegal function call error
	LD	A,(HL)			; file mode
	CP	4			; random i/o ?
	JP	NZ,J65EA		; nope, bad file mode error
	INC	HL
	INC	HL			; +2
	LD	L,(HL)
	LD	H,0
	INC	HL			; record size
	LD	(TMPBUF+0),HL		; store record size
	LD	HL,0
	LD	(TMPBUF+2),HL		; total field size = 0
	LD	BC,9			; offset = to i/o channel buffer
	POP	HL			; restore BASIC pointer
J5FDA:	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL			; update pointer in buffer
	LD	A,(HL)
	CP	","			; field definition follow ?
	RET	NZ			; nope, quit
	PUSH	DE			; store pointer in buffer
	LD	IX,GTBYTC
	CALL	C664F			; evaluate ,byte operand
	PUSH	AF			; store field size
	CALL	C6654			; check for BASIC character
	DEFB	"A"
	CALL	C6654			; check for BASIC character
	DEFB	"S"
	LD	IX,PTRGET
	CALL	C664F			; get address of variable
	LD	IX,GETYPR
	CALL	C664F			; get DAC type
	JP	NZ,J6627		; not a string, type mismatch error
	POP	AF			; restore field size
	EX	(SP),HL			; store BASIC pointer, restore pointer in buffer
	PUSH	DE			; store address of variable
	PUSH	HL			; store pointer in buffer
	LD	HL,(TMPBUF+2)
	LD	C,A
	LD	B,0			; total field size
	ADD	HL,BC
	LD	(TMPBUF+2),HL		; update total field size
	EX	DE,HL
	LD	HL,(TMPBUF+0)		; record size
	RST	DCOMPR			; compare
	JP	C,J6633			; total field size > record size, FIELD overflow error
	POP	DE			; restore pointer in buffer
	POP	HL			; restore address of variable
	LD	(HL),C			; size of string = field size
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; pointer to string = pointer in buffer

	IF	OPTM EQ 0
	LD	B,0			; ?? B is already zero
	ENDIF

	POP	HL			; restore BASIC pointer
	JR	J5FDA			; next field

;	  Subroutine H.RSET handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6025:	DEFB	0F6H		        ; OR xx: trick to skip next instrunction, reset Cx, RSET

;	  Subroutine H.LSET handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6026:	SCF				; LSET
	CALL	C6890			; take control from hook caller
	PUSH	AF			; store SET flag
	LD	IX,PTRGET
	CALL	C664F			; get address of variable (field variable)
	LD	IX,GETYPR
	CALL	C664F			; get DAC type
	JP	NZ,J6627		; not a string, type mismatch error
	PUSH	DE			; store addres of field variable
	LD	IX,FRMEQL
	CALL	C664F			; evaluate =expression
	POP	BC			; restore address of field variable
	EX	(SP),HL			; store BASIC pointer, restore LSET flag
	PUSH	HL			; store LSET flag
	PUSH	BC			; store address of field variable
	LD	IX,FRESTR
	CALL	C664F			; free temporary string descriptor
	LD	B,(HL)			; size of string
	EX	(SP),HL			; store string descriptor, restore address of field variable
	LD	A,(HL)
	LD	C,A			; size of field variable string
	PUSH	BC			; store size of string, size of field
	PUSH	HL			; store address of field variable
	PUSH	AF			; store string released
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; pointer to string of field variable
	OR	A			; size of field = 0 ?
	JR	Z,J60B9			; yep, clean up stack and quit (Cx is reset, so add spaces is skipped)
	LD	HL,(NULBUF)		; pointer to system i/o channel buffer
	DEC	HL
	RST	DCOMPR			; compare
	JR	C,J6097			; field string is in an i/o channel buffer, skip allocation
	LD	HL,(VARTAB)		; start of variable area
	RST	DCOMPR			; compare
	JR	C,J6097			; not a string in program (literal), skip allocation

; literal string

	LD	E,C
	LD	D,0			; size of field variable string
	LD	HL,(STKTOP)
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(FRETOP)
	RST	DCOMPR			; enough string space without garbage collect ?
	JR	C,J60CC			; nope,
	POP	AF			; discard string released

J6079:	LD	A,C			; size of field variable string
	LD	IX,GETSPA
	CALL	C664F			; allocate string space
	POP	HL			; restore address of field variable
	POP	BC			; restore size of string, size of field
	EX	(SP),HL			; store address of field variable, restore string descriptor
	PUSH	DE			; store pointer to string
	PUSH	BC			; store size of string, size of field
	LD	IX,FRESTR
	CALL	C664F			; free temporary string descriptor
	POP	BC			; restore size of string, size of field
	POP	DE			; restore pointer to string
	EX	(SP),HL			; store, restore address of field variable
	PUSH	BC			; store size of string, size of field
	PUSH	HL			; store address of field variable
	INC	HL
	PUSH	AF			; store string released
	LD	(HL),E
	INC	HL
	LD	(HL),D			; update pointer to string

J6097:	POP	AF			; restore string released
	POP	HL			; restore address of field variable
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; pointer to string
	POP	BC			; restore size of string, size of field
	POP	HL			; restore
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; pointer to string
	LD	A,C
	CP	B			; compare size of string with size of field
	JR	NC,J60A9		; size of field >= size of string
	LD	B,A
J60A9:	SUB	B
	LD	C,A			; number of spaces = size difference
	POP	AF			; restore SET flag
	CALL	NC,C60C3		; RSET, add spaces (before)
	INC	B
J60B0:	DEC	B
	JR	Z,J60BE			; copy finished, add spaces when LSET and quit
	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE
	JR	J60B0			; copy string

J60B9:	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC			; clean up stack
J60BE:	CALL	C,C60C3			; LSET add space (after)
	POP	HL
	RET

;	  Subroutine add spaces
;	     Inputs  DE = pointer in string, C = number of spaces
;	     Outputs ________________________

C60C3:	LD	A," "			; character = space
	INC	C			; counter +1
J60C6:	DEC	C			; update counter
	RET	Z			; finished, quit
	LD	(DE),A			; add space
	INC	DE
	JR	J60C6			; next

; keep string when garbage collect may be required

J60CC:	POP	AF			; discard string released
	POP	HL			; restore address of field variable
	POP	BC			; restore size of string, size of field
	EX	(SP),HL			; store address of field variable, restore string descriptor
	EX	DE,HL
	JR	NZ,J60E0		; string not released, skip allocation
	PUSH	BC			; store size of string, size of field
	LD	A,B			; size of string
	LD	IX,STRINI
	CALL	C664F			; allocate temp string
	CALL	C6107			; push temporary string descriptor to temporary descriptor heap
	POP	BC			; restore size of string, size of field
J60E0:	EX	(SP),HL			; store pointer to string, restore address of variable
	PUSH	BC			; store size of string, size of field
	PUSH	HL			; store address of variable
	JP	J6079			; continue

;	  Subroutine H.MKI$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C60E6:	LD	A,2			; integer, size of string = 2
	DEFB	001H			; LD BC,xxxx: skip next instruction

;	  Subroutine H.MKS$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C60E9:	LD	A,4			; single float, size of string = 4
	DEFB	001H			; LD BC,xxxx: skip next instruction

;	  Subroutine H.MKD$ handler
;	     Inputs  ________________________
;	     Outputs ________________________

C60EC:	LD	A,8			; double float, size of string = 8
	CALL	C6890			; take control from hook caller
	PUSH	AF			; store size of string
	LD	IX,DOCNVF
	CALL	C664F			; convert DAC to other type
	POP	AF			; restore size of string
	LD	IX,STRINI
	CALL	C664F			; allocate temp string
	LD	HL,(DSCTMP+1)		; pointer to temp string
	CALL	VMOVMF			; copy variable content from DAC

;	  Subroutine push temporary string descriptor to temporary descriptor heap
;	     Inputs  ________________________
;	     Outputs ________________________

C6107:	LD	DE,DSCTMP		; temporary string descriptor
	LD	HL,(TEMPPT)		; temporary string descriptor heap pointer
	LD	(DAC+2),HL		; pointer to string descriptor
	LD	A,3
	LD	(VALTYP),A		; DAC = string
	CALL	VMOVE			; copy string descriptor
	LD	DE,TEMPST+30+3
	RST	DCOMPR			; temporary string descriptor heap full ?
	LD	(TEMPPT),HL		; update temporary string descriptor heap pointer
	JP	Z,J6624			; yep, string formular too complex error
	RET

;	  Subroutine H.CVI handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6123:	LD	A,2-1			; integer, size of string = 2
	DEFB	001H			; LD BC,xxxx: skip next instruction

;	  Subroutine H.CVS handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6126:	LD	A,4-1			; single float, size of string = 4
	DEFB	001H			; LD BC,xxxx: skip next instruction

;	  Subroutine H.CVD handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6129:	LD	A,8-1			; double float, size of string = 8
	CALL	C6890			; take control from hook caller
	PUSH	AF			; store target size -1
	LD	IX,FRESTR
	CALL	C664F			; free temporary string descriptor
	POP	AF			; restore target size -1
	CP	(HL)			; field size to small ?
	JP	NC,J662D		; yep, illegal function call error
	INC	A			; target size
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,C			; pointer to string
	LD	(VALTYP),A		; target type
	JP	VMOVFM			; copy variable content to DAC

;	  Subroutine convert DAC to 32 bit integer
;	     Inputs  ________________________
;	     Outputs ________________________

C6147:	LD	IX,GETYPR
	CALL	C664F			; get DAC type
	JP	M,J61B3			; integer, handle
	JP	Z,J6627			; string, type mismatch error
	LD	HL,DAC
	LD	A,(HL)
	AND	A			; sign float is positive ?
	JP	M,J662D			; nope, illegal function call error
	LD	DE,TMPBUF
	LD	BC,8
	LDIR				; store DAC (orginal operand)
	LD	HL,I61C0		; double float 65536
	LD	DE,ARG
	LD	C,8
	LDIR				; ARG = 65536
	CALL	DECDIV			; divide double float
	AND	A			; DAC type = double float
	CALL	INT			; integer part of float
	LD	IX,GETUI
	CALL	C664F			; convert to unsigned integer
	PUSH	DE			; store high word
	EX	DE,HL
	LD	IX,FLTLIN
	CALL	C664F			; convert unsigned integer to single float
	CALL	CONDS			; convert DAC from single float to double float
	LD	BC,06545H
	LD	DE,06053H		; single float = 65536
	CALL	SGNMUL			; single float multiply
	LD	HL,DAC
	PUSH	HL			; store pointer to DAC
	LD	DE,ARG
	LD	BC,8
	LDIR				; copy DAC to ARG
	LD	HL,TMPBUF
	POP	DE			; store pointer to DAC
	LD	C,8
	LDIR				; DAC = orginal operand
	CALL	DECSUB			; subtract double float
	LD	IX,GETUI
	CALL	C664F			; convert to unsigned integer
	LD	C,E
	LD	B,D
	POP	HL			; restore high word
	RET

J61B3:	LD	BC,(DAC+2)		; integer value
	INC	B
	DEC	B			; sign is positve ?
	JP	M,J662D			; nope, illegal function call error
	LD	HL,0			; high word = 0
	RET

I61C0:	DEFB	045H,065H,053H,060H,0,0,0,0

;	  Subroutine H.EOF handler (EOF for disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C61C8:	CALL	C6890			; take control from hook caller
	PUSH	HL			; store pointer to i/o channel
	CALL	C5B60			; read character from i/o channel
	LD	HL,0			; assume no end of file
	JR	NC,J61D5		; not at end of file, continue
	DEC	HL			; end of file
J61D5:	PUSH	AF			; store character
	CALL	MAKINT			; integer to DAC
	POP	AF			; restore character
	POP	HL			; restore pointer to i/o channel
	INC	HL
	INC	HL
	INC	HL			; +3
	LD	(HL),A			; save character as backup character
	RET

;	  Subroutine H.FILE handler
;	     Inputs  ________________________
;	     Outputs ________________________

C61E0:	CALL	C6890			; take control from hook caller
	CALL	C665E			; end of BASIC statement ?
	JR	Z,J61F1			; yep, list all files
	CP	","			; operand seperator ?
	JR	Z,J61F1			; yep, list all files
	CALL	C6350			; check for "file name" and disk device
	JR	J61F7			; list specified files

J61F1:	XOR	A
	LD	DE,(PATHNAM)
	LD	(DE),A			; empty BASIC path buffer
J61F7:	CALL	C665E			; end of BASIC statement ?
	SCF				; assume output format = short
	JR	Z,J6206			; yep, continue
	CALL	C6654			; check for BASIC character
	DEFB	","
	CALL	C6654			; check for BASIC character
	DEFB	"L"
	AND	A			; output format = long
J6206:	PUSH	HL			; store BASIC pointer
	LD	A,(PRTFLG)
	INC	A
	DEC	A			; output to printer ?
	PUSH	AF			; store output format, output to printer
	LD	IX,CRDONZ
	CALL	C664F			; newline to OUTDO if not at start of line
	POP	AF			; restore output format, output to printer
	PUSH	AF			; store output format, output to printer
	LD	A,16H			; directory + system + hidden attribute
	JR	NC,J621C		; long format,
	LD	A,10H			; directory attribute
J621C:	CALL	C599D			; find first directory entry
	LD	A,C
	ADD	A,40H			; convert drive id to drive letter
	RST	OUTDO
	LD	A,":"
	RST	OUTDO
	LD	A,"\"
	RST	OUTDO
	LD	DE,TMPBUF+64+1		; pointer in temporary buffer
	PUSH	DE			; store pointer in temporary buffer
	LD	C,5EH			; Get whole path string
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	(HL),A			; add end marker at start of last item
	DEC	HL
	LD	(HL),A
	POP	HL			; restore pointer in temporary buffer
	CALL	C62FC			; ASCIIZ string to interpreter output
	LD	IX,CRDO
	CALL	C664F			; new line to OUTDO

J6240:	POP	AF			; restore output format, output to printer
	PUSH	AF			; store output format, output to printer
	CALL	C6282			; directory entry to interpreter output
	CALL	CKCNTC			; check for CTRL-STOP
	POP	AF			; restore output format, output to printer
	PUSH	AF			; store output format, output to printer
	JR	NC,J6267		; long format, new line and continue
	LD	A,(LINLEN)
	LD	B,A			; assume column width = screen width
	LD	A,(TTYPOS)		; assume current screen column
	JR	Z,J625A			; output to screen,
	LD	B,80			; printer, column width = 80
	LD	A,(LPTPOS)		; current printer column
J625A:	AND	A			; at start of line ?
	JR	Z,J626E			; yep,
	ADD	A,13			; update column
	CP	B			; still fits on line ?
	JR	NC,J6267		; nope, new line and continue
	LD	A," "
	RST	OUTDO			; space to interpreter output
	JR	J626E			; continue

J6267:	LD	IX,CRDO
	CALL	C664F			; new line to interpreter output

J626E:	LD	IX,TMPBUF
	LD	C,41H			; Find next entry
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J6240			; no error, next
	POP	AF			; restore output format, output to printer
J627A:	POP	HL			; restore BASIC pointer
	LD	IX,FINPRT
	JP	C664F			; return interpreter output to screen

;	  Subroutine directory entry to interpreter output
;	     Inputs  ________________________
;	     Outputs ________________________

C6282:	JR	NC,J62A4		; long format,

;	  Subroutine file name and extension to interpreter output
;	     Inputs  ________________________
;	     Outputs ________________________

C6284:	LD	DE,TMPBUF+1
	LD	HL,(PATHNAM)		; BASIC path buffer
	LD	C,5CH			; Parse filename
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	B,8			; size = 8
	CALL	C629E			; characters to interpreter output
	LD	A,(HL)
	CP	" "			; file extension ?
	JR	Z,J629B			; nope, use space
	LD	A,"."			; use dot
J629B:	RST	OUTDO			; character to interpreter output
	LD	B,3			; size = 3

;	  Subroutine characters to interpreter output
;	     Inputs  ________________________
;	     Outputs ________________________

C629E:	LD	A,(HL)			; character
	RST	OUTDO			; character to interpreter output
	INC	HL
	DJNZ	C629E			; next
	RET

J62A4:	CALL	C6284			; file name and extension to interpreter output
	LD	A," "			; space
	RST	OUTDO			; character to interpreter output
	LD	A,(TMPBUF+14)
	LD	C,A			; attribute
	BIT	4,C			; directory ?
	LD	A,"d"			; character = directory
	CALL	C62F6			; character or - to interpreter output
	BIT	0,C			; read only ?
	LD	A,"r"			; character = read only
	CALL	C62F6			; character or - to interpreter output
	BIT	1,C			; hidden ?
	LD	A,"h"			; character = hidden
	CALL	C62F6			; character or - to interpreter output
	BIT	2,C			; system ?
	LD	A,"s"			; character = system
	CALL	C62F6			; character or - to interpreter output
	BIT	5,C			; archive ?
	LD	A,"a"			; character = archive
	CALL	C62F6			; character or - to interpreter output
	LD	BC,(TMPBUF+21)
	LD	HL,(TMPBUF+23)		; file size
	CALL	C63BA			; convert 32 bit integer to double float
	LD	IX,JPFOUT
	CALL	C664F			; convert DAC to text, unformatted
	INC	HL			; skip leading space
	PUSH	HL			; store pointer to text
	LD	B,12
J62E6:	LD	A,(HL)
	INC	HL
	DEC	B
	AND	A			; end marker ?
	JR	NZ,J62E6		; nope, next
	LD	A," "
J62EE:	RST	OUTDO
	DJNZ	J62EE			; leading spaces to interpreter output
	POP	HL			; restore pointer to text
	CALL	C62FC			; ASCIIZ string to interpreter output
	RET

;	  Subroutine character or - to interpreter output
;	     Inputs  ________________________
;	     Outputs ________________________

C62F6:	JR	NZ,J62FA		; bit set, use character
	LD	A,"-"			; character = -
J62FA:	RST	OUTDO			; character to interpreter output
	RET

;	  Subroutine ASCIIZ string to interpreter output
;	     Inputs  ________________________
;	     Outputs ________________________

C62FC:	LD	A,(HL)
	AND	A
	INC	HL
	RET	Z
	RST	OUTDO
	JR	C62FC

;	  Subroutine H.KILL handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6303:	CALL	C6890			; take control from hook caller
	CALL	C6350			; check for "file name" and disk device
	CALL	C665E			; end of BASIC statement ?
	RET	NZ			; nope, quit (generates error later)
	PUSH	HL			; store BASIC pointer
	CALL	C59D1			; DiskBASIC BDOS find first entry normal file with error handling
	LD	C,4DH			; Delete file or subdirectory
	JR	J632E			; execute BDOS function, restore BASIC pointer and quit

;	  Subroutine H.NAME handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6315:	CALL	C6890			; take control from hook caller
	CALL	C6350			; check for "file name" and disk device
	PUSH	HL			; store BASIC pointer
	CALL	C59D1			; DiskBASIC BDOS find first entry normal file with error handling
	POP	HL			; restore BASIC pointer
	CALL	C6654			; check for BASIC character
	DEFB	"A"
	CALL	C6654			; check for BASIC character
	DEFB	"S"
	CALL	C6350			; check for "file name" and disk device
	PUSH	HL			; store BASIC pointer
	LD	C,4EH			; Rename file or subdirectory
J632E:	PUSH	BC			; store BDOS function
	LD	DE,TMPBUF
	LD	HL,(PATHNAM)		; BASIC path buffer
	CALL	C655D			; DiskBASIC BDOS call with error
	CALL	C59D8			; DiskBASIC BDOS find next entry with error handling
	POP	BC			; restore BDOS function
	JR	NC,J632E		; file found, next file
	CALL	C6343			; flush buffers of all drives
	POP	HL			; restore BASIC pointer
	RET

;	  Subroutine flush buffers of all drives
;	     Inputs  ________________________
;	     Outputs ________________________

C6343:	LD	B,0FFH			; all drives
	LD	D,0			; flush only
	LD	C,5FH			; Flush disk buffers
	JP	C655D			; DiskBASIC BDOS call with error

;	  Subroutine check for ("file name" and disk device
;	     Inputs  ________________________
;	     Outputs ________________________

C634C:	CALL	C6654			; check for BASIC character
	DEFB	"("

;	  Subroutine check for "file name" and disk device
;	     Inputs  ________________________
;	     Outputs ________________________

C6350:	LD	IX,FILEVL
	CALL	C664F			; evaluate file name
	LD	A,D
	CP	9			; device = disk drive ?
	RET	C			; yep, quit
	JP	J65ED			; bad drive name error

;	  Subroutine H.LOF handler (LOF disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C635E:	LD	A,2			; type = LOF
	DEFB	011H			; LD DE,xxxx: skip next instruction

;	  Subroutine H.LOC handler (LOC disk device)
;	     Inputs  ________________________
;	     Outputs ________________________

C6361:	LD	A,1			; type = LOC
	CALL	C6890			; take control from hook caller
	PUSH	AF			; store type
	LD	IX,CONINT
	CALL	C664F			; convert to byte
	LD	IX,FILIDX
	CALL	C664F			; get i/o channel pointer
	JP	C,J662D			; not a disk drive device, illegal function call error
	JP	Z,J6645			; i/o channel closed, file not OPEN error
	INC	HL			; +1
	LD	B,(HL)			; file handle
	INC	HL			; +2
	LD	C,(HL)			; random record size -1
	LD	A,1			; relative to current file pointer
	LD	DE,0
	LD	HL,0			; offset = 0
	PUSH	BC			; store file handle, record size -1
	LD	C,4AH			; Move file handle pointer
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	BC			; restore file handle, record size -1
	POP	AF			; restore type
	DEC	A			; LOF ?
	JR	NZ,J6399		; yep,
	PUSH	BC			; store file handle, record size -1
	CALL	C63E4			; current file pointer / record size
	POP	BC			; restore file handle, record size -1
	JR	J63B7			; return result

J6399:	PUSH	HL
	PUSH	DE			; store current file pointer
	LD	A,2			; relative to end of file
	LD	DE,0
	LD	HL,0			; offset = 0
	LD	C,4AH			; Move file handle pointer
	PUSH	BC			; store file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	BC			; restore file handle
	POP	IX
	EX	(SP),HL
	PUSH	DE
	PUSH	IX
	POP	DE			; store file size, restore current file pointer
	XOR	A			; relative to begin of file
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	DE
	POP	HL			; restore file size
J63B7:	LD	C,L
	LD	B,H
	EX	DE,HL

;	  Subroutine convert 32 bit integer to double float
;	     Inputs  ________________________
;	     Outputs ________________________

C63BA:	PUSH	BC			; store low word
	LD	IX,FLTLIN
	CALL	C664F			; convert unsigned integer to single float
	LD	BC,06545H
	LD	DE,06053H		; 65536
	CALL	SGNMUL			; single float multiply
	LD	HL,DAC
	LD	DE,ARG
	LD	BC,8
	LDIR				; copy DAC to ARG
	POP	HL			; restore low word
	LD	IX,FLTLIN
	CALL	C664F			; convert unsigned integer to single float
	CALL	CONDS			; convert DAC from single float to double float
	JP	DECADD			; add double

;	  Subroutine current file pointer / record size
;	     Inputs  ________________________
;	     Outputs ________________________

C63E4:	INC	C			; to record size
	JR	NZ,J63EF		; record size <> 256, divide32
	LD	A,L
	LD	L,H
	LD	H,E
	LD	E,D
	LD	D,0			; DEHL = DEHL / 256, A = remainer
	JR	J6403			; continue

J63EF:	XOR	A
	LD	B,32+1
J63F2:	ADC	A,A
	JR	C,J63F9
	CP	C
	CCF
	JR	NC,J63FB
J63F9:	SUB	C
	SCF
J63FB:	ADC	HL,HL
	EX	DE,HL
	ADC	HL,HL
	EX	DE,HL
	DJNZ	J63F2

J6403:	OR	A			; remainer = 0 ?
	RET	Z			; yep, quit
	INC	L
	RET	NZ
	INC	H
	RET	NZ
	INC	E
	RET	NZ
	INC	D			; DEHL = DEHL +1
	RET

;	  Subroutine H.DSKF
;	     Inputs  ________________________
;	     Outputs ________________________

C640D:	CALL	C6890			; take control from hook caller
	LD	IX,CONINT
	CALL	C664F			; convert to byte
	AND	A			; default drive ?
	CALL	NZ,C5846		; nope, check if valid disk drive
	LD	E,A
	LD	C,1BH			; Get allocation information
	CALL	BDOS			; DiskBASIC BDOS call
	JP	MAKINT			; integer to DAC

;	  Subroutine H.COPY handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6424:	CALL	C6890			; take control from hook caller
	CALL	C6350			; check for "file name" and disk device
	PUSH	HL			; store BASIC pointer
	CALL	C59D1			; DiskBASIC BDOS find first entry normal file with error handling
	POP	HL			; restore BASIC pointer
	CALL	C665E			; end of BASIC statement ?

	IF	OPTM EQ 0
	LD	A,0
	ENDIF

	PUSH	HL			; store BASIC pointer
	LD	HL,(PATHNAM)

	IF	OPTM EQ 0
	LD	(HL),A			; BASIC path buffer = empty
	ELSE
	LD	(HL),0			; BASIC path buffer = empty
	ENDIF

	POP	HL			; restore BASIC pointer
	JR	Z,J6447			; yep, skip destination file specification
	CALL	C6654			; check for BASIC character
	DEFB	0D9H			; TO
	CALL	C6350			; check for "file name" and disk device
	CALL	C665E			; end of BASIC statement ?
	RET	NZ			; nope, quit
J6447:	PUSH	HL			; store BASIC pointer
J6448:	CALL	CKCNTC			; check for CTRL-STOP
	LD	DE,TMPBUF		; source FIB
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	A,B
	LD	(TMPBUF+128),A		; store file handle source file
	XOR	A
	LD	C,56H			; Get/set file handle date and time
	CALL	C655D			; DiskBASIC BDOS call with error
	LD	(TMPBUF+130),DE
	LD	(TMPBUF+132),HL		; store date and time source file
	LD	A,0FFH
	LD	(TMPBUF+129),A		; file handle destination file = destination file not open
	LD	HL,I6532
	LD	(BREAKV),HL		; register DOS1 abort handler
	CALL	C6518			; determine maximium sized temporary buffer
	LD	E,C
	LD	D,B			; start of buffer
J6475:	PUSH	HL			; store size of buffer
	PUSH	DE			; store start of buffer
J6477:	LD	A,L
	OR	H			; space left in buffer ?
	JR	Z,J6498			; nope, write buffer to destination file
	PUSH	HL			; store space left in buffer
	PUSH	DE			; store end of bytes read in buffer
	LD	A,(TMPBUF+128)
	LD	B,A			; file handle source file
	LD	C,48H			; Read from file handle
	CALL	BDOS			; DiskBASIC BDOS call
	JR	Z,J648A			; no error,
	CP	0C7H			; End of file ?
J648A:	JP	NZ,J6538		; nope,
	EX	DE,HL
	POP	HL			; restore store end of bytes read in buffer
	ADD	HL,DE			; + bytes read
	EX	(SP),HL			; store end of bytes read in buffer, restore space left in buffer
	SBC	HL,DE			; space left in buffer = space left in buffer - bytes read
	LD	A,E
	OR	D			; read something ?
	POP	DE			; restore end of bytes read in buffer
	JR	NZ,J6477		; yep, 

; write buffer to destination file

J6498:	EX	DE,HL
	POP	DE			; restore start of buffer
	PUSH	DE			; store start of buffer
	SBC	HL,DE			; number of bytes in buffer = end of bytes read in buffer - start of buffer
	LD	A,(TMPBUF+129)
	INC	A			; destination file already open ?
	JR	NZ,J64CC		; yep, skip
	PUSH	HL			; store number of bytes in buffer
	LD	HL,TMPBUF+1
	LD	DE,TMPBUF+1+64
	LD	BC,13
	LDIR				; copy file name and extension from source FIB
	LD	DE,(PATHNAM)		; destination file specification = BASIC path buffer
	LD	B,0			; attribute = normal file
	LD	IX,TMPBUF+64		; FIB buffer destination file
	LD	C,42H			; Find new entry
	CALL	C6534			; BDOS function for COPY, close file handles if error
	LD	DE,TMPBUF+64		; FIB destination file
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6534			; BDOS function for COPY, close file handles if error
	LD	A,B
	LD	(TMPBUF+129),A		; store file handle destination file
	POP	HL			; restore number of bytes in buffer
J64CC:	POP	DE			; restore start of buffer
	LD	A,(TMPBUF+129)
	LD	B,A			; file handle source file
	PUSH	DE			; store start of buffer
	LD	C,49H			; Write to file handle
	CALL	C6534			; BDOS function for COPY, close file handles if error
	POP	DE			; restore start of buffer
	POP	BC			; restore size of buffer
	SBC	HL,BC			; bytes written - size of buffer
	LD	L,C
	LD	H,B			; size of buffer
	JR	NC,J6475		; full buffer written, not at end of file, next part of file
	LD	A,(TMPBUF+129)
	LD	B,A			; file handle
	LD	A,1			; set date and time destination file
	LD	IX,(TMPBUF+130)
	LD	HL,(TMPBUF+132)		; date and time of source file
	LD	C,56H			; Get/set file handle date and time
	CALL	C6534			; BDOS function for COPY, close file handles if error
	LD	A,(TMPBUF+128)
	LD	B,A			; file handle
	LD	C,45H			; Close file handle
	CALL	C6534			; BDOS function for COPY, close file handles if error
	LD	A,(TMPBUF+129)
	LD	B,A			; file handle
	LD	C,45H			; Close file handle
	CALL	C6534			; BDOS function for COPY, close file handles if error
	LD	HL,I6568
	LD	(BREAKV),HL		; register DOS1 abort handler
	CALL	C59D8			; DiskBASIC BDOS find next entry with error handling
	JP	NC,J6448		; file found, next
	POP	HL			; restore BASIC pointer
	RET

;	  Subroutine save start and end, determine maximium sized temporary buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6511:	LD	(SAVENT),HL		; store start
	LD	(SAVEND),BC		; store end

;	  Subroutine determine maximium sized temporary buffer
;	     Inputs  ________________________
;	     Outputs BC = start address of buffer, HL = size of buffer

C6518:	LD	HL,-512
	ADD	HL,SP
	JR	NC,J652A
	LD	BC,(STREND)
	AND	A
	SBC	HL,BC
	JR	C,J652A
	LD	A,H
	AND	A
	RET	NZ
J652A:	LD	BC,(NULBUF)
	LD	HL,256
	RET

; pointer to DOS1 abort handler

I6532:	DEFW	C656A

;	  Subroutine BDOS function for COPY, close file handles if error
;	     Inputs  ________________________
;	     Outputs ________________________

C6534:	CALL	BDOS			; DiskBASIC BDOS call
	RET	Z

J6538:	PUSH	AF
	LD	HL,I6568
	LD	(BREAKV),HL		; register DOS1 abort handler
	LD	A,(TMPBUF+128)
	LD	B,A			; file handle
	LD	C,45H			; Close file handle
	CALL	BDOS			; DiskBASIC BDOS call
	LD	A,(TMPBUF+129)
	LD	B,A			; file handle
	INC	A
	LD	C,45H			; Close file handle
	CALL	NZ,BDOS			; DiskBASIC BDOS call
	POP	AF
	JR	J65C3			; generate appropriate error

;	  Subroutine DiskBASIC BDOS call with error handling, file specification in BASIC path buffer, temporary buffer for FIB
;	     Inputs  ________________________
;	     Outputs ________________________

J6555:	LD	IX,TMPBUF		; FIB buffer = temporary buffer

;	  Subroutine DiskBASIC BDOS call BASIC path buffer with error
;	     Inputs  ________________________
;	     Outputs ________________________

C6559:	LD	DE,(PATHNAM)		; BASIC path buffer

;	  Subroutine DiskBASIC BDOS call with error
;	     Inputs  ________________________
;	     Outputs ________________________

C655D:	CALL	BDOS			; DiskBASIC BDOS call
	RET	Z			; no error, quit
	JR	J65C3			; generate appropriate error

; pointer to DOS1 disk error handler

I6563:	DEFW	C6565

;	  Subroutine DOS1 disk error handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6565:	LD	C,2			; action = abort
	RET

; pointer to DOS1 abort handler

I6568:	DEFW	C6571

;	  Subroutine DOS1 abort handler
;	     Inputs  ________________________
;	     Outputs ________________________

C656A:	CP	9DH			; diskoperation aborted ?
	JR	NZ,J656F		; nope, quit
	LD	A,B			; orginal error of the aborted diskoperation
J656F:	OR	A
	RET

;	  Subroutine DOS1 abort handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6571:	CALL	C656A
	JR	NZ,J65C3		; generate appropriate error
	LD	IX,READYR
	JP	C664F			; (re)start BASIC

I657D:	DEFB	0BAH
        DEFB	03EH			; .NRAMD -> Bad drive name
        DEFB	04BH			; .RAMDX -> RAM disk already exists
        DEFB	0BDH
        DEFB	0BEH
        DEFB	0BFH
        DEFB	0C0H
        DEFB	0C1H
        DEFB	0C2H
        DEFB	0C3H
        DEFB	0C4H
        DEFB	0C5H
        DEFB	0C6H
        DEFB	037H			; .EOF -> Input past end
        DEFB	03CH			; .FILE -> Bad allocation table
        DEFB	0C9H
        DEFB	040H			; .FOPEN -> File still open
        DEFB	041H			; .FILEX -> File already exists
        DEFB	049H			; .DIRX -> Directory already exists
        DEFB	041H			; .SYSX -> File already exists
        DEFB	038H			; .DOT -> Bad file name
        DEFB	0CFH
        DEFB	041H			; .DIRNE -> File already exists
        DEFB	048H			; .FILRO -> File write protected
        DEFB	0D2H
        DEFB	041H			; .DUPF -> File already exists
        DEFB	042H			; .DKFUL -> Disk full
        DEFB	043H			; .DRFUL -> Too many files
        DEFB	04AH			; .NODIR -> Directory not found
        DEFB	035H			; .NOFIL -> File not found
        DEFB	038H			; .PLONG -> Bad filename
        DEFB	038H			; .IPATH -> Bad filename
        DEFB	038H			; .IFNM -> Bad filename
        DEFB	03EH			; .IDRV -> Bad drivename
        DEFB	0DCH
        DEFB	0DDH
        DEFB	0DEH
        DEFB	0DFH
        DEFB	0E0H
        DEFB	0E1H
        DEFB	0E2H
        DEFB	0E3H
        DEFB	0E4H
        DEFB	0E5H
        DEFB	0E6H
        DEFB	0E7H
        DEFB	0E8H
        DEFB	0E9H
        DEFB	0EAH
        DEFB	0EBH
        DEFB	0ECH
        DEFB	0EDH
        DEFB	0EEH
        DEFB	0EFH
        DEFB	0F0H
        DEFB	0F1H
        DEFB	03CH			; .IFAT -> Bad allocation table
        DEFB	045H			; .SEEK -> Disk I/O error
        DEFB	045H			; .WFILE -> Disk I/O error
        DEFB	045H			; .WDISK -> Disk I/O error
        DEFB	045H			; .NDOS -> Disk I/O error
        DEFB	045H			; .UFORM -> Disk I/O error
        DEFB	044H			; .WPROT -> Disk write protected
        DEFB	045H			; .RNF -> Disk I/O error
        DEFB	045H			; .DATA -> Disk I/O error
        DEFB	045H			; .VERFY -> Disk I/O error
        DEFB	046H			; .NRDY -> Disk offline
        DEFB	045H			; .DISK -> Disk I/O error
        DEFB	045H			; .WRERR -> Disk I/O error
        DEFB	045H			; .NCOMP -> Disk I/O error

;	  Subroutine generate appropriate error
;	     Inputs  A = BDOS error
;	     Outputs ________________________

J65C3:	PUSH	AF			; store BDOS error
	CALL	C6343			; flush buffers of all drives
	POP	AF			; restore BDOS error
	CP	9FH			; CTRL-STOP pressed ?
	JR	Z,J65CE			; yep,
	CP	9EH			; CTRL-C pressed ?
J65CE:	LD	IX,READYR
	JR	Z,C664F			; yep, (re)start BASIC
	LD	E,A			; store BDOS error
	CP	0BAH			; can BDOS error translated ?
	JR	C,J65E6			; nope, use BDOS error
	LD	C,A
	LD	B,0			; BDOS error
	LD	HL,I657D-0BAH		; BDOS error translation table
	ADD	HL,BC
	LD	A,(HL)
	LD	E,A			; translated error
	CP	3CH			; disk BASIC error ?
	JR	C,J6623			; nope, skip close of system i/o channel

J65E6:	DEFB	001H			; LD BC,xxxx: skip next instruction

	IF	OPTM EQ 0
	LD	E,03CH
	DEFB	001H			; LD BC,xxxx: skip next instruction
	ENDIF

J65EA:	LD	E,03DH
	DEFB	001H			; LD BC,xxxx: skip next instruction

J65ED:	LD	E,03EH
	IF	OPTM EQ 0
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,03FH
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,040H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,041H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,042H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,043H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,044H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,045H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,046H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,047H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,048H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,049H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,04AH
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,04BH
	ENDIF

	XOR	A
	LD	(NLONLY),A		; close i/o channels, no BASIC program loading
	PUSH	DE			; store error
					; A=0, i/o channel 0
	LD	IX,CLSFIL		; close i/o channel
	CALL	C664F
	POP	DE			; restore error
J6623:	DEFB	001H			; LD BC,xxxx: skip next instruction

J6624:	LD	E,16
	DEFB	001H			; LD BC,xxxx: skip next instruction

J6627:	LD	E,13
	DEFB	001H			; LD BC,xxxx: skip next instruction

J662A:	LD	E,7
	DEFB	001H			; LD BC,xxxx: skip next instruction

J662D:	LD	E,5
	DEFB	001H			; LD BC,xxxx: skip next instruction

J6630:	LD	E,2
	DEFB	001H			; LD BC,xxxx: skip next instruction

J6633:	LD	E,032H
	DEFB	001H			; LD BC,xxxx: skip next instruction

	IF	OPTM EQ 0
        LD	E,034H
	DEFB	001H			; LD BC,xxxx: skip next instruction

        LD	E,035H
	DEFB	001H			; LD BC,xxxx: skip next instruction
	ENDIF

J663C:	LD	E,036H
	DEFB	001H			; LD BC,xxxx: skip next instruction

	IF	OPTM EQ 0
        LD	E,037H
	DEFB	001H			; LD BC,xxxx: skip next instruction
	ENDIF

J6642:	LD	E,038H
	DEFB	001H			; LD BC,xxxx: skip next instruction

J6645:	LD	E,03BH

	XOR	A
	LD	(FLBMEM),A		; load or save ASCII file
	LD	IX,ERROR		; BASIC error

;	  Subroutine call BASIC routine
;	     Inputs  ________________________
;	     Outputs ________________________

C664F:	CALL	CALBAS
	EI
	RET

;	  Subroutine check for BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C6654:	CALL	C665E			; get BASIC character
	EX	(SP),HL			; store BASIC pointer, restore return address
	CP	(HL)			; correct BASIC character ?
	JR	NZ,J6630		; nope, syntax error error
	INC	HL			; after BASIC character
	EX	(SP),HL			; store new return address, restore BASIC pointer
	INC	HL			; update BASIC pointer

;	  Subroutine get BASIC character
;	     Inputs  ________________________
;	     Outputs Zx set if end of BASIC statement

C665E:	DEC	HL

;	  Subroutine get next BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C665F:	LD	IX,CHRGTR
	JR	C664F

;	  Subroutine H.PARD handler (parse device name)
;	     Inputs  ________________________
;	     Outputs ________________________

C6665:	EI
	LD	A,":"
	CP	(HL)			; empty devicename ?
	JR	Z,J6642			; yep, bad file name error
	PUSH	HL			; store pointer in file specification
	PUSH	DE			; store size of file specification
	LD	A,E
	CP	63+1			; size of filespecification > 63 ?
	JR	NC,J6642		; yep, bad file name error
	LD	C,E
	LD	B,0			; size of file specification
	LD	DE,(PATHNAM)		; BASIC path buffer
	PUSH	BC			; store size of file specification
	PUSH	DE			; store pointer to BASIC path buffer
	LDIR				; copy to BASIC path buffer
	XOR	A
	LD	(DE),A			; add end marker
	POP	HL			; restore pointer to BASIC path buffer
	POP	BC			; restore size of file specification
	CPIR				; null character in string ?
	JR	Z,J6642			; yep, bad file name error
	LD	C,5BH			; Parse path name
	CALL	C6559			; DiskBASIC BDOS call BASIC path buffer with error
	LD	A,(DE)
	CP	":"			; termination character = device name seperator ?
	JR	NZ,J6692		; nope,
	POP	DE			; restore size of file specification
	POP	HL			; restore pointer to file specification
	RET

J6692:	BIT	2,B			; drive name specified ?
	JR	NZ,J6698		; yep, use logical drive id
	LD	C,0			; logical drive id = default drive
J6698:	LD	A,B			; flags
	AND	0C2H			; last item .. OR last item . OR drive name specified ?
	JR	Z,J66A7			; nope,
	LD	A,(DE)
	OR	A			; termination character = end of string ?
	JR	NZ,J6642		; nope, bad file name error
	POP	DE			; restore size of file specification
	LD	E,A			; size of file specification = 0
	PUSH	DE			; store size of file specification
	PUSH	BC			; store flags
	JR	J66F4			; quit

J66A7:	POP	DE			; restore size of file specification
	POP	HL			; restore pointer to file specification
	LD	IX,(PATHNAM)		; BASIC path buffer
	BIT	2,B			; drive name specified ?
	JR	Z,J66B9			; nope,
	INC	HL
	INC	HL			; update pointer in file specfication
	DEC	E
	DEC	E			; update size of file specification
	INC	IX
	INC	IX			; update pointer in BASIC path buffer
J66B9:	PUSH	HL			; restore pointer to file specification
	PUSH	DE			; restore size of file specification
	PUSH	BC			; store flags
	INC	E
	DEC	E			; end of file specification ?
	JR	Z,J66F4			; yep, quit
	LD	C,E			; store counter
	LD	A,(HL)
	CP	" "			; seperator = space ?
	JP	Z,J6642			; yep, bad file name error
	LD	B,8			; maximum size element = 8 (file name)
	CALL	C6731			; validate and copy element
	JR	Z,J66F1			; end of string,
	BIT	1,D			; start of double byte character ?
	JR	Z,J66D4
	DEC	IX			; yep, dispose character
J66D4:	LD	A,"."
	LD	(IX+0),A		; filename seperator
	INC	IX
	CP	(HL)			; source at filename seperator ?
	JR	NZ,J66E2		; nope,
	INC	HL
	DEC	C			; skip
	JR	Z,J66F1			; end of string,
J66E2:	LD	B,3			; maximum size element = 3 (file extension)
	CALL	C6731			; validate and copy element
	JR	Z,J66F1			; end of string,
	LD	A,(HL)
	CP	" "			; trailing space ?
	JP	NZ,J6642		; nope, bad file name error
	LD	C,0
J66F1:	LD	(IX+0),C		; end of string
J66F4:	LD	A,(MASTER)
	ADD	A,A			; DOS kernel ROM in expanded slot ?
	LD	HL,12
	JR	NC,J66FF		; nope
	LD	L,12+8
J66FF:	ADD	HL,SP
	LD	(HL),LOW RETRTN
	INC	HL
	LD	(HL),HIGH RETRTN	; replace return address with empty subroutine
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; address of DEVPAR caller
	PUSH	HL			; store pointer
	LD	HL,BSAVE+3
	RST	DCOMPR			; called by BSAVE statement ?
	LD	BC,(BSVCHK)		; BSAVE handler
	JR	Z,J6724			; yep, replace caller by DOS kernel BSAVE handler
	LD	HL,BLOAD+3
	RST	DCOMPR			; called by BLOAD statement ?
	LD	BC,(BLDCHK)		; BLOAD handler
	JR	Z,J6724			; yep, replace caller by DOS kernel BLOAD handler
	LD	C,E
	LD	B,D			; handler = orginal caller
J6724:	POP	HL			; restore pointer
	LD	(HL),B
	DEC	HL
	LD	(HL),C			; replace caller by handler
	POP	BC			; restore drive id
	LD	A,C			; drive id
	OR	A			; default drive ?
	CALL	NZ,C5846		; nope, check if valid disk drive
	POP	DE			; restore size of file specification
	POP	HL			; restore pointer to file specification
	RET

;	  Subroutine validate and copy element
;	     Inputs  C = length of string, B = maximum size element, HL = pointer to file specification
;	     Outputs ________________________

C6731:	LD	D,1			; character flags, supress upper casing
J6733:	PUSH	HL			; store pointer to file specification
	PUSH	BC			; store size of string, maximum size element
	LD	E,(HL)			; character
	LD	C,5DH			; Check character
	CALL	C655D			; DiskBASIC BDOS call with error
	POP	BC			; restore size of string, maximum size element
	POP	HL			; restore pointer to file specification
	LD	A,E			; character
	BIT	4,D			; valid filename character ?
	JR	NZ,J674E		; nope, eat spaces and quit
	LD	(IX+0),A		; store character
	INC	IX
	INC	HL
	DEC	C			; end of string ?
	RET	Z			; yep, quit
	DJNZ	J6733			; next
	RET

J674D:	LD	A,(HL)
J674E:	CP	" "			; space ?
	RET	NZ			; nope, quit
	INC	HL
	DEC	C			; end of string ?
	RET	Z			; yep, quit
	DJNZ	J674D			; next
	RET

;	  Subroutine H.NODE handler (no device specified)
;	     Inputs  ________________________
;	     Outputs ________________________

C6757:	EI
	LD	A,0			; device code = 0 (default disk drive)
	RET

;	  Subroutine H.ERRP handler (error print)
;	     Inputs  ________________________
;	     Outputs ________________________

C675B:	EI
	LD	A,E			; store error code
	SUB	60			; error code in default BASIC ?
	RET	C			; yep, quit
	CP	76-60			; disk BASIC error code ?
	RET	NC			; nope, quit
	INC	A
	LD	B,A			; 1 based offset
	LD	HL,I677D		; disk BASIC error strings
J6768:	LD	A,(HL)
	AND	A			; end of error message ?
	INC	HL
	JR	NZ,J6768		; nope, again
	DJNZ	J6768			; next errortext
	DEC	HL			; extra end marker at begin (because 'error code' = 1)
	LD	DE,TMPBUF
	PUSH	DE
	LD	BC,26			; maximium size of error message
	LDIR				; copy errortext to temporary buffer
	LD	E,1			; adjust errorcode to 1 (because buffer contains only 1 error message)
	POP	HL
	RET

I677D:	DEFB	0
        DEFB	"Bad FAT",0			; error 60
        DEFB	"Bad file mode",0		; error 61
        DEFB	"Bad drive name",0		; error 62
        DEFB	"Bad sector number",0		; error 63
        DEFB	"File still open",0		; error 64
        DEFB	"File already exists",0		; error 65
        DEFB	"Disk full",0			; error 66
        DEFB	"Too many files",0		; error 67
        DEFB	"Disk write protected",0	; error 68
        DEFB	"Disk I/O error",0		; error 69
        DEFB	"Disk offline",0		; error 70
        DEFB	"Rename across disk",0		; error 71
        DEFB	"File write protected",0	; error 72
        DEFB	"Directory already exists",0	; error 73
        DEFB	"Directory not found",0		; error 74
        DEFB	"RAM disk already exists",0	; error 75

;	  Subroutine take control from hook caller
;	     Inputs  ________________________
;	     Outputs ________________________

C6890:	EI
	PUSH	HL			; store HL
	PUSH	AF			; store AF
	LD	A,(MASTER)
	ADD	A,A			; DOS kernel ROM in expanded slot ?
	LD	HL,12
	JR	NC,J689E		; nope,
	LD	L,12+8
J689E:	ADD	HL,SP
	LD	(HL),LOW RETRTN
	INC	HL
	LD	(HL),HIGH RETRTN	; replace return address with empty subroutine
	POP	AF			; restore AF
	POP	HL			; restore HL
	RET

;	  Subroutine multiply
;	     Inputs  DE = operand1, BC = operand2
;	     Outputs HL = result

C68A7:	LD	HL,0			; result = 0

;	  Subroutine multiply high word
;	     Inputs  HL = result from first mutiply, DE = operand1, BC = operand2
;	     Outputs HL = result

C68AA:	LD	A,16+1
J68AC:	RR	B
	RR	C
	DEC	A
	RET	Z

J68B2:	JR	NC,J68B5
	ADD	HL,DE
J68B5:	RR	H
J68B7:	RR	L
	JR	J68AC

;	  Subroutine prepare for DOS, try to load and start MSXDOS2.SYS
;	     Inputs  HL = pointer to command line, A = boot drive
;	     Outputs ________________________

C68BB:	LD	B,A			; boot drive
	LD	A,(CUR_DRV)		; default drive
	PUSH	AF			; store default drive
	PUSH	BC			; store boot drive
	PUSH	HL			; store pointer to command line
	LD	HL,(HIMSAV)
	LD	(DOSHIM),HL		; bottom of MSXDOS disk system = bottom of basic disks system
	DI
	LD	A,(P0_64K)		; TPA segment page 0
	CALL	PUT_P0			; PUT_P0
	LD	A,(P1_64K)		; TPA segment page 1
	CALL	PUT_P1			; PUT_P1
	LD	A,(P2_64K)		; TPA segment page 2
	CALL	PUT_P2			; PUT_P2
	LD	A,(RAMAD3)
	LD	H,HIGH 08000H
	CALL	ENASLT			; enable RAM on page 2
	CALL	P0_RAM			; enable RAM on page 0
	LD	HL,0
J68E9:	LD	(HL),H
	INC	L
	JR	NZ,J68E9		; clear CP/M zero page
	LD	HL,I6938		; table with slot jump entries in CP/M zero page
J68F0:	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; address jump entry
	INC	HL
	LD	A,D
	OR	E			; end of table ?
	JR	Z,J6902			; yep,
	LD	A,0C3H
	LD	(DE),A
	INC	DE
	LDI
	LDI				; setup jump entry
	JR	J68F0			; next entry

J6902:	CALL	GET_P2			; GET_P2
	EX	AF,AF'			; store current segment page 2
	LD	A,(CODE_S)		; BDOS code segment
	CALL	PUT_P2			; PUT_P2
	LD	HL,SSLOT+08000H
	LD	DE,SSLOT
	LD	BC,SSLSZ
	LDIR				; install secundairy slot helper routines
	EX	AF,AF'			; restore segment page 2
	CALL	PUT_P2			; PUT_P2
	EI
	POP	HL			; restore pointer to command line
	LD	DE,DBUF+1
	LD	B,-1			; size = -1
J6922:	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	DE			; copy character
	INC	B			; update size
	OR	A			; end of string ?
	JR	NZ,J6922		; nope, continue
	LD	A,B
	LD	(DBUF+0),A		; update size of command line
	POP	AF			; restore boot drive
	OR	A			; boot drive specified ?
	CALL	NZ,C69F1		; yep, load and start MSXDOS2.SYS
	POP	AF			; restore default drive
	CALL	C69F1			; load and start MSXDOS2.SYS
	RET

I6938:	DEFW	RDSLT,$RDSLT
        DEFW	WRSLT,$WRSLT
        DEFW	CALSLT,$CALSLT
        DEFW	ENASLT,$ENASLT
        DEFW	CALLF,$CALLF
        DEFW	KEYINT,$IRQ
        DEFW	0

;	  Subroutine try to load bootsector from any drive
;	     Inputs  ________________________
;	     Outputs ________________________

C6952:	LD	HL,I6A58
	LD	(DISKVE),HL		; register DOS1 disk error handler
	LD	HL,I6A5A
	LD	(BREAKV),HL		; register DOS1 abort handler
	LD	DE,($SECBUF)
	LD	C,1AH			; Set disk transfer address
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	LD	C,1			; drive id = A:

	IF ROMVER GE 3

	LD	B,8			; drive count = 8
J696B:	PUSH	BC			; store drive count, drive id
	LD	L,C
	DEC	L			; drive id 0 based
	LD	H,1			; 1 sector
	LD	DE,0			; bootsector
	LD	C,2FH			; Absolute sector read
	CALL	C69A1			; install PROMPT interceptor (for phantom drives)
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	CALL	C69B8			; check PROMPT interceptor status
	POP	BC			; restore drive count, drive id
	JR	NZ,J698B		; error, next drive
	LD	HL,($SECBUF)
	LD	A,(HL)
	OR	02H
	CP	0EBH			; bootloader start with x86 JMP (MSDOS) ?
	JR	Z,J6990			; yep, valid boot disk
J698B:	INC	C
	DJNZ	J696B			; next drive
	XOR	A			; no valid bootdrive found

	ELSE

	LD	DE,DRVTBL
J696C:	PUSH	BC			; store drive count, drive id
	PUSH	DE			; store pointer in DRVTBL
	LD	L,C
	DEC	L			; drive id 0 based
	LD	H,1			; 1 sector
	LD	DE,0			; bootsector
	LD	C,2FH			; Absolute sector read
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	DE			; restore pointer in DRVTBL
	POP	BC			; restore drive count, drive id
	JR	NZ,J6988		; error,
	LD	HL,($SECBUF)
	LD	A,(HL)
	OR	02H
	CP	0EBH			; bootloader start with x86 JMP (MSDOS) ?
	JR	Z,J6990			; yep, valid boot disk
J6988:	LD	A,(DE)			; number of drives disk interface
	ADD	A,C
	LD	C,A			; update drive id to drive of next disk interface
	INC	DE
	INC	DE			; next disk interface
	LD	A,(DE)			; entry used ?
	AND	A
	JR	NZ,J696C		; yep, try disk interface

	ENDIF

	RET				; Zx set, no valid bootdrive found

J6990:	LD	A,C
	LD	(CUR_DRV),A		; select as default drive
	LD	HL,($SECBUF)
	LD	DE,BOT16K
	LD	BC,BOOTSZ
	LDIR				; transfer bootloader to boot location
	OR	A			; Zx reset, valid bootdrive found
	RET

	
	IF ROMVER GE 3

;	  Subroutine install PROMPT interceptor
;	     Inputs  ________________________
;	     Outputs ________________________

C69A1:	PUSH	HL
	LD	HL,H.PROM
	LD	(HL),0C3H
	INC	HL
	LD	(HL),LOW C69B0
	INC	HL
	LD	(HL),HIGH C69B0
	INC	HL
	POP	HL
	RET

;	  Subroutine PROMPT interceptor
;	     Inputs  ________________________
;	     Outputs ________________________

C69B0:	EX	(SP),HL			; store HL, restore return address
	LD	HL,H.PROM
	LD	(HL),0C9H		; disable PROMPT interceptor
	POP	HL			; restore HL
	RET

;	  Subroutine check PROMPT interceptor status
;	     Inputs  ________________________
;	     Outputs ________________________

C69B8:	PUSH	AF			; store AF
	PUSH	HL			; store HL
	LD	HL,H.PROM
	LD	A,(HL)
	CP	0C9H			; PROMPT intercepted (phantom drive) ?
	JR	NZ,J69E6		; nope, remove PROMPT interceptor and quit
	LD	(HL),0C3H		; reenable PROMPT interceptor
	PUSH	HL			; store H.PROM
	PUSH	DE			; store DE
	PUSH	BC			; store BC
	LD	HL,DRVTBL
	LD	A,(TARGET)
	LD	B,A			; restore drive id
	XOR	A
J69CF:	ADD	A,(HL)			; number of drives disk interface
	CP	B			; drive id handled by this disk interface ?
	JR	NC,J69D7		; yep,
	INC	HL
	INC	HL
	JR	J69CF			; next disk interface

J69D7:	SUB	(HL)
	LD	L,A			; first drive of the disk interface
	LD	H,1			; 1 sector
	LD	DE,0			; bootsector
	LD	C,2FH			; Absolute sector read
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	BC			; restore BC
	POP	DE			; restore DE
	POP	HL			; restore H.PROM
J69E6:	LD	(HL),0C9H
	INC	HL
	LD	(HL),0C9H
	INC	HL
	LD	(HL),0C9H		; remove PROMPT interceptor
	POP	HL			; restore HL
	POP	AF			; restore AF
	RET

	ENDIF

;	  Subroutine load and start MSXDOS2.SYS
;	     Inputs  A = boot drive
;	     Outputs ________________________

C69F1:	LD	(CUR_DRV),A		; update default drive
	LD	HL,I6A58
	LD	(DISKVE),HL		; register DOS1 disk error handler
	LD	HL,I6A5A
	LD	(BREAKV),HL		; register DOS1 abort handler
	LD	B,0
	LD	D,B			; cancel all drive assignments
	LD	C,6AH			; Logical drive assignment
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	LD	DE,I6A3E
	XOR	A			; read + write
	LD	C,43H			; Open file handle
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	JR	NZ,J6A3D		; error, quit
	LD	DE,TBASE
	LD	HL,04000H-TBASE
	LD	C,48H			; Read from file handle
	PUSH	BC			; store file handle
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	BC			; restore file handle
	PUSH	AF			; store status
	LD	C,45H			; Close file handle
	CALL	C6A4B			; invoke DiskBASIC BDOS call
	POP	AF			; restore status
	JR	NZ,J6A3D		; error reading, quit
	LD	A,(CUR_DRV)		; default drive
	LD	(BOOT_D),A		; update boot drive
	LD	A,0C3H
	LD	($DOSON+0),A
	LD	($DOSOF+0),A
	LD	(XFER+0),A		; enable MSXDOS page 1 support
	JP	TBASE			; start MSXDOS2

J6A3D:	RET

I6A3E:	DEFB	"\MSXDOS2.SYS"
        DEFB	0

;	  Subroutine invoke DiskBASIC BDOS call
;	     Inputs  ________________________
;	     Outputs ________________________

C6A4B:	CALL	BDOS			; DiskBASIC BDOS call
	CP	9DH			; diskoperation aborted error ?
	JR	NZ,J6A53		; nope, quit
	LD	A,B			; orginal error of the aborted diskoperation
J6A53:	OR	A
	RET

;	  Subroutine DOS1 disk error handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6A55:	LD	C,2			; action = abort

;	  Subroutine DOS1 abort handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6A57:	RET

; pointer to DOS1 disk error handler

I6A58:	DEFW	C6A55

; pointer to DOS1 abort handler

I6A5A:	DEFW	C6A57

;	  Subroutine select TPA segments
;	     Inputs  ________________________
;	     Outputs ________________________

C6A5C:	LD	A,(P0_64K)		; TPA segment page 0
	CALL	PUT_P0			; PUT_P0
	LD	A,(P1_64K)		; TPA segment page 1
	CALL	PUT_P1			; PUT_P1
	LD	A,(P2_64K)		; TPA segment page 2
	CALL	PUT_P2			; PUT_P2
	RET

;	  Subroutine DOS2 abort handler in BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

I6A6F:	EXX
	LD	B,A			; error code
	EXX
	LD	SP,(SP_BDO)
	LD	HL,(BREAKV)		; DOS1 abort handler
	JP	J6A92			; invoke DOS1 style handler

;	  Subroutine DOS2 disk error handler in BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

I6A7C:	EX	AF,AF'
	LD	L,C
	LD	C,A			; flag
	LD	A,B
	DEC	A			; drive id (0 based)
	LD	B,L			; flags
	LD	HL,(DISKVE)		; DOS1 disk error handler
	CALL	C6A8D			; invoke DOS1 style disk error handler
	LD	A,3
	SUB	C			; DOS2 return code
	EI
	RET

;	  Subroutine invoke DOS1 style disk error handler
;	     Inputs  HL = disk error handler
;	     Outputs ________________________

C6A8D:	PUSH	HL			; store HL
	LD	HL,$DOSON
	EX	(SP),HL			; store enable DOS kernel, restore HL
J6A92:	PUSH	HL			; store HL
	LD	HL,JP_VEC
	EX	(SP),HL			; store JP_VEC, restore HL
	JP	$DOSOF			; disable DOS kernel

;	  Subroutine DOS2 interrupt handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6A9A:	DI
	LD	A,1
	LD	(ST_COU),A		; reset no keyboard check counter (because keyboard is scanned as part of this interrupt)
	LD	HL,TIM_CO
	INC	(HL)			; increase interrupt count
	LD	A,(TIM_RA)
	CP	(HL)			; has 100 ms passed since last ?
	JR	NZ,J6AC0		; nope, do not update counters
	LD	(HL),0			; reset interrupt count
	LD	A,(CH_COU)		; screenoutput buffer counter
	CP	2
	ADC	A,-1			; decrease only if >1 (counts down from any value until 1 is reached)
	LD	(CH_COU),A
	LD	A,(TIM_TI)		; disk unchanged counter
	CP	7
	ADC	A,0			; increase only if <7 (counts up from 0 until 7 is reached)
	LD	(TIM_TI),A
J6AC0:	LD	HL,(RANDOM+0)
	LD	A,(RANDOM+2)
	LD	C,A
	RRCA
	RRCA
	RRCA
	XOR	C
	RLA
	RLA
	ADC	HL,HL
	LD	A,C
	ADC	A,A
	LD	(RANDOM+2),A
	LD	(RANDOM+0),HL		; update random seed
	RET

;	  Subroutine DiskBASIC BDOS handler with IX parameter
;	     Inputs  ________________________
;	     Outputs ________________________

I6AD8:	LD	IX,(IX_BDO)		; BDOS IX value

;	  Subroutine DiskBASIC BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

J6ADC:	EX	AF,AF'
	EXX
	LD	HL,I6A6F
	LD	(KAB_VE),HL		; setup abort handler
	LD	HL,I6A7C
	LD	(KDSK_V),HL		; setup disk error handler
	LD	HL,(BDOS_S)
	OR	A
	SBC	HL,SP			; already using the BDOS temp stack ?
	JR	C,J6AF9			; nope, use BDOS temp stack
	LD	BC,300
	SBC	HL,BC			; already using the BDOS temp stack ?
	JR	C,J6B0A			; yep, go
J6AF9:	LD	(SP_BDO),SP
	LD	SP,(BDOS_S)		; switch to temporary BDOS stack
	CALL	C6B0F			; BDOS handler
	LD	SP,(SP_BDO)		; switch to orginal stack
	OR	A
	RET

J6B0A:	CALL	C6B0F			; BDOS handler
	OR	A
	RET

;	  Subroutine BDOS handler
;	     Inputs  ________________________
;	     Outputs ________________________

C6B0F:	EXX
	PUSH	HL
	LD	A,C
	CP	71H			; valid BDOS function ?
	JR	C,J6B18			; yep, continue
	LD	A,1CH			; illegal BDOS function
J6B18:	LD	HL,I6B28
	ADD	A,A
	ADD	A,L
	LD	L,A
	JR	NC,J6B21
	INC	H
J6B21:	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	EX	(SP),HL
	EX	AF,AF'
	RET				; invoke BDOS wrapper routine

I6B28:	DEFW	C6CEE			; BDOS 00: execute BDOS function
	DEFW	C6C0A			; BDOS 01: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 02: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 03: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 04: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 05: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 06: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 07: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 08: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C10			; BDOS 09: wrapper for CP/M string output BDOS function
	DEFW	C6C20			; BDOS 0A: wrapper for CP/M line input BDOS function
	DEFW	C6C0A			; BDOS 0B: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 0C: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 0D: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 0E: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C44			; BDOS 0F: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 10: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 11: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C0A			; BDOS 12: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C44			; BDOS 13: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 14: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 15: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 16: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C44			; BDOS 17: wrapper for BDOS functions with 33 bytes FCB
	DEFW	C6C0A			; BDOS 18: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 19: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C0A			; BDOS 1A: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6C3C			; BDOS 1B: wrapper for get allocation information BDOS function
	DEFW	C6CEE			; BDOS 1C: execute BDOS function
	DEFW	C6CEE			; BDOS 1D: execute BDOS function
	DEFW	C6CEE			; BDOS 1E: execute BDOS function
	DEFW	C6CEE			; BDOS 1F: execute BDOS function
	DEFW	C6CEE			; BDOS 20: execute BDOS function
	DEFW	C6C47			; BDOS 21: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6C47			; BDOS 22: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6C47			; BDOS 23: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6C47			; BDOS 24: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6CEE			; BDOS 25: execute BDOS function
	DEFW	C6C68			; BDOS 26: wrapper for BDOS functions with FCB (custom recordsize)
	DEFW	C6C68			; BDOS 27: wrapper for BDOS functions with FCB (custom recordsize)
	DEFW	C6C47			; BDOS 28: wrapper for BDOS functions with 36 bytes FCB
	DEFW	C6CEE			; BDOS 29: execute BDOS function
	DEFW	C6C83			; BDOS 2A: wrapper for simple BDOS functions A=C
	DEFW	C6C83			; BDOS 2B: wrapper for simple BDOS functions A=C
	DEFW	C6C83			; BDOS 2C: wrapper for simple BDOS functions A=C
	DEFW	C6C83			; BDOS 2D: wrapper for simple BDOS functions A=C
	DEFW	C6C0A			; BDOS 2E: wrapper for simple CP/M compatible BDOS functions
	DEFW	C6CEE			; BDOS 2F: execute BDOS function
	DEFW	C6CEE			; BDOS 30: execute BDOS function
	DEFW	C6C88			; BDOS 31: wrapper for get disk parameters BDOS functions
	DEFW	C6CEE			; BDOS 32: execute BDOS function
	DEFW	C6CEE			; BDOS 33: execute BDOS function
	DEFW	C6CEE			; BDOS 34: execute BDOS function
	DEFW	C6CEE			; BDOS 35: execute BDOS function
	DEFW	C6CEE			; BDOS 36: execute BDOS function
	DEFW	C6CEE			; BDOS 37: execute BDOS function
	DEFW	C6CEE			; BDOS 38: execute BDOS function
	DEFW	C6CEE			; BDOS 39: execute BDOS function
	DEFW	C6CEE			; BDOS 3A: execute BDOS function
	DEFW	C6CEE			; BDOS 3B: execute BDOS function
	DEFW	C6CEE			; BDOS 3C: execute BDOS function
	DEFW	C6CEE			; BDOS 3D: execute BDOS function
	DEFW	C6CEE			; BDOS 3E: execute BDOS function
	DEFW	C6CEE			; BDOS 3F: execute BDOS function
	DEFW	C6C9A			; BDOS 40: wrapper for BDOS functions with FIB + ASCIIZ or ASCIIZ input parameter
	DEFW	C6CA1			; BDOS 41: wrapper for BDOS functions with FIB
	DEFW	C6C9A			; BDOS 42: wrapper for BDOS functions with FIB + ASCIIZ or ASCIIZ input parameter
	DEFW	C6CC3			; BDOS 43: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 44: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CEE			; BDOS 45: execute BDOS function
	DEFW	C6CEE			; BDOS 46: execute BDOS function
	DEFW	C6CEE			; BDOS 47: execute BDOS function
	DEFW	C6CEE			; BDOS 48: execute BDOS function
	DEFW	C6CEE			; BDOS 49: execute BDOS function
	DEFW	C6CEE			; BDOS 4A: execute BDOS function
	DEFW	C6CEE			; BDOS 4B: execute BDOS function
	DEFW	C6CC3			; BDOS 4C: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 4D: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CBD			; BDOS 4E: wrapper for BDOS functions with ASCIIZ + ASCIIZ or FIB parameter
	DEFW	C6CBD			; BDOS 4F: wrapper for BDOS functions with ASCIIZ + ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 50: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CC3			; BDOS 51: wrapper for BDOS functions with ASCIIZ or FIB parameter
	DEFW	C6CEE			; BDOS 52: execute BDOS function
	DEFW	C6CDE			; BDOS 53: wrapper for BDOS functions with second ASCIIZ parameter
	DEFW	C6CDE			; BDOS 54: wrapper for BDOS functions with second ASCIIZ parameter
	DEFW	C6CEE			; BDOS 55: execute BDOS function
	DEFW	C6CEE			; BDOS 56: execute BDOS function
	DEFW	C6CEE			; BDOS 57: execute BDOS function
	DEFW	C6CEE			; BDOS 58: execute BDOS function
	DEFW	C6CF6			; BDOS 59: wrapper for BDOS functions with 64 bytes ASCIIZ string result
	DEFW	C6D39			; BDOS 5A: wrapper for BDOS functions with 64 bytes ASCIIZ string input
	DEFW	C6CF1			; BDOS 5B: wrapper for BDOS functions with 64 bytes ASCIIZ string input and output
	DEFW	C6D16			; BDOS 5C: wrapper for BDOS function parse filename
	DEFW	C6CEE			; BDOS 5D: execute BDOS function
	DEFW	C6CF6			; BDOS 5E: wrapper for BDOS functions with 64 bytes ASCIIZ string result
	DEFW	C6CEE			; BDOS 5F: execute BDOS function
	DEFW	C6CEE			; BDOS 60: execute BDOS function
	DEFW	C6CEE			; BDOS 61: execute BDOS function
	DEFW	C6CEE			; BDOS 62: execute BDOS function
	DEFW	C6CEE			; BDOS 63: execute BDOS function
	DEFW	C6CEE			; BDOS 64: execute BDOS function
	DEFW	C6CEE			; BDOS 65: execute BDOS function
	DEFW	C6D3F			; BDOS 66: wrapper for BDOS function explain error code
	DEFW	C6CEE			; BDOS 67: execute BDOS function
	DEFW	C6CEE			; BDOS 68: execute BDOS function
	DEFW	C6CEE			; BDOS 69: execute BDOS function
	DEFW	C6CEE			; BDOS 6A: execute BDOS function
	DEFW	C6CEE			; BDOS 6B: execute BDOS function
	DEFW	C6CEE			; BDOS 6C: execute BDOS function
	DEFW	C6CEE			; BDOS 6D: execute BDOS function
	DEFW	C6CEE			; BDOS 6E: execute BDOS function
	DEFW	C6CEE			; BDOS 6F: execute BDOS function
	DEFW	C6CEE			; BDOS 70: execute BDOS function

;	  Subroutine wrapper for simple CP/M compatible BDOS functions
;	     Inputs  ________________________
;	     Outputs ________________________

C6C0A:	CALL	C6CEE			; execute BDOS function
	LD	A,L
	LD	B,H			; CP/M 1.x compatible result
	RET

;	  Subroutine wrapper for CP/M string output BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6C10:	LD	A,(DE)			; character (TPA)
	INC	DE
	CP	"$"			; end of string ?
	JR	Z,J6C37			; yep, quit
	PUSH	DE			; store pointer in string
	LD	E,A
	LD	C,2			; _CONOUT
	CALL	C6CEE			; execute BDOS function
	POP	DE			; restore pointer in string
	JR	C6C10			; next

;	  Subroutine wrapper for CP/M line input BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6C20:	PUSH	DE			; store pointer to input buffer (TPA)
	LD	A,(DE)			; size of input buffer (TPA)
	LD	DE,(BUF_1)		; BDOS temp buffer
	LD	(DE),A			; same input buffer size
	CALL	C6CEE			; execute BDOS function
	POP	DE			; restore pointer to input buffer (TPA)
	LD	A,(DE)			; size of input buffer
	INC	DE
	LD	HL,(BUF_1)		; BDOS temp buffer
	INC	HL			; pointer to size of line
	LD	C,A
	LD	B,0
	INC	BC			; include size of line
	LDIR				; copy size of line and line to input buffer (TPA)
J6C37:	XOR	A
	LD	B,A
	LD	L,A
	LD	H,A			; CP/M result = 0
	RET

;	  Subroutine wrapper for get allocation information BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6C3C:	CALL	C6CEE			; execute BDOS function
	LD	A,C			; sectors per cluster
	LD	BC,512			; sectorsize = 512
	RET

;	  Subroutine wrapper for BDOS functions with 33 bytes FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C6C44:	LD	A,33			; size FCB = 33 bytes
	DEFB	021H			; LD HL,xxxx: skip next instruction

;	  Subroutine wrapper for BDOS functions with 36 bytes FCB
;	     Inputs  ________________________
;	     Outputs ________________________

C6C47:	LD	A,36			; szie FCB = 36 bytes (random record)
	PUSH	DE			; store pointer to FCB (TPA)
	EXX
	POP	HL			; restore pointer to FCB (TPA)
	LD	C,A
	LD	B,0			; size of FCB

;	  Subroutine wrapper BDOS functions with FCB
;	     Inputs  HL = pointer to FCB, BC = size of FCB
;	     Outputs ________________________

C6C4F:	PUSH	HL			; store pointer to FCB (TPA)
	PUSH	BC			; store size of FCB
	LD	DE,(BUF_1)		; BDOS temp buffer
	PUSH	DE
	LDIR				; copy FCB (TPA) to temp buffer
	EXX
	POP	DE			; restore pointer to temp buffer
	PUSH	DE			; store pointer to temp buffer
	CALL	C6CEE			; execute BDOS function
	EXX
	POP	HL			; restore pointer to temp buffer
	POP	BC			; restore size of FCB
	POP	DE			; restore pointer to FCB (TPA)
	LDIR				; copy temp buffer to FCB (TPA)
	EXX
	LD	A,L
	LD	B,H			; CP/M 1.x compatible result
	RET

;	  Subroutine wrapper for BDOS functions with FCB (custom record size)
;	     Inputs  ________________________
;	     Outputs ________________________

C6C68:	PUSH	DE			; store pointer to FCB (TPA)
	EXX
	POP	HL			; restore pointer to FCB (TPA)
	PUSH	HL			; store pointer to FCB (TPA)
	LD	BC,15
	ADD	HL,BC
	LD	C,36			; assume size FCB = 36 bytes
	LD	A,(HL)
	OR	A			; high byte recordsize <> 0 ?
	JR	NZ,J6C7D		; yep, record size > 255, FCB is 36 bytes
	DEC	HL
	LD	A,(HL)
	CP	64			; record size < 64 ?
	JR	NC,J6C7D		; nope,
	INC	C			; size FCB = 37 bytes
J6C7D:	POP	HL			; restore pointer to FCB (TPA)
	CALL	C6C4F			; wrapper BDOS functions with FCB
	EX	DE,HL
	RET

;	  Subroutine wrapper for simple BDOS functions A=C
;	     Inputs  ________________________
;	     Outputs ________________________

C6C83:	CALL	C6CEE			; execute BDOS function
	LD	A,C
	RET

;	  Subroutine wrapper for get disk parameters BDOS functions
;	     Inputs  ________________________
;	     Outputs ________________________

C6C88:	PUSH	DE			; store pointer to buffer (TPA)
	LD	DE,(BUF_1)		; BDOS temp buffer
	CALL	C6CEE			; execute BDOS function
	EX	DE,HL
	POP	DE			; restore pointer to buffer (TPA)
	PUSH	DE			; store pointer to buffer (TPA)
	LD	BC,32
	LDIR				; copy BDOS temp buffer to buffer (TPA)
	POP	DE			; restore pointer to buffer (TPA)
	RET

;	  Subroutine wrapper for BDOS functions with FIB + ASCIIZ or ASCIIZ input parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6C9A:	CALL	C6D53			; copy FIB or ASCIIZ string parameter to BDOS temp buffer
	CALL	C,C6D76			; parameter was a FIB, copy ASCIIZ string to BDOS second temp buffer
	RET	NZ			; error, quit

;	  Subroutine wrapper for BDOS functions with FIB
;	     Inputs  ________________________
;	     Outputs ________________________

C6CA1:	PUSH	IX
	POP	HL			; pointer to FIB (TPA)
	PUSH	HL			; store pointer to FIB (TPA)
	LD	DE,(BUF_2)
	PUSH	BC			; store BC
	LD	BC,64			; size of FIB
	LDIR				; copy FIB (TPA) to BDOS FIB buffer
	POP	BC			; restore BC
	CALL	C6CE3			; execute BDOS function with 1 FIB buffer and 2 temp buffer parameters
	POP	DE			; restore pointer to FIB (TPA)
	LD	HL,(BUF_2)
	LD	BC,64			; size of FIB
	LDIR				; copy BDOS FIB buffer back to FIB (TPA)
	RET

;	  Subroutine wrapper for BDOS functions with ASCIIZ + ASCIIZ or FIB parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CBD:	CALL	C6D76			; copy ASCIIZ string to BDOS second temp buffer
	LD	HL,(BUF_3)		; BDOS second temp buffer

;	  Subroutine wrapper for BDOS functions with ASCIIZ or FIB parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CC3:	EX	AF,AF'
	PUSH	DE			; store pointer to FIB or ASCIIZ string (TPA)
	CALL	C6D53			; copy FIB or ASCIIZ string parameter (TPA) to BDOS temp buffer
	PUSH	AF			; store parameter type
	EX	AF,AF'
	CALL	C6CEA			; execute BDOS function with temp buffer parameter
	EX	AF,AF'
	EXX
	POP	AF			; restore parameter type
	POP	DE			; restore pointer to FIB or ASCIIZ string (TPA)
	JR	NC,J6CDB		; parameter was an ASCIIZ string, quit
	LD	HL,(BUF_1)		; BDOS temp buffer
	LD	BC,64			; size of FIB
	LDIR				; copy FIB in temp buffer to FIB (TPA)
J6CDB:	EX	AF,AF'
	EXX
	RET

;	  Subroutine wrapper for BDOS functions with second ASCIIZ parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CDE:	EX	AF,AF'
	CALL	C6D76			; copy ASCIIZ string to BDOS second temp buffer
	EX	AF,AF'

;	  Subroutine execute BDOS function with 1 FIB buffer and 2 temp buffer parameters
;	     Inputs  ________________________
;	     Outputs ________________________

C6CE3:	LD	IX,(BUF_2)		; pointer to BDOS FIB buffer
	LD	HL,(BUF_3)		; pointer to BDOS second temp buffer

;	  Subroutine execute BDOS function with temp buffer parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C6CEA:	LD	DE,(BUF_1)		; pointer to BDOS temp buffer

;	  Subroutine execute BDOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C6CEE:	JP	GO_BDO

;	  Subroutine wrapper for BDOS functions with 64 bytes ASCIIZ string input and output
;	     Inputs  DE = pointer to 64 bytes ASCIIZ string
;	     Outputs ________________________

C6CF1:	PUSH	DE			; store pointer to ASCIIZ string
	CALL	C6D57			; copy 64 bytes to temp buffer (ASCIIZ string)
	POP	DE			; restore pointer to ASCIIZ string

;	  Subroutine wrapper for BDOS functions with 64 bytes ASCIIZ string result
;	     Inputs  DE = pointer to 64 bytes ASCIIZ buffer
;	     Outputs ________________________

C6CF6:	EX	DE,HL
	PUSH	HL			; store pointer to buffer (TPA)
	LD	DE,(BUF_1)		; BDOS temp buffer
	OR	A
	SBC	HL,DE			; offset buffer (TPA) with BDOS temp buffer
	PUSH	HL			; store offset buffer (TPA) with BDOS temp buffer
	PUSH	DE			; store pointer to BDOS temp buffer
	CALL	C6CEE			; execute BDOS function
	EXX
	POP	HL			; restore pointer to BDOS temp buffer
	POP	BC			; restore offset buffer (TPA) with BDOS temp buffer
	POP	DE			; restore pointer to buffer (TPA)
	PUSH	BC			; store offset buffer (TPA) with BDOS temp buffer
	LD	BC,64
	LDIR				; copy temp buffer to buffer (TPA)
	EXX
	EX	(SP),HL			; store pointer in buffer #1, restore offset buffer (TPA) with BDOS temp buffer
	EX	DE,HL
	ADD	HL,DE			; update pointer in buffer #1 (TPA)
	EX	(SP),HL			; store pointer in buffer #1 (TPA, restore pointer in buffer #2
	ADD	HL,DE			; update pointer in buffer #2 (TPA)
	POP	DE			; restore pointer in buffer #1 (TPA)
	RET

;	  Subroutine wrapper for BDOS function parse file name
;	     Inputs  DE = pointer to ASCIIZ string, HL = pointer to file name buffer
;	     Outputs DE = pointer to termination character, HL = pointer to file name buffer

C6D16:	PUSH	HL			; store pointer to file name buffer (TPA)
	PUSH	HL			; store pointer to file name buffer (TPA)
	LD	L,E
	LD	H,D			; pointer to ASCIIZ string (TPA)
	CALL	C6D57			; copy 64 bytes to temp buffer (ASCIIZ string)
	LD	DE,(BUF_1)		; BDOS temp buffer
	OR	A
	SBC	HL,DE			; offset ASCIIZ string (TPA) with BDOS temp buffer
	EX	(SP),HL			; store offset ASCIIZ string (TPA) with BDOS temp buffer, restore pointer to file name buffer (TPA)
	PUSH	HL			; store pointer to file name buffer (TPA)
	CALL	C6CE3			; execute BDOS function with 1 FIB buffer and 2 temp buffer parameters
	EXX
	POP	DE			; restore pointer to file name buffer (TPA)
	LD	BC,11
	LD	HL,(BUF_3)		; BDOS second temp buffer
	LDIR				; copy second temp buffer to file name buffer (TPA)
	EXX
	POP	HL			; restore offset ASCIIZ string (TPA) with BDOS temp buffer
	ADD	HL,DE
	EX	DE,HL			; update pointer in buffer (TPA)
	POP	HL			; restore pointer to file name buffer (TPA)
	RET

;	  Subroutine wrapper for BDOS functions with 64 bytes ASCIIZ string input
;	     Inputs  ________________________
;	     Outputs ________________________

C6D39:	CALL	C6D57			; copy 64 bytes to temp buffer (ASCIIZ string)
	JP	C6CEA			; execute BDOS function with temp buffer parameter

;	  Subroutine wrapper for BDOS function explain error code
;	     Inputs  ________________________
;	     Outputs ________________________

C6D3F:	PUSH	DE			; store pointer to buffer (TPA)
	LD	DE,(ERR_BUF)		; error message buffer
	CALL	C6CEE			; execute BDOS function
	EX	DE,HL
	POP	DE			; restore pointer to buffer (TPA)
	PUSH	DE			; store pointer to buffer (TPA)
	PUSH	BC			; store BC
	LD	BC,64
	LDIR				; copy error message to buffer (TPA)
	POP	BC			; restore BC
	POP	DE			; restore pointer to buffer (TPA)
	RET

;	  Subroutine copy FIB or ASCIIZ string parameter to BDOS temp buffer
;	     Inputs  DE = pointer to FIB or ASCIIZ string
;	     Outputs Cx set = FIB parameter, Cx reset = ASCIIZ parameter, Zx reset = error

C6D53:	LD	A,(DE)
	INC	A			; FIB ?
	JR	NZ,J6D67		; nope, copy ASCIIZ string to BDOS temp buffer

;	  Subroutine copy 64 bytes to temp buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C6D57:	PUSH	HL			; store HL
	PUSH	BC			; store BC
	EX	DE,HL
	LD	DE,(BUF_1)		; BDOS temp buffer
	LD	BC,64
	LDIR				; copy 64 bytes to BDOS temp buffer
	POP	BC			; restore BC
	POP	HL			; restore HL
	SCF				; FIB parameter
	RET

;	  Subroutine copy ASCIIZ string to BDOS temp buffer
;	     Inputs  DE = pointer to ASCIIZ string
;	     Outputs ________________________

J6D67:	PUSH	HL			; store HL
	PUSH	BC			; store BC
	EX	DE,HL
	LD	DE,(BUF_1)		; destination = BDOS temp buffer
	LD	B,100			; maximum size ASCIIZ string = 100
	CALL	C6D84			; copy ASCIIZ string
	POP	BC			; restore BC
	POP	HL			; restore HL
	RET

;	  Subroutine copy ASCIIZ string to BDOS second temp buffer
;	     Inputs  HL = pointer to ASCIIZ string
;	     Outputs ________________________

C6D76:	PUSH	DE			; store DE
	PUSH	BC			; store BC
	LD	DE,(BUF_3)		; destination = BDOS second temp buffer
	LD	B,100			; maximum size ASCIIZ string = 100
	CALL	C6D84			; copy ASCIIZ string
	POP	BC			; restore BC
	POP	DE			; restore DE
	RET

;	  Subroutine copy ASCIIZ string
;	     Inputs  HL = source, DE = destination, B = maximum size of ASCIIZ string
;	     Outputs ________________________

C6D84:	LD	A,(HL)
	INC	HL
	LD	(DE),A
	INC	DE			; copy character
	OR	A			; end of string ?
	RET	Z			; yep, quit
	DJNZ	C6D84			; next
	LD	A,.BUFUL		; buffer full error
	RET

; DSKCHG routine for ramdisk

R_DSKCHG:
C6D8F:	LD	HL,LBC00+32
	LD	A,(DATA_S)		; BDOS data segment
	CALL	RD_SEG			; RD_SEG
	CP	"V"			; check if first letter of VOL_ID
	LD	B,0
	RET	Z			; yep, return DISK CHANGE UNKNOWN
	DEC	B			; return DISK CHANGED
	RET

; DSKIO routine for ramdisk

R_DSKIO:
C6D9F:	EI
	LD	(RD_SNU),DE		; save sectornumber
	LD	(RD_ADD),HL		; save transferaddress
	LD	A,B
	LD	(RD_SCN),A		; save number of sectors
	EX	AF,AF'
	LD	HL,LBC00+32
	LD	A,(DATA_S)		; BDOS data segment
	CALL	RD_SEG			; RD_SEG
	EI
	SUB	"V"			; check if first letter of VOL_ID
	CALL	NZ,C6EB9		; nope, 'format' ramdisk
	RET	C
	LD	HL,(SLTTBL+0)
	PUSH	HL
	LD	HL,(SLTTBL+2)
	PUSH	HL			; save SLTTBL

J6DC4:	LD	DE,(RD_SNU)		; starting sectornumber
	CALL	C6E5D			; caculate transfers from segment
	JR	C,J6DFC			; error, quit
	LD	E,A			; sectors in this segment
	LD	A,(RD_SCN)
	SUB	E			; check if all sectors can be done
	JR	NC,J6DD7		; nope,
	ADD	A,E
	LD	E,A			; sectors from this segment
	XOR	A			; 0 remaining sectors
J6DD7:	LD	(RD_SCN),A
	OR	A
	PUSH	AF
	PUSH	HL
	LD	HL,(RD_SNU)
	LD	D,0
	ADD	HL,DE
	LD	(RD_SNU),HL		; update sectornumber
	POP	HL
	LD	D,E
	SLA	D
	LD	E,0			; number of bytes
	PUSH	DE
	CALL	C6E28			; transfer sectors
	POP	DE
	LD	HL,(RD_ADD)
	ADD	HL,DE
	LD	(RD_ADD),HL		; update transferaddress
	POP	AF
	JR	NZ,J6DC4		; sectors remain, again
	XOR	A
J6DFC:	EX	AF,AF'
	DI
	POP	HL
	LD	(SLTTBL+2),HL
	POP	HL
	LD	(SLTTBL+0),HL		; restore SLTTBL
	LD	HL,SLTTBL
	XOR	A			; slot = primairy slot 0
J6E0A:	LD	C,A			; store primairy slot
	IN	A,(0A8H)
	LD	B,A			; store current primairy slot register
	AND	3FH
	OR	C			; update page 3 with new primairy slot
	LD	E,(HL)			; stored secundiary slot register
	PUSH	HL			; store pointer in SLTTBL
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	BIT	7,(HL)			; slot expanded ?
	POP	HL			; restore pointer in SLTTBL
	INC	HL			; next
	CALL	NZ,SSLOTE		; yep, update secundairy slotregister
	LD	A,C
	ADD	A,40H
	JR	NZ,J6E0A		; next primairy slot
	EI
	EX	AF,AF'
	LD	B,0
	RET

;	  Subroutine transfer sectors
;	     Inputs  ________________________
;	     Outputs ________________________

C6E28:	DI
	LD	A,(RAMAD3)
	CP	B			; same slot as primairy memmory mapper ?
	JR	Z,J6E42			; yep, direct transfer
	CALL	GET_P1			; GET_P1
	PUSH	AF
	LD	A,C
	CALL	PUT_P1			; PUT_P1
	SET	6,H			; address in page 1 range
	CALL	RD_LDI			; transfer to/from page 1
	POP	AF
	CALL	PUT_P1			; PUT_P1
	EI
	RET

J6E42:	CALL	GET_P0			; GET_P0
	PUSH	AF
	LD	A,C
	CALL	PUT_P0			; PUT_P0
	LD	B,D
	LD	C,E
	LD	DE,(RD_ADD)		; transferaddress
	EX	AF,AF'
	JR	NC,J6E54		; reading, HL = source address
	EX	DE,HL			; writing, swap 
J6E54:	EX	AF,AF'
	LDIR				; transfer from/to memory
	POP	AF
	CALL	PUT_P0			; PUT_P0
	EI
	RET

;	  Subroutine caculate transfers from segment
;	     Inputs  ________________________
;	     Outputs ________________________

C6E5D:	LD	A,D
	OR	E			; bootsector ?
	JR	NZ,J6E6F
	LD	A,(DATA_S)		; BDOS data segment
	LD	C,A			; segment
	LD	A,(RAMAD3)
	LD	B,A			; slot = primairy memory mapper
	LD	HL,LBC00-8000H		; base address sector
	LD	A,1			; 1 sector in segment
	RET

J6E6F:	CALL	GET_P2			; GET_P2
	PUSH	AF
	LD	A,(DATA_S)		; BDOS data segment
	CALL	PUT_P2			; PUT_P2
	LD	HL,(LBE00)
	LD	H,0			; number of ramdisk segments
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *32 (32 sectors in a segment)
	POP	AF
	CALL	PUT_P2			; PUT_P2
	SBC	HL,DE			; is sectornumber valid ?
	LD	A,12
	RET	C			; nope, quit with OTHER error
	LD	H,D
	LD	L,E
	DEC	HL			; without bootsector
	ADD	HL,HL
	LD	A,L
	PUSH	AF
	ADD	HL,HL
	ADD	HL,HL
	LD	E,H
	LD	D,0			; segment of sector
	LD	HL,LBE02
	ADD	HL,DE
	ADD	HL,DE
	CALL	GET_P2			; GET_P2
	PUSH	AF
	LD	A,(DATA_S)		; BDOS data segment
	CALL	PUT_P2			; PUT_P2
	LD	C,(HL)			; segment
	INC	HL
	LD	B,(HL)			; slotid
	POP	AF
	CALL	PUT_P2			; PUT_P2
	POP	AF
	AND	3EH			; must be a multiply of 512
	LD	H,A
	LD	L,0			; base address sector
	LD	A,40H
	SUB	H
	RRCA				; sectors in segement
	OR	A			; no error
	RET

;	  Subroutine 'format' ramdisk
;	     Inputs  ________________________
;	     Outputs ________________________

C6EB9:	CALL	GET_P2			; GET_P2
	PUSH	AF			; save current segment
	LD	A,(DATA_S)		; BDOS data segment
	CALL	PUT_P2			; PUT_P2
	LD	A,(LBE00)
	OR	A			; number of ramdisk segments
	JR	NZ,J6ED1		; ramdisk enabled, continue
I6EC9:	POP	AF			; restore current segment
	CALL	PUT_P2			; PUT_P2
	LD	A,12
	SCF				; quit with OTHER error
	RET

J6ED1:	EXX
	LD	HL,LBC00+11
	LD	(HL),LOW 0200H
	INC	HL
	LD	(HL),HIGH 0200H		; Bytes per sector = 512
	INC	HL
	LD	(HL),1			; assume 1 sector per cluster
	CP	129			; less then 129 segments ?
	JR	C,J6EE2			; nope,
	INC	(HL)			; yep, 2 sectors per cluster
J6EE2:	INC	HL
	LD	(HL),LOW 1
	INC	HL
	LD	(HL),HIGH 1		; 1 reserved sector (boot)
	INC	HL
	LD	(HL),2			; 2 FAT's
	INC	HL
	LD	C,A
	SRL	A
	SRL	A
	ADD	A,4			; rootdir. sectors = segments\4 +4
	LD	E,A
	LD	D,0
	PUSH	DE
	EX	DE,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *16 (Entries per sector)
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; number of directory entries
	INC	HL
	LD	E,C
	LD	D,0			; number of ramdisk segments
	EX	DE,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *32 (Sectors in segment)
	INC	HL			; + boot
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; total number of sectors
	INC	HL
	LD	(HL),0FFH		; media descriptor (0FFH)
	INC	HL
	EX	DE,HL
	LD	A,C
	DEC	HL			; - bootsector
	POP	BC
	OR	A
	SBC	HL,BC			; - directory sectors
	CP	129			; number of segments <129 ?
	JR	C,J6F22			; nope, 1 sector per cluster
	SRL	H
	RR	L			; 2 sectors per cluster
J6F22:	LD	B,H
	LD	C,L
	ADD	HL,BC
	ADD	HL,BC			; *3 bytes
	EX	DE,HL
	DEC	DE
	SRL	D
	SRL	D
	INC	D
	LD	(HL),D
	INC	HL
	LD	(HL),0			; number of sectors per FAT
	INC	HL
	LD	HL,I6F44
	LD	DE,LBC00+32
	LD	BC,S6F44
	LDIR				; set volume serial number & id
	EXX
	POP	AF
	CALL	PUT_P2			; PUT_P2
	XOR	A
	RET

I6F44:	DEFB	"VOL_ID"
I6F4A:	DEFB	0

        DEFB	1
        DEFB	2
        DEFB	3
        DEFB	4			; special disk serial number ramdisk

S6F44	EQU	$-I6F44

; GETDPB routine for ramdisk

R_GETDPB:
C6F4F:	OR	A			; do nothing, no error
	RET

; CHOICE routine for ramdisk

R_CHOICE:
C6F51:	LD	HL,I6F4A		; pointer to null string (FORMAT not supported)
	RET

; DSKFMT routine for ramdisk

R_DSKFMT:
C6F55:	LD	A,12
	SCF				; bad parameter error
	RET


	IF ROMVER GE 3

	DEFS	07000H-$,0		; not sure why this was chosen

	ELSE

	DEFS	07405H-$,0		; to align driver code to the 1.x kernel location

	ENDIF


; DRIVER section starts here

        INCLUDE	DRIVER.MAC

; DRIVER section stops here


        DEFS	07FD0H-$,0

C7FD0:
	BNKCHG
        RET


; disk driver interrupt handler

BNKINT:
C7FD4:	EX	AF,AF'
        LD	A,(D40FF)
        PUSH	AF			; Save DOS2 mapper block
        XOR	A
        CALL	C7FD0			; Set block 0
        EX	AF,AF'
        CALL	DSKINT			; interrupt handler
        EX	AF,AF'
        POP	AF
        CALL	C7FD0			; Set old block
        EX	AF,AF'
        RET

        DEFS	08000H-$,0

	END
