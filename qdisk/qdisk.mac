; QDISK.MAC
;
; Quick Disk Extension (version 1.00,1.10 and 1.11)
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by Mitsumi
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders

	.Z80
        ASEG
	ORG	4000H

; 3 code versions are possible
;
; 100 = Version 1.00, used in Daewoo DPQ-280
; 110 = Version 1.10, used in Sanyo QDM-01
; 111 = Version 1.11, used in Philips VY0002

QDVER	EQU	111

; BIOS routines

VDP.DR	EQU	0006H	; vdp data read port
VDP.DW	EQU	0007H	; vdp data write port
RDSLT	EQU	000CH	; read slot
WRSLT	EQU	0014H	; write slot
CALSLT	EQU	001CH	; call slot
DCOMPR	EQU	0020H	; compare hl with de
ENASLT	EQU	0024H	; enable slot
INIFNK	EQU	003EH	; initialize function keys
SETRD	EQU	0050H	; setup vdp for vram read
SETWRT	EQU	0053H	; setup vdp for vram write
CHSNS	EQU	009CH	; check if key
CHGET	EQU	009FH	; get key
CHPUT	EQU	00A2H	; character to screen
BREAKX	EQU	00B7H	; check if CTRL-STOP
FNKSB	EQU	00C9H	; display function keys if enabled
TAPION	EQU	00E1H	; start tape for input
TAPIN	EQU	00E4H	; read byte from tape
TAPIOF	EQU	00E7H	; stop tape for input
SNSMAT	EQU	0141H	; read keyboard row

; BASIC routines (permitted, entrypoints are garanteed)

M4055	EQU	4055H	; syntax error
M406D	EQU	406DH	; type mismatch error
M406F	EQU	406FH	; BASIC error
M4666	EQU	4666H	; get BASIC character
M4134	EQU	4134H	; BASIC main loop
M423B	EQU	423BH	; setup BASIC linelinks from this point, initialize interpreter
M4257	EQU	4257H	; setup BASIC linelinks from this point
M4601	EQU	4601H	; execute new statement
M475A	EQU	475AH	; illegal function call error
M4C64	EQU	4C64H	; evaluate expression
M542F	EQU	542FH	; evaluate address operand
M54EA	EQU	54EAH	; convert to linepointers to linenumbers if needed
M6267	EQU	6267H	; check if enough stackspace left
M6275	EQU	6275H	; out of memory error
M67D0	EQU	67D0H	; free temporary string with type check
M6A0E	EQU	6A0EH	; evaluate filespecification
M6C1C	EQU	6C1CH	; close all i/o channels
M6E6B	EQU	6E6BH	; bad filename
M6E6E	EQU	6E6EH	; file already open error
M6E74	EQU	6E74H	; file not found error
M6E77	EQU	6E77H	; file not open error
M6E80	EQU	6E80H	; internal error
M6E86	EQU	6E86H	; sequential i/o only error
M715D	EQU	715DH	; load/compare BASIC program
M73B2	EQU	73B2H	; device i/o error

; system variables

CSRX	EQU	0F3DDH

BUF	EQU	0F55EH			; used as temporary space (permitted)
T.STAT	EQU	BUF+0			; generated BASIC line
T.EXEC	EQU	BUF+0			; execute routine
T.FLNM	EQU	BUF+0			; filename
T.TFIL	EQU	BUF+12			; filename from tape
T.TSAD	EQU	T.TFIL+12		; start address
T.TEAD	EQU	T.TSAD+2		; end address
T.TXAD	EQU	T.TEAD+2		; execute address

VALTYP	EQU	0F663H
MEMSIZ	EQU	0F672H
TXTTAB	EQU	0F676H
VARTAB	EQU	0F6C2H
DAC	EQU	0F7F6H
FILTAB	EQU	0F860H
NULBUF	EQU	0F862H
PTRFIL	EQU	0F864H
FILNAM	EQU	0F866H
FNKSTR	EQU	0F87FH
HOKVLD	EQU	0FB20H
EXPTBL	EQU	0FCC1H
PROCNM	EQU	0FD89H

; hooks

H.READ	EQU	0FF07H	; hook Ok prompt

; extend bios entries

EXTBIO	EQU	0FFCAH
DISINT	EQU	0FFCFH
ENAINT	EQU	0FFD4H

; quick disk controller is a Zilog Z8440 SIO
;
; RTSA = write enable
; RTSB = mfm demodulator
; DTRA = not used
; DTRB = motor on
;
; CTSA = write protect
; CTSB = not used
; DCDA = media inserted
; DCDB = ready

D6000	EQU	6000H	; quick disk controller, data port channel A
D6002	EQU	6002H	; quick disk controller, control port channel A
D6003	EQU	6003H	; quick disk controller, control port channel B

; quick disk RAM

D7000	EQU	7000H	; 0FFH = this quick disk disabled, 000H = this quick disk enabled
J7001	EQU	7001H	; saved EXTBIO (previous EXTBIO handler)
I7006	EQU	7006H	; saved H.READ
D700B	EQU	700BH	; saved BASIC pointer
D700D	EQU	700DH	; this quick disk device name
D7011	EQU	7011H	; this quick disk id
D7012	EQU	7012H	; filename buffer

; fileentry (64 bytes)

D7023	EQU	7023H	; +0, file type
I7024	EQU	7024H	; +1, file name
D7035	EQU	7035H	; +18, 
D7036	EQU	7036H	; +19, 
D7037	EQU	7037H	; +20, file size
D7039	EQU	7039H	; +22, transfer address
D703B	EQU	703BH	; +24, execute address
I703D	EQU	703DH	; +26, reserved bytes

D7063	EQU	7063H	; wait flag (000H = long, 0FFH = short)
D7064	EQU	7064H	; LOAD flag
D7065	EQU	7065H	; 0FFH = quick disk functionkeys enabled, 000H = quick disk function keys disabled
D7066	EQU	7066H	; first free 'block'
D7067	EQU	7067H	; number of used blocks left
D7068	EQU	7068H	; number of fileentries left
D7069	EQU	7069H	; first free 'block' before write file started
D706A	EQU	706AH	; BIOS first free 'block'
D706B	EQU	706BH	; offset
D706D	EQU	706DH	; pointer to filename
I706F	EQU	706FH	; fileentry #2 buffer
D70AF	EQU	70AFH	; current blocktype
D70B0	EQU	70B0H	; filemode
D70B1	EQU	70B1H	; filesize
D70B3	EQU	70B3H	; fill buffers/flush buffers flag
D70B4	EQU	70B4H	; i/o channel 0 check
D70B5	EQU	70B5H	; use normal/video memory
D70B6	EQU	70B6H	; 'block' check enabled/disabled (000H/001H)

D70B7	EQU	70B7H	; +0, file #0 open status
D70B8	EQU	70B8H	; +1, file #0 first block of file
D70B9	EQU	70B9H	; +2, file #0 pointer to i/o channel
I70BB	EQU	70BBH	; +4, file #0 backup character
D70BC	EQU	70BCH	; +5, file #0 current blocktype
D70BD	EQU	70BDH	; +6, file #0 pointer to i/o channel buffer
D70BF	EQU	70BFH	; +8, file #0 last blocktype
D70C0	EQU	70C0H	; +9, file #0 buffer
D70C2	EQU	70C2H	; +11, file #0 size of buffer
D70C4	EQU	70C4H	; +13, file #0 current position in buffer
D70C6	EQU	70C6H	; +15, file #0 filename

D70D7	EQU	70D7H	; +0, file #1 open status
D70D8	EQU	70D8H	; +1, file #1 first block of file
D70D9	EQU	70D9H	; +2, file #1 pointer to i/o channel
I70DB	EQU	70DBH	; +4, file #1 backup character
D70DD	EQU	70DDH	; +6, file #1 pointer to i/o channel buffer
D70E0	EQU	70E0H	; +9, file #1 buffer
D70E2	EQU	70E2H	; +11, file #1 size of buffer
D70E6	EQU	70E6H	; +15, file #1 filename

I70F7	EQU	70F7H	; file #0 buffer, 768 bytes
I73F7	EQU	73F7H	; file #1 buffer, 768 bytes
I76F7	EQU	76F7H	; generic buffer, 256 bytes


        DEFB    "AB"
        DEFW    C4050
        DEFW    C41E2
        DEFW    C42C0
        DEFW    0
        DEFS    6,0

I4010:	DEFB	0			; ?
	DEFB	0			; ?
	DEFB	0			; ?
?.4013:	JP	J4917			; read file
?.4016:	JP	J48E2			; write file
?.4019:	JP	J4969			; open file
?.401C:	JP	J4975			; sequential input
?.401F:	JP	J4982			; sequential output
?.4022:	JP	J4994			; end of file
?.4025:	JP	J49A4			; close file
?.4028:	JP	J49B0			; find ASCII file
?.402B:	JP	J49D7			; read 1024 bytes from quick disk
?.402E:	JP	J49ED			; reset quick disk controller
?.4031:	JP	J49FB			; write fileentry
?.4034:	JP	J4A15			; write 1024 bytes to quick disk
?.4037:	JP	J4A34			; write first free 'block'
?.403A:	JP	J4A4D			; delete file
?.403D:	RET				; reserved entry
	RET
	RET

I4040:	DEFB	"QUICKDISK"		; identification string
	DEFB	1			; number of drives

	IF	QDVER EQ 100
	DEFB	"V1.00"			; ascii version
	ENDIF

	IF	QDVER EQ 110
	DEFB	"V1.10"			; ascii version
	ENDIF

	IF	QDVER EQ 111
	DEFB	"V1.11"			; ascii version
	ENDIF

	DEFB	0			; ?, may be end marker of ASCIIZ string ?

;	  Subroutine ROM extension init
;	     Inputs  ________________________
;	     Outputs ________________________

C4050:	LD	HL,HOKVLD
	BIT	0,(HL)			; EXTBIO initialized ?
	JR	NZ,J4063		; yep, skip
	SET	0,(HL)
	LD	HL,EXTBIO
	LD	B,5
J405E:	LD	(HL),0C9H
	INC	HL
	DJNZ	J405E			; initialize EXTBIO
J4063:	XOR	A
	LD	(D7000),A		; assume enable this quick disk
	CALL	C415E			; get this quick disk id
	LD	(D7011),A		; save this quick disk id
	PUSH	AF			; save this quick disk id
	ADD	A,"0"
	LD	HL,256*'D'+'Q'
	LD	(D700D+0),HL
	LD	(D700D+2),A		; this quick disk devicename (QDn)
	XOR	A
	LD	(D700D+3),A
	POP	AF			; restore this quick disk id
	CP	8			; valid quick disk id ?
	JR	C,J4088			; yep, continue
	LD	A,0FFH
	LD	(D7000),A		; disable this quick disk
	RET

J4088:	LD	DE,J7001
	DI
	LD	HL,EXTBIO
	LD	BC,5
	LDIR
	LD	A,1			; page 1
	CALL	C5A6B			; get slotid on page
	LD	(EXTBIO+1),A
	LD	A,0F7H
	LD	(EXTBIO+0),A
	LD	HL,I4887
	LD	(EXTBIO+2),HL
	LD	A,0C9H
	LD	(EXTBIO+4),A		; install EXTBIO handler
	LD	BC,L41CA
	LD	HL,I41CA
	LD	DE,DISINT
	LDIR				; install DISINT and ENAINT handlers
	XOR	A
	LD	(D70B4),A		; i/o channel 0 check enabled
	LD	(D70B5),A		; use normal memory
	LD	(D70B7),A		; file #0 closed
	LD	(D70D7),A		; file #1 closed
	LD	(D70C6),A		; file #0 filename = invalid
	LD	(D70E6),A		; file #1 filename = invalid
	CALL	C5BFA			; reset quick disk controller
	LD	A,(D7011)
	AND	A			; is this the first quick disk ?
	RET	NZ			; nope, quit
	LD	HL,I5CF5		; quick disk init string
	CALL	C53BA			; string to screen
	CALL	C5297			; enable quick disk function keys
	LD	HL,I4152
	LD	DE,D7012		; filename buffer
	LD	BC,12
	LDIR				; copy AUTOEXEC to filename buffer
	CALL	C54C2			; find file
	JR	C,J4107			; error, wait 2250 ms, reset quick disk controller and quit
	JR	NZ,J4103		; not found, reset quick disk controller and quit
	LD	A,(D7023)
	CP	1			; filetype = binary file ?
	JR	NZ,J4110		; nope, install H.READ and quit
	LD	HL,(D7039)		; transfer address
	CALL	C5569			; read file to memory
	JR	C,J4103			; error, reset quick disk controller and quit
	LD	HL,J4103
	PUSH	HL			; after return, reset quick disk controller and quit

	IF	QDVER EQ 100

	LD	HL,(D703B)
	JP	(HL)

	ELSE

	JP	J5DBA			; execute routine with BASIC interpreter enabled

	ENDIF


J4103:	CALL	C5BFA			; reset quick disk controller
	RET

J4107:	LD	B,9
J4109:	CALL	C5CE3			; wait 250 ms
	DJNZ	J4109
	JR	J4103			; reset quick disk controller and quit

; install H.READ and quit

J4110:	DI
	LD	HL,H.READ
	PUSH	HL
	LD	DE,I7006
	LD	BC,5
	LDIR				; backup H.READ
	POP	IX
	LD	(IX+0),0F7H
	LD	A,1			; page 1
	CALL	C5A6B			; get slotid on page
	LD	(IX+1),A
	LD	(IX+2),LOW C4139
	LD	(IX+3),HIGH C4139
	LD	(IX+4),0C9H		; install H.READ handler
	JR	J4103			; reset quick disk controller and quit

;	  Subroutine H.READ handler (before Ok prompt is shown)
;	     Inputs  ________________________
;	     Outputs ________________________

C4139:	DI
	LD	HL,I7006
	LD	DE,H.READ
	LD	BC,5
	LDIR				; restore H.READ
	LD	A,2
	LD	(D7064),A		; LOAD with RUN
	LD	A,1
	LD	(D70B6),A		; 'block' check disabled
	JP	J4CFC			; load BASIC program

I4152:	DEFB	"AUTOEXEC   "
	DEFB	13

;	  Subroutine get this quick disk id
;	     Inputs  ________________________
;	     Outputs ________________________

C415E:	LD	A,1			; page 1
	CALL	C5A6B			; get slotid on page
	LD	B,A			; slotid buffer
	LD	HL,I70F7		; use file #0 buffer
	LD	DE,0FF00H		; system exclusive, build slot address table
	PUSH	HL
J416B:	CALL	EXTBIO
	POP	DE
	CALL	C4B57			; compare HL with DE (any EXTBIO device found ?)
	JR	Z,J418A			; nope, quit
	EX	DE,HL
	XOR	A			; quick disk id = 0
	PUSH	AF
J4177:	CALL	C418C			; get number of quick disk drives
	POP	AF
	ADD	A,B			; update quick disk id
J417C:	PUSH	BC
	LD	BC,5
	ADD	HL,BC			; to next entry
	POP	BC
	PUSH	AF
	CALL	C4B57			; compare HL with DE (end of entries ?)
	JR	NZ,J4177		; nope, next EXTBIO device
	POP	AF
	RET

J418A:	XOR	A
	RET

;	  Subroutine get number of quick disk drives
;	     Inputs  ________________________
;	     Outputs ________________________

C418C:	PUSH	AF
	PUSH	DE
	PUSH	HL
	LD	A,(HL)			; slotid EXTBIO device
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL			; jumptable EXTBIO device
	LD	BC,I4040-I4010
	ADD	HL,BC
	LD	DE,I41AF		; QUICKDISK
	LD	B,A
	CALL	C41B9			; compare string from slot
	JR	NZ,J41A9		; nope, no quickdisk
	LD	A,B
	CALL	C4AF0			; read from slot (number of drives)
	LD	B,A
	JR	J41AB

J41A9:	LD	B,0
J41AB:	POP	HL
	POP	DE
	POP	AF
	RET

I41AF:	DEFB	"QUICKDISK"
	DEFB	0

;	  Subroutine compare string from slot
;	     Inputs  ________________________
;	     Outputs ________________________

C41B9:	LD	A,B
	CALL	C4AF0			; read from slot
	INC	HL
	LD	C,A
	LD	A,(DE)
	INC	DE
	CP	C
	JR	NZ,J41C6		; not equal, quit with NZ
	JR	C41B9

J41C6:	DEC	DE
	DEC	HL
	AND	A
	RET

; DISINT handler

I41CA:	PUSH	DE
	LD	E,2			; disable interrupt function
	JR	J41D2

; ENAINT handler

?.41CF:	PUSH	DE
	LD	E,3			; disable interrupt function
J41D2:	LD	D,0			; broadcast
	PUSH	IX
	PUSH	IY
	CALL	EXTBIO
	EI
	POP	IY
	POP	IX
	POP	DE
	RET

L41CA	EQU	$-I41CA

;	  Subroutine ROM extension call statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C41E2:	XOR	A
	LD	(D70B6),A		; 'block' check enabled
	EI
	LD	A,(D7000)
	RRCA				; this quick disk enabled ?
	RET	C			; nope, quit
	LD	(D700B),HL		; save BASIC pointer
	PUSH	HL
	LD	HL,PROCNM
	LD	DE,I706F
	LD	BC,16
	LDIR				; save devicename
	POP	HL
	LD	DE,I4265
	CALL	C421F
	RET	C
	LD	IX,I420B
	PUSH	IX
	PUSH	DE
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

I420B:	CALL	C5BFA			; reset quick disk controller
	RET	NC			; no error, quit
	LD	HL,I706F
	LD	DE,PROCNM
	LD	BC,16
	LDIR				; restore devicename
	LD	HL,(D700B)		; restore BASIC pointer
	SCF
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C421F:	PUSH	BC
	PUSH	HL
J4221:	LD	HL,PROCNM
	LD	A,(DE)
	INC	A
	JR	Z,J423A
	CALL	C423E
	JR	Z,J4232
	INC	DE
	INC	DE
	INC	DE
	JR	J4221

J4232:	EX	DE,HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	AND	A
	JR	J423B

J423A:	SCF
J423B:	POP	HL
	POP	BC
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C423E:	LD	A,(DE)
	CALL	C5A62			; to upper
	LD	C,A
	LD	A,(HL)
	CALL	C5A62			; to upper
	CP	C
	JR	NZ,J4254
	CP	20H
	JR	C,J4252
	INC	DE
	INC	HL
	JR	C423E

J4252:	XOR	A
	RET

J4254:	LD	A,(DE)
	AND	A
	JR	Z,J425B
	INC	DE
	JR	J4254

J425B:	LD	A,(HL)
	AND	A
	JR	Z,J4262
	INC	HL
	JR	J425B

J4262:	LD	A,L
	OR	H
	RET

I4265:	DEFB	"LOAD"
	DEFB	0
	DEFW	C4CC6

	DEFB	"SAVE"
	DEFB	0
	DEFW	C4DC5

	DEFB	"MERGE"
	DEFB	0
	DEFW	C4DA7

	DEFB	"RUN"
	DEFB	0
	DEFW	C4CA2

	DEFB	"BSAVE"
	DEFB	0
	DEFW	C4FB7

	DEFB	"BLOAD"
	DEFB	0
	DEFW	C4EF8

	DEFB	"QDFILES"
	DEFB	0
	DEFW	C4C1B

	DEFB	"QDFORMAT"
	DEFB	0
	DEFW	C4B9E

	DEFB	"QDKILL"
	DEFB	0
	DEFW	C5052

	DEFB	"QDKEY"
	DEFB	0
	DEFW	C50BC

	DEFB	"CASQD"
	DEFB	0
	DEFW	C50E9

	DEFB	0FFH

;	  Subroutine ROM extension device handler
;	     Inputs  ________________________
;	     Outputs ________________________

C42C0:	EI
	PUSH	AF
	XOR	A
	LD	(D70B6),A		; 'block' check enabled
	LD	A,(D7000)
	RRCA				; this quick disk enabled ?
	JR	C,J42D6			; nope,
	POP	AF
	CP	0FFH			; device inquire ?
	JR	NZ,J42D9		; nope, handle function
	CALL	C5A41			; check if devicename is this quick disk devicename
	RET	Z			; yep, quit
	PUSH	AF
J42D6:	POP	AF
	SCF				; device not recognized
	RET

J42D9:
	IF	QDVER EQ 100

	CP	20-1
	JP	NC,J.INTE
	BIT	0,A
	JP	NZ,J.INTE

	ENDIF

	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	HL
	LD	HL,I42FC
	ADD	A,L
	LD	L,A
	JR	NC,J42E5
	INC	H
J42E5:	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	PUSH	HL
	POP	IX
	POP	HL
	LD	IY,I42F5
	PUSH	IY
	JP	(IX)

I42F5:	CALL	C5BFA			; reset quick disk controller
	POP	HL
	POP	DE
	POP	BC
	RET

I42FC:	DEFW	C4310			; 00: open
	DEFW	C4695			; 02: close
	DEFW	J4A8B			; 04: random I/O, sequential i/o only error
	DEFW	C46E3			; 06: sequential output
	DEFW	C4727			; 08: sequential input
	DEFW	J4AA3			; 0A: loc, illegal function call error
	DEFW	J4AA3			; 0C: lof, illegal function call error
	DEFW	C4773			; 0E: eof
	DEFW	J4AA3			; 10: fpos, illegal function call error
	DEFW	C47A3			; 12: backup

;	  Subroutine device: open function
;	     Inputs  E = filemode
;	     Outputs ________________________

C4310:	LD	A,(D70B4)
	AND	A			; i/o channel 0 check disabled ?
	JR	NZ,J4328		; yep, skip
	PUSH	DE
	PUSH	HL
	EX	DE,HL
	LD	HL,(FILTAB)
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; pointer to i/o channel 0
	CALL	C4B57			; compare HL with DE
	POP	HL
	POP	DE
	JP	Z,J4A85			; yep, quit with bad filename error
J4328:	LD	BC,FILNAM
	XOR	A
	LD	(D70B4),A		; i/o channel 0 check enabled
	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C435A			; open file
	POP	HL
	POP	DE
	POP	BC
	PUSH	AF
	LD	A,(D7023)
	CP	3			; filetype = ASCII file ?
	JP	NZ,J4AA3		; nope, quit with illegal function call error
J4341:	POP	AF
	JR	C,J4348			; error, handle error
	LD	(PTRFIL),HL		; interpreter output to file
	RET

J4348:	CP	53			; File not found ?
	JP	Z,J4ABB			; yep, file not found error
	CP	5			; Illegal function call ?
	JP	Z,J4AA3			; yep, illegal function call error
	CP	56			; Bad file name ?
	JP	Z,J4A85			; yep, bad filename error
	JP	J4AAF			; device I/O error

;	  Subroutine open file
;	     Inputs  E = filemode, HL = pointer to filename
;	     Outputs ________________________

C435A:	LD	A,E
	LD	(D70B0),A		; filemode
	CP	2			; sequential output ?
	JR	Z,J436A			; yep,
	CP	1			; sequential input ?
	JP	Z,J4422			; yep,
	JP	C4569			; quit with Illegal function call error

; open file for sequential output

J436A:	PUSH	HL
	PUSH	BC
	POP	HL
	LD	(D706D),HL		; save pointer to filename
	CALL	C5A06			; check filename and copy to filename buffer
	POP	HL
	JP	C,J456D			; error, quit with Bad file name error
	CALL	C460D			; get file #0 and #1 open status
	JR	Z,J4389			; both closed, use file #0 with extra write block buffer
	DEC	A			; file #0 open for input ?
	JR	Z,J43D7			; yep, use file #1
	DEC	A			; file #0 open for output ?
	JR	Z,J4386			; yep, illegal function call
	DEC	A
	DEC	A			; file #1 open for input ?
	JR	Z,J438F			; yep, use file #0
J4386:	JP	C4569			; quit with Illegal function call error

J4389:	PUSH	HL
	LD	HL,768+1024
	JR	J4393

J438F:	PUSH	HL
	LD	HL,768
J4393:	LD	(D70C2),HL		; file #0 size of buffer
	LD	DE,D70E6		; file #1 filename
	LD	HL,(D706D)		; pointer to filename
	CALL	C4680			; compare filenames
	POP	HL
	JP	Z,C4569			; equal, quit with Illegal function call error
	PUSH	HL
	LD	HL,(D706D)		; pointer to filename
	LD	DE,D70C6		; file #0 filename
	LD	BC,12
	LDIR
	CALL	C461A			; write fileentry to quick disk
	POP	HL
	JP	C,C4565			; quit with Device I/O error
	INC	A
	LD	(D70B8),A		; file #0 first block of file
	LD	(D70B9),HL		; file #0 pointer to i/o channel
	CALL	C463D			; set filemode i/o channel, get pointer to i/o channel buffer
	LD	(D70BD),HL		; file #0 pointer to i/o channel buffer
	LD	HL,I70F7
	LD	(D70C0),HL		; file #0 buffer
	LD	IY,D70B7		; file #0 variables
	CALL	C4648
	LD	A,2
	LD	(D70B7),A		; file #0 open for output
	AND	A
	RET

J43D7:	PUSH	HL
	CALL	C45CC
	LD	HL,768
	LD	(D70E2),HL		; file #1 size of buffer
	LD	DE,D70C6		; file #0 filename
	LD	HL,(D706D)		; pointer to filename
	CALL	C4680			; compare filenames
	POP	HL
	JP	Z,C4569			; equal, quit with Illegal function call error
	PUSH	HL
	LD	HL,(D706D)		; pointer to filename
	LD	DE,D70E6		; file #1 filename
	LD	BC,12
	LDIR
	CALL	C461A			; write fileentry to quick disk
	POP	HL
	JP	C,C4565			; quit with Device I/O error
	INC	A
	LD	(D70D8),A		; file #1 first block of file
	LD	(D70D9),HL		; file #1 pointer to i/o channel
	CALL	C463D			; set filemode i/o channel, get pointer to i/o channel buffer
	LD	(D70DD),HL		; file #1 pointer to i/o channel buffer
	LD	HL,I73F7
	LD	(D70E0),HL		; file #1 buffer
	LD	IY,D70D7		; file #1 variables
	CALL	C4648
	LD	A,2
	LD	(D70D7),A		; file #1 open for output
	AND	A
	RET

; open file for sequential input

J4422:	PUSH	HL
	PUSH	BC
	POP	HL
	LD	(D706D),HL		; save pointer to filename
	CALL	C5A06			; check filename and copy to filename buffer
	POP	HL
	JP	C,J456D			; error, quit with Bad file name error
	CALL	C460D			; get file #0 and #1 open status
	JR	Z,J4447			; both closed, use file #0 with read ahead buffer
	DEC	A			; file #0 open for input ?
	JP	Z,J44D2			; yep, use file #1
	DEC	A			; file #0 open for output ?
	JP	Z,J44D7			; yep, use file #1
	DEC	A
	DEC	A			; file #1 open for input ?
	JR	Z,J444D			; yep, use file #0
	CP	4			; BUG: should be DEC A, file #0 open for output ?
	JR	Z,J444D			; yep, use file #0
	JP	C4569			; quit with Illegal function call error

J4447:	PUSH	HL
	LD	HL,768+1024
	JR	J4451

J444D:	PUSH	HL
	LD	HL,768
J4451:	LD	(D70C2),HL		; file #0 size of buffer
	LD	DE,D70E6		; file #1 filename
	LD	HL,(D706D)		; pointer to filename
	CALL	C4680			; compare filenames
	POP	HL
	JP	Z,C4569			; equal, quit with Illegal function call error
	PUSH	HL
	LD	HL,(D706D)		; pointer to filename
	LD	DE,D70C6		; file #0 filename
	LD	BC,12
	LDIR
	POP	HL
	LD	B,3
J4470:	PUSH	BC
	CALL	C447C
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	RET	NC			; no error, quit
	DJNZ	J4470
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C447C:	PUSH	HL
	CALL	C54C2			; find file
	POP	HL
	JP	C,C4565			; error, quit with Device I/O error
	JP	NZ,C4561		; not found, quit with File not found error
	LD	A,(D7023)
	CP	3			; filetype = ASCII file ?
	JP	NZ,C4569		; nope, quit with Illegal function call error
	CALL	C527F			; check first free 'block'
	JP	C,C4565			; error, quit with Device I/O error
	CALL	C528B			; check ? 'block'
	JP	C,C4565			; error, quit with Device I/O error
	LD	A,(D7067)
	LD	B,A			; number of used blocks left
	LD	A,(D7066)		; first free 'block'
	SUB	B
	LD	(D7066),A
	LD	(D70B8),A		; file #0 first block of file
	LD	(D70B9),HL		; file #0 pointer to i/o channel
	CALL	C463D			; set filemode i/o channel, get pointer to i/o channel buffer
	LD	(D70BD),HL		; file #0 pointer to i/o channel buffer
	LD	HL,I70F7
	LD	(D70C0),HL		; file #0 buffer
	LD	IY,D70B7		; file #0 variables
	XOR	A
	LD	(IY+13),A
	LD	(IY+14),A		; current position in buffer = 0
	LD	(IY+4),A		; clear backup character
	LD	A,1
	LD	(D70B7),A		; file #0 open for input
	CALL	C5793			; fill buffers from file
	JP	C,C4565			; quit with Device I/O error
	RET

J44D2:	CALL	C45CC
	JR	J44DD

J44D7:	CALL	C4579
	JP	C,C4565			; quit with Device I/O error
J44DD:	PUSH	HL
	LD	HL,768
	LD	(D70E2),HL		; file #1 size of buffer
	LD	DE,D70C6		; file #0 filename
	LD	HL,(D706D)		; pointer to filename
	CALL	C4680			; compare filenames
	POP	HL
	JP	Z,C4569			; equal, quit with Illegal function call error
	PUSH	HL
	LD	HL,(D706D)		; pointer to filename
	LD	DE,D70E6		; file #1 filename
	LD	BC,12
	LDIR
	POP	HL
	LD	B,3
J4500:	PUSH	BC
	CALL	C450C
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	RET	NC			; no error, quit
	DJNZ	J4500
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C450C:	PUSH	HL
	CALL	C54C2			; find file
	POP	HL
	JP	C,C4565			; error, quit with Device I/O error
	JP	NZ,C4561		; not found, quit with File not found error
	LD	A,(D7023)
	CP	3			; filetype = ASCII file ?
	JP	NZ,C4569		; nope, quit with Illegal function call error
	CALL	C527F			; check first free 'block'
	JP	C,C4565			; error, quit with Device I/O error
	CALL	C528B			; check ? 'block'
	JR	C,C4565			; error, quit with Device I/O error
	LD	A,(D7067)
	LD	B,A			; number of used blocks left
	LD	A,(D7066)		; first free 'block'
	SUB	B
	LD	(D7066),A
	LD	(D70D8),A		; file #1 first block of file
	LD	(D70D9),HL		; file #1 pointer to i/o channel
	CALL	C463D			; set filemode i/o channel, get pointer to i/o channel buffer
	LD	(D70DD),HL		; file #1 pointer to i/o channel buffer
	LD	HL,I73F7
	LD	(D70E0),HL		; file #1 buffer
	LD	IY,D70D7		; file #1 variables
	XOR	A
	LD	(IY+13),A
	LD	(IY+14),A		; current position in buffer = 0
	LD	(IY+4),A		; clear backup character
	LD	A,1
	LD	(D70D7),A		; file #1 open for input
	CALL	C5793			; fill buffers from file
	JP	C,C4565			; quit with Device I/O error
	RET

;	  Subroutine File not found error
;	     Inputs  ________________________
;	     Outputs ________________________

C4561:	LD	A,53
	SCF
	RET

;	  Subroutine Device I/O error
;	     Inputs  ________________________
;	     Outputs ________________________

C4565:	LD	A,19
	SCF
	RET

;	  Subroutine Illegal function call error
;	     Inputs  ________________________
;	     Outputs ________________________

C4569:	LD	A,5
	SCF
	RET

;	  Subroutine Bad file name error
;	     Inputs  ________________________
;	     Outputs ________________________

J456D:	LD	A,56
	SCF
	RET

;	  Subroutine Out of memory error
;	     Inputs  ________________________
;	     Outputs ________________________

J4571:	LD	A,7
	SCF
	RET

;	  Subroutine Verify error
;	     Inputs  ________________________
;	     Outputs ________________________

J4575:	LD	A,20
	SCF
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4579:	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	IY
	LD	IY,D70B7		; file #0 variables
	LD	HL,(D70C2)		; file #0 size of buffer
	LD	DE,768+768+256
	CALL	C4B57			; compare HL with DE
	JR	NZ,J45C5
	LD	HL,768
	LD	(D70C2),HL		; file #0 size of buffer
	LD	HL,(D70C4)		; file #0 current position in buffer
	LD	DE,1024
	AND	A
	SBC	HL,DE
	JR	C,J45C6
	PUSH	HL
	LD	A,3
	LD	(D70BC),A		; blocktype
	LD	(D70BF),A		; blocktype
	CALL	C485B			; flush buffers to quick disk
	POP	HL
	JR	C,J45C6
	LD	(D70C4),HL		; update file #0 current position in buffer
	LD	HL,I73F7
	LD	DE,(D70BD)		; file #0 pointer to i/o channel buffer
	LD	BC,256
	LDIR
	LD	DE,(D70C0)		; file #0 buffer
	LD	BC,768
	LDIR
J45C5:	AND	A
J45C6:	POP	IY
	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C45CC:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,(D70C2)		; file #0 size of buffer
	LD	DE,768+768+256
	CALL	C4B57			; compare HL with DE
	JR	NZ,J4603
	LD	HL,(D70C4)		; file #0 current position in buffer
	LD	DE,1024
	AND	A
	SBC	HL,DE
	JR	C,J45FF
	LD	(D70C4),HL		; update file #0 current position in buffer
	LD	HL,I73F7
	LD	DE,(D70BD)		; file #0 pointer to i/o channel buffer
	LD	BC,256
	LDIR
	LD	DE,(D70C0)		; file #0 buffer
	LD	BC,768
	LDIR
	JR	J4603

J45FF:	LD	HL,(D70B8)
	DEC	(HL)
J4603:	LD	HL,768
	LD	(D70C2),HL		; file #0 size of buffer
	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine get file #0 and #1 open status
;	     Inputs  ________________________
;	     Outputs ________________________

C460D:	PUSH	BC
	LD	A,(D70B7)
	LD	B,A			; file #0 status
	LD	A,(D70D7)		; file #1 status
	ADD	A,A
	ADD	A,A
	ADD	A,B
	POP	BC
	RET

;	  Subroutine write fileentry to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C461A:	CALL	C5476			; search fileentry
	RET	C			; error, quit
	CALL	C5426			; initialize new fileentry
	LD	A,3
	LD	(D7023),A		; filetype = ASCII file
	LD	HL,0
	LD	(D7039),HL		; transfer address = 0
	LD	(D7037),HL		; number of bytes = 0
	LD	(D703B),HL		; execute address = 0
	CALL	C5890			; write 64 bytes to quick disk
	CALL	C5BFA			; reset quick disk controller
	RET	C			; error, quit
	LD	A,(D7066)		; first free 'block'
	RET

;	  Subroutine set filemode i/o channel, get pointer to i/o channel buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C463D:	PUSH	BC
	LD	A,(D70B0)		; filemode
	LD	(HL),A
	LD	BC,9
	ADD	HL,BC
	POP	BC
	RET

;	  Subroutine initialize buffers
;	     Inputs  ________________________
;	     Outputs ________________________

C4648:	PUSH	BC
	PUSH	HL
	XOR	A
	LD	(IY+13),A
	LD	(IY+14),A		; current position in buffer = 0
	LD	(IY+4),A		; clear backup character
	LD	L,(IY+6)
	LD	H,(IY+7)		; pointer to i/o channel buffer
	LD	BC,256
J465D:	LD	A,B
	OR	C
	JR	Z,J4667
	LD	(HL),0
	INC	HL
	DEC	BC
	JR	J465D			; clear i/o channel buffer

J4667:	LD	L,(IY+9)
	LD	H,(IY+10)		; file buffer
	LD	C,(IY+11)
	LD	B,(IY+12)		; size of file buffer
J4673:	LD	A,B
	OR	C
	JR	Z,J467D
	LD	(HL),0
	INC	HL
	DEC	BC
	JR	J4673			; clear file buffer

J467D:	POP	HL
	POP	BC
	RET

;	  Subroutine compare filenames
;	     Inputs  ________________________
;	     Outputs ________________________

C4680:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C468A
	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine compare filenames
;	     Inputs  ________________________
;	     Outputs ________________________

C468A:	LD	B,11
J468C:	LD	A,(DE)
	CP	(HL)
	RET	NZ
	INC	HL
	INC	DE
	DJNZ	J468C
	XOR	A
	RET

;	  Subroutine device: close function
;	     Inputs  ________________________
;	     Outputs ________________________

C4695:	CALL	C469C
	JP	C,J4AAF			; device I/O error
	RET

;	  Subroutine close file
;	     Inputs  ________________________
;	     Outputs ________________________

C469C:	LD	DE,(D70B9)		; file #0 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J46AF
	XOR	A
	LD	(D70B7),A		; file #0 closed
	LD	IY,D70B7
	JR	J46C0

J46AF:	LD	DE,(D70D9)		; file #1 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J46E1		; nope, quit
	XOR	A
	LD	(D70D7),A		; file #1 closed
	LD	IY,D70D7		; file #1 variables
J46C0:	LD	A,(HL)
	CP	2			; filemode = sequential output ?
	JR	NZ,J46D7		; nope, skip flush buffer
	LD	C,1AH			; EOF
	PUSH	HL
	CALL	C46F0			; sequential output
	POP	HL
	LD	A,19			; Device I/O error
	RET	C			; error, quit
	PUSH	HL
	CALL	C481A			; write file end block
	POP	HL
	LD	A,19			; Device I/O error
	RET	C			; error, quit
J46D7:	XOR	A
	LD	(IY+2),A
	LD	(IY+3),A		; clear pointer to i/o channel
	LD	(IY+15),A		; filename invalid
J46E1:	AND	A
	RET

;	  Subroutine device: sequential output function
;	     Inputs  ________________________
;	     Outputs ________________________

C46E3:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C46F0			; sequential output
	POP	HL
	POP	DE
	POP	BC
	JP	C,J4AAF			; device I/O error
	RET

;	  Subroutine sequential output
;	     Inputs  ________________________
;	     Outputs ________________________

C46F0:	LD	DE,(D70B9)		; file #0 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J46FF
	LD	IY,D70B7		; file #0 variables
	JR	J470C

J46FF:	LD	DE,(D70D9)		; file #1 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J4725		; nope, quit with error
	LD	IY,D70D7		; file #1 variables
J470C:	CALL	C4800			; at end of buffer ?
	PUSH	BC
	LD	A,3
	LD	(IY+5),A		; current blocktype = 3
	LD	(IY+8),A		; last blocktype = 3
	CALL	Z,C485B			; yep, flush buffers to quick disk
	POP	BC
	LD	A,19			; Device I/O error
	RET	C			; error, quit
	CALL	C47D3			; get pointer in buffer and update position
	LD	(HL),C			; put character in buffer
	AND	A
	RET

J4725:	SCF
	RET

;	  Subroutine device: sequential input function
;	     Inputs  ________________________
;	     Outputs ________________________

C4727:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C473C
	LD	A,C
	POP	HL
	POP	DE
	POP	BC
	JP	C,J4AAF			; device I/O error
	CP	1AH
	JR	NZ,J473A
	SCF
	RET

J473A:	AND	A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C473C:	LD	DE,(D70B9)		; file #0 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J474B
	LD	IY,D70B7		; file #0 variables
	JR	J4758

J474B:	LD	DE,(D70D9)		; file #1 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J4725		; nope, quit with error
	LD	IY,D70D7		; file #1 variables
J4758:	CALL	C47C2			; get backup character
	RET	NZ			; yep, quit
	CALL	C4800			; at end of buffer ?
	PUSH	HL
	CALL	Z,C484A			; yep, fill buffers from quick disk with retry
	POP	HL
	RET	C			; error, quit
	PUSH	HL
	CALL	C47D3			; get pointer in buffer
	LD	A,(HL)			; get character from buffer
	POP	HL
	CP	1AH			; eof ?
	LD	C,A
	CALL	Z,C47A3			; yep, backup character
	AND	A
	RET

;	  Subroutine device: eof function
;	     Inputs  ________________________
;	     Outputs ________________________

C4773:	PUSH	HL
	CALL	C4784			; end of file
	LD	(DAC+2),HL
	LD	A,2
	LD	(VALTYP),A
	POP	HL
	JP	C,J4AAF			; error, device I/O error
	RET

;	  Subroutine end of file
;	     Inputs  ________________________
;	     Outputs ________________________

C4784:	LD	A,(HL)
	CP	1			; filemode = sequential input ?
	JR	NZ,J4799		; nope,
	PUSH	HL
	CALL	C473C
	POP	HL
	LD	A,19			; Device I/O error
	RET	C			; error, quit
	CALL	C47A3			; backup character
	LD	A,C
	CP	1AH
	JR	Z,J479E
J4799:	XOR	A
	LD	L,A
	LD	H,A			; not end of file
	JR	J47A1

J479E:	LD	HL,-1			; end of file
J47A1:	AND	A
	RET

;	  Subroutine device: backup function
;	     Inputs  ________________________
;	     Outputs ________________________

C47A3:	PUSH	HL
	LD	DE,(D70B9)		; file #0 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J47B2
	LD	HL,I70BB		; file #0 backup character
	JR	J47BE

J47B2:	LD	DE,(D70D9)		; file #1 pointer to i/o channel
	CALL	C4B57			; compare HL with DE
	JR	NZ,J47BF		; nope, quit
	LD	HL,I70DB		; file #1 backup character
J47BE:	LD	(HL),C
J47BF:	AND	A
	POP	HL
	RET

;	  Subroutine get backup character
;	     Inputs  ________________________
;	     Outputs ________________________

C47C2:	LD	A,(IY+4)
	AND	A			; backup character ?
	JR	Z,J47D0			; nope, quit
	CP	1AH			; eof ?
	JR	Z,J47D0			; yep, leave backup character
	LD	(IY+4),0		; clear backup character
J47D0:	LD	C,A
	AND	A
	RET

;	  Subroutine get pointer in buffer and update position
;	     Inputs  ________________________
;	     Outputs ________________________

C47D3:	LD	L,(IY+13)
	LD	H,(IY+14)		; current position in buffer
	LD	DE,256
	AND	A
	SBC	HL,DE
	JR	C,J47F7
	EX	DE,HL
	LD	L,(IY+9)
	LD	H,(IY+10)		; file buffer
J47E8:	ADD	HL,DE
	LD	E,(IY+13)
	LD	D,(IY+14)
	INC	DE
	LD	(IY+13),E
	LD	(IY+14),D		; update current position in buffer
	RET

J47F7:	ADD	HL,DE
	LD	E,(IY+6)
	LD	D,(IY+7)		; pointer to i/o channel buffer
	JR	J47E8

;	  Subroutine at end of buffer ?
;	     Inputs  ________________________
;	     Outputs ________________________

C4800:	PUSH	DE
	PUSH	HL
	LD	L,(IY+11)
	LD	H,(IY+12)		; size of file buffer
	LD	DE,256
	ADD	HL,DE			; + size of i/o channel buffer
	LD	E,(IY+13)
	LD	D,(IY+14)		; current position in buffer
	CALL	C4B57			; compare HL with DE
	SCF
	CCF				; clear Cx (no error)
	POP	HL
	POP	DE
	RET

;	  Subroutine write file end block
;	     Inputs  ________________________
;	     Outputs ________________________

C481A:	LD	L,(IY+13)
	LD	H,(IY+14)		; current position in buffer
	LD	DE,1024
	AND	A
	SBC	HL,DE
	JR	C,J4834
	LD	A,3
	LD	(IY+5),A		; current blocktype = 3
	LD	A,7
	LD	(IY+8),A		; last blocktype = 7
	JR	J4839

J4834:	LD	A,7
	LD	(IY+5),A		; current blocktype = 7
J4839:	CALL	C485B			; flush buffers to quick disk
	RET	C
	LD	A,(IY+1)
	LD	(D7066),A		; first free 'block'
	CALL	C555C			; write first free 'block'
	CALL	C5BFA			; reset quick disk controller
	RET

;	  Subroutine fill buffers from quick disk with retry
;	     Inputs  ________________________
;	     Outputs ________________________

C484A:	LD	B,3
J484C:	PUSH	BC
	XOR	A			; fill buffers
	CALL	C485D			; fill buffers from quick disk
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	RET	NC			; no error, quit
	DJNZ	J484C
	JP	C4565			; quit with Device I/O error

;	  Subroutine flush buffers to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C485B:	LD	A,1			; flush buffers

;	  Subroutine fill buffers from quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C485D:	LD	(D70B3),A		; fill buffers flag
	LD	A,(IY+1)
	LD	(D7067),A		; number of used blocks left
	CALL	C5BFA			; reset quick disk controller
	CALL	C567A			; read fileentry
	RET	C			; error, quit
	LD	A,(D70B3)
	AND	A			; flush buffers ?
	JR	Z,J4878			; nope, fill buffers
	CALL	C5699			; write buffers to file
	JR	J487B

J4878:	CALL	C5793			; fill buffers from file
J487B:	CALL	C5BFA			; reset quick disk controller
	RET	C			; error, quit
	XOR	A
	LD	(IY+13),A
	LD	(IY+14),A		; current position in buffer = 0
	RET

;	  Subroutine EXTBIO handler
;	     Inputs  ________________________
;	     Outputs ________________________

I4887:	EI
	PUSH	AF
	LD	A,D
	INC	A                       ; system exclusive ?
	JP	Z,J48B8			; yep, handle it
	DEC	A                       ; broadcast ?
	JP	NZ,J48CB		; nope, cascade EXTBIO
	LD	A,E
	AND	A                       ; build device name table ?
	JR	Z,J48A2			; yep, handle it
	DEC	A                       ; return numer of trap entries ?
	JR	Z,J48AF			; yep, handle it
	DEC	A                       ; disable interrupt ?
	JR	Z,J48B2			; yep, handle it
	DEC	A                       ; enable interrupt ?
	JR	Z,J48B5			; yep, handle it
	JP	J48CB			; cascade EXTBIO

J48A2:	LD	A,0FFH                  ; deviceid = NONE
	CALL	C4ADE			; write to slot
	LD	A,00H                   ; reserved byte
	CALL	C4ADE			; write to slot
	JP	J48CB			; cascade EXTBIO

J48AF:	JP	J48CB			; cascade EXTBIO

J48B2:	JP	J48CB			; cascade EXTBIO

J48B5:	JP	J48CB			; cascade EXTBIO

J48B8:	LD	A,E
	AND	A                       ; Build slot address table ?
	JR	NZ,J48C9               ; no, unknown to me, cascade EXTBIO
	CALL	C48CF			; build slotid and jumptable address
	LD	A,14H                   ; makerid = MITSUMI DENKI
	CALL	C4ADE			; write to slot
	LD	A,00H                   ; reserved byte
	CALL	C4ADE			; write to slot
J48C9:	JR	J48CB			; cascade EXTBIO

J48CB:	POP	AF
	JP	J7001

;	  Subroutine build slotid and jumptable address
;	     Inputs  ________________________
;	     Outputs ________________________

C48CF:	LD	A,1			; page 1
	CALL	C5A6B			; get slotid on page
	CALL	C4ADE			; write to slot
	LD	A,LOW I4010
	CALL	C4ADE			; write to slot
	LD	A,HIGH I4010
	CALL	C4ADE			; write to slot
	RET

;	  Subroutine entry 4016H (write file)
;	     Inputs  ________________________
;	     Outputs ________________________

J48E2:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	(D7039),HL		; transfer address
	LD	(D7037),BC		; number of bytes
	LD	(D70B5),A		; use normal/video memory
	CALL	C4A72			; copy filename to filename buffer
	CALL	DISINT
	DI
	LD	B,3
J48F8:	PUSH	BC
	CALL	C4E60			; write file
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JR	NC,J490F		; no error, quit
	CP	20			; Verify error ?
	PUSH	AF
	CALL	Z,C4E51			; yep, write first free 'block' when write file failed
	POP	AF
	CALL	C5BFA			; reset quick disk controller
	DJNZ	J48F8
	SCF				; error
J490F:	CALL	ENAINT
	EI
J4913:	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine entry 4013H (read file)
;	     Inputs  HL = offset, A = flag (0 = memory, 1 = videomemory, 2 = leave files open)
;	     Outputs ________________________

J4917:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	(D706B),HL		; offset
	PUSH	AF
	XOR	A
	LD	(D70B5),A		; use normal memory
	LD	(D7064),A		; plain LOAD
	POP	AF
	DEC	A			; videomemory ?
	JR	NZ,J492F		; 
	INC	A
	LD	(D70B5),A		; use video memory
	JR	J4936

J492F:	DEC	A
	JR	NZ,J4936
	INC	A
	LD	(D7064),A		; LOAD, leave files open
J4936:	CALL	C4A72			; copy filename to filename buffer
	CALL	DISINT
	DI
	LD	B,3
J493F:	PUSH	BC
	CALL	C4F87			; read file
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JR	NC,J4955		; no error,
	CP	19			; Device I/O error ?
	SCF
	JP	NZ,J490F		; nope, quit with error
	DJNZ	J493F
	SCF
	JP	J490F			; quit with error

J4955:	CALL	ENAINT
	EI
	LD	A,(D7064)
	AND	A			; plain LOAD ?
	JR	Z,J4966			; yep,
	LD	HL,J4966
	PUSH	HL

	IF	QDVER EQ 100

	LD	HL,(D703B)
	LD	DE,(D706B)
	ADD	HL,DE
	JP	(HL)

	ELSE

	JP	J5DBF			; execute routine (+ offset) with BASIC interpreter enabled

	ENDIF


J4966:	AND	A
	JR	J4913

;	  Subroutine open file entry 4019H
;	     Inputs  E = filemode
;	     Outputs ________________________

J4969:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C435A			; open file
	JR	J498C			; quit routine

;	  Subroutine sequential input entry 401CH
;	     Inputs  ________________________
;	     Outputs ________________________

J4975:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C4727			; sequential input
	LD	A,C
	JR	J498C			; quit routine

;	  Subroutine sequential output entry 401FH
;	     Inputs  ________________________
;	     Outputs ________________________

J4982:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C46F0			; sequential output
J498C:	CALL	ENAINT
	EI
	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine end of file entry 4022H
;	     Inputs  ________________________
;	     Outputs ________________________

J4994:	PUSH	BC
	PUSH	DE
	CALL	DISINT
	DI
	CALL	C4784			; end of file
	CALL	ENAINT
	EI
	POP	DE
	POP	BC
	RET

;	  Subroutine close file entry 4025H
;	     Inputs  ________________________
;	     Outputs ________________________

J49A4:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C469C			; close file
	JR	J498C			; quit routine

;	  Subroutine entry 4028H
;	     Inputs  find ASCII file
;	     Outputs ________________________

J49B0:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C5A18			; copy filename to filename buffer
	CALL	C54C2			; find file
	CALL	C,C4565			; error, set Device I/O error
	CALL	NZ,C4561		; not found, set File not found error
	CALL	C,C5BFA			; error, reset quick disk controller
	JP	C,J498C			; error, quit routine
	LD	A,(D7023)
	CP	3			; filetype = ASCII file ?
	CALL	NZ,C4569		; nope, set Illegal function call error
	CALL	C,C5BFA			; error, reset quick disk controller
	JP	J498C			; quit routine

;	  Subroutine entry 402BH
;	     Inputs  ________________________
;	     Outputs ________________________

J49D7:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C5837			; read 1024 bytes from quick disk
	CALL	C,C4565			; error, set Device I/O error
	JP	C,J498C			; error, quit routine
	LD	A,(D70AF)		; current blocktype
	JP	J498C			; quit routine

;	  Subroutine entry 402EH
;	     Inputs  ________________________
;	     Outputs ________________________

J49ED:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C5BFA			; reset quick disk controller
	AND	A			; no error
	JP	J498C			; quit routine

;	  Subroutine entry 4031H (write fileentry)
;	     Inputs  ________________________
;	     Outputs ________________________

J49FB:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C5A18			; copy filename to filename buffer
	CALL	C461A			; write fileentry to quick disk
	INC	A
	LD	(D706A),A		; update BIOS first free 'block'
	CALL	C,C4565			; error, set Device I/O error
	CALL	C,C5BFA			; error, reset quick disk controller
	JP	J498C			; quit routine

;	  Subroutine entry 4034H (write 1024 bytes to quick disk)
;	     Inputs  ________________________
;	     Outputs ________________________

J4A15:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	LD	(D70AF),A		; current blocktype
	CALL	C575C			; write 1024 bytes to quick disk
	CALL	C,C5BFA			; error, reset quick disk controller
	CALL	C,C4565			; set Device I/O error
	PUSH	AF
	LD	A,(D706A)
	INC	A
	LD	(D706A),A		; update BIOS first free 'block'
	POP	AF
	JP	J498C			; quit routine

;	  Subroutine entry 4037H (write first free 'block')
;	     Inputs  ________________________
;	     Outputs ________________________

J4A34:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	LD	A,(D706A)		; BIOS first free 'block'
	LD	(D7066),A		; first free 'block'
	CALL	C5BFA			; reset quick disk controller
	CALL	C555C			; write first free 'block'
	CALL	C5BFA			; reset quick disk controller
	JP	J498C			; quit routine

;	  Subroutine entry 403AH (delete file)
;	     Inputs  ________________________
;	     Outputs ________________________

J4A4D:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	DISINT
	DI
	CALL	C5A18			; copy filename to filename buffer
	LD	B,3
J4A59:	PUSH	BC
	CALL	C5087			; delete file
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JP	NC,J498C		; no error, quit routine
	CALL	C5BFA			; reset quick disk controller
	CP	19			; Device I/O error ?
	SCF
	JP	NZ,J498C		; nope, quit routine with error
	DJNZ	J4A59			; try again
	JP	J498C			; quit routine with error

;	  Subroutine copy filename to filename buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C4A72:	PUSH	BC
	PUSH	DE
	PUSH	HL
	EX	DE,HL
	LD	DE,D7012
	LD	BC,11
	LDIR
	LD	A,13
	LD	(DE),A
	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine bad filename error
;	     Inputs  ________________________
;	     Outputs ________________________

J4A85:	LD	IX,M6E6B		; bad filename error
	JR	J4ABF


	IF	QDVER EQ 100

;	  Subroutine internal error
;	     Inputs  ________________________
;	     Outputs ________________________

J.INTE:	LD	IX,M6E80
	JR	J4ABF

	ENDIF

;	  Subroutine sequential i/o only error
;	     Inputs  ________________________
;	     Outputs ________________________

J4A8B:	LD	IX,M6E86		; sequential i/o only error
	JR	J4ABF

;	  Subroutine file already open error
;	     Inputs  ________________________
;	     Outputs ________________________

J4A91:	LD	IX,M6E6E		; file already open error
	JR	J4ABF

;	  Subroutine file not open error
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4A97:	LD	IX,M6E77		; file not open error
	JR	J4ABF

;	  Subroutine syntax error
;	     Inputs  ________________________
;	     Outputs ________________________

J4A9D:	LD	IX,M4055		; syntax error
	JR	J4ABF

;	  Subroutine illegal function call error
;	     Inputs  ________________________
;	     Outputs ________________________

J4AA3:	LD	IX,M475A		; illegal function call error
	JR	J4ABF

;	  Subroutine type mismatch error
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4AA9:	LD	IX,M406D		; type mismatch error
	JR	J4ABF

;	  Subroutine device I/O error
;	     Inputs  ________________________
;	     Outputs ________________________

J4AAF:	LD	IX,M73B2		; device I/O error
	JR	J4ABF

;	  Subroutine out of memory error
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4AB5:	LD	IX,M6275		; out of memory error
	JR	J4ABF

;	  Subroutine file not found error
;	     Inputs  ________________________
;	     Outputs ________________________

J4ABB:	LD	IX,M6E74		; file not found error
J4ABF:	CALL	C5BFA			; reset quick disk controller
	JP	C4B91

;	  Subroutine verify error
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4AC5:	LD	A,20

;	  Subroutine throw BASIC error
;	     Inputs  ________________________
;	     Outputs ________________________

J4AC7:	LD	IX,M406F		; BASIC error
	LD	E,A
	JR	J4ABF

;	  Subroutine write to slot
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4ACE:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	E,D
	LD	IX,WRSLT
	CALL	C4B91
	EI
	POP	DE
	POP	BC
	POP	AF
	RET

;	  Subroutine write to slot
;	     Inputs  ________________________
;	     Outputs ________________________

C4ADE:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	E,A
	LD	A,B
	LD	IX,WRSLT
	CALL	C4B91
	EI
	INC	HL
	POP	DE
	POP	BC
	POP	AF
	RET

;	  Subroutine read from slot
;	     Inputs  ________________________
;	     Outputs ________________________

C4AF0:	PUSH	BC
	PUSH	DE
	LD	IX,RDSLT
	CALL	C4B91
	EI
	POP	DE
	POP	BC
	RET

;	  Subroutine setup VDP for VRAM read
;	     Inputs  ________________________
;	     Outputs ________________________

C4AFD:	LD	IX,SETRD
	JR	J4B29

;	  Subroutine setup VDP for VRAM write
;	     Inputs  ________________________
;	     Outputs ________________________

C4B03:	LD	IX,SETWRT
	JR	J4B29

;	  Subroutine check if key pressed
;	     Inputs  ________________________
;	     Outputs ________________________

C4B09:	LD	IX,CHSNS

	IF	QDVER EQ 100

	JR	C4B91

	ELSE

	JR	J4B29

	ENDIF

;	  Subroutine get key
;	     Inputs  ________________________
;	     Outputs ________________________

C4B0F:	LD	IX,CHGET
	JR	C4B91

;	  Subroutine character to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C4B15:	PUSH	AF
	LD	IX,CHPUT
	CALL	C4B91
	POP	AF
	RET

;	  Subroutine initialize function keys
;	     Inputs  ________________________
;	     Outputs ________________________

C4B1F:	LD	IX,INIFNK
	JR	C4B91

;	  Subroutine display function keys if enabled
;	     Inputs  ________________________
;	     Outputs ________________________

C4B25:	LD	IX,FNKSB
J4B29:	JR	C4B91

	IF	QDVER NE 100

;	  Subroutine check if CTRL-STOP pressed
;	     Inputs  ________________________
;	     Outputs ________________________

C4B2B:	LD	IX,BREAKX
	JR	C4B91

;	  Subroutine read keyboard row
;	     Inputs  ________________________
;	     Outputs ________________________

C4B31:	LD	IX,SNSMAT
	JR	C4B91

	ENDIF

;	  Subroutine check for BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C4B37:	LD	A,(HL)
	EX	(SP),HL
	CP	(HL)
	JP	NZ,J4A9D		; syntax error
	INC	HL
	EX	(SP),HL

;	  Subroutine get BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C4B3F:	LD	IX,M4666
	JR	C4B91

;	  Subroutine evaluate expression
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4B45:	LD	IX,M4C64
	JR	C4B91

;	  Subroutine evaluate address operand
;	     Inputs  ________________________
;	     Outputs ________________________

C4B4B:	LD	IX,M542F
	JR	C4B91

;	  Subroutine free temporary string with type check
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4B51:	LD	IX,M67D0
	JR	C4B91

;	  Subroutine compare HL with DE
;	     Inputs  ________________________
;	     Outputs ________________________

C4B57:	LD	IX,DCOMPR
	JR	C4B91

;	  Subroutine setup BASIC linelinks from this point
;	     Inputs  ________________________
;	     Outputs ________________________

C4B5D:	LD	IX,M4257
	JR	C4B91

;	  Subroutine setup BASIC linelinks from this point, initialize interpreter
;	     Inputs  ________________________
;	     Outputs ________________________

J4B63:	LD	IX,M423B
	JR	C4B91

;	  Subroutine BASIC mainloop
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4B69:	LD	IX,M4134
	JR	C4B91

;	  Subroutine execute new statement
;	     Inputs  ________________________
;	     Outputs ________________________

J4B6F:	LD	IX,M4601
	JR	C4B91

;	  Subroutine close all i/o channels
;	     Inputs  ________________________
;	     Outputs ________________________

C4B75:	LD	IX,M6C1C
	JR	C4B91

;	  Subroutine evaluate filespecification
;	     Inputs  ________________________
;	     Outputs ________________________

C4B7B:	LD	IX,M6A0E
	JR	C4B91

;	  Subroutine check if enough stackspace left
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4B81:	LD	IX,M6267
	JR	C4B91

;	  Subroutine load/compare BASIC program
;	     Inputs  ________________________
;	     Outputs ________________________

C4B87:	LD	IX,M715D
	JR	C4B91

;	  Subroutine convert to linepointers to linenumbers if needed
;	     Inputs  ________________________
;	     Outputs ________________________

C4B8D:	LD	IX,M54EA

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4B91:	PUSH	IY
	LD	IY,(EXPTBL+0-1)
	CALL	CALSLT
	POP	IY
	EI
	RET

;	  Subroutine _QDFORMAT
;	     Inputs  ________________________
;	     Outputs ________________________

C4B9E:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4BB4
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
J4BB4:	PUSH	HL
	LD	HL,D7012
	LD	A,(HL)
	CP	" "			; filename starts with space ?
	JP	NZ,J4A85		; nope, bad filename error
	CALL	C5AA0			; read channel A DCD (media inserted)
	JP	C,J4AAF			; reset, device I/O error
	CALL	C5AAE			; read channel A sync/hunt
	JP	C,J4AAF			; reset, device I/O error
	CALL	C4BEE			; continue format ?
	JR	NZ,J4BEB		; nope, quit
	CALL	C5417			; ensure fresh line on screen
	LD	HL,I5D85		; now formatting
	CALL	C53BA			; string to screen
	CALL	C5452			; format quick disk with retry
	JP	C,J4AAF			; device I/O error
	LD	A,(D7066)
	AND	A			; first free 'block' = 0 (empty disk) ?
	JP	NZ,J4AAF		; nope, device I/O error
	LD	HL,I5D96		; complete
	CALL	C53BA			; string to screen
J4BEB:	POP	HL
	AND	A
	RET

;	  Subroutine continue format ?
;	     Inputs  ________________________
;	     Outputs ________________________

C4BEE:	CALL	C4B09			; check if key pressed
	JR	Z,J4BF8			; nope,
	CALL	C4B0F			; get key
	JR	C4BEE

J4BF8:	CALL	C5417			; ensure fresh line on screen
	LD	HL,I5D66
	CALL	C53BA			; string to screen
	CALL	C4B0F			; get key
	CALL	C4B15			; character to screen
	PUSH	AF
	CALL	C541C			; CR/LF to screen
	POP	AF
	CP	"y"
	RET	Z
	CP	"Y"
	RET	Z
	LD	HL,I5D7A
	CALL	C53BA			; string to screen
	XOR	A
	INC	A
	RET

;	  Subroutine _QDFILES
;	     Inputs  ________________________
;	     Outputs ________________________

C4C1B:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4C31			; end of statement,
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
J4C31:	PUSH	HL
	LD	HL,D7012
	LD	A,(HL)
	CP	" "			; filename start with space ?
	JP	NZ,J4C9F		; nope, bad file name error
	CALL	C5AA0			; read channel A DCD (media inserted)
	JP	C,J4AAF			; reset, device I/O error
	LD	HL,I70F7		; use file #0 buffer
	CALL	C54FC			; read all fileentries with retry
	JP	C,J4AAF			; error, device I/O error
	CALL	C5417			; ensure fresh line on screen
	LD	A,(D7068)
	AND	A			; number of fileentries
	PUSH	AF
	LD	HL,I5D38		; no file
	CALL	Z,C53BA			; no fileentries, string to screen
	POP	AF
	JR	Z,J4C81			; no fileentries, quit
	LD	HL,I5D42		; header string
	CALL	C53BA			; string to screen
	LD	HL,I70F7		; file #0 buffer
	LD	A,(D7068)		; number of fileentries
	LD	(D7067),A		; number of used blocks left
J4C6A:	LD	A,(D7068)
	AND	A			; fileentries left ?
	JR	Z,J4C81			; nope, quit
	DEC	A
	LD	(D7068),A		; update fileentries left
	CALL	C5360			; file info to screen

	IF	QDVER EQ 111

	NOP
	NOP
	NOP				; wait ?

	ENDIF

	IF	QDVER NE 100

	CALL	C4B2B			; check if CTRL-STOP pressed
	JR	C,J4C81			; yep, quit

	ENDIF

	JR	J4C6A			; next fileentry

J4C81:	POP	HL
	AND	A
	RET

	IF	QDVER EQ 111

;	  Subroutine check for STOP key
;	     Inputs  ________________________
;	     Outputs ________________________
;	     Remark  NOT USED

?.4C84:	LD	A,7
	CALL	C4B31			; read keyboard row
	BIT	4,A			; STOP key pressed ?
	RET	NZ			; nope, quit
J4C8C:	LD	A,7
	CALL	C4B31			; read keyboard row
	BIT	4,A			; STOP key pressed ?
	JR	Z,J4C8C			; yep, wait until released
J4C95:	LD	A,7
	CALL	C4B31			; read keyboard row
	BIT	4,A			; STOP key pressed ?
	RET	Z			; yep, quit
	JR	J4C95			; wait until pressed again

	ENDIF

J4C9F:	JP	J4A85			; bad filename error

;	  Subroutine _RUN
;	     Inputs  ________________________
;	     Outputs ________________________

C4CA2:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	PUSH	HL
	CALL	C4B75			; close all i/o channels
	XOR	A
	LD	(D70B5),A		; use normal memory
	LD	L,A
	LD	H,A
	LD	(D706B),HL		; offset = 0
	POP	HL
	LD	A,2
	LD	(D7064),A		; LOAD with RUN
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4CFC			; end of statement,
	JR	J4CF5

;	  Subroutine _LOAD
;	     Inputs  ________________________
;	     Outputs ________________________

C4CC6:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	XOR	A
	LD	(D7064),A		; normal LOAD
	LD	(D70B5),A		; use normal memory
	PUSH	HL
	CALL	C4B75			; close all i/o channels
	POP	HL
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4CFC			; end of statement,
	CP	","
	JR	NZ,J4CF5
	CALL	C4B3F			; get BASIC character
	CALL	C4B37			; check for BASIC character
	DEFB	"R"
	PUSH	AF
	LD	A,1
	LD	(D7064),A		; LOAD and leave files open
	POP	AF
	JR	Z,J4CFC			; end of statement,
J4CF5:	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
J4CFC:	PUSH	HL
	LD	A,(D7012)
	CP	" "			; filename start with space ?
	JP	Z,J4A85			; yep, bad filename error
	LD	B,3
J4D07:	PUSH	BC
	CALL	C4D44
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JR	NC,J4D1B		; no error,
	CP	19			; Device I/O error ?
	JP	NZ,J4AC7		; nope, throw BASIC error
	DJNZ	J4D07
	JP	J4AC7			; throw BASIC error

J4D1B:	LD	DE,(TXTTAB)
	CALL	C4B5D			; setup BASIC linelinks from this point
	LD	B,8AH			; RUN token
	LD	A,(D7064)
	AND	A			; plain LOAD ?
	JR	NZ,J4D2C		; nope, use RUN
	LD	B,92H			; CLEAR token
J4D2C:	LD	HL,T.STAT
	PUSH	HL
	LD	(HL),":"
	INC	HL
	LD	(HL),B
	INC	HL
	LD	(HL),":"
	INC	HL
	LD	(HL),81H		; END token
	INC	HL
	LD	(HL),0			; end of BASIC line
	POP	HL
	CALL	C5BFA			; reset quick disk controller
	JP	J4B6F			; execute new statement

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C4D44:	PUSH	HL
	CALL	C54C2			; find file
	POP	HL
	JP	C,C4565			; error, quit with Device I/O error
	JP	NZ,C4561		; not found, quit with File not found error
	CALL	C527F			; check first free 'block'
	JP	C,C4565			; error, quit with Device I/O error
	CALL	C528B			; check ? 'block'
	JP	C,C4565			; error, quit with Device I/O error
	LD	A,(D7023)
	CP	2			; filetype = binary BASIC ?
	JR	Z,J4D7D			; yep,
	CP	1			; filetype = binary file ?
	JR	Z,J4D6E			; yep,
	CP	3			; filetype = ASCII file ?
	JP	Z,J4E93			; yep, generate LOAD statement and execute this
J4D6B:	JP	C4569			; quit with Illegal function call error

; ASCII file

J4D6E:	LD	A,(D7064)
	CP	2			; LOAD with RUN ?
	JR	NZ,J4D6B		; nope,
	POP	HL
	LD	HL,I4F66
	PUSH	HL
	JP	J4FA8

; binary BASIC file

J4D7D:	LD	HL,(TXTTAB)
	DEC	HL
	LD	DE,(D7037)		; number of bytes
	ADD	HL,DE
	JP	C,J4571			; quit with Out of memory error
	LD	DE,256
	ADD	HL,DE
	JP	C,J4571			; quit with Out of memory error
	LD	DE,(MEMSIZ)
	SBC	HL,DE
	JP	NC,J4571		; quit with Out of memory error
	LD	HL,(TXTTAB)
	DEC	HL
	CALL	C5569			; read file to memory
	JP	C,C4565			; quit with Device I/O error
	LD	(VARTAB),HL
	RET

;	  Subroutine _MERGE
;	     Inputs  ________________________
;	     Outputs ________________________

C4DA7:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	PUSH	HL
	CALL	C4B75			; close all i/o channels
	POP	HL
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4DC2
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; not end of statement, syntax error
J4DC2:	JP	J4EC3			; generate MERGE statement and execute this

;	  Subroutine _SAVE
;	     Inputs  ________________________
;	     Outputs ________________________

C4DC5:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	PUSH	HL
	CALL	C4B75			; close all i/o channels
	POP	HL
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4DF7
	CP	")"
	JR	Z,J4DF1
	CALL	C4B37			; check for BASIC character
	DEFB	","
	CALL	C4B37			; check for BASIC character
	DEFB	"A"
	JR	Z,J4DEE
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; not end of statement, syntax error
J4DEE:	JP	J4EB1			; generate SAVE statement and execute this

J4DF1:	CALL	C4B3F			; get BASIC character
	JP	NZ,J4A9D		; not end of statement, syntax error
J4DF7:
	IF	QDVER NE 100

	PUSH	HL

	ENDIF

	LD	A,(D7012)
	CP	" "			; filename start with space ?
	JP	Z,J4A85			; yep, quit with bad filename error
	CALL	C4B8D			; convert to linepointers to linenumbers if needed
	XOR	A
	LD	(D70B5),A		; use normal memory
	LD	A,2
	LD	(D7023),A		; filetype = binary BASIC
	LD	HL,(TXTTAB)
	DEC	HL
	LD	(D7039),HL		; transfer address
	LD	HL,0
	LD	(D703B),HL		; execute address = 0
	LD	HL,(VARTAB)
	DEC	HL
	LD	BC,(D7039)		; transfer address
	OR	A
	SBC	HL,BC
	INC	HL
	LD	(D7037),HL		; number of bytes
	LD	B,3
J4E2A:	PUSH	BC
	CALL	C4E60			; write file
	CALL	C5BFA			; reset quick disk controller
	POP	BC

	IF	QDVER EQ 100

	JR	NC,J4E41

	ELSE

	JR	NC,J4E3E		; no error, quit

	ENDIF

	CP	20			; Verify error ?
	CALL	Z,C4E51			; yep, write first free 'block' when write file failed
	DJNZ	J4E2A
	JP	J4AC7			; throw BASIC error

	IF	QDVER NE 100

J4E3E:	POP	HL
	AND	A
	RET

	ENDIF

J4E41:	CALL	C5417			; ensure fresh line on screen
	LD	HL,I5DA1		; ok
	CALL	C53BA			; string to screen
	LD	DE,(TXTTAB)
	JP	J4B63			; setup BASIC linelinks from this point, initialize interpreter

;	  Subroutine write first free 'block' when write file failed
;	     Inputs  ________________________
;	     Outputs ________________________

C4E51:	LD	A,(D7069)		; first free 'block' before write file started
	LD	(D7066),A		; first free 'block'
	LD	(D7067),A		; number of used blocks left
	PUSH	BC
	CALL	C555C			; write first free 'block'
	POP	BC
	RET

;	  Subroutine write file
;	     Inputs  ________________________
;	     Outputs ________________________

C4E60:	CALL	C5476			; search fileentry
	JP	C,C4565			; error, quit with Device I/O error
	CALL	C5426			; initialize new fileentry
	CALL	C5890			; write 64 bytes to quick disk
	JP	C,C4565			; quit with Device I/O error
	CALL	C55BE			; write block to quick disk from memory
	JP	C,C4565			; quit with Device I/O error
	LD	A,(D7066)		; first free 'block'
	LD	(D7069),A		; save first free 'block' (before write file)
	INC	A
	INC	A
	LD	(D7066),A		; update first free 'block'
	LD	(D7067),A		; number of used blocks left
	CALL	C54B8			; write first free 'block', find next file
	JP	C,J4575			; error, quit with Verify error
	JP	NZ,J4575		; not found, quit with Verify error
	CALL	C5618			; verify file
	JP	C,J4575			; error, quit with Verify error
	RET

; ASCII file

J4E93:	LD	B,0B5H			; LOAD token
	LD	HL,T.STAT
	PUSH	HL
	CALL	C4EC7			; generate BASIC statement with device and filename
	LD	A,(D7064)
	AND	A			; plain LOAD ?
	JR	Z,J4EA8			; yep, skip ,R
	LD	(HL),","
	INC	HL
	LD	(HL),"R"
	INC	HL			; add ,R
J4EA8:	LD	(HL),0
	POP	HL
	CALL	C5BFA			; reset quick disk controller
	JP	J4B6F			; execute new statement

J4EB1:	LD	B,0BAH			; SAVE token
J4EB3:	LD	HL,T.STAT
	PUSH	HL
	CALL	C4EC7			; generate BASIC statement with device and filename
	LD	(HL),0			; end of BASIC line
	POP	HL
	CALL	C5BFA			; reset quick disk controller
	JP	J4B6F			; execute new statement

J4EC3:	LD	B,0B6H			; MERGE token
	JR	J4EB3

;	  Subroutine generate BASIC statement with device and filename
;	     Inputs  ________________________
;	     Outputs ________________________

C4EC7:	LD	A,1
	LD	(D70B4),A		; i/o channel 0 disabled
	LD	(HL),":"
	INC	HL
	LD	(HL),B
	INC	HL
	LD	(HL),'"'
	INC	HL
	EX	DE,HL
	LD	HL,D700D
	LD	BC,3
	LDIR				; this quick disk devicename
	EX	DE,HL
	LD	(HL),":"
	INC	HL
	EX	DE,HL
	LD	HL,D7012
	LD	BC,8
	LDIR				; filename
	LD	A,"."
	LD	(DE),A
	INC	DE
	LD	BC,3
	LDIR				; fileextension
	EX	DE,HL
	LD	(HL),'"'
	INC	HL
	RET

;	  Subroutine _BLOAD
;	     Inputs  ________________________
;	     Outputs ________________________

C4EF8:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	XOR	A
	LD	(D7064),A		; plain LOAD
	LD	(D70B5),A		; use normal memory
	PUSH	HL
	LD	L,A
	LD	H,A
	LD	(D706B),HL		; offset = 0
	POP	HL
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4F57
	CP	","
	JR	NZ,J4F50
	CALL	C4B3F			; get BASIC character
	CP	","
	JR	Z,J4F3F
	CP	"S"
	JR	NZ,J4F2E
	LD	A,1
	LD	(D70B5),A		; use video memory
	CALL	C4B3F			; get BASIC character
	JR	J4F39

J4F2E:	CALL	C4B37			; check for BASIC character
	DEFB	"R"
	PUSH	AF
	LD	A,1
	LD	(D7064),A		; BLOAD with run
	POP	AF
J4F39:	JR	Z,J4F57
	CP	")"
	JR	Z,J4F50
J4F3F:	CALL	C4B37			; check for BASIC character
	DEFB	","
	CALL	C4B4B			; evaluate address operand
	LD	(D706B),DE		; offset
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J4F57
J4F50:	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
J4F57:	PUSH	HL
	LD	A,(D7012)
	CP	" "			; filename start with space ?
	JP	Z,J4A85			; yep, quit with bad filename error
	LD	B,3
J4F62:	PUSH	BC
	CALL	C4F87			; read file
I4F66:	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JR	NC,J4F76		; no error,
	CP	19			; Device I/O error ?
	JP	NZ,J4AC7		; nope, throw BASIC error
	DJNZ	J4F62
	JP	J4AC7			; throw BASIC error

J4F76:	POP	HL
	LD	A,(D7064)
	AND	A			; BLOAD with run ?
	RET	Z			; nope, quit
	PUSH	HL
	LD	HL,I4F84
	PUSH	HL

	IF	QDVER EQ 100

	LD	HL,(D703B)
	LD	DE,(D706B)
	ADD	HL,DE
	JP	(HL)

	ELSE

	JP	J5DBF			; execute routine (+ offset) with BASIC interpreter enabled

	ENDIF


I4F84:	POP	HL
	AND	A
	RET

;	  Subroutine read file
;	     Inputs  ________________________
;	     Outputs ________________________

C4F87:	CALL	C54C2			; find file
	JP	C,C4565			; error, quit with Device I/O error
	JP	NZ,C4561		; not found, quit with File not found error
	CALL	C527F			; check first free 'block'
	JP	C,C4565			; error, quit with Device I/O error
	CALL	C528B			; check ? 'block'
	JP	C,C4565			; error, quit with Device I/O error
	LD	A,(D7023)
	CP	1			; filetype = binary file ?
	JR	Z,J4FA8			; yep,
	CP	11			; filetype = binary (VRAM) file ?
	JP	NZ,C4569		; nope, quit with Illegal function call error
J4FA8:	LD	HL,(D7039)		; transfer address
	LD	DE,(D706B)		; offset
	ADD	HL,DE
	CALL	C5569			; read file to memory
	JP	C,C4565			; quit with Device I/O error
	RET

;	  Subroutine _BSAVE
;	     Inputs  ________________________
;	     Outputs ________________________

C4FB7:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	XOR	A
	LD	(D70B5),A		; use normal memory
	LD	A,1
	LD	(D7023),A		; filetype = binary file
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	CALL	C4B37			; check for BASIC character
	DEFB	","
	CALL	C4B4B			; evaluate address operand
	LD	(D7039),DE		; transfer address
	LD	(D703B),DE		; execute address
	CALL	C4B37			; check for BASIC character
	DEFB	","
	CALL	C4B4B			; evaluate address operand
	LD	(D706D),DE		; save end address
	PUSH	HL
	AND	A
	LD	HL,(D7039)		; transfer address
	EX	DE,HL
	SBC	HL,DE
	JR	NC,J4FF1
	LD	HL,(D706D)		; end address
	DEC	HL
J4FF1:	INC	HL
	LD	(D7037),HL		; number of bytes
	LD	HL,0
	POP	HL
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,C5030			; end of statement, write file with retry and quit
	CP	")"
	JR	Z,J5029
	CALL	C4B37			; check for BASIC character
	DEFB	","
	CP	"S"
	JR	Z,J501A
	CALL	C4B4B			; evaluate address operand
	LD	(D703B),DE		; execute address
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,C5030			; end of statement, write file with retry and quit
	JR	J5029

J501A:	CALL	C4B3F			; get BASIC character
	LD	A,1
	LD	(D70B5),A		; use video memory
	LD	A,11
	LD	(D7023),A		; filetype = binary (VRAM) file
	JR	Z,C5030			; end of statement, write file with retry and quit
J5029:	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error

;	  Subroutine write file with retry
;	     Inputs  ________________________
;	     Outputs ________________________

C5030:	PUSH	HL
	LD	A,(D7012)
	CP	" "			; filename starts with space ?
	JP	Z,J4A85			; yep, quit with bad filename error
	LD	B,3
J503B:	PUSH	BC
	CALL	C4E60			; write file
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JR	NC,J504F		; no error, quit
	CP	20			; Verify error ?
	CALL	Z,C4E51			; yep, write first free 'block' when write file failed
	DJNZ	J503B
	JP	J4AC7			; throw BASIC error

J504F:	POP	HL
	AND	A
	RET

;	  Subroutine QDKILL
;	     Inputs  ________________________
;	     Outputs ________________________

C5052:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	CALL	C59CC			; evaluate optional filespecification and check if it this quick disk
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J5068
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
J5068:	LD	A,(D7012)
	CP	" "			; filename start with space ?
	JP	Z,J4A85			; yep, quit with bad filename error
	PUSH	HL
	LD	B,3
J5073:	PUSH	BC
	CALL	C5087			; delete file
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JR	NC,J504F		; no error, quit
	CP	19			; Device I/O error ?
	JP	NZ,J4AC7		; nope, throw BASIC error
	DJNZ	J5073
	JP	J4AC7			; throw BASIC error

;	  Subroutine delete file
;	     Inputs  ________________________
;	     Outputs ________________________

C5087:	CALL	C54C2			; find file
J508A:	JP	C,C4565			; error, quit with Device I/O error
	JP	NZ,C4561		; not found, quit with File not found error
	CALL	C527F			; check first free 'block'
	JR	C,J508A			; error, quit with device i/o error
	CALL	C528B			; check ? 'block'
	JR	C,J508A			; error, quit with device i/o error
	LD	A,(D7067)
	LD	B,A			; number of used blocks left
	LD	A,(D7066)		; first free 'block'
	SUB	B
	DEC	A
	LD	(D7066),A		; update first free 'block'
	CALL	C58B3			; read file blocks
	JR	C,J508A			; error,
	LD	A,(D7067)
	AND	A			; number of used blocks left = 0 ?
	JP	NZ,C4565		; nope, quit with Device I/O error
	CALL	C5BFA			; reset quick disk controller
	CALL	C555C			; write first free 'block'
	CALL	C5BFA			; reset quick disk controller
	RET

;	  Subroutine _QDKEY
;	     Inputs  ________________________
;	     Outputs ________________________

C50BC:	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J50DC			; end of statement, flip quick disk function key
	CALL	C4B37			; check for BASIC character
	DEFB	"("
	CALL	C4B4B			; evaluate address operand
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
	LD	A,E
	OR	D
J50D2:	PUSH	AF
	CALL	NZ,C5297		; enable quick disk function keys
	POP	AF
	CALL	Z,C52AD			; disable quick disk function keys
	AND	A
	RET

; flip quick disk function key

J50DC:	LD	A,(D7065)
	CPL
	AND	A
	JR	J50D2

;	  Subroutine fill with spaces
;	     Inputs  ________________________
;	     Outputs ________________________

C50E3:	LD	(HL)," "
	INC	HL
	DJNZ	C50E3
	RET

;	  Subroutine _CASQD
;	     Inputs  ________________________
;	     Outputs ________________________

C50E9:	CALL	C460D			; get file #0 and #1 open status
	JP	NZ,J4A91		; open, file already open error
	XOR	A
	LD	(D7064),A
	LD	(D70B5),A		; use normal memory
	PUSH	HL
	CALL	C4B75			; close all i/o channels
	LD	HL,T.FLNM		; clear T.FLNM, T.TFIL
	LD	B,12+12
	CALL	C50E3			; fill with spaces
	LD	HL,FILNAM
	LD	B,11
	CALL	C50E3			; fill with spaces
	LD	HL,D7012		; filename buffer
	LD	B,11
	CALL	C50E3			; fill with spaces
	POP	HL
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J516E
	CALL	C4B37			; check for BASIC character
	DEFB	"("
	CP	","
	JR	Z,J5151
	CALL	C4B7B			; evaluate filespecification
	LD	A,D
	AND	A			; default device ?
	JR	Z,J512D			; yep,
	CP	0FFH			; CAS device ?
	JP	NZ,J4A85		; nope, bad filename error
J512D:	PUSH	HL
	LD	HL,FILNAM
	LD	DE,T.FLNM
	PUSH	HL
	CALL	C5A1D			; copy filename to T.FLNM (source filename on tape)
	POP	HL
	LD	B,11
	CALL	C50E3			; fill with spaces
	POP	HL
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J516E			; end of statement, skip destination filename
	CP	")"
	JR	NZ,J5151
	CALL	C4B3F			; get BASIC character
	JR	Z,J516E			; end of statement, skip destination filename
	JP	J4A9D			; syntax error

J5151:	CALL	C4B37			; check for BASIC character
	DEFB	","
	CALL	C4B7B			; evaluate filespecification
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J5165			; end of statement,
	CALL	C4B37			; check for BASIC character
	DEFB	")"
	JP	NZ,J4A9D		; syntax error
J5165:	LD	A,D
	AND	A			; default device ?
	JR	Z,J516E			; yep,
	CALL	C5A41			; check if devicename is this quick disk devicename
	SCF
	RET	NZ			; nope, statement not recognized
J516E:	LD	HL,FILNAM
	CALL	C5A18			; copy filename to filename buffer (destination filename on quickdisk)
	CALL	C5904			; search for file on tape
	PUSH	BC
	LD	A,(D7012)
	CP	" "			; destination filename starts with space ?
	JR	NZ,J519C		; nope,
	LD	A,(T.FLNM+0)
	CP	" "			; source filename starts with space ?
	JR	Z,J518E			; yep, use filename from tape
	LD	HL,T.FLNM
	CALL	C5A18			; copy filename to filename buffer
	JR	J519C

J518E:	LD	A,(T.TFIL+0)
	CP	" "			; filename on tape start with space ?
	JP	Z,J4A85			; yep, quit with bad filename error
	LD	HL,T.TFIL
	CALL	C5A18			; copy filename to filename buffer
J519C:
	IF	QDVER NE 100

	PUSH	HL
	LD	HL,D7012		; filename buffer
	LD	B,8
	CALL	C5A2B			; check if spaces in between
	JR	C,J51AC			; yep, bad filename error
	LD	B,3
	CALL	C5A2B			; check if spaces in between
J51AC:	POP	HL
	JP	C,J4A85			; yep, bad filename error

	ENDIF

	POP	BC
	LD	A,C			; filetype id
	CP	0EAH			; ASCII file ?
	JR	Z,J51C2
	CP	0D3H			; binary BASIC file ?
	JR	Z,J520C
	CP	0D0H			; binary file ?
	JP	Z,J5256
	JP	J4AAF			; device I/O error

; ASCII file on cassette

J51C2:	LD	HL,I76F7		; generic buffer
	LD	E,2			; filemode = sequential output
	LD	BC,D7012		; filename buffer
	LD	A,1
	LD	(D70D7),A		; file #1 open for input
	CALL	C435A			; open file
	PUSH	AF
	XOR	A
	LD	(D70D7),A		; file #1 closed
	LD	A,(D7023)
	CP	3			; filetype = ASCII ?
	JP	NZ,J4AA3		; nope, illegal function call error
	POP	AF
	JP	C,J4AAF			; device I/O error
J51E3:	LD	HL,(NULBUF)
	PUSH	HL
	CALL	C597C			; read 256 bytes from tape
	POP	DE
	LD	HL,I76F7		; generic buffer
	LD	B,0
J51F0:	LD	A,(DE)
	INC	DE
	LD	C,A
	CP	1AH			; eof ?
	JR	Z,J51FE			; yep, end of file reached
	CALL	C46E3			; sequential output
	DJNZ	J51F0
	JR	J51E3			; next data block

J51FE:	CALL	C4695			; close
	LD	HL,0
	LD	(PTRFIL),HL		; end interpreter output to file
	JP	C,J4AAF			; error, device I/O error
	JR	J527C			; finish command

; binary BASIC file on cassette

J520C:	LD	HL,(TXTTAB)
	CALL	C5990			; load BASIC program

	IF	QDVER EQ 100

	JP	J4DF7

	ELSE

	LD	A,(D7012)
	CP	20H			; filename start with space ?
	CALL	C4B8D			; convert to linepointers to linenumbers if needed
	XOR	A
	LD	(D70B5),A		; use normal memory
	LD	A,2
	LD	(D7023),A		; filetype = binary BASIC
	LD	HL,(TXTTAB)
	DEC	HL
	LD	(D7039),HL		; transfer address
	LD	HL,0
	LD	(D703B),HL		; execute address = 0
	LD	HL,(VARTAB)
	DEC	HL
	LD	BC,(D7039)		; transfer address
	OR	A
	SBC	HL,BC
	INC	HL
	LD	(D7037),HL		; number of bytes
	LD	B,3
J5241:	PUSH	BC
	CALL	C4E60			; write file
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	JP	NC,J4E41		; no error, finish command
	CP	20			; Verify error ?
	CALL	Z,C4E51			; yep, write first free 'block' when write file failed
	DJNZ	J5241
	JP	J4AC7			; throw BASIC error

	ENDIF

; binary file on cassette

J5256:	CALL	C5999
	LD	HL,(DF576)
	LD	(D7039),HL		; transfer address
	EX	DE,HL
	LD	HL,(DF578)
	AND	A
	SBC	HL,DE
	INC	HL
	LD	(D7037),HL		; number of bytes
	LD	HL,(DF57A)
	LD	(D703B),HL		; execute address
	XOR	A
	LD	(D70B5),A		; use normal memory
	LD	A,1
	LD	(D7023),A		; filetype = binary file
	CALL	C5030			; write file with retry
J527C:	JP	J4E41			; finish command

;	  Subroutine check first free 'block'
;	     Inputs  ________________________
;	     Outputs ________________________

C527F:	LD	A,(D70B6)
	AND	A			; 'block' check enabled ?
	RET	NZ			; nope, quit with ok
	LD	A,(D7066)		; first free 'block'
	CP	128
	CCF				; < 128 is ok
	RET

;	  Subroutine check ? 'block'
;	     Inputs  ________________________
;	     Outputs ________________________

C528B:	LD	A,(D70B6)
	AND	A			; 'block' check enabled ?
	RET	NZ			; nope, quit with ok
	LD	A,(D7036)
	AND	A
	RET	Z
	SCF
	RET

;	  Subroutine enable quick disk function keys
;	     Inputs  ________________________
;	     Outputs ________________________

C5297:	PUSH	HL
	LD	A,0FFH
	LD	(D7065),A		; quick disk function keys enabled
	LD	HL,I52C0
	LD	DE,FNKSTR
	LD	BC,10*16
J52A6:	LDIR
	CALL	C4B25			; display function keys if enabled
	POP	HL
	RET

;	  Subroutine disable quick disk function keys
;	     Inputs  ________________________
;	     Outputs ________________________

C52AD:	PUSH	HL
	XOR	A
	LD	(D7065),A		; quick disk function keys disabled
	CALL	C4B1F			; initialize function keys
	LD	HL,I52C0+16*6
	LD	DE,FNKSTR+16*6
	LD	BC,16			; update F7 with QDKEY
	JR	J52A6

I52C0:	DEFB	18,"RUN ",2,18,"_",28,28,28,28,0,0,0,0
	DEFB	18,"LOAD ",2,18,"_",28,28,28,28,28,0,0
	DEFB	18,"BLOAD",2,18,"_",28,28,28,28,28,28,0
	DEFB	"list ",0,0,0,0,0,0,0,0,0,0,0
	DEFB	"run",13,0,0,0,0,0,0,0,0,0,0,0,0
	DEFB	"color 15,4,7",13,0,0,0
	DEFB	"QDKEY ",2,18,"_",28,28,28,28,28,28,0
	DEFB	'SAVE("QD:',2,2,18,"_",14,0,0
	DEFB	'BSAVE("QD:',2,2,18,"_",14,0
	DEFB	"FILES",2,18,"_QD",28,28,28,28,28,0

;	  Subroutine file info to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C5360:	PUSH	HL
	LD	BC,19
	ADD	HL,BC
	LD	A,(HL)
	POP	HL
	AND	A
	JR	Z,J536F

	IF	QDVER EQ 100

	LD	BC,64

	ELSE

	LD	BC,26

	ENDIF

	ADD	HL,BC			; to next entry
	RET

J536F:	PUSH	HL
	LD	HL,I5D60		; (
	CALL	C53BA			; string to screen
	LD	HL,D700D		; this quick disk devicename
	CALL	C53BA			; string to screen
	POP	HL
	LD	A,":"
	CALL	C4B15			; character to screen
	PUSH	HL
	INC	HL
	CALL	C53C3			; filename to screen
	LD	A,13
	CALL	C4B15			; character to screen
	LD	B,18
J538E:	LD	A,1CH
	CALL	C4B15			; character to screen
	DJNZ	J538E
	LD	HL,I5D63
	CALL	C53BA			; string to screen
	POP	HL
	LD	A,(HL)			; filetype
	CALL	C53F3			; hex byte to screen
	LD	A," "
	CALL	C4B15			; character to screen
	LD	BC,20
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; filesize
	PUSH	HL
	EX	DE,HL
	CALL	C53EE			; hex word to screen
	POP	HL
	CALL	C541C			; CR/LF to screen

	IF	QDVER EQ 100

	LD	BC,64-20-1

	ELSE

	LD	BC,26-20-1

	ENDIF

	ADD	HL,BC			; to next entry
	RET

;	  Subroutine string to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C53BA:	LD	A,(HL)
	INC	HL
	AND	A
	RET	Z
	CALL	C4B15			; character to screen
	JR	C53BA

;	  Subroutine filename to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C53C3:	PUSH	BC
	PUSH	HL
	LD	B,8
J53C7:	LD	A,(HL)
	CP	20H
	JR	NC,J53CE
	LD	A," "
J53CE:	CALL	C4B15			; character to screen
	INC	HL
	DJNZ	J53C7
	LD	B,3
	LD	A,(HL)
	CP	" "
	JR	Z,J53DF
	LD	A,"."
	JR	J53E1

J53DF:	LD	A," "
J53E1:	CALL	C4B15			; character to screen
J53E4:	LD	A,(HL)
	CALL	C4B15			; character to screen
	INC	HL
	DJNZ	J53E4
	POP	HL
	POP	BC
	RET

;	  Subroutine hex word to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C53EE:	LD	A,H
	CALL	C53F3			; hex byte to screen
	LD	A,L

;	  Subroutine hex byte to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C53F3:	PUSH	DE
	CALL	C5401			; hex byte to ASCII
	LD	A,D
	CALL	C4B15			; character to screen
	LD	A,E
	CALL	C4B15			; character to screen
	POP	DE
	RET

;	  Subroutine hex byte to ASCII
;	     Inputs  A = byte
;	     Outputs D = ASCII high nibble, E = ASCII low nibble

C5401:	PUSH	AF
	CALL	C540B			; hex nibble to ASCII
	LD	E,A			; E = low nibble
	POP	AF
	RRCA
	RRCA
	RRCA
	RRCA

;	  Subroutine hex nibble to ASCII
;	     Inputs  A = nibble
;	     Outputs A,D = ASCII nibble

C540B:	AND	0FH
	ADD	A,"0"
	CP	"9"+1
	LD	D,A
	RET	C
	ADD	A,7
	LD	D,A
	RET

;	  Subroutine ensure fresh line on screen
;	     Inputs  ________________________
;	     Outputs ________________________

C5417:	LD	A,(CSRX)
	DEC	A
	RET	Z

;	  Subroutine CR/LF to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C541C:	LD	A,13
	CALL	C4B15			; character to screen
	LD	A,10
	JP	C4B15			; character to screen

;	  Subroutine initialize new fileentry
;	     Inputs  ________________________
;	     Outputs ________________________

C5426:	XOR	A
	LD	(D7035),A
	LD	(D7036),A
	LD	HL,I703D
	LD	B,38
J5432:	LD	(HL),A
	INC	HL
	DJNZ	J5432			; clear reserved bytes
	LD	HL,D7012		; filename buffer
	LD	DE,I7024		; fileentry filename
	LD	C,17
J543E:	LD	A,(HL)
	INC	HL
	LD	(DE),A
	INC	DE
	DEC	C
	CP	13
	JR	NZ,J543E
	LD	B,C
	LD	A,C
	AND	A
	RET	Z
	LD	A," "
J544D:	LD	(DE),A
	INC	DE
	DJNZ	J544D
	RET

;	  Subroutine format quick disk with retry
;	     Inputs  ________________________
;	     Outputs ________________________

C5452:	LD	B,3
J5454:	PUSH	BC
	CALL	C5461			; format quick disk
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	RET	NC			; no error, quit
	DJNZ	J5454
	SCF
	RET

;	  Subroutine format quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5461:	CALL	C5B0B			; write marker (special)
	LD	A,0			; first free 'block' = 0 (empty disk)
	CALL	C5C53			; write byte to quick disk
	CALL	C5C2C			; check channel B DCD (ready)
	CALL	C5BFA			; reset quick disk controller
	CALL	C5ABB			; read first free 'block'
	CALL	C5BFA			; reset quick disk controller
	RET

;	  Subroutine search fileentry
;	     Inputs  ________________________
;	     Outputs ________________________

C5476:	CALL	C5AA0			; read channel A DCD (media inserted)
	RET	C			; reset, quit
	CALL	C5AAE			; read channel A sync/hunt
	RET	C			; reset, quit
	CALL	C5ABB			; read first free 'block'
	RET	C			; error, quit
	CALL	C527F			; check first free 'block'
	RET	C			; error, quit

	IF	QDVER EQ 100

	CP	65			; first free 'block' < 65

	ELSE

	CP	119			; first free 'block' < 119

	ENDIF

	CCF
	RET	C			; nope, quit with error
	LD	(D7067),A		; number of used blocks left
J548D:	LD	A,(D7067)
	OR	A			; used blocks left ?
	RET	Z			; nope, quit
	LD	HL,I706F		; fileentry #2 buffer
	PUSH	HL
	CALL	C5863			; read 64 bytes from quick disk
	POP	HL
	RET	C			; error, quit
	LD	DE,D7012		; filename buffer
	INC	HL
J549F:	LD	A,(HL)
	INC	HL
	CALL	C5A62			; to upper
	LD	C,A
	LD	A,(DE)
	INC	DE
	CP	C
	JR	NZ,J54B0
	CP	13
	JR	Z,J54B6			; found, quit with error
	JR	J549F			; next filename character

J54B0:	CALL	C58B3			; read file blocks
	RET	C			; error, quit
	JR	J548D			; next fileentry

J54B6:	SCF
	RET

;	  Subroutine write first free 'block', find next file
;	     Inputs  ________________________
;	     Outputs ________________________

C54B8:	CALL	C555C			; write first free 'block'
	CALL	C54D0			; find next file
	CALL	C5BFA			; reset quick disk controller
	RET

;	  Subroutine find file
;	     Inputs  ________________________
;	     Outputs ________________________

C54C2:	CALL	C5AA0			; read channel A DCD (media inserted)
	RET	C			; reset, quit
	CALL	C5ABB			; read first free 'block'
	RET	C			; error, quit
	LD	A,(D7066)		; first free 'block'
	LD	(D7067),A		; number of used blocks left

;	  Subroutine find next file
;	     Inputs  ________________________
;	     Outputs ________________________

C54D0:	LD	A,(D7067)
	AND	A			; used blocks left ?
	JR	Z,J54F9			; nope, quit with not found
	LD	HL,D7023		; fileentry buffer
	PUSH	HL
	CALL	C5863			; read 64 bytes from quick disk
	POP	HL
	RET	C
	LD	DE,D7012		; filename buffer
	INC	HL
J54E3:	LD	A,(HL)
	INC	HL
	CALL	C5A62			; to upper
	LD	C,A
	LD	A,(DE)
I54EA:	INC	DE
	CP	C
	JR	NZ,J54F3
	CP	13
	RET	Z			; quit with found
	JR	J54E3

J54F3:	CALL	C58B3			; read file blocks
	RET	C			; error, quit
	JR	C54D0			; next fileentry

J54F9:	XOR	A
	INC	A
	RET

;	  Subroutine read all fileentries with retry
;	     Inputs  ________________________
;	     Outputs ________________________

C54FC:	LD	B,3
J54FE:	PUSH	BC
	CALL	C550B			; read all fileentries
	CALL	C5BFA			; reset quick disk controller
	POP	BC
	RET	NC			; no error, quit
	DJNZ	J54FE
	SCF
	RET

;	  Subroutine read all fileentries
;	     Inputs  HL = fileentry buffer
;	     Outputs ________________________

C550B:	PUSH	HL
	CALL	C5ABB			; read first free 'block'
	POP	HL
	RET	C			; error, quit
	CALL	C527F			; check first free 'block'
	RET	C			; error, quit
	LD	(D7067),A		; number of used blocks left
	XOR	A
	LD	(D7068),A		; number of fileentries = 0
J551C:	LD	A,(D7067)
	AND	A			; used blocks left ?
	JR	Z,J555A			; nope, quit
	PUSH	HL
	CALL	C5863			; read 64 bytes from quick disk
	POP	HL
	RET	C			; error, quit
	LD	A,(D7068)
	INC	A
	LD	(D7068),A		; update number of fileentries

	IF	QDVER EQ 100

	CP	20			; =20 ?

	ELSE

	CP	60			; =60 ?

	ENDIF

	JR	NC,J555A		; yep, quit
	LD	A,(D7067)
	AND	A			; used blocks left ?
	JR	Z,J555A			; nope, quit
	PUSH	HL
	CALL	C58B3			; read file blocks
	LD	(D70B1),HL		; filesize
	POP	HL
	RET	C			; error, quit
	LD	A,(HL)
	CP	3			; filetype = ASCII ?
	JR	NZ,J5554		; nope,
	PUSH	HL
	LD	DE,(D70B1)		; filesize
	LD	BC,20
	ADD	HL,BC			; fileentry + 20
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
J5554:
	IF	QDVER EQ 100

	LD	BC,64

	ELSE

	LD	BC,26

	ENDIF

	ADD	HL,BC
	JR	J551C			; next fileentry

J555A:	AND	A
	RET

;	  Subroutine write first free 'block'
;	     Inputs  ________________________
;	     Outputs ________________________

C555C:	CALL	C5B0B			; write marker (special)
	LD	A,(D7066)		; first free 'block'
	CALL	C5C53			; write byte to quick disk
	CALL	C5C2C			; check channel B DCD (ready)
	RET

;	  Subroutine read file to memory
;	     Inputs  ________________________
;	     Outputs ________________________

C5569:	LD	A,(D70B5)
	AND	A			; use video memory ?
	JR	NZ,J5596		; yep,

; read file to memory

	PUSH	HL
	CALL	C5B65			; read marker
	POP	HL
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	BC,(D7037)		; number of bytes
J5582:	CALL	C5C77			; read byte from quick disk
	RET	C			; error, quit
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,J5582		; next
J558D:	CALL	C5AEB			; wait for 4 received bytes
	RET	C			; error, quit
	CALL	C5BFA			; reset quick disk controller
	XOR	A
	RET

; read file to video memory

J5596:	CALL	C4B03			; setup VDP for VRAM write
	CALL	C5B65			; read marker
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	A,(VDP.DW)
	LD	C,A
	LD	DE,(D7037)		; number of bytes
J55AE:	PUSH	DE
	CALL	C5C77			; read byte from quick disk
	POP	DE
	RET	C
	OUT	(C),A
	INC	HL
	DEC	DE
	LD	A,D
	OR	E
	JR	NZ,J55AE
	JR	J558D

;	  Subroutine write block to quick disk from memory
;	     Inputs  ________________________
;	     Outputs ________________________

C55BE:	LD	A,(D70B5)
	AND	A			; use video memory ?
	JR	NZ,J55EE		; yep,

; write block to quick disk from memory

	CALL	C5B23			; write marker
	LD	A,5
	CALL	C5C53			; write byte to quick disk
	LD	DE,(D7037)		; number of bytes
	LD	HL,(D7039)		; transfer address
	LD	A,E			; number of bytes, low byte
	CALL	C5C53			; write byte to quick disk
	LD	A,D			; number of bytes, high byte
	CALL	C5C53			; write byte to quick disk
J55DB:	LD	A,(HL)
	INC	HL
	CALL	C5C53			; write byte to quick disk
	DEC	DE
	LD	A,E
	OR	D
	JR	NZ,J55DB
J55E5:	CALL	C5C2C			; check channel B DCD (ready)
	RET	C			; reset, quit with error
	CALL	C5BFA			; reset quick disk controller
	AND	A
	RET

; write block from video memory to quick disk

J55EE:	LD	HL,(D7039)		; transfer address (VRAM)
	CALL	C4AFD			; setup VDP for VRAM read
	CALL	C5B23			; write marker
	LD	A,(VDP.DR)
	LD	C,A
	LD	A,5
	CALL	C5C53			; write byte to quick disk
	LD	DE,(D7037)		; number of bytes
	LD	A,E
	CALL	C5C53			; write byte to quick disk
	LD	A,D
	CALL	C5C53			; write byte to quick disk
J560C:	IN	A,(C)
	CALL	C5C53			; write byte to quick disk
	DEC	DE
	LD	A,E
	OR	D
	JR	NZ,J560C
	JR	J55E5

;	  Subroutine verify file
;	     Inputs  ________________________
;	     Outputs ________________________

C5618:	LD	A,(D70B5)
	AND	A			; use video memory ?
	JR	NZ,J564A		; yep,

; verify file with memory

	CALL	C5B65			; read marker
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	HL,(D7039)		; transfer address
	LD	BC,(D7037)		; number of bytes
J5632:	CALL	C5C77			; read byte from quick disk
	RET	C
	CP	(HL)
	JR	NZ,J5648
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,J5632
J563F:	CALL	C5AEB			; wait for 4 received bytes
	RET	C			; error, quit
	CALL	C5BFA			; reset quick disk controller
	AND	A
	RET

J5648:	SCF
	RET

; verify file with video memory

J564A:	LD	HL,(D7039)		; transfer address (VRAM)
	CALL	C4AFD			; setup VDP for VRAM read
	PUSH	HL
	CALL	C5B65			; read marker
	POP	HL
	RET	C			; error, quit
	LD	A,(VDP.DR)
	LD	C,A
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	DE,(D7037)
J5667:	PUSH	DE
	CALL	C5C77			; read byte from quick disk
	POP	DE
	RET	C
	LD	B,A
	IN	A,(C)
	CP	B
	JR	NZ,J5648
	DEC	DE
	LD	A,E
	OR	D
	JR	NZ,J5667
	JR	J563F

;	  Subroutine read fileentry
;	     Inputs  ________________________
;	     Outputs ________________________

C567A:	CALL	C5AA0			; read channel A DCD (media inserted)
	RET	C			; reset, quit
	CALL	C5ABB			; read first free 'block'
	RET	C			; error, quit
J5682:	LD	A,(D7067)
	AND	A			; used blocks left ?
	RET	Z			; nope, quit
	LD	HL,D7023		; fileentry buffer
	CALL	C5863			; read 64 bytes from quick disk
	RET	C			; error, quit
	LD	A,(D7067)
	AND	A			; used blocks left ?
	RET	Z			; nope, quit
	CALL	C58B3			; read file blocks
	RET	C			; error, quit
	JR	J5682

;	  Subroutine write buffers to file
;	     Inputs  ________________________
;	     Outputs ________________________

C5699:	CALL	C56BD			; write i/o channel buffer + file buffer to quick disk
	RET	C
	LD	L,(IY+11)
	LD	H,(IY+12)		; size of file buffer
	LD	DE,768
	CALL	C4B57			; compare HL with DE
	JR	NZ,J56B0		; extra write block buffer,
J56AB:	CALL	C4648			; initialize buffers
	AND	A
	RET

J56B0:	LD	A,(IY+5)
	CP	7			; blocktype = last block ?
	JR	Z,J56AB			; yep,
	CALL	C5715			; write 1024 bytes to quick disk
	RET	C
	JR	J56AB			; initialize buffers and quit

;	  Subroutine write i/o channel buffer + file buffer to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C56BD:	CALL	C5B23			; write marker
	LD	A,(IY+5)		; blocktype
	PUSH	AF
	CALL	C5C53			; write byte to quick disk
	LD	A,2
	CALL	C5C53			; write byte to quick disk
	LD	A,4
	CALL	C5C53			; write byte to quick disk
	POP	AF
	CP	7			; blocktype = last block ?
	LD	A,0
	JR	NZ,J56D9		; nope, use 000H
	DEC	A			; yep, use 0FFH
J56D9:	CALL	C5C53			; write byte to quick disk
	CALL	C5C53			; write byte to quick disk
	LD	L,(IY+6)
	LD	H,(IY+7)		; pointer to i/o channel buffer
	LD	BC,256
J56E8:	LD	A,C
	OR	B
	JR	Z,J56F4
	LD	A,(HL)
	INC	HL
	CALL	C5C53			; write byte to quick disk
	DEC	BC
	JR	J56E8

J56F4:	LD	L,(IY+9)
	LD	H,(IY+10)		; file buffer
	LD	BC,768
J56FD:	LD	A,C
	OR	B
	JR	Z,J5709
	LD	A,(HL)
	INC	HL
	CALL	C5C53			; write byte to quick disk
	DEC	BC
	JR	J56FD

J5709:	CALL	C5C2C			; check channel B DCD (ready)
	RET	C			; reset, quit with error
	LD	A,(IY+1)
	INC	A
	LD	(IY+1),A
	RET

;	  Subroutine write 1024 bytes to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5715:	CALL	C5B23			; write marker
	LD	A,(IY+8)		; last blocktype
	PUSH	AF
	CALL	C5C53			; write byte to quick disk
	LD	A,2
	CALL	C5C53			; write byte to quick disk
	LD	A,4
	CALL	C5C53			; write byte to quick disk
	POP	AF
	CP	7			; blocktype = last block ?
	LD	A,0
	JR	NZ,J5731		; nope, use 000H
	DEC	A			; yep, use 0FFH
J5731:	CALL	C5C53			; write byte to quick disk
	CALL	C5C53			; write byte to quick disk
	LD	L,(IY+9)
	LD	H,(IY+10)		; file buffer
	LD	BC,768
	ADD	HL,BC
	LD	BC,1024
J5744:	LD	A,B
	OR	C
	JR	Z,J5750
	LD	A,(HL)
	INC	HL
	CALL	C5C53			; write byte to quick disk
	DEC	BC
	JR	J5744

J5750:	CALL	C5C2C			; check channel B DCD (ready)
	RET	C			; reset, quit with error
	LD	A,(IY+1)
	INC	A
	LD	(IY+1),A
	RET

;	  Subroutine write 1024 bytes to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C575C:	PUSH	HL
	CALL	C5B23			; write marker
	POP	HL
	LD	A,(D70AF)		; current blocktype
	PUSH	AF
	CALL	C5C53			; write byte to quick disk
	LD	A,2
	CALL	C5C53			; write byte to quick disk
	LD	A,4
	CALL	C5C53			; write byte to quick disk
	POP	AF
	CP	7			; blocktype = last block ?
	LD	A,0
	JR	NZ,J577A		; nope, use 000H
	DEC	A			; yep, use 0FFH
J577A:	CALL	C5C53			; write byte to quick disk
	CALL	C5C53			; write byte to quick disk
	LD	BC,1024
J5783:	LD	A,B
	OR	C
	JR	Z,J578F
	LD	A,(HL)
	INC	HL
	CALL	C5C53			; write byte to quick disk
	DEC	BC
	JR	J5783

J578F:	CALL	C5C2C			; check channel B DCD (ready)
	RET

;	  Subroutine fill buffers from file
;	     Inputs  ________________________
;	     Outputs ________________________

C5793:	CALL	C57AD			; read file in i/o channel buffer, rest in file buffer
	RET	C			; error, quit
	LD	L,(IY+11)
	LD	H,(IY+12)		; size of file buffer
	LD	DE,768
	CALL	C4B57			; compare HL with DE
	RET	Z			; no read ahead buffer, quit
	LD	A,(D70AF)		; current blocktype
	CP	7			; blocktype = last block ?
	CALL	NZ,C57FB		; nope, read in read ahead buffer
	RET

;	  Subroutine read file in i/o channel buffer, rest in file buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C57AD:	CALL	C5B65			; read marker
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	LD	(D70AF),A		; current blocktype
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	L,(IY+6)
	LD	H,(IY+7)		; pointer to i/o channel buffer
	LD	BC,256
J57CC:	LD	A,C
	OR	B
	JR	Z,J57D9
	CALL	C5C77			; read byte from quick disk
	RET	C
	LD	(HL),A
	INC	HL
	DEC	BC
	JR	J57CC

J57D9:	LD	L,(IY+9)
	LD	H,(IY+10)		; file buffer
	LD	BC,768
J57E2:	LD	A,C
	OR	B
	JR	Z,J57EF
	CALL	C5C77			; read byte from quick disk
	RET	C
	LD	(HL),A
	INC	HL
	DEC	BC
	JR	J57E2

J57EF:	CALL	C5AEB			; wait for 4 received bytes
	RET	C			; error, quit
	LD	A,(IY+1)
	INC	A
	LD	(IY+1),A
	RET

;	  Subroutine read in read ahead buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C57FB:	CALL	C5B65			; read marker
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	LD	(D70AF),A		; current blocktype
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	L,(IY+9)
	LD	H,(IY+10)		; file buffer
	LD	BC,768
	ADD	HL,BC			; read ahead buffer
	LD	BC,1024
J581E:	LD	A,C
	OR	B
	JR	Z,J582B
	CALL	C5C77			; read byte from quick disk
	RET	C			; error, quit
	LD	(HL),A
	INC	HL
	DEC	BC
	JR	J581E

J582B:	CALL	C5AEB			; wait for 4 received bytes
	RET	C			; error, quit
	LD	A,(IY+1)
	INC	A
	LD	(IY+1),A
	RET

;	  Subroutine read 1024 bytes from quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5837:	PUSH	HL
	CALL	C5B65			; read marker
	POP	HL
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	LD	(D70AF),A		; current blocktype
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	BC,1024
J5852:	LD	A,C
	OR	B
	JR	Z,J585F
	CALL	C5C77			; read byte from quick disk
	RET	C
	LD	(HL),A
	INC	HL
	DEC	BC
	JR	J5852

J585F:	CALL	C5AEB			; wait for 4 received bytes
	RET

;	  Subroutine read 64 bytes from quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5863:	DI
	PUSH	HL
	CALL	C5B65			; read marker
	POP	HL
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	AND	A
	SCF
	RET	NZ
	CALL	C5C77			; read byte from quick disk
	CALL	C5C77			; read byte from quick disk
	LD	B,64
J5878:	CALL	C5C77			; read byte from quick disk
	RET	C
	LD	(HL),A
	INC	HL
	DJNZ	J5878
	CALL	C5CA1			; wait for received byte
	RET	C			; error, quit
	CALL	C5CA1			; wait for received byte
	RET	C			; error, quit
	LD	A,(D7067)
	DEC	A
	LD	(D7067),A
	RET

;	  Subroutine write 64 bytes to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5890:	DI
	CALL	C5B23			; write marker
	LD	A,00H
	CALL	C5C53			; write byte to quick disk
	LD	A,40H
	CALL	C5C53			; write byte to quick disk
	LD	A,00H
	CALL	C5C53			; write byte to quick disk
	LD	HL,D7023		; fileentry buffer
	LD	B,64
J58A8:	LD	A,(HL)
	INC	HL
	CALL	C5C53			; write byte to quick disk
	DJNZ	J58A8
	CALL	C5C2C			; check channel B DCD (ready)
	RET

;	  Subroutine read file blocks
;	     Inputs  ________________________
;	     Outputs ________________________

C58B3:	LD	HL,0
J58B6:	LD	A,(D7067)
	AND	A
	RET	Z
	CALL	C58CC			; read block from quick disk
	RET	C			; error, quit
	PUSH	BC
	LD	BC,1024
	ADD	HL,BC
	POP	BC
	LD	A,D
	CP	3			; id 3 ?
	JR	Z,J58B6			; yep, next
	AND	A
	RET

;	  Subroutine read block from quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C58CC:	DI
	PUSH	HL
	CALL	C5B65			; read marker
	POP	HL
	RET	C			; error, quit
	CALL	C5C77			; read byte from quick disk
	LD	D,A			; id ?
	PUSH	DE
	CALL	C5AD1			; read block from quick disk
	POP	DE
	RET	C			; error, quit
	LD	A,(D7067)
	DEC	A
	LD	(D7067),A		; update number of used blocks left
	AND	A
	RET

;	  Subroutine start tape for data input
;	     Inputs  ________________________
;	     Outputs ________________________

C58E6:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	TAPION			; start tape for data input
	CALL	C,TAPIOF		; error, stop tape for data input
	JP	C,J4AAF			; error, device I/O error
J58F2:	POP	HL
	POP	DE
	POP	BC
	RET

;	  Subroutine read byte from tape
;	     Inputs  ________________________
;	     Outputs ________________________

C58F6:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	TAPIN
	CALL	C,TAPIOF		; error, stop tape for data input
	JP	C,J4AAF			; error, device I/O error
	JR	J58F2

;	  Subroutine search for file on tape
;	     Inputs  ________________________
;	     Outputs ________________________

C5904:	DI
	CALL	C58E6			; start tape for data input
	CALL	C58F6			; read byte from tape
	LD	C,A			; filetype id
	LD	B,9
J590E:	CALL	C58F6			; read byte from tape
	CP	C			; must 10x filetype id
	JR	NZ,C5904		; nope, skip to next file
	DJNZ	J590E
	LD	HL,T.TFIL
	PUSH	HL
	LD	B,6
J591C:	CALL	C58F6			; read byte from tape
	LD	(HL),A
	INC	HL
	DJNZ	J591C
	POP	HL
	LD	DE,T.FLNM
	LD	B,6
J5929:	LD	A,(DE)
	INC	DE
	CP	" "
	JR	NZ,J5933
	DJNZ	J5929
	JR	J5947

J5933:	LD	DE,T.FLNM
	LD	B,6
	PUSH	BC
J5939:	LD	A,(HL)
	CALL	C5A62			; to upper
	LD	C,A
	LD	A,(DE)
	CP	C
	JR	NZ,J5950
	INC	HL
	INC	DE
	DJNZ	J5939
	POP	BC
J5947:	LD	HL,I5959		; found
	PUSH	BC
	CALL	C5967			; stop tape, string to screen, filename to screen
	POP	BC
	RET

J5950:	POP	BC
	LD	HL,I5960		; skip
	CALL	C5967			; stop tape, string to screen, filename to screen
	JR	C5904			; skip to next file

I5959:	DEFB	"Found:"
	DEFB	0

I5960:	DEFB	"Skip :"
	DEFB	0

;	  Subroutine stop tape, string to screen, filename to screen
;	     Inputs  ________________________
;	     Outputs ________________________

C5967:	CALL	TAPIOF			; stop tape for data input
	CALL	C53BA			; string to screen
	LD	HL,T.TFIL
	LD	B,6
J5972:	LD	A,(HL)
	INC	HL
	CALL	CHPUT
	DJNZ	J5972
	JP	C541C			; CR/LF to screen

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C597C:	DI
	PUSH	HL
	CALL	C58E6			; start tape for data input
	POP	HL
	LD	B,0
J5984:	CALL	C58F6			; read byte from tape
	LD	(HL),A
	INC	HL
	DJNZ	J5984
	CALL	TAPIOF			; stop tape for data input
	DEC	HL
	RET

;	  Subroutine load BASIC program
;	     Inputs  ________________________
;	     Outputs ________________________

C5990:	DI
	SCF				; load
	CALL	C4B87			; load/compare BASIC program
	LD	(VARTAB),HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C5999:	DI
	CALL	C58E6			; start tape for data input
	CALL	C59C3			; read address from tape
J59A0:	LD	(DF576),HL		; start address
	EX	DE,HL
	CALL	C59C3			; read address from tape
	LD	(DF578),HL		; end address
	PUSH	HL
	CALL	C59C3			; read address from tape
	LD	(DF57A),HL		; execute address
	EX	DE,HL
	POP	DE
J59B3:	CALL	C58F6			; read byte from tape
	LD	(HL),A
	CALL	DCOMPR
	JR	Z,J59BF
	INC	HL
	JR	J59B3

J59BF:	CALL	TAPIOF			; stop tape for data input
	RET

;	  Subroutine read address from tape
;	     Inputs  ________________________
;	     Outputs ________________________

C59C3:	CALL	C58F6			; read byte from tape
	LD	L,A
	CALL	C58F6			; read byte from tape
	LD	H,A
	RET

;	  Subroutine evaluate optional filespecification and check if it this quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C59CC:	PUSH	HL
	LD	HL,FILNAM
	LD	B,11
J59D2:	LD	(HL)," "
	INC	HL
	DJNZ	J59D2			; clear filename
	POP	HL
	DEC	HL
	CALL	C4B3F			; get BASIC character
	JR	Z,J59F4			; end of statement,
	CALL	C4B37			; check for BASIC character
	DEFB	"("
	CALL	C4B7B			; evaluate filespecification
	JR	Z,J59F4			; default device,
	PUSH	HL
	CALL	C5A41			; check if devicename is this quick disk devicename
	POP	HL
	JR	Z,J59FA			; yep, continue

; statement not recognized

J59EE:	POP	HL
	LD	HL,(D700B)		; restore BASIC pointer
	SCF				; statement not recognized
	RET

J59F4:	LD	A,(D7011)
	AND	A			; is this the first quick disk ?
	JR	NZ,J59EE		; nope, quit with statement not recognized
J59FA:	PUSH	HL
	CALL	C5A03			; check filename in FILNAM and copy to filename buffer
	POP	HL
	JP	C,J4A85			; error, bad filename error
	RET

;	  Subroutine check filename in FILNAM and copy to filename buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C5A03:	LD	HL,FILNAM

;	  Subroutine check filename and copy to filename buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C5A06:	LD	(D706D),HL		; pointer to filename
	LD	B,8
	CALL	C5A2B			; check if spaces in between
	RET	C			; yep, quit
	LD	B,3
	CALL	C5A2B			; check if spaces in between
	RET	C			; yep, quit
	LD	HL,(D706D)		; pointer to filename

;	  Subroutine copy filename to filename buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C5A18:	LD	DE,D7012		; filename buffer
	LD	B,11

;	  Subroutine copy filename
;	     Inputs  ________________________
;	     Outputs ________________________

C5A1D:	LD	A,(HL)
	CALL	C5A62			; to upper
	LD	(DE),A
	INC	HL
	INC	DE
	DJNZ	C5A1D
	LD	A,13
	LD	(DE),A
	AND	A
	RET

;	  Subroutine check if spaces in between
;	     Inputs  ________________________
;	     Outputs ________________________

C5A2B:	LD	A,(HL)
	CP	" "
	JR	Z,J5A35
	INC	HL
	DJNZ	C5A2B
	JR	J5A3D

J5A35:	LD	A,(HL)
	CP	" "
	JR	NZ,J5A3F
	INC	HL
	DJNZ	J5A35
J5A3D:	AND	A
	RET

J5A3F:	SCF
	RET

;	  Subroutine check if devicename is this quick disk devicename
;	     Inputs  ________________________
;	     Outputs ________________________

C5A41:	LD	HL,PROCNM
	LD	DE,D700D		; this quick disk devicename
	LD	B,0
J5A49:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J5A54
	AND	A			; end of devicename ?
	RET	Z			; yep, quit
	INC	DE
	INC	HL
	INC	B
	JR	J5A49

J5A54:	LD	A,B
	CP	2			; QD: ?
	SCF
	CCF
	RET	NZ			; nope, quit
	LD	A,(HL)
	AND	A			; end of devicename ?
	RET	NZ			; nope, quit
	LD	A,(D7011)
	AND	A			; is this the first quick disk ?
	RET

;	  Subroutine to upper
;	     Inputs  ________________________
;	     Outputs ________________________

C5A62:	CP	"a"
	RET	C
	CP	"z"+1
	RET	NC
	SUB	20H
	RET

;	  Subroutine get slotid on page
;	     Inputs  ________________________
;	     Outputs ________________________

C5A6B:	DI
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	D,A
	IN	A,(0A8H)
	CALL	C5A8E
	LD	C,A
	LD	B,00H
	LD	HL,EXPTBL
	ADD	HL,BC
	OR	(HL)
	LD	C,A
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	CALL	C5A8E
	RLCA
	RLCA
	OR	C
	POP	HL
	POP	DE
	POP	BC
	EI
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C5A8E:	PUSH	DE
	LD	E,A
J5A90:	LD	A,D
	AND	A
	JR	Z,J5A9B
	DEC	D
	RRC	E
	RRC	E
	JR	J5A90

J5A9B:	LD	A,E
	AND	03H
	POP	DE
	RET

;	  Subroutine read channel A DCD (media inserted)
;	     Inputs  ________________________
;	     Outputs ________________________

C5AA0:	LD	A,10H
	LD	(D6002),A		; null code, reset interrupts, register 0
	LD	A,(D6002)		; read status register 0
	RRCA
	RRCA
	RRCA
	RRCA
	CCF
	RET

;	  Subroutine read channel A sync/hunt
;	     Inputs  ________________________
;	     Outputs ________________________

C5AAE:	LD	A,10H
	LD	(D6002),A		; null code, reset interrupts, register 0
	LD	A,(D6002)		; read status register 0
	RLCA
	RLCA
	RLCA
	CCF
	RET

;	  Subroutine read first free 'block'
;	     Inputs  ________________________
;	     Outputs ________________________

C5ABB:	CALL	C5BD3			; initialize channel A for receive
	CALL	C5BE9			; disable interrupts, channel B, DTR=1, RTS=0 (motor on, mfm demodulator)
	CALL	C5C14			; wait for channel B DCD (ready)
	CALL	C5B58			; read marker (extra wait)
	CALL	C5C77			; read byte from quick disk
	LD	(D7066),A		; first free 'block'
	CALL	C5AEB			; wait for 4 received bytes
	RET

;	  Subroutine read block from quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5AD1:	CALL	C5C77			; read byte from quick disk
	LD	C,A			; number of bytes, low byte
	CALL	C5C77			; read byte from quick disk
	LD	B,A			; number of bytes, high byte
J5AD9:	CALL	C5C77			; read byte from quick disk
	RET	C
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,J5AD9
	CALL	C5CA1			; wait for received byte
	RET	C			; error, quit
	CALL	C5CA1			; wait for received byte
	RET

;	  Subroutine wait for 4 received bytes
;	     Inputs  ________________________
;	     Outputs ________________________

C5AEB:	CALL	C5CA1			; wait for received byte
	RET	C			; error, quit
	CALL	C5CA1			; wait for received byte
	RET	C			; error, quit
	CALL	C5CA1			; wait for received byte
	RET	C			; error, quit
J5AF7:	LD	A,(D6002)		; read status register 0
	RRCA				; all sent ?
	JR	NC,J5AF7		; nope, wait
	LD	A,01H
	LD	(D6002),A		; register 1
	LD	A,(D6002)		; read status register 1
	BIT	6,A			; CRC error ?
	SCF
	RET	NZ			; yep, quit
	CCF
	RET

;	  Subroutine write marker (special)
;	     Inputs  ________________________
;	     Outputs ________________________

C5B0B:	XOR	A
	LD	(D7063),A		; wait flag = long
	CALL	C5BDB			; initialize channel A for transmit
	CALL	C5BE9			; disable interrupts, channel B, DTR=1, RTS=0 (motor on, mfm demodulator)
	CALL	C5C14			; wait for channel B DCD (ready)
	CALL	C5CDD			; wait 180 ms
	CALL	C5C21			; channel A, DTR=1, RTS=1, send break (write enable)
J5B1E:	CALL	C5CE3			; wait 250 ms
	JR	J5B40

;	  Subroutine write marker
;	     Inputs  ________________________
;	     Outputs ________________________

C5B23:	LD	A,98H
	LD	(D6002),A		; reset Tx CRC generator, channel reset, register 0
	CALL	C5C48			; channel B, DTR=1, RTS=0 (motor on, mfm demodulator)
	CALL	C5BDB			; initialize channel A for transmit
	CALL	C5C21			; channel A, DTR=1, RTS=1, send break (write enable)
	LD	A,(D7063)
	OR	A			; wait flag
	JR	NZ,J5B3D		; short, wait short and continue
	DEC	A
	LD	(D7063),A		; wait flag = short
	JR	J5B1E			; wait long and continue

J5B3D:	CALL	C5CD1			; wait 20 ms
J5B40:	LD	A,05H
	LD	(D6002),A		; register 5
	LD	A,0EFH
	LD	(D6002),A		; channel A, DTR=1, Tx 8 bit, no break, Tx enabled, CRC16, RTS=1, Tx CRC enabled (write enable)
	CALL	C5CC5			; wait 1 ms
	LD	A,0A5H
	CALL	C5C53			; write byte to quick disk
	LD	A,0C0H
	LD	(D6002),A		; reset Tx underrun, null code, register 0
	RET

;	  Subroutine read marker (extra wait)
;	     Inputs  ________________________
;	     Outputs ________________________

C5B58:	DI
	CALL	C5CDD			; wait 180 ms
	XOR	A
	LD	(D7063),A		; wait flag = long
J5B60:	CALL	C5CD7			; wait 125 ms
	JR	J5B80

;	  Subroutine read marker
;	     Inputs  ________________________
;	     Outputs ________________________

C5B65:	DI
	LD	A,58H
	LD	(D6002),A		; reset Rx CRC checker, channel reset, register 0
	CALL	C5C48			; channel B, DTR=1, RTS=0 (motor on, mfm demodulator)
	CALL	C5BD3			; initialize channel A for receive
	LD	A,(D7063)
	OR	A			; wait flag
	JR	NZ,J5B7D		; short, wait short and continue
	DEC	A
	LD	(D7063),A		; wait flag = short
	JR	J5B60			; wait long and continue

J5B7D:	CALL	C5CCB			; wait 2 ms
J5B80:	CALL	C5C3D			; channel B, DTR=1, RTS=1 (motor on, mfm demodulator)
	LD	A,03H
	LD	(D6002),A		; register 3
	LD	A,0D3H
	LD	(D6002),A		; 8 bits, no auto enable, hunt phase, no sync character, Rx enabled
	LD	BC,2CC0H
J5B90:	LD	A,10H
	LD	(D6002),A		; null code, reset interrupts, register 0
	LD	A,(D6002)		; read status register 0
	BIT	4,A			; sync/hunt ?
	JR	Z,J5BA3			; nope,
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,J5B90
	SCF
	RET

J5BA3:	LD	A,03H
	LD	(D6002),A		; register 3
	LD	A,0C3H
	LD	(D6002),A		; 8 bits, no auto enable, no hunt phase, no sync character, Rx enabled
	LD	B,9FH
J5BAF:	LD	A,10H
	LD	(D6002),A		; null code, reset interrupts, register 0
	LD	A,(D6002)		; read status register 0
	BIT	0,A			; Rx character ?
	JR	NZ,J5BC0		; yep,
	DEC	B
	JR	NZ,J5BAF
	SCF
	RET

J5BC0:	LD	A,03H
	LD	(D6002),A		; register 3
	LD	A,0C9H
	LD	(D6002),A		; 8 bits, no auto enable, hunt phase, Rx CRC enabled, no sync character, Rx enabled
	CALL	C5C60			; wait long for received byte
	RET	C			; error, quit
	CP	0A5H
	RET	Z
	SCF
	RET

;	  Subroutine initialize channel A for receive
;	     Inputs  ________________________
;	     Outputs ________________________

C5BD3:	DI
	LD	HL,I5DAF
	LD	B,11
	JR	J5BE1

;	  Subroutine initialize channel A for transmit
;	     Inputs  ________________________
;	     Outputs ________________________

C5BDB:	DI
	LD	HL,I5DA6
	LD	B,9
J5BE1:	LD	A,(HL)
	LD	(D6002),A
	INC	HL
	DJNZ	J5BE1
	RET

;	  Subroutine disable interrupts, channel B, DTR=1, RTS=0
;	     Inputs  ________________________
;	     Outputs ________________________

C5BE9:	PUSH	AF
	CALL	DISINT
	DI
	LD	A,05H
	LD	(D6003),A		; register 5
	LD	A,80H
	LD	(D6003),A		; channel B, DTR=1, RTS=0 (motor on, mfm demodulator)
	POP	AF
	RET

;	  Subroutine reset quick disk controller
;	     Inputs  ________________________
;	     Outputs ________________________

C5BFA:	PUSH	AF
	LD	A,05H
	LD	(D6002),A		; register 5
	LD	A,60H
	LD	(D6002),A		; channel A, DTR=0, Tx 8 bit, no break, Tx disabled, no CRC16, RTS=0, Tx CRC disabled (write disable)
	LD	A,05H
	LD	(D6003),A		; register 5
	XOR	A
	LD	(D6003),A		; channel B, DTR=0, RTS=0 (motor off, mfm demodulator)
	CALL	ENAINT
	EI
	POP	AF
	RET

;	  Subroutine wait for channel B DCD (ready)
;	     Inputs  ________________________
;	     Outputs ________________________

C5C14:	LD	A,10H
	LD	(D6003),A		; null code, reset interrupts, register 0
	LD	A,(D6003)		; read status register 0
	BIT	3,A			; DCD ?
	JR	Z,C5C14			; nope,
	RET

;	  Subroutine channel A, DTR=1, RTS=1, send break
;	     Inputs  ________________________
;	     Outputs ________________________

C5C21:	LD	A,05H
	LD	(D6002),A		; register 5
	LD	A,0FFH
	LD	(D6002),A		; DTR=1, Tx 8 bit, break, Tx enabled, CRC16, RTS=1, Tx CRC enabled (write enable)
	RET

;	  Subroutine check channel B DCD (ready)
;	     Inputs  ________________________
;	     Outputs ________________________

C5C2C:	CALL	C5CC5			; wait 1 ms
	LD	A,10H
	LD	(D6003),A		; null code, reset interrupts, register 0
	LD	A,(D6003)		; read status register 0
	AND	A
	BIT	3,A			; DCD ?
	RET	NZ			; yep, quit
	SCF
	RET

;	  Subroutine channel B, DTR=1, RTS=1
;	     Inputs  ________________________
;	     Outputs ________________________

C5C3D:	LD	A,05H
	LD	(D6003),A		; register 5
	LD	A,82H
	LD	(D6003),A		; DTR=1, RTS=1 (motor on, mfm demodulator)
	RET

;	  Subroutine channel B, DTR=1, RTS=0
;	     Inputs  ________________________
;	     Outputs ________________________

C5C48:	LD	A,05H
	LD	(D6003),A		; register 5
	LD	A,80H
	LD	(D6003),A		; DTR=1, RTS=0 (motor on, mfm demodulator)
	RET

;	  Subroutine write byte to quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5C53:	PUSH	AF
J5C54:	LD	A,(D6002)		; read status register
	BIT	2,A			; Tx buffer empty ?
	JR	Z,J5C54			; nope, wait
	POP	AF
	LD	(D6000),A
	RET

;	  Subroutine wait long for received byte
;	     Inputs  ________________________
;	     Outputs ________________________

C5C60:	PUSH	BC
	LD	B,4
J5C63:	LD	DE,0
J5C66:	CALL	C5C83			; check receive status
	JR	C,J5C75			; error, quit
	JR	NZ,J5C75		; byte received, quit
	DEC	DE
	LD	A,D
	OR	E
	JR	NZ,J5C66
	DJNZ	J5C63
	SCF
J5C75:	POP	BC
	RET

;	  Subroutine read byte from quick disk
;	     Inputs  ________________________
;	     Outputs ________________________

C5C77:	LD	D,0
J5C79:	CALL	C5C83			; check receive status
	RET	C			; error, quit
	RET	NZ			; byte received, quit
	DEC	D
	JR	NZ,J5C79
	SCF
	RET

;	  Subroutine check receive status
;	     Inputs  ________________________
;	     Outputs ________________________

C5C83:	LD	A,01H
	LD	(D6002),A		; register 1
	LD	A,(D6002)		; read status register 1
	AND	0A0H			; end of frame or Rx overrun ?
	JR	NZ,J5C9E		; yep, quit
	LD	A,(D6002)
	BIT	7,A			; end of frame ?
	JR	NZ,J5C9E		; yep, quit
	AND	01H			; all sent ?
	RET	Z			; nope, quit
	AND	A
	LD	A,(D6000)		; read received byte
	RET

J5C9E:	XOR	A
	SCF
	RET

;	  Subroutine wait for received byte
;	     Inputs  ________________________
;	     Outputs ________________________

C5CA1:	LD	D,0
J5CA3:	LD	A,01H
	LD	(D6002),A		; register 1
	LD	A,(D6002)		; read status register 1
	BIT	5,A			; Rx overrun ?
	JR	NZ,J5CC3		; yep, quit
	LD	A,(D6002)
	BIT	7,A			; end of frame ?
	JR	NZ,J5CC3		; yep, quit
	BIT	0,A			; all sent ?
	JR	NZ,J5CBF		; yep, 
	DEC	D
	JR	NZ,J5CA3
	JR	J5CC3

J5CBF:	LD	A,(D6000)		; read received byte
	RET

J5CC3:	SCF
	RET

;	  Subroutine wait 1 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C5CC5:	PUSH	BC
	LD	BC,1
	JR	J5CE7

;	  Subroutine wait 2 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C5CCB:	PUSH	BC
	LD	BC,3
	JR	J5CE7

;	  Subroutine wait 20 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C5CD1:	PUSH	BC
	LD	BC,29
	JR	J5CE7

;	  Subroutine wait 125 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C5CD7:	PUSH	BC
	LD	BC,160
	JR	J5CE7

;	  Subroutine wait 180 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C5CDD:	PUSH	BC
	LD	BC,233
	JR	J5CE7

;	  Subroutine wait 250 ms
;	     Inputs  ________________________
;	     Outputs ________________________

C5CE3:	PUSH	BC
	LD	BC,320
J5CE7:	PUSH	AF
J5CE8:	LD	A,98H
J5CEA:	DEC	A
	JR	NZ,J5CEA
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,J5CE8
	POP	AF
	POP	BC
	RET

I5CF5:	DEFB	12
	DEFB	27,"Y",10+32,6+32
	DEFB	"Quick Disk System"
	DEFB	27,"Y",11+32,9+32

	IF	QDVER EQ 100
	DEFB	"Version 1.00"
	ELSE
	DEFB	"Version 1.1"
	ENDIF

	DEFB	27,"Y",13+32,2+32
	DEFB	"Copyright 1984 by Mitsumi"
	DEFB	0

I5D38:	DEFB	"No file",13,10
	DEFB	0

I5D42:	DEFB	"      Name         Atr Size",13,10
	DEFB	0

I5D60:	DEFB	'("'
	DEFB	0

I5D63:	DEFB	'"',"'"
	DEFB	0

I5D66:	DEFB	"Are you sure (Y/N)?"
	DEFB	0

I5D7A:	DEFB	"Canceled",13,10
	DEFB	0

I5D85:	DEFB	"Now formatting",13,10
	DEFB	0

I5D96:	DEFB	"Complete",13,10
	DEFB	0

I5DA1:	DEFB	"Ok",13,10
	DEFB	0

; Z8440 in transmit mode

I5DA6:	DEFB	098H			; reset Tx CRC generator, channel reset, register 0
	DEFB	004H,010H		; register 4, X1 clock, 16 bit sync, sync mode, parity disabled
	DEFB	006H,016H		; register 6, sync low byte
	DEFB	007H,016H		; register 7, sync high byte
	DEFB	005H,06DH		; register 5, DTR=0, Tx 8 bit, no break, Tx enabled, CRC16, RTS=0, Tx CRC enabled (write disable)

; Z8440 in receive mode

I5DAF:	DEFB	058H			; reset Rx CRC checker, channel reset, register 0
	DEFB	004H,010H		; register 4, X1 clock, 16 bit sync, sync mode, parity disabled
	DEFB	005H,004H		; register 5, DTR=0, Tx 6 bit, no break, Tx disabled, CRC16, RTS=0, Tx CRC disabled (write disable)
	DEFB	003H,0D0H		; register 3, 8 bits, no auto enable, hunt phase, sync character, Rx disabled
	DEFB	006H,016H		; register 6, sync low byte
	DEFB	007H,016H		; register 7, sync high byte


	IF	QDVER NE 100

;	  Subroutine execute routine with BASIC interpreter enabled
;	     Inputs  ________________________
;	     Outputs ________________________

J5DBA:	LD	HL,(D703B)		; execute address
	JR	J5DC7

;	  Subroutine execute routine (+ offset) with BASIC interpreter enabled
;	     Inputs  ________________________
;	     Outputs ________________________

J5DBF:	LD	HL,(D703B)		; execute address
	LD	DE,(D706B)		; offset
	ADD	HL,DE
J5DC7:	PUSH	HL
	LD	HL,I5DD7
	LD	DE,T.EXEC
	LD	BC,12
	LDIR
	POP	HL
	JP	T.EXEC

; execute BASIC routine

I5DD7:	LD	A,(EXPTBL+0)
	PUSH	HL
	LD	HL,4000H
	CALL	ENASLT
	POP	HL
	JP	(HL)

	ENDIF

	DEFS	06000H-$,0

	END
