; BASICKUN.MAC
;
; MSX BASIC KUN (version 2.1)
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders

	.Z80
        ASEG
	ORG	4000H

VDP.DR	EQU	0006H
VDP.DW	EQU	0007H
IDBYT2	EQU	002DH
WRTVDP	EQU	0047H
CHGMOD	EQU	005FH
CHGCLR	EQU	0062H
CLRSPR	EQU	0069H
CALPAT	EQU	0084H
CALATR	EQU	0087H
GSPSIZ	EQU	008AH
WRTPSG	EQU	0093H
CHSNS	EQU	009CH
CHGET	EQU	009FH
QINLIN	EQU	00B4H
BEEP	EQU	00C0H
CLS	EQU	00C3H
POSIT	EQU	00C6H
ERAFNK	EQU	00CCH
DSPFNK	EQU	00CFH
GTSTCK	EQU	00D5H
GTTRIG	EQU	00D8H
GTPAD	EQU	00DBH
GTPDL	EQU	00DEH
SCALXY	EQU	010EH
MAPXYC	EQU	0111H
READC	EQU	011DH
CALBAS	EQU	0159H
EXTROM	EQU	015FH

S.INIPLT	EQU	0141H
S.RSTPLT	EQU	0145H
S.GETPLT	EQU	0149H
S.SETPLT	EQU	014DH

M406F	EQU	406FH			; BASIC error
M57F1	EQU	57F1H			; PSET
M58C1	EQU	58C1H			; LINE boxfill
M58FC	EQU	58FCH			; LINE
M5912	EQU	5912H			; LINE box
M59E3	EQU	59E3H			; PAINT MSX1
M5B19	EQU	5B19H			; CIRCLE
M5EA4	EQU	5EA4H			; locate variable
M5F5D	EQU	5F5DH			; locate variable (search only)
M7810	EQU	7810H			; check ON <trap> GOTO

S266E	EQU	266EH			; PAINT MSX2 (subrom)


USRTAB	EQU	0F39AH
CSRY	EQU	0F3DCH
RG0SAV	EQU	0F3DFH
RG1SAV	EQU	0F3E0H
RG2SAV	EQU	0F3E1H
RG6SAV	EQU	0F3E5H
FORCLR	EQU	0F3E9H
BAKCLR	EQU	0F3EAH
BDRCLR	EQU	0F3EBH
ATRBYT	EQU	0F3F2H
LPTPOS	EQU	0F415H
PRTFLG	EQU	0F416H
CURLIN	EQU	0F41CH
BUF	EQU	0F55EH
TTYPOS	EQU	0F661H
VALTYP	EQU	0F663H
TXTTAB	EQU	0F676H
DATLIN	EQU	0F6A3H
SUBFLG	EQU	0F6A5H
SAVTXT	EQU	0F6AFH
SAVSTK	EQU	0F6B1H
STREND	EQU	0F6C6H
DATPTR	EQU	0F6C8H
DEFTBL	EQU	0F6CAH
SWPTMP	EQU	0F7BCH
FBUFFR	EQU	0F7C5H
DAC	EQU	0F7F6H
NULBUF	EQU	0F862H
DPPAGE	EQU	0FAF5H
ACPAGE	EQU	0FAF6H
MODE	EQU	0FAFCH
FNKFLG	EQU	0FBCEH
ONGSBF	EQU	0FBD8H
LINWRK	EQU	0FC18H
TRPTBL	EQU	0FC4CH
INTFLG	EQU	0FC9BH
JIFFY	EQU	0FC9EH
SCRMOD	EQU	0FCAFH
BRDATR	EQU	0FCB2H
GXPOS	EQU	0FCB3H
GYPOS	EQU	0FCB5H
GRPACX	EQU	0FCB7H
GRPACY	EQU	0FCB9H
PROCNM	EQU	0FD89H
RG8SAV	EQU	0FFE7H
RG11SAV	EQU	0FFEAH
RG23SAV	EQU	0FFF6H
RG25SAV	EQU	0FFFAH
RG26SAV	EQU	0FFFBH

        DEFB	"AB"
        DEFW	0
        DEFW	C.4032
        DEFW	0
        DEFW	0
	DEFS	6,0

	DEFM	"BASIC'n ver 2.1 (C) 1992 by ASCII"
	DEFB	0

C.4032:	EI
	LD	DE,I.4047
	PUSH	HL
	LD	HL,PROCNM
	CALL	C.4065			; check if recognized CALL statement
	POP	HL
	RET	C			; not recognized, quit with statement not recognized
	CALL	C$4045			; start statement handler
	EI
	AND	A			; statement recognized, quit
	RET

;	  Subroutine start statement handler
;	     Inputs  ________________________
;	     Outputs ________________________

C$4045:	PUSH	DE
	RET

I.4047:	DEFB	"RUN"
	DEFB	0
	DEFW	C.4149
	DEFB	"TURBO"
	DEFB	0FFH
	DEFB	"ON"
	DEFB	0
	DEFW	C.4E88
	DEFB	"TURBO"
	DEFB	0FFH
	DEFB	"OFF"
	DEFB	0
	DEFW	C.4EFF
	DEFB	0FFH
	
;	  Subroutine check if recognized CALL statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4065:	PUSH	HL
	LD	A,(DE)
	INC	A
	JR	Z,J$4075
	CALL	C.4078
	POP	HL
	JR	NZ,C.4065
	EX	DE,HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; statement handler
	RET

J$4075:	SCF				; statement not recognized
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.4078:	OR	A
	RET	Z
J$407A:	LD	A,(DE)
	CP	(HL)
	INC	DE
	INC	HL
	JR	Z,C.4078
	INC	A
	JR	NZ,J$408D
	DEC	HL
J$4084:	LD	A,(HL)
	CP	" "
	INC	HL
	JR	Z,J$4084
	DEC	HL
	JR	J$407A

J$408D:	DEC	DE
J$408E:	LD	A,(DE)
	AND	A
	INC	DE
	JR	NZ,J$408E
	INC	DE
	INC	DE
	INC	A
	RET

I$4097:	DEFW	J.4E16			; unused token, BASIC error: syntax error
	DEFW	C.4D0A			; END
	DEFW	C.480E			; FOR
	DEFW	J$48BF			; NEXT
	DEFW	J$4DF2			; DATA
	DEFW	C.4A6B			; INPUT
	DEFW	J$452C			; DIM
	DEFW	J$4519			; READ
	DEFW	C.445F			; LET
	DEFW	C.4696			; GOTO
	DEFW	C.467C			; RUN
	DEFW	C.45DD			; IF
	DEFW	C.4A2A			; RESTORE
	DEFW	C$4699			; GOSUB
	DEFW	C.4689			; RETURN
	DEFW	C.43BA			; REM
	DEFW	C.4D13			; STOP
	DEFW	C$4B34			; PRINT
	DEFW	J.4E16			; CLEAR, BASIC error: syntax error
	DEFW	J.4E16			; LIST, BASIC error: syntax error
	DEFW	J.4E16			; NEW, BASIC error: syntax error
	DEFW	C.46C0			; ON
	DEFW	C.4CA6			; WAIT
	DEFW	C.4CE3			; DEF
	DEFW	C.4B9E			; POKE
	DEFW	J.4E16			; CONT, BASIC error: syntax error
	DEFW	J.4E16			; CSAVE, BASIC error: syntax error
	DEFW	J.4E16			; CLOAD, BASIC error: syntax error
	DEFW	C.4C1B			; OUT
	DEFW	C.4B1D			; LPRINT
	DEFW	J.4E16			; LLIST, BASIC error: syntax error
	DEFW	C.6956			; CLS
	DEFW	J.4E16			; WIDTH, BASIC error: syntax error
	DEFW	J.4E16			; ELSE, BASIC error: syntax error
	DEFW	J.4E16			; TRON, BASIC error: syntax error
	DEFW	J.4E16			; TROFF, BASIC error: syntax error
	DEFW	C.47DF			; SWAP
	DEFW	J.4E16			; ERASE, BASIC error: syntax error
	DEFW	J.4E16			; ERROR, BASIC error: syntax error
	DEFW	J.4E16			; RESUME, BASIC error: syntax error
	DEFW	J.4E16			; DELETE, BASIC error: syntax error
	DEFW	J.4E16			; AUTO, BASIC error: syntax error
	DEFW	J.4E16			; RENUM, BASIC error: syntax error
	DEFW	C.479A			; DEFSTR
	DEFW	C.4797			; DEFINT
	DEFW	C.479D			; DEFSGN
	DEFW	C.47A0			; DEFDBL
	DEFW	C.66D5			; LINE
	DEFW	J.4E16			; OPEN, BASIC error: syntax error
	DEFW	J.4E16			; FIELD, BASIC error: syntax error
	DEFW	J.4E16			; GET, BASIC error: syntax error
	DEFW	C.6880			; PUT
	DEFW	J.4E16			; CLOSE, BASIC error: syntax error
	DEFW	J.4E16			; LOAD, BASIC error: syntax error
	DEFW	J.4E16			; MERGE, BASIC error: syntax error
	DEFW	J.4E16			; FILES, BASIC error: syntax error
	DEFW	J.4E16			; LSET, BASIC error: syntax error
	DEFW	J.4E16			; RSET, BASIC error: syntax error
	DEFW	J.4E16			; SAVE, BASIC error: syntax error
	DEFW	J.4E16			; LFILES, BASIC error: syntax error
	DEFW	C.6853			; CIRCLE
	DEFW	C.65A4			; COLOR
	DEFW	J.4E16			; DRAW, BASIC error: syntax error
	DEFW	C.6AC0			; PAINT
	DEFW	C.4B95			; BEEP
	DEFW	J.4E16			; PLAY, BASIC error: syntax error
	DEFW	C.677A			; PSET
	DEFW	C.677B			; PRESET
	DEFW	C.4DA5			; SOUND
	DEFW	C.6933			; SCREEN
	DEFW	C.695C			; VPOKE
	DEFW	C.4D22			; SPRITE
	DEFW	C.6A81			; VDP
	DEFW	J.4E16			; BASE, BASIC error: syntax error
	DEFW	C$4E36			; CALL
	DEFW	C.4DE6			; TIME
	DEFW	C.4D34			; KEY
	DEFW	J.4E16			; MAX, BASIC error: syntax error
	DEFW	J.4E16			; MOTOR, BASIC error: syntax error
	DEFW	J.4E16			; BLOAD, BASIC error: syntax error
	DEFW	J.4E16			; BSAVE, BASIC error: syntax error
	DEFW	J.4E16			; DSKO$, BASIC error: syntax error
	DEFW	C.69A3			; SET
	DEFW	J.4E16			; NAME, BASIC error: syntax error
	DEFW	J.4E16			; KILL, BASIC error: syntax error
	DEFW	J.4E16			; IPL, BASIC error: syntax error
	DEFW	C.6B1D			; COPY
	DEFW	J.4E16			; CMD, BASIC error: syntax error
	DEFW	C.4DC7			; LOCATE

;	  Subroutine CALL RUN
;	     Inputs  ________________________
;	     Outputs ________________________

C.4149:	LD	(SAVTXT),HL
	LD	DE,DEFTBL
	LD	B,26
	LD	A,8
J$4153:	LD	(DE),A
	INC	DE
	DJNZ	J$4153
	LD	HL,(TXTTAB)
	DEC	HL
	LD	(DATPTR),HL		; initialize DATA pointer
	INC	HL
	XOR	A			; not in turbo block

; start turbo block

J$4160:	LD	(BUF+7),HL		; start of turbo block basic text
	LD	(BUF+5),A		; turbo flag
	LD	(SAVSTK),SP
	AND	A			; in turbo block ?
	JR	Z,J$4171		; nope,
	LD	B,A
	XOR	A
	CPIR				; skip to end of line
J$4171:	LD	BC,0			; number of BASIC lines = 0
J$4174:	INC	BC
	LD	A,(HL)
	INC	HL
	PUSH	HL
	POP	IX
	LD	H,(HL)
	LD	L,A			; next line pointer
	OR	H			; end of program ?
	JR	Z,J$4191		; yep,
	INC	IX
	INC	IX
	INC	IX			; skip line number
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0CAH			; line start with CALL token ?
	JR	Z,J$4190		; yep,
	CP	"_"			; line start with CALL character ?
	JR	NZ,J$4174		; nope, next line

J$4190:	INC	BC
J$4191:	LD	L,C
	LD	H,B			; number of BASIC lines
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL			; *6
	LD	(BUF+19),HL		; size of line number list buffer
	EX	DE,HL
	LD	HL,0
	ADD	HL,SP			; current bottom of stack
	SBC	HL,DE
	LD	(BUF+17),HL		; start list of code pointer per line number
	LD	SP,HL			; allocate space on stack for line number list
	LD	(HL),0FFH
	INC	HL
	LD	(HL),0FFH
	DEC	HL			; end marker line number list
	DEC	H
	DEC	H
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(HL),0
	LD	(BUF+21),HL		; start of variable list
	LD	(BUF+23),HL		; end of variable list
	XOR	A
	LD	(BUF+4),A		; no bytes in execution buffer
	LD	(BUF+6),A		; no traps defined
	LD	(BUF+12),A		; reset force float flag
	LD	(BUF+13),A		; reset NULBUF in use flag
	LD	(BUF+14),A		; next overflow check off
	LD	HL,(STREND)
	LD	(BUF+0),HL		; start of compiled basic program
	LD	(BUF+2),HL		; current compiled code pointer
	LD	IX,(BUF+7)		; start of turbo block basic text
	LD	A,(BUF+5)
	AND	A			; in turbo block ?
	JR	Z,J.41F1		; nope, skip CALL TURBO ON parameter parsing
	LD	A,(IX+0)
	CP	":"			; next statement ?
	JR	Z,J.420F		; yep, start compiling
	INC	IX
	AND	A			; end of line ?
	JR	Z,J.41F1		; yep, check if end of program and start compiling
	CP	"("
	JP	NZ,J.4E16		; BASIC error: syntax error
	CALL	C.4E97			; parse CALL TURBO ON parameters
	JR	J$4214

J.41F1:	LD	A,(IX+0)
	OR	(IX+1)			; end of basic program ?
	JR	Z,J$421A		; yep, stop compiling
	LD	(BUF+15),IX
	LD	L,(IX+2)
	LD	H,(IX+3)		; line number
	LD	(CURLIN),HL
	CALL	C$42D9			; register code pointer of line number
	INC	IX
	INC	IX
	INC	IX
J.420F:	INC	IX
	CALL	C.4258			; compile statement
J$4214:	JR	C,J.420F		; end of statement, next statement
	INC	IX
	JR	J.41F1			; next line

J$421A:	LD	A,(BUF+5)
	AND	A			; in turbo block ?
	JR	Z,J$422B		; nope,
	LD	HL,(BUF+15)
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEC	HL
	LD	(SAVTXT),HL
J$422B:	CALL	C.4D0A			; compile END statement
	CALL	C$4387			; replace line number references by code pointers
	CALL	C$648C
	LD	HL,(BUF+19)		; size of line number list buffer
	ADD	HL,SP
	LD	SP,HL			; release line number list on stack
	LD	HL,-2
	LD	(CURLIN),HL		; running compiled basic
	LD	HL,3579H		; y5
	LD	(SWPTMP+0),HL
	LD	HL,7531H		; 1u
	LD	(SWPTMP+2),HL
	LD	HL,MODE
	RES	4,(HL)			; 212 lines mode
	LD	HL,I$4E28		; BASIC error: return without gosub
	PUSH	HL
	LD	HL,(BUF+0)
	JP	(HL)			; start compiled basic program

;	  Subroutine compile statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4258:	CALL	C.6032			; get BASIC character, skip spaces
	AND	A			; end of line ?
	RET	Z			; yep, quit
	CP	":"			; end of statement ?
	SCF
	RET	Z			; yep, quit
	PUSH	AF
	LD	A,(BUF+6)
	AND	A			; traps defined ?
	JR	Z,J$4270		; nope, skip trap check handler
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$6C27			; check for traps
	DEFW	0

J$4270:	POP	AF
	INC	IX
	CP	"_"			; call statement ?
	JR	NZ,J$427C		; nope,
	CALL	C$4E36			; handle CALL statement
	JR	J.42CC			; check for end of statement and quit

J$427C:	AND	A			; statement/function token ?
	JP	M,J$4285		; yep,
	CALL	C$4464			; compile LET statement
	JR	J.42CC			; check for end of statement and quit

J$4285:	CP	0FFH			; function token ?
	JR	NZ,J$42B8		; nope,
	LD	A,(IX+0)
	INC	IX
	LD	HL,J.42CC
	PUSH	HL			; when quit, check for end of statement and quit
	CP	83H			; MID$ function token ?
	JP	Z,J$61B6		; yep,
	CP	0A3H			; STRIG function token ?
	JP	Z,J$4D2F		; yep,
	CP	85H			; INT function token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	A,"E"
	CALL	C.604A
	LD	A,"R"
	CALL	C.604A
	LD	A,0FFH
	CALL	C.604A
	LD	A,94H
	CALL	C.604A			; check for BASIC ERVAL
	JP	J$4D1D

J$42B8:	CP	0D9H			; valid statement token ?
	JP	NC,J.4E16		; nope, BASIC error: syntax error
	ADD	A,A
	LD	L,A
	LD	H,0
	LD	BC,I$4097
	ADD	HL,BC
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; statement handler
	CALL	C$42D8			; invoke statement handler

;	  Subroutine check for end of statement and quit
;	     Inputs  ________________________
;	     Outputs ________________________

J.42CC:	CALL	C.6032			; get BASIC character, skip spaces
	AND	A			; end of line ?
	RET	Z			; yep, quit
	CP	":"			; end of statement ?
	SCF
	RET	Z			; yep, quit
	JP	J.4E16			; BASIC error: syntax error

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$42D8:	JP	(HL)

;	  Subroutine register code pointer of line number
;	     Inputs  HL = linenumber
;	     Outputs ________________________

C$42D9:	PUSH	IX
	LD	IX,(BUF+17)		; start list of code pointer per line number
J$42DF:	LD	A,(IX+0)
	AND	(IX+1)
	INC	A			; end marker ?
	JR	Z,J$42FB		; yep, create new entry
	LD	A,L
	CP	(IX+0)			; line number found ?
	JR	NZ,J$42F4		; nope, next
	LD	A,H
	CP	(IX+1)			; line number found ?
	JR	Z,J$4310		; yep, register code pointer of line number
J$42F4:	LD	BC,6
	ADD	IX,BC
	JR	J$42DF			; next entry

J$42FB:	LD	(IX+0),L
	LD	(IX+1),H		; line number
	XOR	A
	LD	(IX+4),A
	LD	(IX+5),A		; code pointer of referenced line number = unknown
	LD	(IX+6),0FFH
	LD	(IX+7),0FFH		; new end marker
J$4310:	LD	HL,(BUF+2)		; current compiled code pointer
	LD	(IX+2),L
	LD	(IX+3),H
	POP	IX
	RET

;	  Subroutine fetch code pointer of line number and generate address
;	     Inputs  HL = line number
;	     Outputs ________________________

C.431C:	PUSH	IX
	LD	IX,(BUF+17)		; start list of code pointer per line number
J$4322:	LD	A,(IX+0)
	AND	(IX+1)
	INC	A			; end marker ?
	JR	Z,J$433E		; yep, create new entry
	LD	A,L
	CP	(IX+0)			; line number found ?
	JR	NZ,J$4337		; nope, next entry
	LD	A,H
	CP	(IX+1)			; line number found ?
	JR	Z,J$4360		; yep,
J$4337:	LD	BC,6
	ADD	IX,BC
	JR	J$4322			; next entry

J$433E:	LD	(IX+0),L
	LD	(IX+1),H		; line number
	XOR	A
	LD	(IX+2),A
	LD	(IX+3),A		; code pointer of line number = unknown
	LD	HL,(BUF+2)		; current compiled code pointer
	LD	(IX+4),L
	LD	(IX+5),H		; code pointer of referenced line number
	LD	(IX+6),0FFH
	LD	(IX+7),0FFH		; new end marker
	LD	L,A
	LD	H,A			; code pointer of line number = unknown
	JR	J.4381

J$4360:	LD	A,(IX+2)
	OR	(IX+3)			; code pointer of line number unknown ?
	JR	Z,J$4370		; yep,
	LD	L,(IX+2)
	LD	H,(IX+3)		; code pointer of line number
	JR	J.4381

J$4370:	LD	L,(IX+4)
	LD	H,(IX+5)		; code pointer of referenced line number
	PUSH	HL
	LD	HL,(BUF+2)		; current compiled code pointer
	LD	(IX+4),L
	LD	(IX+5),H		; update code pointer of referenced line number
	POP	HL
J.4381:	CALL	C.60AE			; put word in execution buffer
	POP	IX
	RET

;	  Subroutine replace line number references by code pointers
;	     Inputs  ________________________
;	     Outputs ________________________

C$4387:	LD	IX,(BUF+17)		; start list of code pointer per line number
J$438B:	LD	A,(IX+0)
	AND	(IX+1)
	INC	A			; end marker ?
	RET	Z			; yep, quit
	LD	E,(IX+2)
	LD	D,(IX+3)		; code pointer of line number
	LD	A,E
	OR	D			; code pointer unknown ?
	JP	Z,J.4E19		; yep, BASIC error: undefined linenumber
	LD	L,(IX+4)
	LD	H,(IX+5)		; code pointer of referenced line number
	LD	A,L
	OR	H			; line number referenced ?
	JR	Z,J$43B3		; nope,
J$43A8:	LD	C,(HL)
	LD	(HL),E
	INC	HL
	LD	B,(HL)
	LD	(HL),D			; replace next referenced code pointer by code pointer of linenumber
	LD	L,C
	LD	H,B			; next referenced code pointer
	LD	A,L
	OR	H			; more replacements ?
	JR	NZ,J$43A8		; yep, next
J$43B3:	LD	BC,6
	ADD	IX,BC
	JR	J$438B			; next entry

;	  Subroutine REM statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.43BA:	LD	A,(IX+0)
	CP	0E6H			; ' token ?
	JR	NZ,J$43C3
	INC	IX			; yep, skip
J$43C3:	CALL	C.6032			; get BASIC character, skip spaces
	CP	"#"			; basic compiler option ?
	JP	NZ,J.4453		; nope,
	LD	A,(IX+1)
	CALL	C.7E39			; to upper
	CP	"I"
	JR	NZ,J$441F

; I -> inline

	INC	IX
J$43D7:	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	PUSH	IX
	POP	DE
	CALL	C.7E39			; to upper
	CP	"@"			; linenumber indicator ?
	JR	Z,J$43F8		; yep,
	CP	"A"
	JR	C,J.4405
	CP	"Z"+1
	JR	NC,J.4405
	CALL	C.6503			; fetch variable name
	LD	C,0			; generate address code
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	JR	J$4412

J$43F8:	INC	DE
	CALL	C.7D18
	PUSH	DE
	CALL	C.7901			; covert float to integer
	CALL	C.431C			; fetch code pointer of line number and generate address
	JR	J$4410

J.4405:	CALL	C.7D18
	PUSH	DE
	CALL	C.7901			; covert float to integer
	LD	A,L
	CALL	C.60B9			; put byte in execution buffer
J$4410:	POP	IX
J$4412:	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$43D7
	AND	A
	JP	NZ,J.4E16		; BASIC error: syntax error
	JR	J.4453

J$441F:	CP	"C"
	JR	NZ,J$4441

; C -> clip

	LD	A,(IX+2)
	CP	"+"
	LD	HL,0A6CBH		; RES 4,(HL)
	JR	Z,J$4434
	CP	"-"
	JR	NZ,J.4453
	LD	HL,0E6CBH		; SET 4,(HL)
J$4434:	CALL	C.6058			; copy code block in execution buffer

	LD	HL,MODE
	DEFW	0

	CALL	C.60AE			; put word in execution buffer
	JR	J.4453

J$4441:	CP	"N"
	JR	NZ,J.4453

; N -> next overflow check

	LD	A,(IX+2)
	CP	"+"
	JR	Z,J$4450
	SUB	"-"
	JR	NZ,J.4453
J$4450:	LD	(BUF+14),A		; next overflow check
J.4453:	LD	HL,(BUF+15)
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEC	HL
	PUSH	HL
	POP	IX
	RET

;	  Subroutine LET statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.445F:	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX

;	  Subroutine compile LET statement
;	     Inputs  ________________________
;	     Outputs ________________________

C$4464:	DEC	IX
	CALL	C.5BF3			; fetch variable name or index variable name with index
	PUSH	AF
	CALL	C.603C			; check for BASIC token =
	POP	AF
	INC	B
	BIT	5,A			; string variable ?
	JP	NZ,J$44DF		; yep,
	BIT	6,A			; float variable ?
	JR	NZ,J$449F		; yep,
	DJNZ	J$4481

; B=0, integer

	PUSH	HL
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	HL
	JR	C.44B2			; put LD (xxxx),HL in execution buffer

J$4481:	DJNZ	J$448B

; B=1, integer

	PUSH	HL
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	HL
	JP	C.608B			; put LD (var),HL in execution buffer (AF retained)

; B>1, integer

J$448B:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

J$449F:	DJNZ	J$44B7

; B=0, float

	PUSH	HL
	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	POP	HL
J$44A6:	CALL	C.6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	LD	A,32H			; LD (xxxx),A
	CALL	C.60AB			; put 3 bytes in execution buffer
	INC	HL

;	  Subroutine put LD (xxxx),HL in execution buffer
;	     Inputs  HL = xxxx
;	     Outputs ________________________

C.44B2:	LD	A,22H			; LD (xxxx),HL
	JP	C.60AB			; put 3 bytes in execution buffer

J$44B7:	DJNZ	J$44C9

; B=1, float

	PUSH	HL
	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	POP	HL

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.44BE:	CALL	C.6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	LD	C,2			; generate store code
	JP	C.62E7			; create simple variable if needed, generate variable address code

; B>1, float

J$44C9:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	EX	DE,HL
	LD	(HL),B
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

J$44DF:	DJNZ	J$44ED

; B=0, string

	PUSH	HL
	CALL	C.4FFE			; evaluate string expression
	POP	HL
J$44E6:	LD	A,11H			; LD DE,xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	JR	J.450D

J$44ED:	DJNZ	J$44FE

; B=1, string

	PUSH	HL
	CALL	C.4FFE			; evaluate string expression
	POP	HL
J$44F4:	LD	A,11H			; LD DE,xxxx
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	JR	J.450D

; B>1, string

J$44FE:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4FFE			; evaluate string expression
	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J.450D:	CALL	C.6058			; copy code block in execution buffer

	LD	C,(HL)			; size of string
	LD	B,0
	INC	BC			; include endmarker
	LDIR
	DEFW	0

	RET

;	  Subroutine READ statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$4519:	LD	HL,I$75A1
	LD	DE,I$7560
	CALL	C.4A88
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	RET	NZ
	INC	IX
	JR	J$4519

;	  Subroutine DIM statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$452C:	LD	A,(BUF+4)
	AND	A			; bytes in the execution buffer ?
	JP	NZ,J.4E22		; yep, BASIC error: redemensioned array
	CALL	C.6503			; fetch variable name
	LD	(BUF+25),HL		; save variable name
	CALL	C.6044			; check for BASIC character "("
	LD	D,0
J$453E:	PUSH	DE
	CALL	C.4FA9			; evaluate integer operand
	POP	DE
	LD	A,B
	AND	A			; > 255 elements ?
	JP	NZ,J.4E0D		; yep, BASIC error: illegal function call
	INC	HL
	LD	A,L
	OR	H
	JP	Z,J.4E1F		; BASIC error: out of memory
	PUSH	HL
	INC	D
	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	")"
	JR	Z,J$4560
	CP	","
	JR	Z,J$453E		; yep, next dimension
	JP	J.4E16			; BASIC error: syntax error

J$4560:	PUSH	DE
	LD	HL,(BUF+25)		; variable name
	LD	DE,(BUF+0)		; start of compiled basic program
	PUSH	DE
	CALL	C$62FB			; create array variable if needed 
	POP	HL
	POP	BC
	LD	(HL),B			; register number of dimensions
J$456F:	POP	DE
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; pointer to start of dimension of array
	DJNZ	J$456F			; next dimension
	LD	HL,(BUF+0)		; start of compiled basic program
	LD	B,(HL)			; number of dimensions
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; pointer to start of dimension of array
	INC	HL
	DEC	B			; more dimensions ?
	JR	Z,J$4591		; nope,
J$4582:	LD	A,(HL)
	INC	HL
	PUSH	HL
	PUSH	BC
	LD	H,(HL)
	LD	L,A
	CALL	C.7624			; multiply
	EX	DE,HL
	POP	BC
	POP	HL
	INC	HL
	DJNZ	J$4582
J$4591:	EX	DE,HL
	LD	A,(BUF+26)
	BIT	5,A			; array of strings ?
	JR	Z,J$45A3		; nope,
	LD	A,H
	AND	A
	JP	NZ,J.4E1F		; BASIC error: out of memory
	LD	H,L
	LD	L,0
	JR	J.45B1

J$45A3:	LD	C,L
	LD	B,H
	ADD	HL,HL			; assume integer, 2 bytes per element
	JP	C,J.4E1F		; overflow, BASIC error: out of memory
	BIT	6,A			; array of floats ?
	JR	Z,J.45B1		; nope, assumption was ok
	ADD	HL,BC			; 3 bytes per element
	JP	C,J.4E1F		; overflow, BASIC error: out of memory
J.45B1:	LD	C,L
	LD	B,H
	ADD	HL,DE
	JP	C,J.4E1F		; overflow, BASIC error: out of memory
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+23)		; end of variable list
	SBC	HL,DE
	JP	NC,J.4E1F		; BASIC error: out of memory
	POP	DE
	POP	HL
	LD	(BUF+0),HL		; update start of compiled basic program
	LD	(BUF+2),HL		; update current compiled code pointer
J$45CA:	XOR	A
	LD	(DE),A
	INC	DE
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J$45CA		; clear array
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","			; more arrays ?
	RET	NZ			; nope, quit
	INC	IX
	JP	J$452C

;	  Subroutine IF statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.45DD:	CALL	C.4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	89H			; GOTO token ?
	JR	Z,J$45EC		; yep,
	LD	A,0DAH			; THEN token
	CALL	C.604A			; check for BASIC character
J$45EC:	LD	A,B
	CP	2			; generated integer ?
	JR	Z,J$45FA		; yep,
	CALL	C.6058			; copy code block in execution buffer

	LD	A,B
	AND	A			; is float 0.0 ?
	DEFW	0

	JR	J$4601

J$45FA:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	OR	H			; is integer 0 ?
	DEFW	0

J$4601:	CALL	C.6058			; copy code block in execution buffer

	JP	Z,0FFFFH		; jump over THEN code
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL			; save start of THEN code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0DH			; linepointer token ?
	JR	Z,J$4618		; yep,
	CP	0EH			; linenumber token ?
	JR	NZ,J.4623		; nope,
J$4618:	CALL	C.4696			; compile GOTO statement
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J$4626		; yep,
	JP	J.4E16			; BASIC error: syntax error

J.4623:	CALL	C.4258			; compile statement
J$4626:	AND	A			; end of line ?
	JR	Z,J.4671		; yep,
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0A1H			; ELSE token ?
	JR	NZ,J.4623		; nope, compile next statement
	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	JP	0FFFFH			; THEN code, jump over ELSE code
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	LD	E,L
	LD	D,H
	EX	(SP),HL			; save start of THEN code
	DEC	HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E			; update start of THEN code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0DH			; linepointer token ?
	JR	Z,J$4651		; yep,
	CP	0EH			; linenumber token ?
	JR	NZ,J.465C		; nope,
J$4651:	CALL	C.4696			; compile GOTO statement
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J$465F		; yep,
	JP	J.4E16			; nope, BASIC error: syntax error

J.465C:	CALL	C.4258			; compile statement
J$465F:	PUSH	IX
	POP	HL
	AND	A			; end of line ?
	JR	Z,J.4671		; yep,
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0A1H			; ELSE token ?
	JR	NZ,J.465C		; nope,
	PUSH	HL
	POP	IX
J.4671:	POP	HL
	DEC	HL
	DEC	HL
	LD	DE,(BUF+2)		; current compiled code pointer
	LD	(HL),E
	INC	HL
	LD	(HL),D			; update start of THEN or ELSE code
	RET

;	  Subroutine RUN statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.467C:	CALL	C.4F00			; end of line or statement ?
	JR	NZ,C.4696		; nope, compile GOTO statement
	LD	A,0C3H			; JP xxxx
	LD	HL,(BUF+0)		; start of compiled basic program
	JP	C.60AB			; put 3 bytes in execution buffer

;	  Subroutine RETURN statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4689:	CALL	C.4F00			; end of line or statement ?
	LD	A,0C9H			; RET
	JP	Z,C.60B9		; yep, put byte in execution buffer and quit
	LD	A,0F1H			; POP AF (removes return address)
	CALL	C.60B9			; put byte in execution buffer

;	  Subroutine GOTO statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4696:	LD	A,0C3H
	DEFB	001H

;	  Subroutine GOSUB statement
;	     Inputs  ________________________
;	     Outputs ________________________

C$4699:	LD	A,0CDH

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$469B:	CALL	C.60B9			; put byte in execution buffer
	CALL	C.6032			; get BASIC character, skip spaces
	LD	L,(IX+1)
	LD	H,(IX+2)
	INC	IX
	INC	IX
	INC	IX
	CP	0EH			; linenumber token ?
	JR	Z,J$46BD		; yep,
	CP	0DH			; linepointer token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	INC	HL
	INC	HL
	INC	HL			; skip next line pointer
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A			; linenumber
J$46BD:	JP	C.431C			; fetch code pointer of line number and generate address

;	  Subroutine ON statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.46C0:	CALL	C.6032			; get BASIC character, skip spaces
	PUSH	IX
	POP	HL
	LD	IX,M7810
	CALL	CALBAS			; check if trap identifier
	EI
	PUSH	HL
	POP	IX
	JP	NC,J$4744		; yep, handle ON <trap> GOSUB
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	AND	A
	JP	Z,0FFFFH
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	CALL	C.6032			; get BASIC character, skip spaces
	CP	89H			; GOTO token ?
	JR	NZ,J$4701		; nope,
J$46EB:	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	DEC	A
	DEFW	0

	LD	A,0CAH			; JP Z,xxxx
	CALL	C$469B
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$46EB
	JR	J.4733

J$4701:	SUB	8DH			; GOSUB token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	L,A
	LD	H,A			; end marker
	PUSH	HL

J$4709:	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	DEC	A
	JR	NZ,J$4711+6
J$4711:	DEFW	0

	CALL	C$4699			; compile GOSUB statement
	CALL	C.6058			; copy code block in execution buffer

	JP	0FFFFH
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","			; more gosub routines ?
	JR	Z,J$4709		; yep,
J$4729:	POP	HL
	LD	A,L
	OR	H			; end marker ?
	JR	Z,J.4733		; yep,
	CALL	C.4734			; replace address with current compiled code pointer
	JR	J$4729

J.4733:	POP	HL

;	  Subroutine replace address with current compiled code pointer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4734:	LD	BC,(BUF+2)		; current compiled code pointer
	DEC	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.473D:	LD	A,(BUF+2)		; current compiled code pointer
	SUB	C
	DEC	BC
	LD	(BC),A
	RET

;	  Subroutine ON <trap> GOSUB
;	     Inputs  ________________________
;	     Outputs ________________________

J$4744:	INC	IX
	LD	A,8DH			; GOSUB token
	LD	(BUF+6),A		; traps defined
	CALL	C.604A			; check for BASIC character
J$474E:	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$478E
	LD	A,21H			; LD HL,xxxx
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.6032			; get BASIC character, skip spaces
	LD	L,(IX+1)
	LD	H,(IX+2)
	INC	IX
	INC	IX
	INC	IX
	CP	0EH			; linenumber token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	A,L
	OR	H
	JR	Z,J$4779
	PUSH	BC
	CALL	C.431C			; fetch code pointer of line number and generate address
	POP	BC
	JR	J$477C

J$4779:	CALL	C.60AE			; put word in execution buffer
J$477C:	LD	HL,TRPTBL+1
	LD	E,B
	LD	D,0			; trap number
	ADD	HL,DE
	ADD	HL,DE
	ADD	HL,DE			; *3
	CALL	C.44B2			; put LD (xxxx),HL in execution buffer
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	RET	NZ
J$478E:	INC	IX
	INC	B
	DEC	C
	JR	NZ,J$474E
	JP	J.4E16			; BASIC error: syntax error

;	  Subroutine DEFINT
;	     Inputs  ________________________
;	     Outputs ________________________

C.4797:	LD	E,2			; integer type
	DEFB	001H

;	  Subroutine DEFSTR
;	     Inputs  ________________________
;	     Outputs ________________________

C.479A:	LD	E,3			; string type
	DEFB	001H

;	  Subroutine DEFSGN
;	     Inputs  ________________________
;	     Outputs ________________________

C.479D:	LD	E,4			; single type
	DEFB	001H

;	  Subroutine DEFDBL
;	     Inputs  ________________________
;	     Outputs ________________________

C.47A0:	LD	E,8			; double type
J$47A2:	CALL	C.47D1
	LD	C,A
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F2H			; - token ?
	JR	NZ,J$47B6		; nope,
	INC	IX
	CALL	C.47D1
	INC	IX
J$47B6:	LD	A,B
	SUB	C
	JP	C,J.4E16		; BASIC error: syntax error
	INC	A
	LD	HL,DEFTBL
	LD	B,0
	ADD	HL,BC
J$47C2:	LD	(HL),E
	INC	HL
	DEC	A
	JR	NZ,J$47C2
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	RET	NZ
	INC	IX
	JR	J$47A2

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.47D1:	CALL	C.6032			; get BASIC character, skip spaces
	SUB	"A"
	LD	B,A
	JR	C,J$47DC
	CP	1AH
	RET	C
J$47DC:	JP	J.4E16			; BASIC error: syntax error

;	  Subroutine SWAP statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.47DF:	CALL	C.5BDE
	PUSH	AF
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.6040			; check for BASIC character ","
	CALL	C.5BDE
	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

	POP	BC
	CP	B			; variables of the same type ?
	JP	NZ,J.4E10		; nope, BASIC error: type mismatch
	LD	HL,I$6BFB		; swap string
	BIT	5,A			; string variable ?
	JR	NZ,J.480B		; yep,
	LD	HL,I$6BFF		; swap float
	BIT	6,A			; float variable ?
	JR	NZ,J.480B		; yep,
	LD	HL,I$6BF7		; swap integer
J.480B:	JP	C.4DA0			; generate CALL xxxx (xxxx in HL)

;	  Subroutine FOR statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.480E:	CALL	C.6503			; fetch variable name
	CALL	C.603C			; check for BASIC token =
	PUSH	HL
	BIT	6,H			; float variable ?
	JP	NZ,J$487F		; yep,

; FOR with integer loop variable

	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	HL
	PUSH	HL
	CALL	C.608B			; put LD (var),HL in execution buffer (AF retained)
	LD	A,0D9H			; TO token
	CALL	C.604A			; check for BASIC character
	CALL	C.4FE9			; evaluate numeric expression, convert to integer, generate code
	EX	DE,HL
	POP	HL
	INC	B
	DJNZ	J$483B

; B=0 (FOR end value is constant)

	PUSH	DE
	LD	D,B
	LD	E,B			; constant end value, assume step value is constant (DE=0)
	CALL	C.6301			; create FOR variable (end value and step value flags) if needed, generate variable address code
	POP	DE
	CALL	C$6305			; create FOR variable (constant end value) if needed, generate variable address code
	JR	J$4849

; B>0 (FOR end value is variable)

J$483B:	LD	DE,2*256+0		; variable end value, assume step value is constant (DE=512)
	CALL	C.6301			; create FOR variable (end value and step value flags) if needed, generate variable address code
	LD	A,22H			; LD (xxxx),HL
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.62EB			; create FOR variable (variable end value) if needed, generate variable address code

J$4849:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0DCH			; STEP token ?
	JR	Z,J$4858		; yep,
	LD	DE,1			; use step value 1
	CALL	C.630B			; create FOR variable (constant step value) if needed, generate variable address code
	JR	J.4878

J$4858:	INC	IX
	PUSH	HL
	CALL	C.4FE9			; evaluate numeric expression, convert to integer, generate code
	EX	DE,HL
	POP	HL
	INC	B
	DJNZ	J$4868

; B=0 (STEP value is constant)

	CALL	C.630B			; create FOR variable (constant step value) if needed, generate variable address code
	JR	J.4878			; create FOR variable (code pointer start FOR) and quit

; B>0 (STEP value is variable)

J$4868:	CALL	C.643F			; fetch address FOR variable (end value and step value flags)
	LD	E,2			; change step value variable
	CALL	C.6301			; create FOR variable (end value and step value flags) if needed, generate variable address code
	LD	A,22H			; LD (xxxx),HL
	CALL	C.60B9			; put byte in execution buffer
J$4875:	CALL	C.62F1			; create FOR variable (variable step value) if needed, generate variable address code

J.4878:	LD	DE,(BUF+2)		; current compiled code pointer
	JP	J$6313			; create FOR variable (code pointer start FOR) if needed, generate variable address code

; FOR with float loop variable

J$487F:	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	POP	HL
	PUSH	HL
	CALL	C.44BE
	LD	A,0D9H			; TO token
	CALL	C.604A			; check for BASIC character
	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C.6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	POP	HL
	PUSH	HL
	LD	C,2			; generate store code
	CALL	C.62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0DCH			; STEP token ?
	JR	NZ,J$48B0		; nope,
	INC	IX
	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C.6058			; copy code block in execution buffer

	LD	A,B
	DEFW	0

	JR	J$48BA

J$48B0:	CALL	C.6058			; copy code block in execution buffer

	LD	A,81H
	LD	HL,0
	DEFW	0

J$48BA:	POP	HL
	LD	C,2			; generate store code
	JR	J$4875

;	  Subroutine NEXT statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$48BF:	CALL	C.6503			; fetch variable name
	BIT	6,H			; float variable ?
	JP	NZ,J$49DB		; yep,

; NEXT with integer loop variable

	CALL	C.6086			; put LD HL,(var) in execution buffer
	CALL	C.643F			; fetch address FOR variable (end value and step value flags)
	LD	A,E
	AND	A			; step value variable ?
	JR	NZ,J$491E		; yep, use different code

; NEXT with integer loop variable, step value is constant

	CALL	C$6449			; fetch address FOR variable (constant step value)
	LD	A,(BUF+14)
	AND	A			; next overflow check enabled ?
	JR	NZ,J.48FD		; yep, can not use INC/DEC approach
	OR	D			; step > 255 or negative ?
	JR	NZ,J$48E2		; yep, can not use INC approach
	LD	A,E			; low byte step
	LD	C,23H			; INC HL
	JR	J$48EA

J$48E2:	INC	A			; step > -255
	JR	NZ,J.48FD		; yep, can not use DEC approach
	LD	A,E
	NEG				; change sign step
	LD	C,2BH			; DEC HL
J$48EA:	CP	5			; step value less then 5 ?
	JR	NC,J.48FD		; nope, use ADD approach
	AND	A			; step value is zero ?
	JR	Z,J$48F8		; yep, skip INC/DEC generation
	LD	B,A			; step value
	LD	A,C			; step opcode
J$48F3:	CALL	C.60B9			; put byte in execution buffer
	DJNZ	J$48F3
J$48F8:	LD	BC,0			; do not adjust HL=HL+DE code
	JR	J$4905

J.48FD:	EX	DE,HL			; step value in HL
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	EX	DE,HL
	CALL	C.4951			; generate HL=HL+DE code

J$4905:	PUSH	BC
	CALL	C.608B			; put LD (var),HL in execution buffer (AF retained)
	BIT	7,D			; generate for positive or negative step value
	CALL	C.4971

J$490E:	POP	HL
	LD	A,L
	OR	H			; adjust HL=HL+DE code ?
	CALL	NZ,C.4734		; yep, replace address with current compiled code pointer
J$4914:	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	RET	NZ
	INC	IX
	JR	J$48BF

; NEXT with integer loop variable, step value is variable

J$491E:	PUSH	HL
	LD	HL,5BEDH		; LD DE,(xxxx)
	CALL	C.60AE			; put word in execution buffer
	POP	HL
	CALL	C.62F1			; create FOR variable (variable step value) if needed, generate variable address code
	CALL	C.4951			; generate HL=HL+DE code
	PUSH	BC
	CALL	C.608B			; put LD (var),HL in execution buffer (AF retained)
	CALL	C.6058			; copy code block in execution buffer

	BIT	7,D
J$4935:	JR	NZ,J$4935
	DEFW	0

	XOR	A			; generate for postive step value
	CALL	C.4971
	CALL	C.6058			; copy code block in execution buffer

J$4940:	JR	J$4940
	DEFW	0

	CALL	C.473D
	OR	01H			; generate for negative step value
	CALL	C.4971
	CALL	C.473D
	JR	J$490E

;	  Subroutine generate HL=HL+DE code
;	     Inputs  ________________________
;	     Outputs BC = address

C.4951:	LD	A,(BUF+14)
	AND	A			; next overflow check enabled ?
	JR	NZ,J$4961		; yep,
	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,DE
	DEFW	0

	LD	BC,0
	RET

J$4961:	CALL	C.6058			; copy code block in execution buffer

	AND	A
	ADC	HL,DE
J$4967:	JP	PE,J$4967
	DEFW	0

	LD	BC,(BUF+2)		; current compiled code pointer
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.4971:	LD	BC,(BUF+2)		; current compiled code pointer
	PUSH	BC
	CALL	C.6058			; copy code block in execution buffer

	LD	A,H
	XOR	80H
	LD	H,A
	DEFW	0

	PUSH	AF
	LD	A,0EBH			; EX DE,HL
	CALL	Z,C.60B9		; put byte in execution buffer
	CALL	C.643F			; fetch address FOR variable (end value and step value flags)
	LD	A,D
	AND	A			; end value is a constant ?
	JR	NZ,J$499E		; nope, generate code for variable end value

; end value is a constant

	CALL	C$6443			; fetch address FOR variable (constant end value)
	EX	DE,HL
	LD	A,H
	XOR	80H
	LD	H,A
	POP	AF
	CALL	Z,C.607E		; nope, put LD HL,xxxx in execution buffer
	CALL	NZ,C.6079		; yep, put LD DE,xxxx in execution buffer
	EX	DE,HL
	JR	J.49C8

; end value is variable

J$499E:	POP	AF
	JR	NZ,J$49B4
	LD	A,2AH			; LD HL,(xxxx)
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	LD	A,H
	XOR	80H
	LD	H,A
	DEFW	0

	JR	J.49C8

J$49B4:	PUSH	HL
	LD	HL,5BEDH		; LD DE,(xxxx)
	CALL	C.60AE			; put word in execution buffer
	POP	HL
	CALL	C.62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	LD	A,D
	XOR	80H
	LD	D,A
	DEFW	0

J.49C8:	CALL	C.6058			; copy code block in execution buffer

	SBC	HL,DE
	DEFW	0

	CALL	C.6451			; fetch address FOR variable (code pointer start FOR)
	EX	DE,HL
	LD	A,0D2H			; JP NC,xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	EX	DE,HL
	POP	BC
	RET

; NEXT with float loop variable

J$49DB:	LD	C,0AH			; generate fetch code
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	LD	C,A
	EX	DE,HL
	DEFW	0

	LD	C,0AH			; generate fetch code
	CALL	C.62F1			; create FOR variable (variable step value) if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	LD	B,A
	CALL	C.76D7			; add floats
	DEFW	0

	CALL	C.44BE
	CALL	C.6058			; copy code block in execution buffer

	LD	C,B
	EX	DE,HL
	DEFW	0

	LD	C,0AH			; generate fetch code
	CALL	C.62EB			; create FOR variable (variable end value) if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	CALL	C.7966
	POP	HL
	DEFW	0

	CALL	C.6451			; fetch address FOR variable (code pointer start FOR)
	EX	DE,HL
	LD	A,0CAH			; JP Z,xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	BIT	7,H
	JR	Z,J$4A20
	CCF
J$4A20:	DEFW	0

	LD	A,0D2H			; JP NC,xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	JP	J$4914

;	  Subroutine RESTORE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4A2A:	LD	HL,(TXTTAB)
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J$4A5E
	CP	0EH			; linenumber token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	C,(IX+1)
	LD	B,(IX+2)
	INC	IX
	INC	IX
	INC	IX
	LD	HL,(TXTTAB)
J$4A46:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	A,E
	OR	D
	JP	Z,J.4E19		; BASIC error: undefined linenumber
	INC	HL
	LD	A,(HL)
	CP	C
	JR	NZ,J$4A58
	INC	HL
	LD	A,(HL)
	CP	B
	JR	Z,J$4A5B
J$4A58:	EX	DE,HL
	JR	J$4A46

J$4A5B:	DEC	HL
	DEC	HL
	DEC	HL
J$4A5E:	DEC	HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	(DATPTR),HL
	DEFW	0

	RET

;	  Subroutine INPUT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4A6B:	CALL	C.6032			; get BASIC character, skip spaces
	CP	'"'			; input text parameter ?
	LD	HL,J.751A
	LD	DE,I$7546
	JR	NZ,C.4A88		; nope, plain input
	INC	IX
	CALL	C$583B			; generate code for constant string
	LD	A,";"
	CALL	C.604A			; check for BASIC character
	LD	HL,I$7517
	LD	DE,I$7543

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.4A88:	PUSH	HL
	PUSH	DE
	PUSH	IX
	CALL	C.6503			; fetch variable name
	POP	IX
	BIT	5,H			; string variable ?
	JR	Z,J$4ABE		; nope,
	POP	HL
	POP	AF
	CALL	C.4DA0			; generate CALL xxxx (xxxx in HL)
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.5BF3			; fetch variable name or index variable name with index
	INC	B
	DJNZ	J$4AAC

; B=0

	CALL	C.60D7			; remove byte from execution buffer
	JP	J$44E6

J$4AAC:	DJNZ	J$4AB4

; B=1

	CALL	C.60D7			; remove byte from execution buffer
	JP	J$44F4

; B>1

J$4AB4:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

	JP	J.450D

J$4ABE:	POP	AF
	EX	(SP),HL
	CALL	C.4DA0			; generate CALL xxxx (xxxx in HL)
	POP	HL
	BIT	6,H			; float variable ?
	JR	NZ,J$4AEF		; yep,
	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	PUSH	HL
	DEFW	0

	CALL	C.5BF3			; fetch variable name or index variable name with index
	INC	B
	DJNZ	J$4ADD

; B=0

	CALL	C.60D7			; remove byte from execution buffer
	JP	C.44B2			; put LD (xxxx),HL in execution buffer

J$4ADD:	DJNZ	J$4AE5

; B=1

	CALL	C.60D7			; remove byte from execution buffer
	JP	C.608B			; put LD (var),HL in execution buffer (AF retained)

J$4AE5:	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

J$4AEF:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	BC
	DEFW	0

	CALL	C.5BF3			; fetch variable name or index variable name with index
	INC	B
	DJNZ	J$4B05

; B=0

	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	JP	J$44A6

J$4B05:	DJNZ	J$4B10

; B=1

	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	JP	C.44BE

J$4B10:	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	POP	DE
	LD	(HL),B
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEFW	0

	RET

;	  Subroutine LPRINT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4B1D:	CALL	C.6058			; copy code block in execution buffer

	LD	A,1
	LD	(PRTFLG),A
	DEFW	0

	CALL	C$4B34
	CALL	C.6058			; copy code block in execution buffer

	XOR	A
	LD	(PRTFLG),A
	DEFW	0

	RET

;	  Subroutine PRINT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C$4B34:	CALL	C.4F00			; end of line or statement ?
	JR	Z,J.4B5B		; yep, print new line and quit
J$4B39:	CALL	C$4B64			; print expression
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J.4B5B		; yep, print new line and quit
	CP	","			; more arguments with tab seperation ?
	JR	NZ,J$4B4F		; nope,
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$74F3			; print tab
	DEFW	0

	JR	J$4B53

J$4B4F:	CP	";"			; more arguments with no seperation ?
	JR	NZ,J$4B55		; nope,
J$4B53:	INC	IX
J$4B55:	CALL	C.4F00			; end of line or statement ?
	JR	NZ,J$4B39		; nope, next
	RET

J.4B5B:	CALL	C.6058			; copy code block in execution buffer

	CALL	C$74F7			; print new line
	DEFW	0

	RET

;	  Subroutine print expression
;	     Inputs  ________________________
;	     Outputs ________________________

C$4B64:	CALL	C.5012			; evaluate expression
	INC	B
	DJNZ	J$4B6F

; B=0 (expression is a integer constant)

	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J.4B78

J$4B6F:	DJNZ	J$4B76

; B=1 (expression is a variable)

	CALL	C.6086			; put LD HL,(var) in execution buffer
	JR	J.4B78

J$4B76:	DJNZ	J$4B81

; B=2 (expression is a generated integer result)

J.4B78:	CALL	C.6058			; copy code block in execution buffer

	CALL	C$7508			; print integer
	DEFW	0

	RET

J$4B81:	DJNZ	J$4B8C

; B=3 (expression is a generated float result)

	CALL	C.6058			; copy code block in execution buffer

	CALL	C$750D			; print float
	DEFW	0

	RET


; B=4 (expression is a generated string result)

J$4B8C:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.74FE			; print string
	DEFW	0

	RET

;	  Subroutine BEEP
;	     Inputs  ________________________
;	     Outputs ________________________

C.4B95:	CALL	C.6058			; copy code block in execution buffer

	CALL	BEEP
	DEFW	0

	RET

;	  Subroutine POKE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4B9E:	CALL	C.4FA9			; evaluate integer operand
	CALL	C.6040			; check for BASIC character ","
	DEC	IX
	LD	DE,C.4FA9		; operand2 handler = evaluate integer operand
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type
	
	DEFW	C.4BCD			; integer constant, integer constant
	DEFW	C.4BD2			; integer constant, variable
	DEFW	C.4BD7			; integer constant, generated integer
	DEFW	C.4BE3			; variable, integer constant
	DEFW	C.4BEA			; variable, variable
	DEFW	C.4BF1			; variable, generated integer
	DEFW	C.4C02			; generated integer, integer constant
	DEFW	C.4C08			; generated integer, variable
	DEFW	C.4C12			; generated integer, generated integer
	DEFW	0			; integer constant, generated float
	DEFW	0			; variable, generated float
	DEFW	0			; generated integer, generated float
	DEFW	0			; generated float, integer constant
	DEFW	0			; generated float, variable
	DEFW	0			; generated float, generated integer
	DEFW	0			; generated float, generated float

	RET

;	  Subroutine poke, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4BCD:	CALL	C.4F5A			; generate LD A,constant code
	JR	J.4BDD

;	  Subroutine poke, integer constant, integer variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.4BD2:	CALL	C.4F75			; generate LD A,(variable) code
	JR	J.4BDD

;	  Subroutine poke, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4BD7:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

J.4BDD:	EX	DE,HL
	LD	A,32H			; LD (xxxx),A
	JP	C.60AB			; put 3 bytes in execution buffer

;	  Subroutine poke, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4BE3:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.4C02

;	  Subroutine poke, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.4BEA:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.4C08

;	  Subroutine poke, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4BF1:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	(HL),A
	DEFW	0

	RET

;	  Subroutine poke, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C02:	LD	H,L
	LD	L,36H			; LD (HL),xx
	JP	C.60AE			; put word in execution buffer

;	  Subroutine poke, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C08:	CALL	C.4F75			; generate LD A,(variable) code
	CALL	C.6058			; copy code block in execution buffer

	LD	(HL),A
	DEFW	0

	RET

;	  Subroutine poke, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C12:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	POP	HL
	LD	(HL),A
	DEFW	0

	RET

;	  Subroutine OUT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C1B:	CALL	C.4FA9			; evaluate integer operand
	CALL	C.6040			; check for BASIC character ","
	DEC	IX
	LD	DE,C.4FA9		; operand2 handler = evaluate integer operand
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.4C4A			; integer constant, integer constant
	DEFW	C.4C4F			; integer constant, variable
	DEFW	C.4C54			; integer constant, generated integer
	DEFW	C.4C60			; variable, integer constant
	DEFW	C.4C65			; variable, variable
	DEFW	C.4C7A			; variable, generated integer
	DEFW	C.4C8C			; generated integer, integer constant
	DEFW	C.4C91			; generated integer, variable
	DEFW	C.4C9D			; generated integer, generated integer
	DEFW	0			; integer constant, generated float
	DEFW	0			; variable, generated float
	DEFW	0			; generated integer, generated float
	DEFW	0			; generated float, integer constant
	DEFW	0			; generated float, variable
	DEFW	0			; generated float, generated integer
	DEFW	0			; generated float, generated float

	RET

;	  Subroutine out, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C4A:	CALL	C.4F5A			; generate LD A,constant code
	JR	J.4C5A

;	  Subroutine out, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C4F:	CALL	C.4F75			; generate LD A,(variable) code
	JR	J.4C5A

;	  Subroutine out, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C54:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

J.4C5A:	LD	H,E
	LD	L,0D3H			; OUT (xx),A
	JP	C.60AE			; put word in execution buffer

;	  Subroutine out, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C60:	CALL	C.4F5A			; generate LD A,constant code
	JR	J$4C68

;	  Subroutine out, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C65:	CALL	C.4F75			; generate LD A,(variable) code
J$4C68:	LD	HL,4BEDH		; LD BC,(xxxx)
	CALL	C.60AE			; put word in execution buffer
	EX	DE,HL
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	OUT	(C),A
	DEFW	0

	RET

;	  Subroutine out, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C7A:	LD	HL,4BEDH		; LD BC,(xxxx)
	CALL	C.60AE			; put word in execution buffer
	EX	DE,HL
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	OUT	(C),L
	DEFW	0

	RET

;	  Subroutine out, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C8C:	CALL	C.4F5A			; generate LD A,constant code
	JR	J$4C94

;	  Subroutine out, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C91:	CALL	C.4F75			; generate LD A,(variable) code
J$4C94:	CALL	C.6058			; copy code block in execution buffer

	LD	C,L
	OUT	(C),A
	DEFW	0

	RET

;	  Subroutine out, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4C9D:	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	OUT	(C),L
	DEFW	0

	RET

;	  Subroutine WAIT statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4CA6:	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.6040			; check for BASIC character ","
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$4CC9
	CALL	C.6058			; copy code block in execution buffer

	LD	D,A
	POP	BC
J$4CC1:	IN	A,(C)
	AND	D
	JR	Z,J$4CC1
	DEFW	0

	RET

J$4CC9:	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	H,A
	POP	DE
	POP	BC
J$4CDA:	IN	A,(C)
	XOR	H
	AND	D
	JR	Z,J$4CDA
	DEFW	0

	RET

;	  Subroutine DEF statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4CE3:	LD	A,0DDH			; USR token
	CALL	C.604A			; check for BASIC character
	CALL	C.6032			; get BASIC character, skip spaces
	LD	C,0
	SUB	11H
	JR	C,J.4CF8
	CP	0AH
	JR	NC,J.4CF8
	LD	C,A
	INC	IX
J.4CF8:	CALL	C.603C			; check for BASIC token =
	PUSH	BC
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	BC
	LD	B,0
	LD	HL,USRTAB
	ADD	HL,BC
	ADD	HL,BC
	JP	C.44B2			; put LD (xxxx),HL in execution buffer

;	  Subroutine END statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4D0A:	CALL	C.6058			; copy code block in execution buffer

	JP	J.4DFA
	DEFW	0

	RET

;	  Subroutine STOP statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4D13:	CALL	C.4F00			; end of line or statement ?
	JR	Z,C.4D0A		; yep, compile END statement
	LD	HL,TRPTBL+10*3
	JR	J.4D6A

;	  Subroutine INTERVAL statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$4D1D:	LD	HL,TRPTBL+17*3
	JR	J.4D6A

;	  Subroutine SPRITE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4D22:	CALL	C.6032			; get BASIC character, skip spaces
	CP	"$"
	JP	Z,J$68FC
	LD	HL,TRPTBL+11*3
	JR	J.4D6A

;	  Subroutine STRIG statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$4D2F:	LD	DE,TRPTBL+12*3
	JR	J$4D58

;	  Subroutine KEY statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4D34:	CALL	C.6032			; get BASIC character, skip spaces
	CP	95H			; ON token ?
	JR	NZ,J$4D46		; nope,
	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	CALL	DSPFNK
	DEFW	0

	RET

J$4D46:	CP	0EBH			; OFF token ?
	JR	NZ,J$4D55		; nope,
	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	CALL	ERAFNK
	DEFW	0

	RET

J$4D55:	LD	DE,TRPTBL-3
J$4D58:	PUSH	DE
	CALL	C.6044			; check for BASIC character "("
	CALL	C.4FA9			; evaluate integer operand
	CALL	C.6048			; check for BASIC character ")"
	POP	DE
	INC	B
	DJNZ	J$4D6F

; B=0

	EX	DE,HL
	ADD	HL,DE
	ADD	HL,DE
	ADD	HL,DE			; FKEY*3
J.4D6A:	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J$4D85

J$4D6F:	DEC	B			; B=1 ?
	CALL	Z,C.6086		; yep, put LD HL,(var) in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,DE
	ADD	HL,DE
	ADD	HL,DE			; FKEY*3
	DEFW	0

J$4D85:	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	95H			; ON token ?
	LD	HL,I$6C8B		; enable trap handler
	JR	Z,C.4DA0
	CP	0EBH			; OFF token ?
	LD	HL,I$6C9E		; disable trap handler
	JR	Z,C.4DA0
	CP	90H			; STOP token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	HL,C.6CA7		; pause trap handler

;	  Subroutine generate CALL xxxx (xxxx in HL)
;	     Inputs  ________________________
;	     Outputs ________________________

C.4DA0:	LD	A,0CDH			; CALL xxxx
	JP	C.60AB			; put 3 bytes in execution buffer

;	  Subroutine SOUND statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4DA5:	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	E,A
	POP	AF
	CP	7
	JR	NZ,J$4DC1
	RES	6,E
	SET	7,E
J$4DC1:	CALL	WRTPSG
	DEFW	0

	RET

;	  Subroutine LOCATE statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4DC7:	CALL	C.6032			; get BASIC character, skip spaces
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.6040			; check for BASIC character ","
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	POP	HL
	LD	L,A
	INC	L
	INC	H
	CALL	POSIT
	DEFW	0

	RET

;	  Subroutine TIME statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.4DE6:	CALL	C.603C			; check for BASIC token =
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	LD	HL,JIFFY
	JP	C.44B2			; put LD (xxxx),HL in execution buffer

;	  Subroutine DATA statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$4DF2:	CALL	C.4F00			; end of line or statement ?
	RET	Z			; end of line, quit
	INC	IX
	JR	J$4DF2

J.4DFA:	LD	HL,MODE
	RES	4,(HL)			; 212 lines mode
	LD	SP,(SAVSTK)
	LD	HL,(SAVTXT)
	RET

J$4E07:	LD	E,4
	DEFB	001H
J$4E0A:	LD	E,12
	DEFB	001H
J.4E0D:	LD	E,5
	DEFB	001H
J.4E10:	LD	E,13
	DEFB	001H
J$4E13:	LD	E,16
	DEFB	001H
J.4E16:	LD	E,2
	DEFB	001H
J.4E19:	LD	E,8
	DEFB	001H
J.4E1C:	LD	E,1
	DEFB	001H
J.4E1F:	LD	E,7
	DEFB	001H
J.4E22:	LD	E,10
	DEFB	001H
J.4E25:	LD	E,9
	DEFB	001H
I$4E28:	LD	E,3
	LD	HL,MODE
	RES	4,(HL)			; 212 lines mode
	LD	IX,M406F
	JP	CALBAS			; BASIC error

;	  Subroutine CALL statement
;	     Inputs  ________________________
;	     Outputs ________________________

C$4E36:	LD	A,(BUF+5)
	AND	A			; in turbo block ?
	JP	Z,J.4E16		; nope, BASIC error: syntax error
	CALL	C.6032			; get BASIC character, skip spaces
	LD	DE,PROCNM
	LD	B,15
J$4E45:	LD	A,(IX+0)
	CALL	C$4F03			; end of line or statement ?
	JR	Z,J.4E57		; yep,
	CP	"("			; start of parameters ?
	JR	Z,J.4E57		; yep,
	LD	(DE),A
	INC	IX
	INC	DE
	DJNZ	J$4E45
J.4E57:	LD	A,B
	CP	15			; CALL name zero length ?
	JP	Z,J.4E16		; yep, BASIC error: syntax error
J$4E5D:	XOR	A
	LD	(DE),A
	DEC	DE
	LD	A,(DE)
	CP	" "
	JR	Z,J$4E5D		; strip off trailing spaces
	LD	DE,I.4047
	LD	HL,PROCNM
	CALL	C.4065			; check if recognized CALL statement
	JP	C,J.4E16		; BASIC error: syntax error
	LD	HL,C.4EFF
	SBC	HL,DE			; TURBO OFF ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	CALL	C.6032			; get BASIC character, skip spaces
	AND	A			; end of line ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	IX,I$4E85
	RET

I$4E85:	DEFB	0			; end of line
	DEFW	0			; end of program

;	  Subroutine CALL TURBO ON
;	     Inputs  ________________________
;	     Outputs ________________________

C.4E88:	LD	DE,(CURLIN)
	LD	A,E
	AND	D			; in direct mode ?
	INC	A
	JP	Z,J$4E0A		; yep, BASIC error: illegal direct
	LD	A,1			; turbo block
	JP	J$4160			; start turbo block

;	  Subroutine parse CALL TURBO ON parameters
;	     Inputs  ________________________
;	     Outputs ________________________

C.4E97:	CALL	C.6503			; fetch variable name
	LD	A,H
	AND	60H			; integer variable ?
	JP	NZ,J.4E0D		; nope, BASIC error: illegal function call
	PUSH	HL
	LD	HL,SWPTMP+1
	LD	A,(HL)
	AND	A
	JR	Z,J$4EA9
	INC	HL
J$4EA9:	LD	(HL),"%"		; add % to variable name (force integer type)
	CALL	C.6032			; get BASIC character, skip spaces
	CP	"("			; array indicator ?
	JR	Z,J$4EDB		; yep,
	LD	HL,SWPTMP
	PUSH	IX
	LD	IX,M5F5D
	CALL	CALBAS			; locate variable (search only)
	EI
	POP	IX
	LD	A,E
	OR	D			; variable found ?
	JP	Z,J.4E0D		; nope, BASIC error: illegal function call
	POP	HL
	CALL	C$63E1			; register simple variable reference
J$4ECA:	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	","
	JR	Z,C.4E97		; next variable
	CP	")"
	JP	NZ,J.4E16		; BASIC error: syntax error
	JP	J.42CC			; check for end of statement and quit

J$4EDB:	INC	IX
	CALL	C.6048			; check for BASIC character ")"
	LD	HL,SWPTMP
	LD	A,1
	LD	(SUBFLG),A		; variable search flag = array variable
	PUSH	IX
	LD	IX,M5EA4
	CALL	CALBAS			; locate variable
	EI
	POP	IX
	LD	(SUBFLG),A		; clear search flag
	LD	E,C
	LD	D,B
	POP	HL
	CALL	C$63E5			; register array variable reference
	JR	J$4ECA

;	  Subroutine CALL TURBO OFF
;	     Inputs  ________________________
;	     Outputs ________________________

C.4EFF:	RET

;	  Subroutine end of line or statement ?
;	     Inputs  ________________________
;	     Outputs ________________________

C.4F00:	CALL	C.6032			; get BASIC character, skip spaces

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$4F03:	AND	A
	RET	Z
	CP	":"
	RET

I$4F08:	DEFW	J.4E16			; unkown token, BASIC error: syntax error
	DEFW	C.6149			; LEFT$
	DEFW	C.614E			; RIGHT$
	DEFW	C.6173			; MID$
	DEFW	C.5B51			; SGN
	DEFW	C.5B04			; INT
	DEFW	C.5B2A			; ABS
	DEFW	C.5AF6			; SQR
	DEFW	C.5AD3			; RND
	DEFW	C.5AE2			; SIN
	DEFW	C.5ADD			; LOG
	DEFW	C.5AD8			; EXP
	DEFW	C.5AE7			; COS
	DEFW	C.5AEC			; TAN
	DEFW	C.5AF1			; ATN
	DEFW	J.4E16			; FRE, BASIC error: syntax error
	DEFW	C.5B9B			; INP
	DEFW	C.5C8B			; POS
	DEFW	C.6273			; LEN
	DEFW	C.625A			; STR$
	DEFW	C.6296			; VAL
	DEFW	C.6284			; ASC
	DEFW	C.621B			; CHR$
	DEFW	C.5B85			; PEEK
	DEFW	C.6A73			; VPEEK
	DEFW	C.6216			; SPACE$
	DEFW	C.6208			; OCT$
	DEFW	C.6203			; HEX$
	DEFW	C.5C90			; LPOS
	DEFW	C.620D			; BIN$
	DEFW	J.4E16			; CINT, BASIC error: syntax error
	DEFW	J.4E16			; CSNG, BASIC error: syntax error
	DEFW	J.4E16			; CDBL, BASIC error: syntax error
	DEFW	C.5B17			; FIX
	DEFW	C.5CA3			; STICK
	DEFW	C.5CB4			; TRIG
	DEFW	C.5D14			; PDL
	DEFW	C.5CC7			; PAD

;	  Subroutine evaluate byte operand and generate LD A, byte operand code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4F54:	CALL	C.5008			; evaluate numeric expression

;	  Subroutine generate LD A,byte operand code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4F57:	INC	B
	DJNZ	C.4F73			; generate LD A,non constant

;	  Subroutine generate LD A,constant code
;	     Inputs  L = value
;	     Outputs ________________________

C.4F5A:	LD	A,L
	AND	A			; low byte zero ?
	JR	NZ,J$4F67		; nope, use LD

; generate LD A,0

	CALL	C.6058			; copy code block in execution buffer

	XOR	A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; generate LD A,constant code

J$4F67:	LD	A,3EH			; LD A,xx
	CALL	C.60B9			; put byte in execution buffer
	LD	A,L
	CALL	C.60B9			; put byte in execution buffer
	LD	B,2			; result = generated integer
	RET

;	  Subroutine generate LD A,non constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.4F73:	DJNZ	J$4F80

;	  Subroutine generate LD A,(variable) code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4F75:	LD	A,3AH			; LD A,(xxxx)
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	LD	B,2			; result = generated integer
	RET

J$4F80:	DJNZ	J$4F8B

; generate LD A,integer in register HL

	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; generate LD A,float in register B:HL

J$4F8B:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	LD	A,L
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate integer operand, generate LD HL, integer operand code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4F97:	CALL	C.5008			; evaluate numeric expression
	CALL	C.4FEF			; convert to integer
	CALL	C.4FE0			; if constant, compile LD HL,xxxx

;	  Subroutine if load from variable, generate LD HL,(variable) code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FA0:	LD	A,B
	DEC	A			; B=1 ?
	RET	NZ			; nope, quit
	CALL	C.6086			; put LD HL,(var) in execution buffer
	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate integer operand
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FA9:	CALL	C.5008			; evaluate numeric expression
	JR	C.4FEF			; convert to integer and quit

;	  Subroutine evaluate numeric expression, convert to float, generate code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FAE:	LD	A,1
	LD	(BUF+12),A		; set force float flag
	CALL	C.5008			; evaluate numeric expression
J$4FB6:	CALL	C.4FA0			; if load from variable, generate LD HL,(variable) code
	LD	A,B
	CP	2			; generated integer ?
	JR	NZ,J$4FC4		; nope,
	CALL	C.6140			; generate convert integer to float code
	LD	B,3			; result = generated float
	RET

J$4FC4:	INC	B
	DEC	B			; constant ?
	RET	NZ			; nope, quit
	CALL	C.78DF			; convert integer to float

;	  Subroutine generate load float code
;	     Inputs  BHL = float value
;	     Outputs ________________________

C.4FCA:	LD	A,06H			; LD B,xx
	CALL	C.60B9			; put byte in execution buffer
	LD	A,B
	CALL	C.60B9			; put byte in execution buffer
	AND	A
	CALL	NZ,C.607E		; yep, put LD HL,xxxx in execution buffer
	LD	B,3			; result = generated float
	RET

;	  Subroutine evaluate numeric expression and generate appropriate code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FDA:	CALL	C.5008			; evaluate numeric expression
	CALL	C.4FA0			; if load from variable, generate LD HL,(variable) code

;	  Subroutine if constant, compile LD HL,xxxx
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FE0:	INC	B
	DEC	B			; B=0 ?
	RET	NZ			; nope, quit
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate numeric expression, convert to integer, generate code
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FE9:	CALL	C.5008			; evaluate numeric expression
	CALL	C.4FA0			; if load from variable, generate LD HL,(variable) code

;	  Subroutine convert to integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FEF:	LD	A,B
	CP	3			; float ?
	RET	NZ			; nope, quit
	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate string expression
;	     Inputs  ________________________
;	     Outputs ________________________

C.4FFE:	CALL	C.5012			; evaluate expression

;	  Subroutine check for string
;	     Inputs  ________________________
;	     Outputs ________________________

C.5001:	LD	A,B
	CP	4			; string ?
	RET	Z			; yep, quit
	JP	J.4E10			; nope, BASIC error: type mismatch

;	  Subroutine evaluate numeric expression
;	     Inputs  ________________________
;	     Outputs ________________________

C.5008:	CALL	C.5012			; evaluate expression

;	  Subroutine check for numeric
;	     Inputs  ________________________
;	     Outputs ________________________

C.500B:	LD	A,B
	CP	4			; string ?
	RET	NZ			; nope, quit
	JP	J.4E10			; yep, BASIC error: type mismatch

;	  Subroutine evaluate expression
;	     Inputs  ________________________
;	     Outputs ________________________

C.5012:	CALL	C.5025
J$5015:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F8H			; XOR token ?
	RET	NZ

; XOR

	LD	DE,C.5025		; operand2 handler = 
	LD	A,0EEH-0E6H		; XOR opcode offset
	CALL	C.5D25			; generate logical operation code
	JR	J$5015

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5025:	CALL	C.5038
J$5028:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F7H			; OR token ?
	RET	NZ

; OR

	LD	DE,C.5038		; operand2 handler = 
	LD	A,0F6H-0E6H		; OR opcode offset
	CALL	C.5D25			; generate logical operation code
	JR	J$5028

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5038:	CALL	C.504B
J$503B:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F6H			; AND token ?
	RET	NZ

; AND

	LD	DE,C.504B		; operand2 handler = 
	LD	A,0E6H-0E6H		; AND opcode offset
	CALL	C.5D25			; generate logical operation code
	JR	J$503B

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.504B:	CALL	C.5120
J.504E:	LD	D,0
J$5050:	CALL	C.6032			; get BASIC character, skip spaces
	SUB	0EEH			; compare operator token (> = <) ?
	JR	C,J.5068		; nope,
	CP	3
	JR	NC,J.5068		; nope,
	CP	1
	RLA                             ; b0 is >, b1 is =, b2 is <
	XOR	D
	CP	D
	JP	C,J.4E16		; BASIC error: syntax error
	LD	D,A
	INC	IX
	JR	J$5050

J.5068:	LD	A,D
	AND	A			; no compare ?
	RET	Z			; yep, quit
	DEC	A
	ADD	A,A
	LD	D,A
	LD	A,B
	CP	4			; string ?
	LD	A,D
	JR	Z,J$507E		; yep, string compare

; numeric compare

	DEC	IX
	LD	DE,C.5120
	CALL	C$5E87			; numeric compare
	JR	J.504E

; string compare

J$507E:	PUSH	AF
	CALL	C.50A1			; generate copy string to NULBUF code
	CALL	C.5120
	CALL	C.5001			; check for string
	POP	AF
	LD	E,A
	LD	D,0
	LD	HL,I$50DE
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	A,0CDH			; CALL xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	XOR	A
	LD	(BUF+13),A		; reset NULBUF in use flag
	LD	B,2			; result = generated integer
	JR	J.504E

;	  Subroutine generate copy string to NULBUF code
;	     Inputs  ________________________
;	     Outputs ________________________

C.50A1:	LD	HL,BUF+13
	LD	A,(HL)
	AND	A			; NULBUF in use flag set ?
	JP	NZ,J$4E13		; yep, BASIC error: string formula too complex
	LD	(HL),1			; set NULBUF in use flag
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$7F40			; copy string to NULBUF
	DEFW	0

	RET

I$50B4:	DEFW	I.50FF
	DEFW	I.5100
	DEFW	I.50EC
	DEFW	I.50EC
	DEFW	I.510E
	DEFW	I.510D
	DEFW	I.5100
	DEFW	I.50FF
	DEFW	I.50F6
	DEFW	I.50F6
	DEFW	I.510D
	DEFW	I.510E
	DEFW	I.511C
	DEFW	I.511C

I$50D0:	DEFW	C.793C			; 001 >
	DEFW	C.792A			; 010 =
	DEFW	C.7946			; 011 >=
	DEFW	C.794F			; 100 <
	DEFW	C.7933			; 101 <>
	DEFW	C.7958			; 110 <=
	DEFW	C.7962			; 111 <=> return true

I$50DE:	DEFW	C.7F4B			; 001 >
	DEFW	C.7F55			; 010 =
	DEFW	C.7F5B			; 011 >=
	DEFW	C.7F61			; 100 <
	DEFW	C.7F67			; 101 <>
	DEFW	C.7F6D			; 110 <=
	DEFW	C.7F77			; 111 <=> return true

I.50EC:	AND	A
	SBC	HL,DE
	LD	HL,-1
	JR	Z,J$50F5
	INC	HL
J$50F5:	DEFB	0

I.50F6:	AND	A
	SBC	HL,DE
	JR	Z,J$50FE
	LD	HL,0FFFFH
J$50FE:	DEFB	0

I.50FF:	EX	DE,HL
I.5100:	LD	A,H
	XOR	80H
	LD	H,A
	LD	A,D
	XOR	80H
	LD	D,A
	SBC	HL,DE
	SBC	HL,HL
	DEFB	0

I.510D:	EX	DE,HL
I.510E:	LD	A,H
	XOR	80H
	LD	H,A
	LD	A,D
	XOR	80H
	LD	D,A
	SBC	HL,DE
	CCF
	SBC	HL,HL
	DEFB	0

I.511C:	LD	HL,0FFFFH
	DEFB	0

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5120:	CALL	C.525A			; evaluate operand

; check if + or - 

J$5123:	LD	DE,C.525A		; operand2 handler = evaluate operand
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F1H			; + token ?
	JR	Z,J$5159
	CP	0F2H			; - token ?
	RET	NZ			; nope, quit

; -

	LD	IY,C.76D3		; auxilair handler (used in operator handler) = handler for subtract floats
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.51A2			; integer constant, integer constant
	DEFW	C.51A9			; integer constant, variable
	DEFW	C.51B0			; integer constant, generated integer
	DEFW	C.51BC			; variable, integer constant
	DEFW	C.51C3			; variable, variable
	DEFW	C.51CA			; variable, generated integer
	DEFW	C.51D6			; generated integer, integer constant
	DEFW	C.51F7			; generated integer, variable
	DEFW	C.51FC			; generated integer, generated integer
	DEFW	C.60E1			; integer constant, generated float
	DEFW	C.60F1			; variable, generated float
	DEFW	C.60FE			; generated integer, generated float
	DEFW	C.6109			; generated float, integer constant
	DEFW	C.612B			; generated float, variable
	DEFW	C.612E			; generated float, generated integer
	DEFW	C.6131			; generated float, generated float

	JR	J$5123

; +

J$5159:	LD	A,B
	CP	4			; string ?
	JR	Z,J$5187		; yep,
	LD	IY,C.76D7		; auxilair handler (used in operator handler) = handler for add floats
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.520E			; integer constant, integer constant
	DEFW	C.5212			; integer constant, variable
	DEFW	C.5215			; integer constant, generated integer
	DEFW	C.5218			; variable, integer constant
	DEFW	C.521F			; variable, variable
	DEFW	C.5226			; variable, generated integer
	DEFW	C.5229			; generated integer, integer constant
	DEFW	C.5246			; generated integer, variable
	DEFW	C.524B			; generated integer, generated integer
	DEFW	C.60E1			; integer constant, generated float
	DEFW	C.60F1			; variable, generated float
	DEFW	C.60FE			; generated integer, generated float
	DEFW	C.6109			; generated float, integer constant
	DEFW	C.611B			; generated float, variable
	DEFW	C.611E			; generated float, generated integer
	DEFW	C.6121			; generated float, generated float

	JR	J$5123

J$5187:	INC	IX
	CALL	C.50A1			; generate copy string to NULBUF code
	CALL	C.525A			; evaluate operand
	CALL	C.5001			; check for string
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$7F99			; concat strings
	DEFW	0

	XOR	A
	LD	(BUF+13),A		; reset NULBUF in use flag
	LD	B,4			; result = generated string
	JR	J$5123

;	  Subroutine subtract, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.51A2:	EX	DE,HL
	AND	A
	SBC	HL,DE
	LD	B,0			; result = integer constant
	RET

;	  Subroutine subtract, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.51A9:	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	EX	DE,HL
	JR	C.51F7

;	  Subroutine subtract, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.51B0:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J.5203

;	  Subroutine subtract, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.51BC:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.51D6

;	  Subroutine subtract, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.51C3:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.51F7

;	  Subroutine subtract, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.51CA:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	JR	J.5203

;	  Subroutine subtract, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.51D6:	INC	H
	DEC	H
	JR	NZ,J$51DF
	LD	A,L
	CP	5
	JR	C,J$51E8
J$51DF:	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	JP	C.5229

J$51E8:	AND	A
	JR	Z,J$51F4
	LD	B,A
J$51EC:	CALL	C.6058			; copy code block in execution buffer

	DEC	HL
	DEFW	0

	DJNZ	J$51EC
J$51F4:	LD	B,2			; result = generated integer
	RET

;	  Subroutine subtract, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.51F7:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.5203

;	  Subroutine subtract, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.51FC:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

J.5203:	CALL	C.6058			; copy code block in execution buffer

	AND	A
	SBC	HL,DE
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine add, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.520E:	ADD	HL,DE
	LD	B,0			; result = integer constant
	RET

;	  Subroutine add, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5212:	EX	DE,HL
	JR	C.5218

;	  Subroutine add, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5215:	EX	DE,HL
	JR	C.5229

;	  Subroutine add, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5218:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.5229

;	  Subroutine add, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.521F:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.5246

;	  Subroutine add, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5226:	EX	DE,HL
	JR	C.5246

;	  Subroutine add, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5229:	INC	H
	DEC	H
	JR	NZ,J$5232
	LD	A,L
	CP	05H	; 5 
	JR	C,J$5237
J$5232:	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.5251

J$5237:	AND	A
	JR	Z,J$5243
	LD	B,A
J$523B:	CALL	C.6058			; copy code block in execution buffer

	INC	HL
	DEFW	0

	DJNZ	J$523B
J$5243:	LD	B,2			; result = generated integer
	RET

;	  Subroutine add, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5246:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.5251

;	  Subroutine add, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.524B:	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J.5251:	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,DE
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine evaluate operand
;	     Inputs  ________________________
;	     Outputs ________________________

C.525A:	CALL	C.52E0
J$525D:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0FBH			; MOD
	RET	NZ			; nope, quit

; MOD

	LD	DE,C.52E0		; operand2 handler = 
	LD	IY,C.76CE		; auxilair handler (used in operator handler) = remainer of divide integer
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.528F			; integer constant, integer constant
	DEFW	C.5296			; integer constant, variable
	DEFW	C.529E			; integer constant, generated integer
	DEFW	C.52AA			; variable, integer constant
	DEFW	C.52B1			; variable, variable
	DEFW	C.52B8			; variable, generated integer
	DEFW	C.52C4			; generated integer, integer constant
	DEFW	C.52C9			; generated integer, variable
	DEFW	C.52CE			; generated integer, generated integer
	DEFW	C.5392			; integer constant, generated float
	DEFW	C.53A1			; variable, generated float
	DEFW	C.53B0			; generated integer, generated float
	DEFW	C.53BC			; generated float, integer constant
	DEFW	C.53C9			; generated float, variable
	DEFW	C.53DE			; generated float, generated integer
	DEFW	C.53D6			; generated float, generated float

	JR	J$525D

;	  Subroutine mod, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.528F:	EX	DE,HL
	CALL	C.76CE			; divide
	LD	B,0			; result = integer constant
	RET

;	  Subroutine mod, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5296:	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	EX	DE,HL
	JP	C.52C9

;	  Subroutine mod, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.529E:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J.52D5

;	  Subroutine mod, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.52AA:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.52C4

;	  Subroutine mod, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.52B1:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.52C9

;	  Subroutine mod, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.52B8:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	JR	J.52D5

;	  Subroutine mod, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.52C4:	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.52D5

;	  Subroutine mod, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.52C9:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.52D5

;	  Subroutine mod, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.52CE:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

J.52D5:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.76CE			; divide
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.52E0:	CALL	C.53F3
J$52E3:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0FCH			; \ token ?
	RET	NZ

; \

	LD	DE,C.53F3		; operand2 handler = 
	LD	IY,C.7643		; auxilair handler (used in operator handler) = divide integer
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.5315			; integer constant, integer constant
	DEFW	C.531C			; integer constant, variable
	DEFW	C.5324			; integer constant, generated integer
	DEFW	C.5330			; variable, integer constant
	DEFW	C.5337			; variable, variable
	DEFW	C.533E			; variable, generated integer
	DEFW	C.534A			; generated integer, integer constant
	DEFW	C.537B			; generated integer, variable
	DEFW	C.5380			; generated integer, generated integer
	DEFW	C.5392			; integer constant, generated float
	DEFW	C.53A1			; variable, generated float
	DEFW	C.53B0			; generated integer, generated float
	DEFW	C.53BC			; generated float, integer constant
	DEFW	C.53C9			; generated float, variable
	DEFW	C.53DE			; generated float, generated integer
	DEFW	C.53D6			; generated float, generated float

	JR	J$52E3

;	  Subroutine \, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5315:	EX	DE,HL
	CALL	C.7643			; divide
	LD	B,0			; result = integer constant
	RET

;	  Subroutine \, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.531C:	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	EX	DE,HL
	JP	C.537B

;	  Subroutine \, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5324:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J.5387

;	  Subroutine \, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5330:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.534A

;	  Subroutine \, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5337:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.537B

;	  Subroutine \, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.533E:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	JR	J.5387

;	  Subroutine \, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.534A:	CALL	C.552D
	JR	C,J$5354
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.5387

J$5354:	LD	A,H
	DEC	A
	OR	L
	JR	Z,J$536E
	LD	B,(IY+32)
	INC	B
	DEC	B
	JR	Z,J$536B
J$5360:	CALL	C.6058			; copy code block in execution buffer

	SRA	H
	RR	L
	DEFW	0

	DJNZ	J$5360
J$536B:	LD	B,2			; result = generated integer
	RET

J$536E:	CALL	C.6058			; copy code block in execution buffer

	LD	L,H
	RL	H
	SBC	A,A
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine \, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.537B:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.5387

;	  Subroutine \, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5380:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	POP	HL
	DEFW	0

J.5387:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7643			; divide
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine mod \, integer constant, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.5392:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J.53E9

;	  Subroutine mod \, variable, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.53A1:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	JR	J.53E9

;	  Subroutine mod \, generated integer, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.53B0:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	EX	DE,HL
	POP	HL
	DEFW	0

	JR	J.53E9

;	  Subroutine mod \, generated float, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.53BC:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.53E9

;	  Subroutine mod \, generated float, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.53C9:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.53E9

;	  Subroutine mod \, generated float, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.53D6:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

;	  Subroutine mod \, generated float, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.53DE:	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	EX	(SP),HL
	CALL	C.7901			; covert float to integer
	POP	DE
	DEFW	0

J.53E9:	LD	B,2			; result = generated integer

;	  Subroutine generate CALL xxxx (xxxx is in IY)
;	     Inputs  ________________________
;	     Outputs ________________________

J$53EB:	PUSH	IY
	POP	HL

;	  Subroutine generate CALL xxxx (xxxx is in HL)
;	     Inputs  ________________________
;	     Outputs ________________________

J$53EE:	LD	A,0CDH			; CALL xxxx
	JP	C.60AB			; put 3 bytes in execution buffer

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.53F3:	CALL	C.5622
J.53F6:	LD	DE,C.5622		; operand2 handler = 
	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F4H			; / token ?
	JR	Z,J$542C
	CP	0F3H			; * token ?
	RET	NZ			; nope, quit

; *
	LD	IY,C.7748		; auxilair handler (used in operator handler) = handler for multipy floats
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.54D1			; integer constant, integer constant
	DEFW	C.54D7			; integer constant, variable
	DEFW	C.54DA			; integer constant, generated integer
	DEFW	C.54DE			; variable, integer constant
	DEFW	C.54E5			; variable, variable
	DEFW	C.54EB			; variable, generated integer
	DEFW	C.54EE			; generated integer, integer constant
	DEFW	C.5517			; generated integer, variable
	DEFW	C.551C			; generated integer, generated integer
	DEFW	C.60E1			; integer constant, generated float
	DEFW	C.60F1			; variable, generated float
	DEFW	C.60FE			; generated integer, generated float
	DEFW	C.6109			; generated float, integer constant
	DEFW	C.611B			; generated float, variable
	DEFW	C.611E			; generated float, generated integer
	DEFW	C.6121			; generated float, generated float

	JR	J.53F6

; /

J$542C:	LD	IY,C.782C		; auxilair handler (used in operator handler) = handler for divide floats
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.5455			; integer constant, integer constant
	DEFW	C.5469			; integer constant, variable
	DEFW	C.546C			; integer constant, generated integer
	DEFW	C.547F			; variable, integer constant
	DEFW	C.5499			; variable, variable
	DEFW	C.549C			; variable, generated integer
	DEFW	C.5484			; generated integer, integer constant
	DEFW	C.54AC			; generated integer, variable
	DEFW	C.54AF			; generated integer, generated integer
	DEFW	C.60E1			; integer constant, generated float
	DEFW	C.60F1			; variable, generated float
	DEFW	C.60FE			; generated integer, generated float
	DEFW	C.6109			; generated float, integer constant
	DEFW	C.612B			; generated float, variable
	DEFW	C.612E			; generated float, generated integer
	DEFW	C.6131			; generated float, generated float

	JR	J.53F6

;	  Subroutine divide, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5455:	PUSH	DE
	CALL	C.78DF			; convert integer to float
	POP	DE
	PUSH	HL
	PUSH	BC
	EX	DE,HL
	CALL	C.78DF			; convert integer to float
	POP	DE
	LD	C,D
	POP	DE
	CALL	C.782C			; divide floats
	JP	C.4FCA			; generate load float code and quit

;	  Subroutine divide, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5469:	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine divide, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.546C:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.78DF			; convert integer to float
	LD	C,B
	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.78DF			; convert integer to float
	CALL	C.4FCA			; generate load float code
	JR	J.54C6

;	  Subroutine divide, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.547F:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL

;	  Subroutine divide, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5484:	CALL	C.6140			; generate convert integer to float code
	CALL	C.78DF			; convert integer to float
	LD	A,0EH			; LD C,xx
	CALL	C.60B9			; put byte in execution buffer
	LD	A,B
	CALL	C.60B9			; put byte in execution buffer
	AND	A
	CALL	NZ,C.6079		; yep, put LD DE,xxxx in execution buffer
	JR	J.54C6

;	  Subroutine divide, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5499:	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine divide, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.549C:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.78DF			; convert integer to float
	PUSH	HL
	PUSH	BC
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	JR	J$54BB

;	  Subroutine divide, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.54AC:	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine divide, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.54AF:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.78DF			; convert integer to float
	POP	DE
	PUSH	HL
	PUSH	BC
	EX	DE,HL
	DEFW	0

J$54BB:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.78DF			; convert integer to float
	POP	DE
	LD	C,D
	POP	DE
	DEFW	0

J.54C6:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.782C			; divide floats
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine multiply, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.54D1:	CALL	C.7624			; multiply
	LD	B,0			; result = integer constant
	RET

;	  Subroutine multiply, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.54D7:	EX	DE,HL
	JR	C.54DE

;	  Subroutine multiply, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.54DA:	EX	DE,HL
	JP	C.54EE

;	  Subroutine multiply, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.54DE:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.54EE

;	  Subroutine multiply, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.54E5:	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.5517

;	  Subroutine multiply, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.54EB:	EX	DE,HL
	JR	C.5517

;	  Subroutine multiply, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.54EE:	CALL	C$5587
	JR	C,J.54FD
	CALL	C.552D
	JR	C,J$5509
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.5522

J.54FD:	LD	A,(HL)
	CP	0FFH
	LD	B,2			; result = generated integer
	RET	Z
	CALL	C.60B9			; put byte in execution buffer
	INC	HL
	JR	J.54FD

J$5509:	LD	B,(IY+32)
J$550C:	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,HL
	DEFW	0

	DJNZ	J$550C
	LD	B,2			; result = generated integer
	RET

;	  Subroutine multiply, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5517:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.5522

;	  Subroutine multiply, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.551C:	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J.5522:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7624			; multiply
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.552D:	LD	IY,I$5547
	LD	B,16
J$5533:	LD	A,L
	CP	(IY+0)
	JR	NZ,J$553F
	LD	A,H
	CP	(IY+1)
	SCF
	RET	Z
J$553F:	INC	IY
	INC	IY
	DJNZ	J$5533
	AND	A
	RET

I$5547:	DEFW	1
	DEFW	2
	DEFW	4
	DEFW	8
	DEFW	16
	DEFW	32
	DEFW	64
	DEFW	128
	DEFW	256
	DEFW	512
	DEFW	1024
	DEFW	2048
	DEFW	4096
	DEFW	8192
	DEFW	16384
	DEFW	32768

	DEFW	0
	DEFW	1
	DEFW	2
	DEFW	3
	DEFW	4
	DEFW	5
	DEFW	6
	DEFW	7
	DEFW	8
	DEFW	9
	DEFW	10
	DEFW	11
	DEFW	12
	DEFW	13
	DEFW	14
	DEFW	15

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$5587:	LD	IY,I$55AC
J$558B:	LD	A,(IY+0)
	OR	(IY+1)
	RET	Z
	LD	A,(IY+0)
	CP	L
	JR	NZ,J$559E
	LD	A,(IY+1)
	CP	H
	JR	Z,J$55A4
J$559E:	INC	IY
	INC	IY
	JR	J$558B

J$55A4:	LD	L,(IY+34)
	LD	H,(IY+35)
	SCF
	RET

I$55AC:	DEFW	1
	DEFW	3
	DEFW	5
	DEFW	6
	DEFW	7
	DEFW	9
	DEFW	10
	DEFW	20
	DEFW	25
	DEFW	40
	DEFW	50
	DEFW	80
	DEFW	100
	DEFW	200
	DEFW	256
	DEFW	257
	DEFW	0

	DEFW	C.55F3
	DEFW	C.55EF
	DEFW	C.55F8
	DEFW	C.55EE
	DEFW	C.55FE
	DEFW	C.5605
	DEFW	C.55F7
	DEFW	C.55F6
	DEFW	C.560F
	DEFW	C.55F5
	DEFW	C.560E
	DEFW	C.55F4
	DEFW	C.560D
	DEFW	C.560C
	DEFW	C.561A
	DEFW	C.561E

C.55EE:	ADD	HL,HL
C.55EF:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,DE
C.55F3:	DEFB	0FFH

C.55F4:	ADD	HL,HL
C.55F5:	ADD	HL,HL
C.55F6:	ADD	HL,HL
C.55F7:	ADD	HL,HL
C.55F8:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	DEFB	0FFH

C.55FE:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,HL
	ADD	HL,DE
	DEFB	0FFH

C.5605:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	DEFB	0FFH

C.560C:	ADD	HL,HL
C.560D:	ADD	HL,HL
C.560E:	ADD	HL,HL
C.560F:	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	DEFB	0FFH

C.561A:	LD	H,L
	LD	L,0
	DEFB	0FFH

C.561E:	LD	A,L
	ADD	A,H
	LD	H,A
	DEFB	0FFH

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5622:	CALL	C.56EC
J.5625:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F5H			; ^ token ?
	RET	NZ

; ^

	LD	DE,C.56EC		; operand2 handler = 
	LD	IY,I$78BF		; auxilair handler (used in operator handler) = handler for ^ floats
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.5657			; integer constant, integer constant
	DEFW	C.5666			; integer constant, variable
	DEFW	C.5672			; integer constant, generated integer
	DEFW	C.5681			; variable, integer constant
	DEFW	C.5688			; variable, variable
	DEFW	C.568F			; variable, generated integer
	DEFW	C.56A4			; generated integer, integer constant
	DEFW	C.56AC			; generated integer, variable
	DEFW	C.56B4			; generated integer, generated integer
	DEFW	C.60E1			; integer constant, generated float
	DEFW	C.60F1			; variable, generated float
	DEFW	C.60FE			; generated integer, generated float
	DEFW	C.56C9			; generated float, integer constant
	DEFW	C.56CE			; generated float, variable
	DEFW	C.56D9			; generated float, generated integer
	DEFW	C.6131			; generated float, generated float

	JR	J.5625

;	  Subroutine ^, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5657:	PUSH	HL
	EX	DE,HL
	CALL	C.78DF			; convert integer to float
	POP	DE
	CALL	C.7878
	CALL	C.4FCA			; generate load float code
	LD	B,3			; result = generated float
	RET

;	  Subroutine ^, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5666:	PUSH	HL
	EX	DE,HL
	CALL	C.78DF			; convert integer to float
	CALL	C.4FCA			; generate load float code
	POP	HL
	JP	J$56AF

;	  Subroutine ^, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5672:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	DEFW	0

	EX	DE,HL
	CALL	C.78DF			; convert integer to float
	CALL	C.4FCA			; generate load float code
	JR	J.56BE

;	  Subroutine ^, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5681:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.56A4

;	  Subroutine ^, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5688:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.56AC

;	  Subroutine ^, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.568F:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	CALL	C.78DF			; convert integer to float
	POP	DE
	DEFW	0

	JR	J.56BE

;	  Subroutine ^, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.56A4:	CALL	C.6140			; generate convert integer to float code
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.56BE

;	  Subroutine ^, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.56AC:	CALL	C.6140			; generate convert integer to float code
J$56AF:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.56BE

;	  Subroutine ^, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.56B4:	CALL	C.6058			; copy code block in execution buffer

	EX	(SP),HL
	CALL	C.78DF			; convert integer to float
	POP	DE
	DEFW	0

J.56BE:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7878
	DEFW	0

	LD	B,3			; result = generated float
	RET

C.56C9:	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.56E1

C.56CE:	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.56E1

C.56D9:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	POP	BC
	POP	HL
	DEFW	0

J.56E1:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7878
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.56EC:	LD	HL,(BUF+21)		; start of variable list
	LD	BC,140
	ADD	HL,BC
	SBC	HL,SP
	JP	NC,J.4E1F		; BASIC error: out of memory
	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	"("
	JR	NZ,J$5707
	CALL	C.5012			; evaluate expression
	JP	C.6048			; check for BASIC character ")"

J$5707:	LD	HL,BUF+12
	BIT	0,(HL)			; force float flag ?
	RES	0,(HL)			; reset force float flag
	JR	Z,C.5716		; nope,
	CALL	C.5716
	JP	J$4FB6			; convert to float, generate code

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5716:	CP	11H			; constant very small integer ?
	JR	C,J.5725		; nope,
	CP	1BH
	JR	NC,J.5725		; nope,
	SUB	11H
	LD	L,A
	LD	H,0			; HL = very small integer
	LD	B,H			; B = 0
	RET

J.5725:	CP	0FH			; constant small integer ?
	JR	NZ,J$5732		; nope,
	LD	L,(IX+0)
	INC	IX
	LD	H,0			; HL = small integer
	LD	B,H			; B = 0
	RET

J$5732:	CP	1CH			; constant integer ?
	JR	Z,J.573E		; yep,
	CP	0CH			; hexadecimal constant integer ?
	JR	Z,J.573E		; yep,
	CP	0BH			; octal constant integer ?
	JR	NZ,J$574B		; nope,
J.573E:	LD	L,(IX+0)
	LD	H,(IX+1)		; HL = integer
	INC	IX
	INC	IX
	LD	B,0			; result = integer constant
	RET

J$574B:	CP	"&"
	JR	NZ,J$576A
	LD	A,(IX+0)
	CP	"B"
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	LD	B,0			; result = integer constant
	LD	L,B
	LD	H,B			; HL = 0
J$575B:	INC	IX
	LD	A,(IX+0)
	SUB	"0"
	CP	1+1
	RET	NC
	ADD	HL,HL
	OR	L
	LD	L,A
	JR	J$575B

J$576A:	CP	"0"
	JR	C,J.578E
	CP	"9"+1
	JR	NC,J.578E
	LD	B,0			; result = integer constant
	SUB	"0"
	LD	L,A
	LD	H,B
J$5778:	CALL	C.6032			; get BASIC character, skip spaces
	SUB	"0"
	CP	9+1
	RET	NC
	LD	E,L
	LD	D,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	ADD	HL,HL
	LD	E,A
	LD	D,0
	ADD	HL,DE
	INC	IX
	JR	J$5778

J.578E:	CP	1DH			; single real ?
	LD	C,3
	JR	Z,J$579B
	CP	1FH			; double real ?
	LD	C,7
	JP	NZ,J.5837		; 
J$579B:	LD	B,0
	LD	A,(IX+0)
	ADD	IX,BC
	AND	A
	JR	Z,J$57EE
	PUSH	IX
	LD	A,C
J$57A8:	PUSH	AF
	LD	A,(IX+0)
	CALL	C.57FA
	LD	A,(IX+0)
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	C.57FA
	POP	AF
	DEC	IX
	DEC	A
	JR	NZ,J$57A8
	LD	A,(IX+0)
	POP	IX
	INC	IX
	AND	A
	JP	P,J.57CE
	SET	7,H
	AND	7FH
J.57CE:	CP	40H
	JP	Z,C.4FCA		; generate load float code and quit
	PUSH	AF
	JR	NC,J$57E2
	LD	C,7DH
	LD	DE,4CCCH
	CALL	C.7748			; multipy floats
	POP	AF
	INC	A
	JR	J.57CE

J$57E2:	LD	C,84H
	LD	DE,2000H
	CALL	C.7748			; multipy floats
	POP	AF
	DEC	A
	JR	J.57CE

J$57EE:	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	LD	B,0
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.57FA:	AND	0FH
	PUSH	HL
	PUSH	BC
	LD	C,A
	LD	B,0
	LD	HL,I$5819
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,BC
	POP	BC
	LD	C,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	E,(HL)
	POP	HL
	CALL	C.76D7			; add floats
	LD	C,7DH
	LD	DE,4CCCH
	JP	C.7748			; multipy floats

I$5819:	DEFB	000H,000H,000H
	DEFB	081H,000H,000H
	DEFB	082H,000H,000H
	DEFB	082H,040H,000H
	DEFB	083H,000H,000H
	DEFB	083H,020H,000H
	DEFB	083H,040H,000H
	DEFB	083H,060H,000H
	DEFB	084H,000H,000H
	DEFB	084H,010H,000H

;	  Subroutine generate code for 
;	     Inputs  ________________________
;	     Outputs ________________________

J.5837:	CP	'"'
	JR	NZ,J$586F

;	  Subroutine generate code for constant string
;	     Inputs  ________________________
;	     Outputs ________________________

C$583B:	CALL	C.6058			; copy code block in execution buffer

J$583E:	JP	J$583E			; dummy for jump over string
	RST	38H			; dummy for size of string
	DEFW	0

	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	LD	E,0
J$584A:	LD	A,(IX+0)
	AND	A			; end of line ?
	JR	Z,J.585C		; yep,
	INC	IX
	CP	'"'			; end of string ?
	JR	Z,J.585C		; yep,
	CALL	C.60B9			; put byte in execution buffer
	INC	E
	JR	J$584A

J.585C:	POP	HL
	DEC	HL
	LD	(HL),E			; size of string
	LD	DE,(BUF+2)		; current compiled code pointer
	DEC	HL
	DEC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; jump over string
	INC	HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	LD	B,4			; result = generated string
	RET

J$586F:	CP	"A"
	JP	C,J.5920
	CP	"Z"+1
	JP	NC,J.5920
	DEC	IX
	CALL	C.6503			; fetch variable name
	CP	"("			; array index indicator ?
	JR	Z,J$58A4		; yep,
	BIT	5,H			; string variable ?
	JR	NZ,J$5899		; yep,
	BIT	6,H			; float variable ?
	LD	B,1
	RET	Z			; nope, return fetch from variable
	LD	C,0AH			; generate fetch code
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

J$5899:	LD	A,21H			; LD HL,xxxx
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	LD	B,4			; result = generated string
	RET

J$58A4:	INC	IX
	CALL	C.59FC			; fetch index
	BIT	5,A			; string array ?
	JP	NZ,J$5904		; yep,
	BIT	6,A			; float array ?
	JR	NZ,J$58D1		; yep,
	INC	B
	DJNZ	J$58BF

; B=0

	ADD	HL,HL			; 2 bytes per element
	ADD	HL,DE
	LD	A,2AH			; LD HL,(xxxx)
	CALL	C.60AB			; put 3 bytes in execution buffer
	LD	B,2			; result = generated integer
	RET

; B>0

J$58BF:	EX	DE,HL
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,HL			; 2 bytes per element
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

J$58D1:	INC	B
	DJNZ	J$58ED

; B=0

	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,BC			; 3 bytes per element
	ADD	HL,DE
	LD	A,3AH			; LD A,(xxxx)
	CALL	C.60AB			; put 3 bytes in execution buffer
	LD	A,2AH			; LD HL,(xxxx)
	INC	HL
	CALL	C.60AB			; put 3 bytes in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

; B>0

J$58ED:	EX	DE,HL
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,BC			; 3 bytes per element
	ADD	HL,DE
	LD	B,(HL)
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

J$5904:	INC	B
	DJNZ	J$5910

; B=0

	LD	H,L
	LD	L,0			; 256 bytes per element
	ADD	HL,DE
	LD	B,4			; result = generated string
	JP	C.607E			; put LD HL,xxxx in execution buffer

; B=1

J$5910:	EX	DE,HL
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	H,L
	LD	L,0			; 256 bytes per element
	ADD	HL,DE
	DEFW	0

	LD	B,4			; result = generated string
	RET

J.5920:	CP	0E0H			; NOT token ?
	JR	NZ,J$594A		; nope,
	CALL	C.56EC
	CALL	C.500B			; check for numeric
	CALL	C.4FA0			; if load from variable, generate LD HL,(variable) code
	CALL	C.4FEF			; convert to integer
	INC	B
	DJNZ	J$593C

; B=0

	LD	A,L
	CPL
	LD	L,A
	LD	A,H
	CPL
	LD	H,A
	LD	B,0			; result = integer constant
	RET

; B>0

J$593C:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	CPL
	LD	L,A
	LD	A,H
	CPL
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

J$594A:	CP	0F2H			; - token ?
	JR	NZ,J$597E		; nope,
	CALL	C.56EC
	CALL	C.500B			; check for numeric
	CALL	C.4FA0			; if load from variable, generate LD HL,(variable) code
	INC	B
	DJNZ	J$5961

; B=1

	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	RET

J$5961:	DEC	B
	DJNZ	J$5972

; B=2

	CALL	C.6058			; copy code block in execution buffer

	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; B=1 or >2

J$5972:	CALL	C.6058			; copy code block in execution buffer

	LD	A,H
	XOR	80H
	LD	H,A
	DEFW	0

	LD	B,3			; result = generated float
	RET

J$597E:	CP	0CBH			; TIME token ?
	JR	NZ,J$5995		; nope,

; TIME function

	LD	A,2AH
	LD	HL,JIFFY		; LD HL,(JIFFY)
	CALL	C.60AB			; put 3 bytes in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$78CD
	DEFW	0

	LD	B,3			; result = generated float
	RET

J$5995:	CP	0ECH			; INKEY$ token ?
	JR	NZ,J$59A4		; nope,

; INKEY$ function

	CALL	C.6058			; copy code block in execution buffer

	CALL	C$7F01
	DEFW	0

	LD	B,4			; result = generated string
	RET

J$59A4:	CP	0E8H			; CSRLIN token ?
	JR	NZ,J$59B4		; nope,

; CSRLIN function

	CALL	C.6058			; copy code block in execution buffer

	LD	HL,(CSRY)
	DEC	L
	DEFW	0

	JP	J.5B91

J$59B4:	CP	0E3H			; STRING$ token ?
	JP	Z,J$6228
	CP	0E5H			; INSTR token ?
	JP	Z,J$62A7
	CP	0E7H			; VARPTR token ?
	JP	Z,J$5BD3
	CP	0DDH			; USR token ?
	JP	Z,J$5C55
	CP	0C8H			; VDP token ?
	JP	Z,J$6AAF
	CP	0EDH			; POINT token ?
	JP	Z,J$6AA3
	CP	0C7H			; SPRITE token ?
	JP	Z,J$691A
	CP	0FFH			; function token ?
	JR	NZ,J$59F9		; nope,
	LD	A,(IX+0)
	INC	IX
	AND	A
	JP	P,J.4E16		; BASIC error: syntax error
	CP	0A6H
	JP	NC,J.4E16		; BASIC error: syntax error
	ADD	A,A
	LD	L,A
	LD	H,0
	LD	DE,I$4F08
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	C.6044			; check for BASIC character "("
	JP	(HL)

J$59F9:	JP	J.4E16			; BASIC error: syntax error

;	  Subroutine fetch index
;	     Inputs  ________________________
;	     Outputs ________________________

C.59FC:	PUSH	HL
	CALL	C$643B			; fetch address of array variable
	PUSH	DE
	LD	A,(DE)
	LD	B,A			; number of dimensions
	CALL	C.5ACB
	LD	HL,BUF+28
	CALL	C.5A7E
	DEC	B
	CALL	NZ,C.5A50
	SUB	")"
	JP	NZ,J.4E25		; BASIC error: subscript out of range
	LD	(HL),A
	INC	HL
	LD	A,L
	LD	DE,BUF+27
	SUB	E
	LD	(DE),A
	LD	C,A
	LD	B,0
	EX	DE,HL
	DEC	DE
	LD	HL,-1
	ADD	HL,SP
	EX	DE,HL
	DI
	LDDR
	EX	DE,HL
	INC	HL
	EI
	LD	SP,HL
	PUSH	IX
	INC	HL
	PUSH	HL
	POP	IX
	CALL	C.4FE9			; evaluate numeric expression, convert to integer, generate code
	POP	IX
	LD	A,B
	PUSH	HL
	POP	IY
	LD	HL,0
	ADD	HL,SP
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	LD	SP,HL
	PUSH	IY
	POP	HL
	LD	B,A
	POP	DE
	CALL	C.5ACB
	POP	AF
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5A50:	LD	(HL),0F1H
	INC	HL
	LD	(HL),1CH
	INC	HL
	INC	HL
	DEC	DE
	LD	A,(DE)
	LD	(HL),A
	DEC	DE
	DEC	HL
	LD	A,(DE)
	LD	(HL),A
	INC	HL
	INC	HL
	LD	(HL),0F3H
	INC	HL
	LD	(HL),28H	; "("
	INC	HL
	LD	(HL),28H	; "("
	INC	HL
	CALL	C.5A7E
	LD	(HL),29H	; ")"
	INC	HL
	DEC	B
	JR	Z,J$5A7A
	CP	","
	JP	NZ,J.4E25		; BASIC error: subscript out of range
	CALL	C.5A50
J$5A7A:	LD	(HL),")"
	INC	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5A7E:	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	AND	A			; end of line ?
	JP	Z,J.4E25		; yep, BASIC error: subscript out of range
	CP	","
	RET	Z
	CP	")"
	RET	Z
	LD	(HL),A
	INC	HL
	CP	20H
	JR	C,J$5AA2
	CP	"("
	JR	NZ,C.5A7E
J$5A97:	CALL	C.5A7E
	LD	(HL),A
	INC	HL
	CP	")"
	JR	NZ,J$5A97
	JR	C.5A7E

J$5AA2:	CP	0BH			; special number token ?
	JR	C,C.5A7E		; nope,
	PUSH	BC
	CP	0FH			; byte integer ?
	LD	B,1			; 1 byte
	JR	Z,J.5ABF		; yep, copy
	INC	B			; 2 bytes
	JR	C,J.5ABF		; yep, copy
	CP	1BH
	JR	C,J$5AC8
	SUB	1CH
	JR	Z,J.5ABF		; integer, copy 2 bytes
	DEC	A
	LD	B,4
	JR	Z,J.5ABF		; single real, copy 4 bytes
	LD	B,8			; double real, copy 8 bytes
J.5ABF:	LD	A,(IX+0)
	LD	(HL),A
	INC	IX
	INC	HL
	DJNZ	J.5ABF
J$5AC8:	POP	BC
	JR	C.5A7E

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5ACB:	LD	A,(DE)
	INC	DE
J$5ACD:	INC	DE
	INC	DE
	DEC	A
	RET	Z
	JR	J$5ACD

;	  Subroutine RND function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AD3:	LD	HL,I$768E		; rnd handler
	JR	J.5AF9

;	  Subroutine EXP function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AD8:	LD	HL,J.7AA8		; exp handler
	JR	J.5AF9

;	  Subroutine LOG function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5ADD:	LD	HL,C.7B01		; log handler
	JR	J.5AF9

;	  Subroutine SIN function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AE2:	LD	HL,C.79EA		; sin handler
	JR	J.5AF9

;	  Subroutine COS function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AE7:	LD	HL,C.79E2		; cos handler
	JR	J.5AF9

;	  Subroutine TAN function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AEC:	LD	HL,I$7A41		; tan handler
	JR	J.5AF9

;	  Subroutine ATN function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AF1:	LD	HL,I$7A63		; atn handler
	JR	J.5AF9

;	  Subroutine SQR function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5AF6:	LD	HL,I$7B60		; sqr handler
J.5AF9:	PUSH	HL
	CALL	C.4FAE			; evaluate numeric expression, convert to float, generate code
	CALL	C.6048			; check for BASIC character ")"
	POP	HL
	JP	J$53EE			; generate CALL xxxx (xxxx is in HL)

;	  Subroutine INT function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5B04:	CALL	C.4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C.6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	RET	Z			; yep, quit
	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7999
	DEFW	0

	RET

;	  Subroutine FIX function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5B17:	CALL	C.4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C.6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	RET	Z			; yep, quit
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$798C
	DEFW	0

	RET

;	  Subroutine ABS function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5B2A:	CALL	C.4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C.6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	JR	NZ,J$5B47		; nope,
	CALL	C.6058			; copy code block in execution buffer

	LD	A,H
	ADD	A,A
	JR	NC,J$5B42
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
J$5B42:	DEFW	0

	LD	B,2			; result = generated integer
	RET

J$5B47:	CALL	C.6058			; copy code block in execution buffer

	RES	7,H
	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine SGN function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5B51:	CALL	C.4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C.6048			; check for BASIC character ")"
	LD	A,B
	CP	2			; generated integer ?
	JR	NZ,J$5B71		; nope,
	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	OR	H
	JR	Z,J.5B6C
	BIT	7,H
	LD	HL,-1
	JR	NZ,J.5B6C
	INC	HL
	INC	HL
J.5B6C:	DEFW	0

	LD	B,2			; result = generated integer
	RET

J$5B71:	CALL	C.6058			; copy code block in execution buffer

	LD	A,B
	AND	A
	JR	Z,J$5B80
	LD	B,81H
	LD	L,0
	LD	A,H
	AND	80H
	LD	H,A
J$5B80:	DEFW	0

	LD	B,3			; result = generated float
	RET

;	  Subroutine PEEK function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5B85:	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6048			; check for BASIC character ")"
	CALL	C.6058			; copy code block in execution buffer

	LD	L,(HL)
	DEFW	0

J.5B91:	CALL	C.6058			; copy code block in execution buffer

	LD	H,0
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine INP function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5B9B:	CALL	C.4FA9			; evaluate integer operand
	CALL	C.6048			; check for BASIC character ")"
	INC	B
	DJNZ	J$5BB5
	LD	A,0DBH			; IN A,(xx)
	CALL	C.60B9			; put byte in execution buffer
	LD	A,L
	CALL	C.60B9			; put byte in execution buffer
J.5BAD:	CALL	C.6058			; copy code block in execution buffer

	LD	L,A
	DEFW	0

	JR	J.5B91

J$5BB5:	DJNZ	J$5BC4
	PUSH	HL
	LD	HL,4BEDH		; LD BC,(xxxx)
	CALL	C.60AE			; put word in execution buffer
	POP	HL
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	JR	J$5BCA

J$5BC4:	CALL	C.6058			; copy code block in execution buffer

	LD	C,L
	DEFW	0

J$5BCA:	CALL	C.6058			; copy code block in execution buffer

	IN	L,(C)
	DEFW	0

	JR	J.5B91

; VARPTR function

J$5BD3:	CALL	C.6044			; check for BASIC character "("
	CALL	C.5BDE
	LD	B,2			; result = generated integer
	JP	C.6048			; check for BASIC character ")"

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5BDE:	CALL	C.5BF3			; fetch variable name or index variable name with index
	PUSH	AF
	CALL	C.4FE0			; if constant, compile LD HL,xxxx
	DJNZ	J$5BF1

; B=1

	LD	A,21H			; LD HL,xxxx
	CALL	C.60B9			; put byte in execution buffer
	LD	C,0			; generate address
	CALL	C.62E7			; create simple variable if needed, generate variable address code
J$5BF1:	POP	AF
	RET

;	  Subroutine fetch variable name or index variable name with index
;	     Inputs  ________________________
;	     Outputs ________________________

C.5BF3:	CALL	C.6503			; fetch variable name
	CP	"("			; array index indicator ?
	JR	Z,J$5C00		; yep,
	LD	B,1			; fetch from variable
	LD	A,H
	AND	60H			; A = variable type
	RET

J$5C00:	INC	IX
	PUSH	HL
	CALL	C$5C0A			; fetch index and calculate or compile code pointer
	POP	AF
	AND	60H			; A = variable type
	RET

;	  Subroutine fetch index and calculate or compile code pointer
;	     Inputs  ________________________
;	     Outputs ________________________

C$5C0A:	CALL	C.59FC			; fetch index
	INC	B
	DJNZ	J$5C25

; array index a constant

	BIT	5,A			; string variable ?
	JR	NZ,J$5C1E		; yep,
	LD	C,L
	LD	B,H
	ADD	HL,HL			; assume integer, 2 bytes per element
	BIT	6,A			; float variable ?
	JR	Z,J.5C21		; nope, it is an integer
	ADD	HL,BC			; float has 3 bytes per element
	JR	J.5C21

J$5C1E:	LD	H,L
	LD	L,0			; 256 bytes per element
J.5C21:	ADD	HL,DE
	LD	B,0			; result = constant
	RET

; array index not a constant

J$5C25:	BIT	5,A			; string variable ?
	JR	NZ,J$5C40		; yep,
	BIT	6,A			; float variable ?
	JR	Z,J$5C38		; nope,
	CALL	C.6058			; copy code block in execution buffer

	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,BC			; 3 bytes per element
	DEFW	0

	JR	J.5C48

J$5C38:	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,HL			; 2 bytes per element
	DEFW	0

	JR	J.5C48

J$5C40:	CALL	C.6058			; copy code block in execution buffer

	LD	H,L
	LD	L,0			; 256 bytes per element
	DEFW	0

J.5C48:	EX	DE,HL
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	ADD	HL,DE
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; USR function

J$5C55:	CALL	C.6032			; get BASIC character, skip spaces
	LD	C,0
	SUB	11H
	JR	C,J.5C65
	CP	9+1
	JR	NC,J.5C65
	LD	C,A
	INC	IX
J.5C65:	CALL	C.6044			; check for BASIC character "("
	PUSH	BC
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	POP	BC
	CALL	C.6048			; check for BASIC character ")"
	LD	HL,5BEDH		; LD DE,(xxxx)
	CALL	C.60AE			; put word in execution buffer
	LD	HL,USRTAB
	LD	B,0
	ADD	HL,BC
	ADD	HL,BC
	CALL	C.60AE			; put word in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$6C0B			; put in DAC, execute routine DE (USR routine), get result from DAC
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine POS function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5C8B:	LD	HL,TTYPOS
	JR	J$5C93

;	  Subroutine LPOS function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5C90:	LD	HL,LPTPOS
J$5C93:	PUSH	HL
	CALL	C.5012			; evaluate expression (dummy parameter)
	CALL	C.6048			; check for BASIC character ")"
	POP	HL
	LD	A,2AH			; LD HL,(xxxx)
	CALL	C.60AB			; put 3 bytes in execution buffer
	JP	J.5B91

;	  Subroutine STICK function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5CA3:	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048			; check for BASIC character ")"
	CALL	C.6058			; copy code block in execution buffer

	CALL	GTSTCK
	DEFW	0

	JP	J.5BAD

;	  Subroutine TRIG function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5CB4:	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048			; check for BASIC character ")"
	CALL	C.6058			; copy code block in execution buffer

	CALL	GTTRIG
	LD	L,A
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine PAD function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5CC7:	CALL	C.4FA9			; evaluate integer operand
	CALL	C.6048			; check for BASIC character ")"
	INC	B
	DJNZ	J$5CF4

; parameter is a constant

	PUSH	HL
	CALL	C.4F5A			; generate LD A,constant code
	CALL	C.6058			; copy code block in execution buffer

	CALL	GTPAD
	DEFW	0

	POP	HL
	LD	A,L
	ADD	A,04H
	AND	0F3H
	DEC	A
	CP	2
	JP	C,J.5BAD
	CALL	C.6058			; copy code block in execution buffer

	LD	L,A
	ADD	A,A
	SBC	A,A
	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

; parameter is not a constant

J$5CF4:	CALL	C.4F73			; generate LD A,non constant
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	CALL	GTPAD
	LD	L,A
	LD	H,0
	POP	AF
	ADD	A,04H
	AND	0F3H
	DEC	A
	CP	2
	JR	C,J$5D0F
	LD	A,L
	ADD	A,A
	SBC	A,A
	LD	H,A
J$5D0F:	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine PDL function
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D14:	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048			; check for BASIC character ")"
	CALL	C.6058			; copy code block in execution buffer

	CALL	GTPDL
	DEFW	0

	JP	J.5BAD

;	  Subroutine generate logical operation code
;	     Inputs  B = operand1 type, DE = operand2 handler
;	     Outputs ________________________

C.5D25:	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.5D49			; integer constant, integer constant
	DEFW	C.5D7C			; integer constant, variable
	DEFW	C.5D81			; integer constant, generated integer
	DEFW	C.5D7D			; variable, integer constant
	DEFW	C.5E32			; variable, variable
	DEFW	C.5E35			; variable, generated integer
	DEFW	C.5D82			; generated integer, integer constant
	DEFW	C.5E36			; generated integer, variable
	DEFW	C.5E3B			; generated integer, generated integer
	DEFW	C.5D68			; integer constant, generated float
	DEFW	C.5DFE			; variable, generated float
	DEFW	C.5E08			; generated integer, generated float
	DEFW	C.5D72			; generated float, integer constant
	DEFW	C.5E12			; generated float, variable
	DEFW	C.5E24			; generated float, generated integer
	DEFW	C.5E1C			; generated float, generated float

	RET

;	  Subroutine generate logical operation code, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D49:	OR	0E6H			; AND/OR/XOR xx
	LD	(BUF+9),A
	LD	A,0C9H			; RET
	LD	(BUF+11),A
	LD	A,E
	LD	(BUF+10),A		; xx
	LD	A,L
	CALL	BUF+9
	LD	L,A
	LD	A,D
	LD	(BUF+10),A
	LD	A,H
	CALL	BUF+9
	LD	H,A
	LD	B,0			; integer constant
	RET

;	  Subroutine generate logical operation code, integer constant, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D68:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	JR	C.5D81

;	  Subroutine generate logical operation code, generated float, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D72:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	JR	C.5D82

;	  Subroutine generate logical operation code, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D7C:	EX	DE,HL

;	  Subroutine generate logical operation code, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D7D:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine generate logical operation code, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D81:	EX	DE,HL

;	  Subroutine generate logical operation code, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5D82:	OR	0E6H
	LD	B,A
	LD	A,L
	CALL	C.5E64
	JR	Z,J.5DC0
	LD	A,L
	CALL	C.5E74
	JR	NZ,J$5D9B
	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	CPL
	LD	L,A
	DEFW	0

	JR	J.5DC0

J$5D9B:	LD	A,L
	CALL	C.5E7A
	JR	NZ,J$5DAC
	LD	A,2EH			; LD L,xx
	CALL	C.60B9			; put byte in execution buffer
	LD	A,L
	CALL	C.60B9			; put byte in execution buffer
	JR	J.5DC0

J$5DAC:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	LD	A,B
	CALL	C.60B9			; put byte in execution buffer
	LD	A,L
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	L,A
	DEFW	0

J.5DC0:	LD	A,H
	CALL	C.5E64
	JR	Z,J.5DFB
	LD	A,H
	CALL	C.5E74
	JR	NZ,J$5DD6
	CALL	C.6058			; copy code block in execution buffer

	LD	A,H
	CPL
	LD	H,A
	DEFW	0

	JR	J.5DFB

J$5DD6:	LD	A,H
	CALL	C.5E7A
	JR	NZ,J$5DE7
	LD	A,26H			; LD H,xx
	CALL	C.60B9			; put byte in execution buffer
	LD	A,H
	CALL	C.60B9			; put byte in execution buffer
	JR	J.5DFB

J$5DE7:	CALL	C.6058			; copy code block in execution buffer

	LD	A,H
	DEFW	0

	LD	A,B
	CALL	C.60B9			; put byte in execution buffer
	LD	A,H
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	H,A
	DEFW	0

J.5DFB:	LD	B,2			; result = generated integer
	RET

;	  Subroutine generate logical operation code, variable, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.5DFE:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	JR	C.5E35

;	  Subroutine generate logical operation code, generated integer, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E08:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	JR	C.5E3B

;	  Subroutine generate logical operation code, generated float, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E12:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

	JR	C.5E36

;	  Subroutine generate logical operation code, generated float, generated float
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E1C:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.7901			; covert float to integer
	DEFW	0

;	  Subroutine generate logical operation code, generated float, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E24:	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	POP	DE
	PUSH	HL
	EX	DE,HL
	CALL	C.7901			; covert float to integer
	DEFW	0

	JR	C.5E3B

;	  Subroutine generate logical operation code, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E32:	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine generate logical operation code, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E35:	EX	DE,HL

;	  Subroutine generate logical operation code, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E36:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J$5E41

;	  Subroutine generate logical operation code, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E3B:	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J$5E41:	LD	B,A
	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	DEFW	0

	LD	A,B
	OR	0A3H			; AND reg
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	L,A
	LD	A,H
	DEFW	0

	LD	A,B
	OR	0A2H			; AND reg
	CALL	C.60B9			; put byte in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	LD	H,A
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E64:	AND	A			; A=0 ?
	JR	Z,J$5E6D		; yep,
	INC	A			; A=FFH ?
	RET	NZ			; nope, quit
	LD	A,B
	CP	0E6H			; AND ?
	RET

J$5E6D:	LD	A,B
	CP	0F6H			; OR ?
	RET	Z			; yep, quit
	CP	0EEH			; XOR ?
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E74:	INC	A			; A=0FFH ?
	RET	NZ			; nope, quit
	LD	A,B
	CP	0EEH			; XOR ?
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.5E7A:	AND	A			; A=0 ?
	JR	Z,J$5E83		; yep,
	INC	A			; A=0FFH ?
	RET	NZ			; nope, quit
	LD	A,B
	CP	0F6H			; OR ?
	RET

J$5E83:	LD	A,B
	CP	0E6H			; AND ?
	RET

;	  Subroutine numeric compare
;	     Inputs  ________________________
;	     Outputs ________________________

C$5E87:	PUSH	HL
	PUSH	BC
	PUSH	AF
	LD	C,A
	LD	B,0
	LD	HL,I$50D0
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	BC
	POP	IY			; auxilair handler (used in operator handler) = compare handler
	POP	AF
	POP	BC
	POP	HL
	CALL	C.5F04			; invoke operator handler based on operand1 and operand2 type

	DEFW	C.5EC0			; integer constant, integer constant
	DEFW	C.5EC5			; integer constant, variable
	DEFW	C.5EC8			; integer constant, generated integer
	DEFW	C.5ECE			; variable, integer constant
	DEFW	C.5ED5			; variable, variable
	DEFW	C.5ED8			; variable, generated integer
	DEFW	C.5EDE			; generated integer, integer constant
	DEFW	C.5EE3			; generated integer, variable
	DEFW	C.5EE8			; generated integer, generated integer
	DEFW	C.60E1			; integer constant, generated float
	DEFW	C.60F1			; variable, generated float
	DEFW	C.60FE			; generated integer, generated float
	DEFW	C.6109			; generated float, integer constant
	DEFW	C.612B			; generated float, variable
	DEFW	C.612E			; generated float, generated integer
	DEFW	C.6131			; generated float, generated float
	
	LD	B,2			; result = generated integer
	RET

;	  Subroutine numeric compare, integer constant, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5EC0:	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	C.5EC8

;	  Subroutine numeric compare, integer constant, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5EC5:	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine numeric compare, integer constant, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5EC8:	EX	DE,HL
	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.5EEE

;	  Subroutine numeric compare, variable, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5ECE:	EX	DE,HL
	CALL	C.6086			; put LD HL,(var) in execution buffer
	EX	DE,HL
	JR	C.5EDE

;	  Subroutine numeric compare, variable, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5ED5:	CALL	C.6086			; put LD HL,(var) in execution buffer

;	  Subroutine numeric compare, variable, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5ED8:	EX	DE,HL
	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.5EEE

;	  Subroutine numeric compare, generated integer, integer constant
;	     Inputs  ________________________
;	     Outputs ________________________

C.5EDE:	CALL	C.6079			; put LD DE,xxxx in execution buffer
	JR	J.5EEF

;	  Subroutine numeric compare, generated integer, variable
;	     Inputs  ________________________
;	     Outputs ________________________

C.5EE3:	CALL	C.6096			; put LD DE,(var) in execution buffer
	JR	J.5EEF

;	  Subroutine numeric compare, generated integer, generated integer
;	     Inputs  ________________________
;	     Outputs ________________________

C.5EE8:	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	DEFW	0

J.5EEE:	INC	A
J.5EEF:	ADD	A,A
	LD	L,A
	LD	H,0
	LD	DE,I$50B4
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
J$5EFB:	LD	A,(HL)
	AND	A
	RET	Z
	CALL	C.60B9			; put byte in execution buffer
	INC	HL
	JR	J$5EFB

;	  Subroutine invoke operator handler based on operand1 and operand2 type
;	     Inputs  B = operand1 type, DE = operand2 handler
;	     Outputs ________________________

C.5F04:	INC	IX
	INC	B
	DJNZ	J$5F4A

; first argument = integer constant

	PUSH	HL
	PUSH	AF
	PUSH	IY
	CALL	C.6030			; call DE
	CALL	C.500B			; check for numeric
	POP	IY
	POP	AF
	POP	DE
	INC	B
	DJNZ	J$5F25

; first argument = integer constant, second argument = integer constant

	EX	(SP),IY
	LD	C,(IY+0)
	LD	B,(IY+1)
	JP	J.6020

J$5F25:	DJNZ	J$5F32

; first argument = integer constant, second argument = variable

	EX	(SP),IY
	LD	C,(IY+2)
	LD	B,(IY+3)
	JP	J.6020

J$5F32:	DJNZ	J$5F3F

; first argument = integer constant, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+4)
	LD	B,(IY+5)
	JP	J.6020

; first argument = integer constant, second argument = generated float

J$5F3F:	EX	(SP),IY
	LD	C,(IY+18)
	LD	B,(IY+19)
	JP	J.6020

J$5F4A:	DJNZ	J$5F8D

; first argument = variable

	PUSH	HL
	PUSH	AF
	PUSH	IY
	CALL	C.6030			; call DE
	CALL	C.500B			; check for numeric
	POP	IY
	POP	AF
	POP	DE
	INC	B
	DJNZ	J$5F68

; first argument = variable, second argument = integer constant

	EX	(SP),IY
	LD	C,(IY+6)
	LD	B,(IY+7)
	JP	J.6020

J$5F68:	DJNZ	J$5F75

; first argument = variable, second argument = variable

	EX	(SP),IY
	LD	C,(IY+8)
	LD	B,(IY+9)
	JP	J.6020

J$5F75:	DJNZ	J$5F82

; first argument = variable, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+10)
	LD	B,(IY+11)
	JP	J.6020

; first argument = variable, second argument = generated float

J$5F82:	EX	(SP),IY
	LD	C,(IY+20)
	LD	B,(IY+21)
	JP	J.6020

J$5F8D:	DJNZ	J$5FD6

; first argument = generated integer

	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	PUSH	AF
	PUSH	IY
	CALL	C.6030			; call DE
	CALL	C.500B			; check for numeric
	POP	IY
	POP	AF
	INC	B
	DJNZ	J$5FB1

; first argument = generated integer, second argument = integer constant

	CALL	C.60D7			; remove byte from execution buffer
	EX	(SP),IY
	LD	C,(IY+12)
	LD	B,(IY+13)
	JR	J.6020

J$5FB1:	DJNZ	J$5FC0

; first argument = generated integer, second argument = variable

	CALL	C.60D7			; remove byte from execution buffer
	EX	(SP),IY
	LD	C,(IY+14)
	LD	B,(IY+15)
	JR	J.6020

J$5FC0:	DJNZ	J$5FCC

; first argument = generated integer, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+16)
	LD	B,(IY+17)
	JR	J.6020

; first argument = generated integer, second argument = generated float

J$5FCC:	EX	(SP),IY
	LD	C,(IY+22)
	LD	B,(IY+23)
	JR	J.6020

J$5FD6:	DEC	B
	JP	NZ,J.4E10		; BASIC error: type mismatch

; first argument = generated float

	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	BC
	DEFW	0

	PUSH	AF
	PUSH	IY
	CALL	C.6030			; call DE
	CALL	C.500B			; check for numeric
	POP	IY
	POP	AF
	INC	B
	DJNZ	J$6000

; first argument = generated float, second argument = integer constant

	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	EX	(SP),IY
	LD	C,(IY+24)
	LD	B,(IY+25)
	JR	J.6020

J$6000:	DJNZ	J$600C

; first argument = generated float, second argument = variable

	EX	(SP),IY
	LD	C,(IY+26)
	LD	B,(IY+27)
	JR	J.6020

J$600C:	DJNZ	J$6018

; first argument = generated float, second argument = generated integer

	EX	(SP),IY
	LD	C,(IY+28)
	LD	B,(IY+29)
	JR	J.6020

; first argument = generated float, second argument = generated float

J$6018:	EX	(SP),IY
	LD	C,(IY+30)
	LD	B,(IY+31)

J.6020:	EX	(SP),IY
	CALL	C$602E			; call BC
	EX	(SP),HL
	PUSH	DE
	LD	DE,32
	ADD	HL,DE
	POP	DE
	EX	(SP),HL			; skip over table
	RET

;	  Subroutine call BC
;	     Inputs  ________________________
;	     Outputs ________________________

C$602E:	PUSH	BC
	RET

;	  Subroutine call DE
;	     Inputs  ________________________
;	     Outputs ________________________

C.6030:	PUSH	DE
	RET

;	  Subroutine get BASIC character, skip spaces
;	     Inputs  ________________________
;	     Outputs ________________________

C.6032:	LD	A,(IX+0)
	CP	" "
	RET	NZ
	INC	IX
	JR	C.6032

;	  Subroutine check for BASIC token =
;	     Inputs  ________________________
;	     Outputs ________________________

C.603C:	LD	A,0EFH			; = token
	JR	C.604A			; check for BASIC character

;	  Subroutine check for BASIC character ","
;	     Inputs  ________________________
;	     Outputs ________________________

C.6040:	LD	A,","
	JR	C.604A			; check for BASIC character

;	  Subroutine check for BASIC character "("
;	     Inputs  ________________________
;	     Outputs ________________________

C.6044:	LD	A,"("
	JR	C.604A			; check for BASIC character

;	  Subroutine check for BASIC character ")"
;	     Inputs  ________________________
;	     Outputs ________________________

C.6048:	LD	A,")"

;	  Subroutine check for BASIC character
;	     Inputs  ________________________
;	     Outputs ________________________

C.604A:	PUSH	AF
	CALL	C.6032			; get BASIC character, skip spaces
	POP	AF
	CP	(IX+0)
	JP	NZ,J.4E16		; BASIC error: syntax error
	INC	IX
	RET

;	  Subroutine copy code block in execution buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C.6058:	EX	(SP),IX
	PUSH	AF
J$605B:	LD	A,(IX+0)
	INC	IX
	AND	A
	JR	Z,J$6068
J.6063:	CALL	C.60B9			; put byte in execution buffer
	JR	J$605B

J$6068:	XOR	A
	CP	(IX+0)
	JR	NZ,J.6063
	CP	(IX+1)
	JR	Z,J.6063
	INC	IX
	POP	AF
	EX	(SP),IX
	RET

;	  Subroutine put LD DE,xxxx in execution buffer
;	     Inputs  HL = xxxx
;	     Outputs ________________________

C.6079:	PUSH	AF
	LD	A,11H			; LD DE,xxxx
	JR	J$6081

;	  Subroutine put LD HL,xxxx in execution buffer
;	     Inputs  HL = xxxx
;	     Outputs ________________________

C.607E:	PUSH	AF
	LD	A,21H			; LD HL,xxxx
J$6081:	CALL	C.60AB			; put 3 bytes in execution buffer
	POP	AF
	RET

;	  Subroutine put LD HL,(var) in execution buffer
;	     Inputs  HL = var
;	     Outputs ________________________

C.6086:	PUSH	AF
	LD	A,2AH			; LD HL,(xxxx)
	JR	J$608E

;	  Subroutine put LD (var),HL in execution buffer (AF retained)
;	     Inputs  HL = var
;	     Outputs ________________________

C.608B:	PUSH	AF
	LD	A,22H			; LD (xxxx),HL
J$608E:	CALL	C.60B9			; put byte in execution buffer
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	POP	AF
	RET

;	  Subroutine put LD DE,(var) in execution buffer
;	     Inputs  HL = var
;	     Outputs ________________________

C.6096:	PUSH	AF
	PUSH	HL
	LD	HL,5BEDH		; LD DE,(xxxx)
	JR	J$60A2

;	  Subroutine put LD (var),DE in execution buffer
;	     Inputs  HL = var
;	     Outputs ________________________

?.609D:	PUSH	AF
	PUSH	HL
	LD	HL,53EDH		; LD (xxxx),DE
J$60A2:	CALL	C.60AE			; put word in execution buffer
	POP	HL
	CALL	C.62E7			; create simple variable if needed, generate variable address code
	POP	AF
	RET

;	  Subroutine put 3 bytes in execution buffer
;	     Inputs  A = byte1, H = byte2, L = byte3
;	     Outputs ________________________

C.60AB:	CALL	C.60B9			; put byte in execution buffer

;	  Subroutine put word in execution buffer
;	     Inputs  HL = word
;	     Outputs ________________________

C.60AE:	PUSH	AF
	LD	A,L
	CALL	C.60B9			; put byte in execution buffer
	LD	A,H
	CALL	C.60B9			; put byte in execution buffer
	POP	AF
	RET

;	  Subroutine put byte in execution buffer
;	     Inputs  A = byte
;	     Outputs ________________________

C.60B9:	PUSH	HL
	LD	HL,(BUF+2)		; current compiled code pointer
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+23)		; end of variable list
	AND	A
	SBC	HL,DE
	POP	DE
	POP	HL
	JP	NC,J.4E1F		; BASIC error: out of memory
	LD	(HL),A
	INC	HL
	LD	(BUF+2),HL		; update current compiled code pointer
	LD	HL,BUF+4
	LD	(HL),1			; bytes in the execution buffer
	POP	HL
	RET

;	  Subroutine remove byte from execution buffer
;	     Inputs  ________________________
;	     Outputs ________________________

C.60D7:	PUSH	HL
	LD	HL,(BUF+2)		; current compiled code pointer
	DEC	HL
	LD	(BUF+2),HL		; update current compiled code pointer
	POP	HL
	RET

;	  Subroutine generic handler, integer constant, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.60E1:	CALL	C.6058			; copy code block in execution buffer

	EX	DE,HL
	LD	C,B
	DEFW	0

	EX	DE,HL
	CALL	C.78DF			; convert integer to float
	CALL	C.4FCA			; generate load float code
	JR	J.613B			; generate CALL operator handler and quit

;	  Subroutine generic handler, variable, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.60F1:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	BC
	DEFW	0

	EX	DE,HL
	CALL	C.6086			; put LD HL,(xxxx) in execution buffer
	JR	C.611E

;	  Subroutine generic handler, generated integer, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.60FE:	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	PUSH	HL
	PUSH	BC
	EX	DE,HL
	DEFW	0

	JR	C.611E

;	  Subroutine generic handler, generated float, integer constant
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.6109:	CALL	C.78DF			; convert integer to float
	LD	A,0EH			; LD C,xx
	CALL	C.60B9			; put byte in execution buffer
	LD	A,B
	CALL	C.60B9			; put byte in execution buffer
	AND	A
	CALL	NZ,C.6079		; yep, put LD DE,xxxx in execution buffer
	JR	J.613B			; generate CALL operator handler and quit


C.611B:	CALL	C.6086			; put LD HL,(xxxx) in execution buffer
C.611E:	CALL	C.6140			; generate convert integer to float code
C.6121:	CALL	C.6058			; copy code block in execution buffer

	POP	AF
	LD	C,A
	POP	DE
	DEFW	0

	JR	J.613B			; generate CALL operator handler and quit

;	  Subroutine generic handler, generated float, variable
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.612B:	CALL	C.6086			; put LD HL,(xxxx) in execution buffer

;	  Subroutine generic handler, generated float, generated integer
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.612E:	CALL	C.6140			; generate convert integer to float code

;	  Subroutine generic handler, generated float, generated float
;	     Inputs  IY = operator handler
;	     Outputs ________________________

C.6131:	CALL	C.6058			; copy code block in execution buffer

	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	DEFW	0


J.613B:	LD	B,3			; result = generated float
	JP	J$53EB			; generate CALL operator handler

;	  Subroutine generate convert integer to float code
;	     Inputs  ________________________
;	     Outputs ________________________

C.6140:	CALL	C.6058			; copy code block in execution buffer

	CALL	C.78DF			; convert integer to float
	DEFW	0

	RET

;	  Subroutine LEFT$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6149:	LD	HL,I$7E42		; left of string handler
	JR	J$6151

;	  Subroutine RIGHT$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.614E:	LD	HL,I$7E49		; right of string handler
J$6151:	PUSH	HL
	CALL	C.4FFE			; evaluate string expression
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	POP	HL
	DEFW	0

	POP	HL
	LD	A,0CDH			; CALL xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	LD	B,4			; result = generated string
	RET

;	  Subroutine MID$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6173:	CALL	C.4FFE			; evaluate string expression
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$619F
	INC	IX
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	DEFW	0

	JR	J$61AA

J$619F:	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	LD	A,0FFH
	DEFW	0

J$61AA:	CALL	C.6058			; copy code block in execution buffer

	POP	HL
	CALL	C$7E5A
	DEFW	0

	LD	B,4			; result = generated string
	RET

;	  Subroutine MID$ statement
;	     Inputs  ________________________
;	     Outputs ________________________

J$61B6:	CALL	C.6044			; check for BASIC character "("
	CALL	C.5BDE
	BIT	5,A			; string variable ?
	JP	Z,J.4E10		; nope, BASIC error: type mismatch
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$61E1
	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J$61E8

J$61E1:	CALL	C.6058			; copy code block in execution buffer

	LD	A,0FFH
	DEFW	0

J$61E8:	CALL	C.6048
	CALL	C.603C			; check for BASIC token =
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.4FFE			; evaluate string expression
	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	POP	AF
	POP	DE
	CALL	C$7E81
	DEFW	0

	RET

;	  Subroutine HEX$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6203:	LD	HL,I$7EC3		; hex handler
	JR	J.6210

;	  Subroutine OCT$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6208:	LD	HL,I$7EC6		; oct handler
	JR	J.6210

;	  Subroutine BIN$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.620D:	LD	HL,I$7EC9		; bin handler
J.6210:	PUSH	HL
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	JR	J$6222

;	  Subroutine SPACE$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6216:	LD	HL,I$7EEF		; space handler
	JR	J$621E

;	  Subroutine CHR$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.621B:	LD	HL,I$7EA8		; chr handler
J$621E:	PUSH	HL
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
J$6222:	CALL	C.6048
	POP	HL
	JR	J.626B

; STRING$ function

J$6228:	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.5012			; evaluate expression
	CALL	C.6048
	LD	A,B
	CP	04H
	JR	Z,J$6247
	CALL	C.4F57			; generate LD A,byte operand code
	JR	J$624E

J$6247:	CALL	C.6058			; copy code block in execution buffer

	INC	HL
	LD	A,(HL)
	DEFW	0

J$624E:	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	CALL	C$7EF2
	DEFW	0

	LD	B,4			; result = generated string
	RET

;	  Subroutine STR$ function
;	     Inputs  ________________________
;	     Outputs ________________________

C.625A:	CALL	C.4FDA			; evaluate numeric expression and generate appropriate code
	CALL	C.6048
	LD	A,B
	CP	2			; generated integer ?
	LD	HL,C.7BD1		; integer to text
	JR	Z,J.626B		; yep,
	LD	HL,C.7C2B		; float to text
J.626B:	LD	A,0CDH			; CALL xxxx
	CALL	C.60AB			; put 3 bytes in execution buffer
	LD	B,4			; result = generated string
	RET

;	  Subroutine LEN function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6273:	CALL	C.4FFE			; evaluate string expression
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	LD	L,(HL)
	LD	H,0
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine ASC function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6284:	CALL	C.4FFE			; evaluate string expression
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	INC	HL
	LD	L,(HL)
	LD	H,0
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine VAL function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6296:	CALL	C.4FFE			; evaluate string expression
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$7EB0
	DEFW	0

	LD	B,3			; result = generated float
	RET

; INSTR function

J$62A7:	CALL	C.6044			; check for BASIC character "("
	CALL	C.5012			; evaluate expression
	CALL	C.6040			; check for BASIC character ","
	LD	A,B
	CP	4			; string ?
	JR	Z,J$62C6		; yep,
	CALL	C.4F57			; generate LD A,byte operand code
	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	DEFW	0

	CALL	C.4FFE			; evaluate string expression
	CALL	C.6040			; check for BASIC character ","
	JR	J$62CE

J$62C6:	CALL	C.6058			; copy code block in execution buffer

	LD	A,1
	PUSH	AF
	DEFW	0

J$62CE:	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	DEFW	0

	CALL	C.4FFE			; evaluate string expression
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	POP	AF
	CALL	C$7F15
	DEFW	0

	LD	B,2			; result = generated integer
	RET

;	  Subroutine create simple variable if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=0, b5=0

C.62E7:	RES	7,L			; b7=0
	JR	J$62F3

;	  Subroutine create FOR variable (variable end value) if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=1, b5=0

C.62EB:	RES	7,L			; b7=0
	SET	6,L			; b6=1
	JR	J$62F5

;	  Subroutine create FOR variable (variable step value) if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=0, b5=0

C.62F1:	SET	7,L			; b7=1
J$62F3:	RES	6,L			; b6=0
J$62F5:	RES	5,L			; b5=0
	RES	7,H			; simple variable
	JR	J$631B

;	  Subroutine create array variable if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=0, b5=0

C$62FB:	RES	7,L			; b7=0
	RES	6,L			; b6=0
	JR	J.630F

;	  Subroutine create FOR variable (end value and step value flags) if needed, generate variable address code
;	     Inputs  HL = variable, DE = ?, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=0, b6=1, b5=0

C.6301:	RES	7,L			; b7=0
	JR	J$630D

;	  Subroutine create FOR variable (constant end value) if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=0, b5=0

C$6305:	SET	7,L			; b7=1
	RES	6,L			; b6=0
	JR	J.630F

;	  Subroutine create FOR variable (constant step value) if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=1, b5=0

C.630B:	SET	7,L			; b7=1
J$630D:	SET	6,L			; b6=1
J.630F:	RES	5,L			; b5=0
	JR	J$6319

;	  Subroutine create FOR variable (code pointer start FOR) if needed, generate variable address code
;	     Inputs  HL = variable, C = 0 (variable address only), 02H (store at variable), 0AH (fetch from variable)
;	     Outputs ________________________
; b7=1, b6=1, b5=1

J$6313:	SET	7,L			; b7=1
	SET	6,L			; b6=1
	SET	5,L			; b5=1
J$6319:	SET	7,H			; array variable
J$631B:	PUSH	IX
	PUSH	HL
	PUSH	DE
	CALL	C$6327			; create variable if needed
	POP	DE
	POP	HL
	POP	IX
	RET

;	  Subroutine create variable if needed
;	     Inputs  ________________________
;	     Outputs ________________________

C$6327:	LD	IX,(BUF+21)		; start of variable list
J.632B:	LD	A,(IX+0)
	AND	A			; end of variable list ?
	JR	Z,J$638F		; yep, register new variable
	CP	L
	LD	A,(IX+1)
	DEC	IX
	DEC	IX
	DEC	IX
	DEC	IX
	JR	NZ,J.632B		; not found, try again
	CP	H
	JR	NZ,J.632B		; not found, try again
	BIT	7,H			; array variable ?
	JR	NZ,J$637F		; yep,
	LD	A,H
	LD	E,(IX+6)
	LD	D,(IX+7)		; address variable
	PUSH	DE
	SET	7,D			; b7=1
	LD	HL,(STREND)
	AND	A
	SBC	HL,DE			; above STREND ?
	POP	DE
	JR	NC,J$637B		; nope,
	BIT	6,A			; b6=0 ?
	LD	HL,(BUF+2)		; current compiled code pointer
	JR	Z,C.6371		; yep,
	LD	A,C
	AND	A			; C=0 (address only) ?
	JR	Z,J$636F		; yep,
	OR	30H			; LD (xxxx),A or LD A,(xxxx)
	CALL	C.60B9			; put byte in execution buffer
	INC	HL
	CALL	C.6371			; update address variable, put word in execution buffer
	JR	J$63CD			; generate fetch or store HL code and quit

J$636F:	RES	7,H			; simple variable

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.6371:	LD	(IX+6),L
	LD	(IX+7),H		; update address variable
	EX	DE,HL
	JP	C.60AE			; put word in execution buffer and quit

J$637B:	EX	DE,HL
	JP	C.60AE			; put word in execution buffer

J$637F:	BIT	7,L			; b7=1 ?
	JR	NZ,J$6388		; yep,
	BIT	6,L			; b6=0 ?
	JP	Z,J.4E22		; yep, BASIC error: redemensioned array
J$6388:	LD	(IX+6),E
	LD	(IX+7),D
	RET

J$638F:	LD	(IX+0),L
	LD	(IX+1),H		; variable
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+2)		; current compiled code pointer
	PUSH	IX
	POP	HL
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(BUF+23),HL		; update end of variable list
	XOR	A
	LD	(HL),A			; end marker variable list
	SBC	HL,DE			; any memory left ?
	POP	DE
	POP	HL
	JP	C,J.4E1F		; nope, BASIC error: out of memory
	BIT	7,H			; b7=0 ?
	JR	Z,J$63B9		; yep,
	LD	(IX+2),E
	LD	(IX+3),D		; address variable
	RET

J$63B9:	BIT	6,H			; b6=0 ?
	LD	HL,(BUF+2)		; current compiled code pointer
	JR	Z,C.63D5		; yep,
	LD	A,C
	AND	A			; C=0 ?
	JR	Z,J$63D3		; yep,
	OR	30H			; LD A,(xxxx) or LD (xxxx),A
	CALL	C.60B9			; put byte in execution buffer
	INC	HL
	CALL	C.63D5
J$63CD:	LD	A,C
	OR	20H			; LD HL,(xxxx) or LD (xxxx),HL
	JP	C.60AB			; put 3 bytes in execution buffer and quit

J$63D3:	RES	7,H			; simple variable

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.63D5:	LD	(IX+2),L
	LD	(IX+3),H
	LD	HL,0
	JP	C.60AE			; put word in execution buffer

;	  Subroutine register simple variable reference
;	     Inputs  HL = variable, DE = address
;	     Outputs ________________________

C$63E1:	RES	7,H			; simple variable
	JR	J$63E7

;	  Subroutine register array variable reference
;	     Inputs  HL = variable, DE = address
;	     Outputs ________________________

C$63E5:	SET	7,H			; array variable
J$63E7:	RES	7,L
	RES	6,L
	RES	5,L
	PUSH	IX
	PUSH	HL
	PUSH	DE
	LD	IX,(BUF+21)		; start of variable list
J.63F5:	LD	A,(IX+0)
	AND	A			; end of variable list ?
	JR	Z,J$6411		; yep, add to variable list
	CP	L
	LD	A,(IX+1)
	DEC	IX
	DEC	IX
	DEC	IX
	DEC	IX
	JR	NZ,J.63F5
	CP	H
	JR	NZ,J.63F5
	POP	DE
	POP	HL
	POP	IX
	RET

J$6411:	LD	(IX+0),L
	LD	(IX+1),H		; register variable
	PUSH	HL
	PUSH	DE
	LD	DE,(BUF+2)		; current compiled code pointer
	PUSH	IX
	POP	HL
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(BUF+23),HL		; end of variable list
	XOR	A
	LD	(HL),A			; end marker
	SBC	HL,DE
	POP	DE
	POP	HL
	JP	C,J.4E1F		; BASIC error: out of memory
	LD	(IX+2),E
	LD	(IX+3),D		; address variable
	POP	DE
	POP	HL
	POP	IX
	RET

;	  Subroutine fetch address of array variable
;	     Inputs  ________________________
;	     Outputs ________________________
; b7=0, b6=0, b5=0

C$643B:	RES	7,L
	JR	J$6445

;	  Subroutine fetch address FOR variable (end value and step value flags)
;	     Inputs  ________________________
;	     Outputs ________________________
; b7=0, b6=1, b5=0

C.643F:	RES	7,L
	JR	J$644B

;	  Subroutine fetch address FOR variable (constant end value)
;	     Inputs  ________________________
;	     Outputs ________________________
; b7=1, b6=0, b5=0

C$6443:	SET	7,L
J$6445:	RES	6,L
	JR	J$644D

;	  Subroutine fetch address FOR variable (constant step value)
;	     Inputs  ________________________
;	     Outputs ________________________
; b7=1, b6=1, b5=0

C$6449:	SET	7,L
J$644B:	SET	6,L
J$644D:	RES	5,L
	JR	J$6457

;	  Subroutine fetch address FOR variable (code pointer start FOR)
;	     Inputs  ________________________
;	     Outputs ________________________
; b7=1, b6=1, b5=1

C.6451:	SET	7,L
	SET	6,L
	SET	5,L
J$6457:	SET	7,H
	PUSH	IX
	LD	IX,(BUF+21)		; start of variable list
J.645F:	LD	A,(IX+0)
	AND	A			; end of variable list ?
	JR	Z,J$647F		; yep (not found), generate error
	CP	L			; variable found ?
	LD	A,(IX+1)
	DEC	IX
	DEC	IX
	DEC	IX
	DEC	IX
	JR	NZ,J.645F		; nope, try next
	CP	H			; variable found ?
	JR	NZ,J.645F		; nope, try next
	LD	E,(IX+6)
	LD	D,(IX+7)		; address variable
	POP	IX
	RET

J$647F:	BIT	7,L
	JP	NZ,J.4E1C		; BASIC error: next without for
	BIT	6,L
	JP	NZ,J.4E1C		; BASIC error: next without for
	JP	J.4E25			; BASIC error: subscript out of range

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$648C:	LD	IX,(BUF+23)		; end of variable list
	LD	DE,(BUF+2)		; current compiled code pointer
J.6494:	INC	IX
	INC	IX
	INC	IX
	INC	IX
	LD	HL,(BUF+21)		; start of variable list
	PUSH	IX
	POP	BC
	AND	A
	SBC	HL,BC
	RET	C
	BIT	7,(IX+1)
	JR	NZ,J.6494		; next
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	SET	7,H
	LD	BC,(STREND)
	SBC	HL,BC
	POP	HL
	JR	C,J.6494
	BIT	6,(IX+1)
	JR	NZ,J$64E4
	XOR	A
	LD	(DE),A
	INC	DE
	LD	(DE),A
	DEC	DE
J$64C9:	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	LD	(HL),D
	DEC	HL
	LD	(HL),E
	LD	L,C
	LD	H,B
	LD	A,L
	OR	H
	JR	NZ,J$64C9
	BIT	5,(IX+1)
	JR	Z,J.64E0
	LD	HL,254
	ADD	HL,DE
	EX	DE,HL
J.64E0:	INC	DE
	INC	DE
	JR	J.6494

J$64E4:	XOR	A
	LD	(DE),A
J$64E6:	BIT	7,H
	SET	7,H
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	DEC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JR	Z,J$64FA
	INC	HL
	INC	HL
	INC	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEC	DE
J$64FA:	LD	L,C
	LD	H,B
	LD	A,L
	OR	H
	JR	NZ,J$64E6
	INC	DE
	JR	J.64E0

;	  Subroutine fetch variable name
;	     Inputs  ________________________
;	     Outputs L = first variable letter, H = second variable letter (b5 set if string, b6 set if float)

C.6503:	CALL	C.6032			; get BASIC character, skip spaces
	CALL	C.7E39			; to upper
	CP	"A"
	JP	C,J.4E16		; not a letter, BASIC error: syntax error
	CP	"Z"+1
	JP	NC,J.4E16		; not a letter, BASIC error: syntax error
	LD	L,A			; first variable letter
	LD	H,0			; second variable letter clear
J.6516:	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	"!"			; single real type indicator ?
	JR	Z,J.656D		; yep, finish float variable
	CP	"#"			; double real type indicator ?
	JR	Z,J.656D		; yep, finish float variable
	CP	"%"			; integer type indicator ?
	JR	Z,J.654E		; yep, finsh integer variable
	CP	"$"			; string type indicator ?
	JR	Z,J.6545		; yep, finish string variable
	CALL	C.7E39			; to upper
	CP	"0"
	JR	C,J.655A
	CP	"9"+1
	JR	C,J$653E		; digit, valid variable name character
	CP	"A"
	JR	C,J.655A
	CP	"Z"+1
	JR	NC,J.655A
J$653E:	INC	H
	DEC	H			; second variable name character ?
	JR	NZ,J.6516		; nope, ignore and continue
	LD	H,A			; second variable letter/digit
	JR	J.6516

; finish string variable

J.6545:	CALL	C.6576
	RES	6,H
	SET	5,H			; type string
	JR	J.6555

; finish integer variable

J.654E:	CALL	C.6576
	RES	6,H
	RES	5,H			; type integer
J.6555:	INC	IX
	JP	C.6032			; get BASIC character, skip spaces

J.655A:	PUSH	HL
	PUSH	BC
	LD	BC,DEFTBL-"A"
	LD	H,0
	ADD	HL,BC
	LD	A,(HL)			; default variable type
	POP	BC
	POP	HL
	DEC	IX
	SUB	3			; string ?
	JR	Z,J.6545		; yep, finish string variable
	JR	C,J.654E		; integer, finish integer variable

; finish float variable

J.656D:	CALL	C.6576
	SET	6,H
	RES	5,H			; type float
	JR	J.6555

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.6576:	PUSH	DE
	PUSH	BC
	LD	(SWPTMP),HL		; register variable name
	PUSH	HL
	LD	A,L
	SUB	"A"
	LD	L,A
	LD	H,0
	LD	DE,37
	CALL	C.7624			; multiply
	POP	AF
	AND	A			; variable name more as 1 character ?
	JR	Z,J$6594		; nope,
	CP	"A"
	JR	C,J$6592
	SUB	07H
J$6592:	SUB	2FH
J$6594:	LD	E,A
	LD	D,0
	ADD	HL,DE
	LD	DE,31
	CALL	C.7643			; divide
	LD	H,L
	LD	L,E
	INC	L
	POP	BC
	POP	DE
	RET

;	  Subroutine COLOR
;	     Inputs  ________________________
;	     Outputs ________________________

C.65A4:	CALL	C.4F00			; end of line or statement ?
	JP	Z,J.6683
	CP	0C7H
	JP	Z,J$669D
	CP	0EFH
	JP	NZ,J$663C
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	94H			; NEW token ?
	JP	Z,J.6683		; yep,
	CP	8CH			; RESTORE token ?
	JP	Z,J$6690		; yep,
	CP	"("
	JP	NZ,J.4E16		; BASIC error: syntax error
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6A6F			; generate PUSH AF
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$65E9
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6A6F			; generate PUSH AF
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$661E
	JR	J$65F1

J$65E9:	CALL	C.6058			; copy code block in execution buffer

	LD	A,0FFH
	PUSH	AF
	DEFW	0

J$65F1:	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$6609
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6A6F			; generate PUSH AF
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$6626
	JR	J$6611

J$6609:	CALL	C.6058			; copy code block in execution buffer

	LD	A,0FFH
	PUSH	AF
	DEFW	0
J$6611:	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

	JR	J$662D

J$661E:	CALL	C.6058			; copy code block in execution buffer

	LD	A,0FFH
	PUSH	AF
	DEFW	0

J$6626:	CALL	C.6058			; copy code block in execution buffer

	LD	B,0FFH
	DEFW	0

J$662D:	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	POP	HL
	POP	DE
	POP	AF
	CALL	C$710E
	DEFW	0

	RET

J$663C:	CP	","
	JR	Z,J$6652
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	(FORCLR),A
	DEFW	0

	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J.667A
J$6652:	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$666D
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	(BAKCLR),A
	DEFW	0

	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J.667A
J$666D:	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	(BDRCLR),A
	DEFW	0

J.667A:	CALL	C.6058			; copy code block in execution buffer

	CALL	CHGCLR
	DEFW	0

	RET

J.6683:	CALL	C.6058			; copy code block in execution buffer

	LD	IX,S.INIPLT
	CALL	EXTROM
	DEFW	0

	RET

J$6690:	CALL	C.6058			; copy code block in execution buffer

	LD	IX,S.RSTPLT
	CALL	EXTROM
	DEFW	0

	RET

J$669D:	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	"$"
	PUSH	AF
	JR	NZ,J$66A9
	INC	IX
J$66A9:	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048
	CALL	C.603C			; check for BASIC token =
	CALL	C.6A6F			; generate PUSH AF
	POP	AF
	JR	Z,J$66C8
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	CALL	C$7189
	DEFW	0

	RET

J$66C8:	CALL	C.4FFE			; evaluate string expression
	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	CALL	C$7194
	DEFW	0

	RET

;	  Subroutine LINE
;	     Inputs  ________________________
;	     Outputs ________________________

C.66D5:	CALL	C.6032			; get BASIC character, skip spaces
	CP	0F2H			; - token ?
	JR	NZ,J$66ED		; nope,
	CALL	C.6058			; copy code block in execution buffer

	LD	HL,(GRPACX)
	PUSH	HL
	LD	HL,(GRPACY)
	PUSH	HL
	DEFW	0

	INC	IX
	JR	J$66FB

J$66ED:	CALL	C.6B8B
	LD	A,0F2H			; - token
	CALL	C.604A			; check for BASIC character
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.6A6A			; generate PUSH HL
J$66FB:	CALL	C.6B8B
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J.673D
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J.673D
	CALL	C.6058			; copy code block in execution buffer

	PUSH	DE
	PUSH	HL
	DEFW	0

	CALL	C.4FA9			; evaluate integer operand
	INC	B
	DJNZ	J$6726
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.4F5A			; generate LD A,constant code
	JR	J.6745

J$6726:	DJNZ	J$6733
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.4F75			; load A from (HL)
	JR	J.6745

J$6733:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	POP	HL
	POP	DE
	DEFW	0

	JR	J.6745

J.673D:	CALL	C.6058			; copy code block in execution buffer

	LD	A,(FORCLR)
	DEFW	0

J.6745:	CALL	C.6058			; copy code block in execution buffer

	POP	IY
	POP	IX
	DEFW	0

	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	LD	DE,C.6DA9		; draw line
	JR	NZ,J.6777
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J.6777
	CP	"B"
	JP	NZ,J.4E16		; BASIC error: syntax error
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	"F"
	LD	DE,I$6D4B		; draw box
	JR	NZ,J.6777
	INC	IX
	LD	DE,I$6E29		; draw filled box
J.6777:	JP	J.67D1

;	  Subroutine PSET
;	     Inputs  ________________________
;	     Outputs ________________________

C.677A:	DEFB	0F6H

;	  Subroutine PRESET
;	     Inputs  ________________________
;	     Outputs ________________________

C.677B:	XOR	A
	PUSH	AF
	CALL	C.6B8B
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J.67C0
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J.67C0
	POP	AF
	CALL	C.6058			; copy code block in execution buffer

	PUSH	HL
	PUSH	DE
	DEFW	0

	CALL	C.4FA9			; evaluate integer operand
	INC	B
	DJNZ	J$67A9

; B=0

	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.4F5A			; generate LD A,constant code
	JR	J.67CE

J$67A9:	DJNZ	J$67B6

; B=1

	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.4F75
	JR	J.67CE

; B>1

J$67B6:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	POP	DE
	POP	HL
	DEFW	0

	JR	J.67CE

J.67C0:	POP	AF
	LD	HL,FORCLR
	JR	NZ,J$67C9
	LD	HL,BAKCLR
J$67C9:	LD	A,3AH			; LD A,(xxxx)
	CALL	C.60AB			; put 3 bytes in execution buffer
J.67CE:	LD	DE,I$6F73		; draw point
J.67D1:	CALL	C$67DA			; evaluate optional graphic operation
	EX	DE,HL
J.67D5:	LD	A,0CDH			; CALL xxxx
	JP	C.60AB			; put 3 bytes in execution buffer

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$67DA:	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$6811
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	"T"
	JR	Z,J$6818
	CP	0D9H			; TO token ?
	JR	Z,J$6832
	CP	0FFH			; function token ?
	JR	Z,J$6840		; yep,
	CP	0F8H			; XOR token ?
	LD	H,03H
	JR	Z,J.6813
	CP	0F7H			; OR token ?
	LD	H,2
	JR	Z,J.6813
	CP	0F6H			; AND token ?
	LD	H,01H
	JR	Z,J.6813
	CP	0C3H			; PRESET token ?
	LD	H,04H
	JR	Z,J.6813
	CP	0C2H			; PSET token ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
J$6811:	LD	H,0
J.6813:	LD	L,6
	JP	C.60AE			; put word in execution buffer

J$6818:	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	0F8H			; XOR token ?
	LD	H,0BH
	JR	Z,J.6813
	CP	0C3H			; PRESET token ?
	LD	H,0CH
	JR	Z,J.6813
	CP	0C2H			; PSET token ?
	LD	H,08H
	JR	Z,J.6813
	JP	J.4E16			; nope, BASIC error: syntax error

J$6832:	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	"R"
	LD	H,0AH
	JR	Z,J.6813
	JP	J.4E16			; nope, BASIC error: syntax error

J$6840:	LD	A,8DH			; GOSUB token
	CALL	C.604A			; check for BASIC character
	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	"D"
	LD	H,09H	; 9 
	JR	Z,J.6813
	JP	J.4E16			; BASIC error: syntax error

;	  Subroutine CIRCLE
;	     Inputs  ________________________
;	     Outputs ________________________

C.6853:	CALL	C.6B8B
	CALL	C.6040			; check for BASIC character ","
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$6872
	INC	IX
	CALL	C.6A6A			; generate PUSH HL
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	LD	A,0E1H			; POP HL
	CALL	C.60B9			; put byte in execution buffer
	JR	J$687A

J$6872:	CALL	C.6058			; copy code block in execution buffer

	LD	A,(FORCLR)
	DEFW	0

J$687A:	LD	HL,I$74DC		; circle
	JP	J.67D5

;	  Subroutine PUT
;	     Inputs  ________________________
;	     Outputs ________________________

C.6880:	LD	A,0C7H			; SPRITE token
	CALL	C.604A			; check for BASIC character
	XOR	A
	PUSH	AF
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6A6F			; generate PUSH AF
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$68AD
	CALL	C.6B8B
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.6A6A			; generate PUSH HL
	POP	AF
	OR	80H
	PUSH	AF
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$68B4
	JR	J$68E4

J$68AD:	CALL	C.6058			; copy code block in execution buffer

	PUSH	AF
	PUSH	AF
	DEFW	0

J$68B4:	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$68D0
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6A6F			; generate PUSH AF
	POP	AF
	OR	40H
	PUSH	AF
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$68D3
	JR	J.68E7

J$68D0:	CALL	C.6A6F			; generate PUSH AF
J$68D3:	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	H,A
	DEFW	0

	POP	AF
	OR	20H
	PUSH	AF
	JR	J.68E7

J$68E4:	CALL	C.6A6F			; generate PUSH AF
J.68E7:	POP	HL
	LD	L,6
	CALL	C.60AE			; put word in execution buffer
	CALL	C.6058			; copy code block in execution buffer

	POP	DE
	POP	IY
	POP	IX
	POP	AF
	CALL	C$71BF
	DEFW	0

	RET

J$68FC:	INC	IX
	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048
	CALL	C.603C			; check for BASIC token =
	CALL	C.6A6F			; generate PUSH AF
	CALL	C.4FFE			; evaluate string expression
	CALL	C.6058			; copy code block in execution buffer

	POP	AF
	CALL	C$7145
	DEFW	0

	RET

; SPRITE function

J$691A:	LD	A,"$"
	CALL	C.604A			; check for BASIC character
	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$716E
	DEFW	0

	LD	B,4			; result = generated string
	RET

;	  Subroutine SCREEN statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.6933:	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$694B
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$7369
	DEFW	0

	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	RET	NZ
J$694B:	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	LD	HL,I$70BE		; set sprite mode
	JP	J.67D5

;	  Subroutine CLS statement
;	     Inputs  ________________________
;	     Outputs ________________________

C.6956:	LD	HL,I$6CE3		; clear screen
	JP	J.67D5

;	  Subroutine VPOKE
;	     Inputs  ________________________
;	     Outputs ________________________

C.695C:	CALL	C.4FA9			; evaluate integer operand
	CALL	C.6040			; check for BASIC character ","
	INC	B
	DJNZ	J$696F

; B=0

	PUSH	HL
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	POP	HL
	CALL	C.607E			; put LD HL,xxxx in execution buffer
	JR	J.699D

J$696F:	DJNZ	J$697B

; B=1

	PUSH	HL
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	POP	HL
	CALL	C.6086			; put LD HL,(xxxx) in execution buffer
	JR	J.699D

; B>2

J$697B:	CALL	C.6A6A			; generate PUSH HL
	CALL	C.4FA9			; evaluate integer operand
	INC	B
	DJNZ	J$698C

; B=3

	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.4F5A			; generate LD A,constant code
	JR	J.699D

; B>3

J$698C:	DJNZ	J$6996
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.4F75
	JR	J.699D

J$6996:	CALL	C.6058			; copy code block in execution buffer

	LD	A,L
	POP	HL
	DEFW	0

J.699D:	LD	HL,I$70B7		; write VRAM
	JP	J.67D5

;	  Subroutine SET
;	     Inputs  ________________________
;	     Outputs ________________________

C.69A3:	CALL	C.6032			; get BASIC character, skip spaces
	CP	"S"
	JR	Z,J$69E4

; SET PAGE

	LD	A,"P"
	CALL	C.604A			; check for BASIC character
	LD	A,"A"
	CALL	C.604A			; check for BASIC character
	LD	A,"G"
	CALL	C.604A			; check for BASIC character
	LD	A,"E"
	CALL	C.604A			; check for BASIC character
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$69D6
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	CALL	C$70CC			; change display page
	DEFW	0

	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	RET	NZ
J$69D6:	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	(ACPAGE),A		; change active page
	DEFW	0

	RET

; SET SCROLL

J$69E4:	INC	IX
	LD	A,"C"
	CALL	C.604A			; check for BASIC character
	LD	A,"R"
	CALL	C.604A			; check for BASIC character
	LD	A,"O"
	CALL	C.604A			; check for BASIC character
	LD	A,"L"
	CALL	C.604A			; check for BASIC character
	CALL	C.604A			; check for BASIC character
	CALL	C.6A46			; generate code for optional parameter
	CALL	C.6A46			; generate code for optional parameter
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J$6A1F		; yep, generate code for mask default
	CP	","			; parameter not specified ?
	JR	Z,J$6A1D		; yep, generate code for mask default
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J.6A26		; yep, generate code for pagemode
	CP	","			; parameter not specified ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	INC	IX
	JR	J.6A26

J$6A1D:	INC	IX
J$6A1F:	CALL	C.6058			; copy code block in execution buffer

	LD	A,0FFH
	DEFW	0

J.6A26:	CALL	C.6A6F			; generate PUSH AF
	CALL	C.4F00			; end of line or statement ?
	JR	Z,J$6A33		; yep, generate code for pagemode default
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J$6A3A

J$6A33:	CALL	C.6058			; copy code block in execution buffer

	LD	A,0FFH
	DEFW	0

J$6A3A:	CALL	C.6058			; copy code block in execution buffer

	POP	BC
	POP	HL
	POP	DE
	CALL	C$7004			; setup scroll
	DEFW	0

	RET

;	  Subroutine generate code for optional parameter
;	     Inputs  ________________________
;	     Outputs ________________________

C.6A46:	CALL	C.4F00			; end of line or statement ?
	JR	Z,J$6A62		; yep, generate code for default value
	CP	","
	JR	Z,J$6A60		; parameter not specified, generate code for default value
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.4F00			; end of line or statement ?
	JR	Z,C.6A6A		; yep, generate PUSH HL and quit
	CP	","			; more parameters ?
	JP	NZ,J.4E16		; nope, BASIC error: syntax error
	INC	IX
	JR	C.6A6A			; yep, generate PUSH HL and quit

J$6A60:	INC	IX
J$6A62:	CALL	C.6058			; copy code block in execution buffer

	LD	HL,-1
	DEFW	0

;	  Subroutine generate PUSH HL
;	     Inputs  ________________________
;	     Outputs ________________________

C.6A6A:	LD	A,0E5H			; PUSH HL
J$6A6C:	JP	C.60B9			; put byte in execution buffer

;	  Subroutine generate PUSH AF
;	     Inputs  ________________________
;	     Outputs ________________________

C.6A6F:	LD	A,0F5H			; PUSH AF
	JR	J$6A6C

;	  Subroutine VPEEK function
;	     Inputs  ________________________
;	     Outputs ________________________

C.6A73:	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6048
	LD	B,2			; result = generated integer
	LD	HL,I$70A3		; read VRAM
	JP	J.67D5

;	  Subroutine VDP
;	     Inputs  ________________________
;	     Outputs ________________________

C.6A81:	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6048
	CALL	C.6A6F
	CALL	C.603C			; check for BASIC token =
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	POP	AF
	CP	8
	ADC	A,0FFH
	LD	C,A
	CALL	WRTVDP
	DEFW	0

	RET

; POINT function

J$6AA3:	SCF
	CALL	C$6B8C
	LD	B,2			; result = generated integer
	LD	HL,I$6FA9		; point
	JP	J.67D5

; VDP function

J$6AAF:	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6048
	LD	B,2			; result = generated integer
	LD	HL,I$7339		; read vdp register
	JP	J.67D5

C.6AC0:	CALL	C.6B8B
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.6A6A			; generate PUSH HL
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$6B04
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J$6AF2
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$6B0C
	INC	IX
	CALL	C.6A6F
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	LD	A,0C1H			; POP BC
	CALL	C.60B9			; put byte in execution buffer
	JR	J.6B12

J$6AF2:	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	C,A
	LD	A,(FORCLR)
	LD	B,A
	LD	A,C
	DEFW	0

	JR	J.6B12

J$6B04:	CALL	C.6058			; copy code block in execution buffer

	LD	A,(FORCLR)
	DEFW	0

J$6B0C:	CALL	C.6058			; copy code block in execution buffer

	LD	B,A
	DEFW	0

J.6B12:	CALL	C.6058			; copy code block in execution buffer

	POP	HL
	POP	DE
	CALL	C$74BC
	DEFW	0

	RET

;	  Subroutine COPY
;	     Inputs  ________________________
;	     Outputs ________________________

C.6B1D:	CALL	C.6B8B
	LD	A,0F2H			; - token
	CALL	C.604A			; check for BASIC character
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.6A6A			; generate PUSH HL
	CALL	C.6B8B
	CALL	C.60D7			; remove byte from execution buffer
	CALL	C.6A6A			; generate PUSH HL
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J$6B42
	INC	IX
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J$6B4A

J$6B42:	CALL	C.6058			; copy code block in execution buffer

	LD	A,(ACPAGE)
	DEFW	0

J$6B4A:	CALL	C.6058			; copy code block in execution buffer

J$6B4D:	LD	(LINWRK+0),A
	DEFW	0

	LD	A,0D9H			; TO token
	CALL	C.604A			; check for BASIC character
	CALL	C.6B8B
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	NZ,J.6B6F
	INC	IX
	CALL	C.6032			; get BASIC character, skip spaces
	CP	","
	JR	Z,J.6B6F
	CALL	C.4F54			; evaluate byte operand and generate LD A, byte operand code
	JR	J$6B77

J.6B6F:	CALL	C.6058			; copy code block in execution buffer

	LD	A,(ACPAGE)
	DEFW	0

J$6B77:	CALL	C.6058			; copy code block in execution buffer

	LD	(LINWRK+1),A
	POP	IY
	POP	IX
	POP	HL
	POP	DE
	DEFW	0

	LD	DE,I$6EC8		; copy
	JP	J.67D1

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.6B8B:	AND	A

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$6B8C:	PUSH	AF
	CALL	C.6032			; get BASIC character, skip spaces
	INC	IX
	CP	"("
	JR	NZ,J$6BB0
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6040			; check for BASIC character ","
	POP	AF
	PUSH	AF
	JR	C,J$6BA8
	CALL	C.6058			; copy code block in execution buffer

	LD	(GRPACX),HL
	DEFW	0

J$6BA8:	CALL	C.6A6A			; generate PUSH HL
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	JR	J$6BE4

J$6BB0:	CP	0DCH
	JP	NZ,J.4E16		; BASIC error: syntax error
	CALL	C.6044			; check for BASIC character "("
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6040			; check for BASIC character ","
	CALL	C.6058			; copy code block in execution buffer

	LD	DE,(GRPACX)
	ADD	HL,DE
	DEFW	0

	POP	AF
	PUSH	AF
	JR	C,J$6BD4
	CALL	C.6058			; copy code block in execution buffer

	LD	(GRPACX),HL
	DEFW	0

J$6BD4:	CALL	C.6A6A			; generate PUSH HL
	CALL	C.4F97			; evaluate integer operand, generate LD HL, integer operand code
	CALL	C.6058			; copy code block in execution buffer

	LD	DE,(GRPACY)
	ADD	HL,DE
	DEFW	0

J$6BE4:	CALL	C.6048
	POP	AF
	JR	C,J$6BF2
	CALL	C.6058			; copy code block in execution buffer

	LD	(GRPACY),HL
	DEFW	0

J$6BF2:	LD	A,0D1H			; POP DE
	JP	C.60B9			; put byte in execution buffer

;	  Subroutine swap integer
;	     Inputs  ________________________
;	     Outputs ________________________

I$6BF7:	LD	B,2			; integer is 2 bytes
	JR	J.6C01

;	  Subroutine swap string
;	     Inputs  ________________________
;	     Outputs ________________________

I$6BFB:	LD	B,0			; string is 256 bytes
	JR	J.6C01

;	  Subroutine swap float
;	     Inputs  ________________________
;	     Outputs ________________________

I$6BFF:	LD	B,3			; float is 3 bytes

J.6C01:	LD	C,(HL)
	LD	A,(DE)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	J.6C01
	RET

;	  Subroutine put in DAC, execute routine DE, get result from DAC
;	     Inputs  ________________________
;	     Outputs ________________________

C$6C0B:	LD	(DAC+2),HL
	LD	A,2
	LD	(VALTYP),A
	LD	HL,DAC
	CALL	C.6C25			; CALL DE
	LD	A,(VALTYP)
	CP	2
	JP	NZ,J.4E10		; BASIC error: type mismatch
	LD	HL,(DAC+2)
	RET

;	  Subroutine CALL DE
;	     Inputs  ________________________
;	     Outputs ________________________

C.6C25:	PUSH	DE
	RET

;	  Subroutine check for traps handler
;	     Inputs  ________________________
;	     Outputs ________________________

C$6C27:	LD	HL,TRPTBL+10*3
	BIT	0,(HL)
	JR	Z,J.6C4A
	EX	DE,HL
	LD	HL,INTFLG
	DI
	LD	A,(HL)
	EI
	LD	(HL),0
	CP	03H
	JR	NZ,J.6C4A
	EX	DE,HL
	LD	A,(HL)
	SET	2,(HL)
	CP	(HL)
	JR	Z,J.6C4A
	AND	02H
	JR	NZ,J.6C4A
	LD	HL,ONGSBF
	INC	(HL)
J.6C4A:	LD	A,(ONGSBF)
	AND	A
	RET	Z
	LD	HL,TRPTBL
	LD	B,26
J$6C54:	LD	A,(HL)
	CP	05H
	INC	HL
	JR	Z,J$6C5F
	INC	HL
J$6C5B:	INC	HL
	DJNZ	J$6C54
	RET

J$6C5F:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	A,E
	OR	D			; trap handler defined ?
	JR	Z,J$6C5B		; nope, next trap
	DEC	HL
	DEC	HL
	CALL	C$6CB1
	CALL	C.6CA7			; pause trap
	PUSH	HL
	CALL	C.6C25
	POP	HL
	BIT	0,(HL)
	RET	Z
	DI
	LD	A,(HL)
	AND	05H	; 5 
	CP	(HL)
	LD	(HL),A
	JR	Z,J.6CBE
	CP	05H	; 5 
	JR	NZ,J.6CBE
J$6C82:	LD	A,(ONGSBF)
	INC	A
	LD	(ONGSBF),A
	EI
	RET

;	  Subroutine enable trap
;	     Inputs  ________________________
;	     Outputs ________________________

I$6C8B:	CALL	C$6CC0
	DI
	LD	A,(HL)
	AND	04H
	OR	01H
	CP	(HL)
	LD	(HL),A
	JR	Z,J.6CBE
	AND	04H
	JR	NZ,J$6C82
	EI
	RET

;	  Subroutine disable trap
;	     Inputs  ________________________
;	     Outputs ________________________

I$6C9E:	CALL	C$6CC8
	DI
	LD	A,(HL)
	LD	(HL),0
	JR	J$6CAB

;	  Subroutine pause trap
;	     Inputs  ________________________
;	     Outputs ________________________

C.6CA7:	DI
	LD	A,(HL)
	SET	1,(HL)
J$6CAB:	CP	05H
	JR	Z,J$6CB4
	EI
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$6CB1:	DI
	RES	2,(HL)
J$6CB4:	LD	A,(ONGSBF)
	SUB	1
	JR	C,J.6CBE
	LD	(ONGSBF),A
J.6CBE:	EI
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$6CC0:	CALL	C.6CCF
	RET	NC
	LD	A,1
	LD	(DE),A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$6CC8:	CALL	C.6CCF
	RET	NC
	XOR	A
	LD	(DE),A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.6CCF:	PUSH	HL
	LD	DE,TRPTBL+10*3
	AND	A
	SBC	HL,DE
	LD	C,L
	POP	HL
	RET	NC
	LD	DE,FNKFLG+9+1
J$6CDC:	DEC	DE
	INC	C
	INC	C
	INC	C
	JR	NZ,J$6CDC
	RET

;	  Subroutine clear screen
;	     Inputs  ________________________
;	     Outputs ________________________

I$6CE3:	LD	A,(SCRMOD)
	CP	5
	JP	C,J$746E
	CALL	C.73D3
	CALL	C.7079
	INC	C
	INC	C
	XOR	A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	LD	A,(ACPAGE)
	OUT	(C),A
	XOR	A
	OUT	(C),A
	LD	A,(SCRMOD)
	RRCA
	AND	01H
	INC	A
	OUT	(C),A
	LD	A,(MODE)
	AND	10H			; 212 lines mode ?
	JR	Z,J$6D18		; yep,
	XOR	A
	OUT	(C),A
	INC	A
	JR	J$6D1D

J$6D18:	LD	A,0D4H
	OUT	(C),A
	XOR	A
J$6D1D:	OUT	(C),A
	LD	A,(BAKCLR)
	CALL	C$6D2F
	OUT	(C),H
	XOR	A
	OUT	(C),A
	LD	A,0C0H
	OUT	(C),A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$6D2F:	LD	H,A
	LD	A,(SCRMOD)
	CP	8
	RET	Z
	CP	7
	JR	Z,J.6D43
	CP	5
	JR	Z,J.6D43
	LD	A,H
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
J.6D43:	LD	A,H
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
	RET

;	  Subroutine draw box
;	     Inputs  ________________________
;	     Outputs ________________________

I$6D4B:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5
	JP	C,J$747B
	POP	AF
	PUSH	HL
	PUSH	IX
	POP	HL
	AND	A
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	NC,J$6D62
	EX	DE,HL
	AND	A
J$6D62:	EX	(SP),HL
	PUSH	DE
	PUSH	IY
	POP	DE
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,J$6D6E
	EX	DE,HL
J$6D6E:	PUSH	DE
	POP	IY
	POP	DE
	POP	IX
	PUSH	IY
	PUSH	HL
	POP	IY
	DEC	IX
	PUSH	AF
	PUSH	BC
	CALL	C.6DA9			; draw line
	POP	BC
	POP	AF
	INC	IX
	POP	HL
	DEC	HL
	PUSH	IY
	PUSH	DE
	PUSH	IX
	POP	DE
	PUSH	AF
	PUSH	BC
	CALL	C.6DA9			; draw line
	POP	BC
	POP	AF
	INC	HL
	POP	IX
	INC	IX
	PUSH	HL
	POP	IY
	PUSH	AF
	PUSH	BC
	CALL	C.6DA9			; draw line
	POP	BC
	POP	AF
	DEC	IX
	POP	HL
	INC	HL
	PUSH	IX
	POP	DE
					; draw line and quit

;	  Subroutine draw line
;	     Inputs  ________________________
;	     Outputs ________________________

C.6DA9:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5
	JP	C,J$7476
	POP	AF
	CALL	C.73D3
	PUSH	AF
	CALL	C.7441
	CALL	C.742D
	POP	AF
	PUSH	DE
	PUSH	HL
	PUSH	IX
	PUSH	IY
	PUSH	AF
	PUSH	AF
	PUSH	HL
	CALL	C.7079
	INC	C
	INC	C
	PUSH	IX
	POP	HL
	OUT	(C),L
	OUT	(C),H
	PUSH	IY
	POP	HL
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	LD	A,0CH	; 12 
	PUSH	IX
	POP	HL
	SBC	HL,DE
	JR	NC,J$6DEF
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	AND	0FBH
J$6DEF:	PUSH	HL
	POP	IX
	POP	DE
	PUSH	IY
	POP	HL
	SBC	HL,DE
	JR	NC,J$6E02
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	AND	0F7H
J$6E02:	PUSH	IX
	POP	DE
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,J$6E0E
	EX	DE,HL
	OR	01H
J$6E0E:	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	OUT	(C),H
	LD	E,A
	POP	AF
	OUT	(C),A
	OUT	(C),E
	LD	A,B
	OR	70H	; "p"
	OUT	(C),A
	POP	AF
	POP	IY
	POP	IX
	POP	HL
	POP	DE
	RET

;	  Subroutine draw filled box
;	     Inputs  ________________________
;	     Outputs ________________________

I$6E29:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5
	JP	C,J$7480
	POP	AF
	CALL	C.73D3

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$6E36:	PUSH	AF
	CALL	C.7441
	CALL	C.742D
	POP	AF
	PUSH	AF
	PUSH	HL
	PUSH	IX
	POP	HL
	AND	A
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	NC,J$6E4C
	EX	DE,HL
	AND	A
J$6E4C:	EX	(SP),HL
	PUSH	DE
	PUSH	IY
	POP	DE
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,J$6E58
	EX	DE,HL
J$6E58:	PUSH	DE
	POP	IY
	POP	DE
	POP	IX
	CALL	C.7079
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	PUSH	HL
	PUSH	IX
	POP	HL
	AND	A
	SBC	HL,DE
	INC	HL
	OUT	(C),L
	OUT	(C),H
	LD	A,L
	OR	E
	PUSH	IY
	POP	HL
	POP	DE
	SBC	HL,DE
	INC	HL
	OUT	(C),L
	OUT	(C),H
	LD	E,A
	POP	HL
	INC	B
	DJNZ	J.6EA7
	LD	A,(SCRMOD)
	CP	8
	JR	Z,J$6EBE
	CP	7
	JR	Z,J$6E9C
	CP	6
	JR	Z,J$6EA2
J$6E9C:	LD	A,E
	RRCA
	JR	NC,J$6EB7
	JR	J.6EA7

J$6EA2:	LD	A,E
	AND	3
	JR	Z,J$6EB2
J.6EA7:	OUT	(C),H
	XOR	A
	OUT	(C),A
	LD	A,B
	OR	80H
	OUT	(C),A
	RET

J$6EB2:	LD	A,H
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
J$6EB7:	LD	A,H
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	H
	LD	H,A
J$6EBE:	OUT	(C),H
	XOR	A
	OUT	(C),A
	LD	A,0C0H
	OUT	(C),A
	RET

;	  Subroutine copy
;	     Inputs  ________________________
;	     Outputs ________________________

I$6EC8:	CALL	C.7441
	CALL	C.742D
	PUSH	HL
	PUSH	DE
	LD	DE,(GRPACX)
	LD	HL,(GRPACY)
	CALL	C.7441
	LD	(GRPACX),DE
	LD	(GRPACY),HL
	POP	DE
	POP	HL
	PUSH	DE
	PUSH	BC
	LD	A,20H
	CALL	C.707B
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(LINWRK+0)
	OR	H
	OUT	(C),A
	PUSH	HL
	LD	HL,(GRPACX)
	OUT	(C),L
	OUT	(C),H
	LD	HL,(GRPACY)
	OUT	(C),L
	LD	A,(LINWRK+1)
	OR	H
	OUT	(C),A
	LD	B,0
	LD	A,(GRPACX)
	OR	E
	PUSH	IX
	POP	HL
	SBC	HL,DE
	JR	NC,J$6F28
	LD	A,(GRPACX)
	CPL
	LD	D,A
	LD	A,E
	CPL
	OR	D
	EX	DE,HL
	LD	HL,0
	SBC	HL,DE
	SET	2,B
J$6F28:	INC	HL
	OUT	(C),L
	OUT	(C),H
	OR	L
	POP	DE
	PUSH	IY
	POP	HL
	SBC	HL,DE
	JR	NC,J$6F3E
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	SET	3,B
J$6F3E:	INC	HL
	OUT	(C),L
	OUT	(C),H
	OUT	(C),A
	OUT	(C),B
	LD	B,A
	POP	HL
	POP	DE
	LD	A,H
	AND	A
	JR	NZ,J.6F68
	LD	A,(SCRMOD)
	CP	8
	JR	Z,J.6F6E
	CP	7
	JR	Z,J$6F5D
	CP	6
	JR	Z,J$6F63
J$6F5D:	LD	A,B
	RRCA
	JR	NC,J.6F6E
	JR	J.6F68

J$6F63:	LD	A,B
	AND	3
	JR	Z,J.6F6E
J.6F68:	LD	A,H
	OR	90H
	OUT	(C),A
	RET

J.6F6E:	LD	A,0D0H
	OUT	(C),A
	RET

;	  Subroutine draw point
;	     Inputs  ________________________
;	     Outputs ________________________

I$6F73:	PUSH	AF
	LD	A,(SCRMOD)
	CP	5
	JP	C,J$749A
	POP	AF
	CALL	C.73D3
	PUSH	AF
	CALL	C.7441
	CALL	C.7079
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	POP	AF
	OUT	(C),A
	XOR	A
	OUT	(C),A
	LD	A,B
	OR	50H	; "P"
	OUT	(C),A
	RET

;	  Subroutine point
;	     Inputs  ________________________
;	     Outputs ________________________

I$6FA9:	LD	A,(SCRMOD)
	CP	5
	JP	C,J$74A8
	CALL	C.7441
	LD	A,20H
	CALL	C.707B
	INC	C
	INC	C
	OUT	(C),E
	OUT	(C),D
	OUT	(C),L
	LD	A,(ACPAGE)
	OR	H
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	OUT	(C),A
	XOR	A
	OUT	(C),A
	LD	A,40H
	OUT	(C),A
	DEC	C
	DEC	C
	LD	H,0
	CALL	C.708A
	LD	A,07H	; 7 
	DI
	CALL	C.709C			; read VDP status register
	IN	L,(C)
	XOR	A
	CALL	C.709C			; read VDP status register
	EI
	CALL	C.73BE
	RET	NZ
	LD	A,L
	AND	0F8H
	RRA
	RRA
	RRA
	RRA
	LD	L,A
	RET	C
	LD	L,0FFH
	RET

;	  Subroutine setup scroll
;	     Inputs  ________________________
;	     Outputs ________________________

C$7004:	PUSH	AF
	LD	A,E
	AND	D
	INC	A
	JR	Z,J$7023
	LD	C,E
	DEC	DE
	RR	D
	RR	E
	SRL	E
	SRL	E
	INC	E
	LD	A,E
	AND	3FH
	LD	E,A
	LD	A,C
	NEG
	AND	07H
	LD	D,A
	LD	(RG26SAV),DE
J$7023:	LD	A,L
	AND	H
	INC	A
	JR	Z,J$702C
	LD	A,L
	LD	(RG23SAV),A
J$702C:	LD	HL,RG25SAV
	INC	B
	JR	Z,J.7038
	SET	1,(HL)
	DJNZ	J.7038
	RES	1,(HL)
J.7038:	POP	BC
	INC	B
	JR	Z,J.7042
	SET	0,(HL)
	DJNZ	J.7042
	RES	0,(HL)
J.7042:	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	LD	A,2
	DI
	CALL	C.709C			; read VDP status register
J$704D:	IN	A,(C)
	ADD	A,A
	JP	M,J$704D
J$7053:	IN	A,(C)
	ADD	A,A
	JP	P,J$7053
	XOR	A
	CALL	C.709C			; read VDP status register
	LD	A,(RG23SAV)
	OUT	(C),A
	LD	A,128+23
	OUT	(C),A
	LD	A,25
	OUT	(C),A
	LD	A,128+17
	OUT	(C),A
	INC	C
	INC	C
	LD	B,3
	LD	HL,RG25SAV
	OTIR
	EI
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7079:	LD	A,24H

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.707B:	PUSH	AF
	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	POP	AF
	DI
	OUT	(C),A
	LD	A,128+17
	EI
	OUT	(C),A

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.708A:	LD	A,2
	DI
	CALL	C.709C			; read VDP status register
	IN	A,(C)
	RRA
	LD	A,0
	CALL	C.709C			; read VDP status register
	EI
	JR	C,C.708A
	RET

;	  Subroutine read VDP status register
;	     Inputs  ________________________
;	     Outputs ________________________

C.709C:	OUT	(C),A
	LD	A,128+15
	OUT	(C),A
	RET

;	  Subroutine read VRAM
;	     Inputs  ________________________
;	     Outputs ________________________

I$70A3:	CALL	C.70AB			; setup VDP for VRAM read
	LD	H,0
	IN	L,(C)
	RET

;	  Subroutine setup VDP for VRAM read
;	     Inputs  ________________________
;	     Outputs ________________________

C.70AB:	LD	A,(VDP.DR)
	LD	C,A

;	  Subroutine setup VDP for VRAM read
;	     Inputs  ________________________
;	     Outputs ________________________

C.70AF:	CALL	C.7403
	EI
	OUT	(C),A
	DEC	C
	RET

;	  Subroutine write VRAM
;	     Inputs  ________________________
;	     Outputs ________________________

I$70B7:	LD	B,A
	CALL	C.71B1			; setup VDP for VRAM write
	OUT	(C),B
	RET

;	  Subroutine set sprite mode
;	     Inputs  ________________________
;	     Outputs ________________________

I$70BE:	AND	3
	LD	HL,RG1SAV
	RES	0,(HL)
	RES	1,(HL)
	OR	(HL)
	LD	(HL),A
	JP	CLRSPR

;	  Subroutine change display page
;	     Inputs  ________________________
;	     Outputs ________________________

C$70CC:	LD	(DPPAGE),A
	RRCA
	RRCA
	RRCA
	AND	0E0H
	LD	E,A			; OR mask
	LD	A,(RG2SAV)
	AND	1FH
	LD	C,2			; register 2
	CALL	C$7109			; write VDP register with OR mask
	LD	A,(SCRMOD)
	CP	7
	LD	A,(DPPAGE)
	LD	D,0FCH			; AND mask
	JR	C,J$70EE
	ADD	A,A
	LD	D,0FDH			; AND mask
J$70EE:	LD	E,A			; OR mask
	LD	A,(RG11SAV)
	LD	C,11			; register 11
	CALL	C$7108			; write VDP register with AND and OR mask
	LD	A,D
	RLCA
	RLCA
	RLCA
	RLCA
	LD	D,A			; AND mask
	LD	A,E
	RLCA
	RLCA
	RLCA
	RLCA
	LD	E,A			; OR mask
	LD	A,(RG6SAV)
	LD	C,6			; register 6

;	  Subroutine write VDP register with AND and OR mask
;	     Inputs  ________________________
;	     Outputs ________________________

C$7108:	AND	D

;	  Subroutine write VDP register with OR mask
;	     Inputs  ________________________
;	     Outputs ________________________

C$7109:	OR	E
	LD	B,A
	JP	WRTVDP

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$710E:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	IX,S.GETPLT
	CALL	EXTROM
	POP	DE
	LD	L,C
	LD	A,B
	RLCA
	RLCA
	RLCA
	RLCA
	AND	0FH	; 15 
	LD	E,A
	LD	A,B
	POP	BC
	AND	0FH	; 15 
	LD	C,A
	LD	A,D
	INC	A
	JR	NZ,J$712C
	LD	D,E
J$712C:	LD	A,H
	INC	A
	JR	NZ,J$7131
	LD	H,L
J$7131:	LD	A,B
	INC	A
	JR	NZ,J$7136
	LD	B,C
J$7136:	LD	A,D
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	B
	POP	DE
	LD	E,H
	LD	IX,S.SETPLT
	JP	EXTROM

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7145:	PUSH	HL
	CALL	CALPAT
	CALL	C.71B1			; setup VDP for VRAM write
	CALL	GSPSIZ
	LD	A,8
	JR	NC,J$7155
	LD	A,32
J$7155:	LD	B,A
	POP	HL
	SUB	(HL)
	PUSH	AF
	JR	C,J$7160
	LD	B,(HL)
	INC	B
	DEC	B
	JR	Z,J$7164
J$7160:	INC	HL
	CALL	C.71A4
J$7164:	POP	AF
	RET	Z
	RET	C
	LD	B,A
	XOR	A
J.7169:	OUT	(C),A
	DJNZ	J.7169
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$716E:	CALL	CALPAT
	CALL	C.70AB			; setup VDP for VRAM read
	CALL	GSPSIZ
	LD	B,8
	JR	NC,J$717D
	LD	B,32
J$717D:	LD	HL,BUF
	PUSH	HL
	LD	(HL),B
	INC	HL
J$7183:	INI
	JR	NZ,J$7183
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7189:	AND	7FH
	PUSH	AF
	CALL	C.71A9
	POP	AF
	LD	B,16
	JR	J.7169

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7194:	PUSH	HL
	CALL	C.71A9
	POP	HL
	LD	A,(HL)
	AND	A
	RET	Z
	CP	11H	; 17 
	JR	C,J$71A2
	LD	A,10H	; 16 
J$71A2:	LD	B,A
	INC	HL

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.71A4:	OUTI
	JR	NZ,C.71A4
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.71A9:	LD	A,B
	ADD	A,A
	ADD	A,A
	CALL	CALATR
	DEC	H
	DEC	H

;	  Subroutine setup VDP for VRAM write
;	     Inputs  ________________________
;	     Outputs ________________________

C.71B1:	LD	A,(VDP.DR)
	LD	C,A

;	  Subroutine setup VDP for VRAM write
;	     Inputs  ________________________
;	     Outputs ________________________

C.71B5:	CALL	C.7403
	OR	40H
	EI
	OUT	(C),A
	DEC	C
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$71BF:	PUSH	AF
	LD	A,(VDP.DR)
	LD	C,A
	LD	A,(SCRMOD)
	CP	4
	JP	NC,J$722E
	POP	AF
	PUSH	HL
	PUSH	DE
	CALL	CALATR
	POP	DE
	PUSH	HL
	CALL	C.70AF			; setup VDP for VRAM read
	LD	A,B
	LD	HL,LINWRK
	LD	B,4
J$71DD:	INI
	JR	NZ,J$71DD
	LD	B,A
	BIT	7,B
	JR	Z,J$7201
	LD	(LINWRK+0),IY
	PUSH	IX
	POP	HL
	LD	A,H
	AND	80H
	LD	E,A
	LD	A,L
	LD	HL,LINWRK+3
	JR	Z,J$71F9
	ADD	A,20H	; " "
J$71F9:	LD	(LINWRK+1),A
	LD	A,(HL)
	AND	7FH
	OR	E
	LD	(HL),A
J$7201:	BIT	6,B
	JR	Z,J$7211
	LD	HL,LINWRK+3
	LD	A,D
	AND	0FH	; 15 
	LD	D,A
	LD	A,(HL)
	AND	0F0H
	OR	D
	LD	(HL),A
J$7211:	POP	HL
	EX	(SP),HL
	BIT	5,B
	JR	Z,J$7222
	CALL	GSPSIZ
	LD	A,H
	JR	NC,J$721F
	ADD	A,A
	ADD	A,A
J$721F:	LD	(LINWRK+2),A
J$7222:	POP	HL
	CALL	C.71B5			; setup VDP for VRAM write
	LD	HL,LINWRK
	LD	B,4
	JP	C.71A4

J$722E:	POP	AF
	PUSH	AF
	PUSH	HL
	PUSH	DE
	PUSH	AF
	CALL	CALATR
	POP	AF
	PUSH	HL
	PUSH	AF
	CALL	C.70AF			; setup VDP for VRAM read
	LD	A,B
	LD	HL,LINWRK
	LD	B,3
J$7242:	INI
	JR	NZ,J$7242
	LD	B,A
	POP	AF
	ADD	A,A
	ADD	A,A
	CALL	CALATR
	DEC	H
	DEC	H
	PUSH	HL
	CALL	C.70AF			; setup VDP for VRAM read
	LD	A,B
	LD	HL,LINWRK+4
	LD	B,16
J$7259:	INI
	JR	NZ,J$7259
	LD	B,A
	LD	E,0
	LD	L,0FFH
	BIT	7,B
	JR	Z,J$727B
	LD	(LINWRK+0),IY
	PUSH	IX
	POP	HL
	LD	A,H
	AND	80H
	LD	E,A
	LD	A,L
	JR	Z,J$7276
	ADD	A,20H	; " "
J$7276:	LD	(LINWRK+1),A
	LD	L,7FH
J$727B:	POP	IX
	POP	IY
	POP	AF
	BIT	6,B
	JR	Z,J$728C
	AND	0FH	; 15 
	OR	E
	LD	E,A
	LD	A,L
	AND	0F0H
	LD	L,A
J$728C:	PUSH	BC
	LD	D,L
	LD	HL,LINWRK+4
	LD	B,16
J$7293:	LD	A,(HL)
	AND	D
	OR	E
	LD	(HL),A
	INC	HL
	DJNZ	J$7293
	POP	BC
	POP	HL
	BIT	5,B
	JR	Z,J$72AB
	CALL	GSPSIZ
	LD	A,H
	JR	NC,J$72A8
	ADD	A,A
	ADD	A,A
J$72A8:	LD	(LINWRK+2),A
J$72AB:	PUSH	IX
	POP	HL
	CALL	C.71B5			; setup VDP for VRAM write
	LD	HL,LINWRK+4
	LD	B,16
	CALL	C.71A4
	PUSH	IY
	POP	HL
	CALL	C.71B5			; setup VDP for VRAM write
	LD	HL,LINWRK
	LD	B,3
	CALL	C.71A4
	POP	DE
	LD	A,1FH
	SUB	D
	RET	Z
	LD	E,A
	LD	D,A
	PUSH	IX
	POP	HL
J$72D1:	LD	A,L
	ADD	A,10H	; 16 
	LD	L,A
	JR	NC,J$72D8
	INC	H
J$72D8:	CALL	C.70AF			; setup VDP for VRAM read
	LD	B,16
J$72DD:	IN	A,(C)
	AND	40H	; "@"
	JR	NZ,J$72E7
	DJNZ	J$72DD
	JR	J$72EA

J$72E7:	DEC	E
	JR	NZ,J$72D1
J$72EA:	LD	A,D
	SUB	E
	RET	Z
	LD	E,A
	PUSH	IX
	POP	HL
	PUSH	DE
	LD	A,(LINWRK+4)
	AND	80H
	LD	D,A
J$72F8:	LD	A,L
	ADD	A,10H	; 16 
	LD	L,A
	JR	NC,J$72FF
	INC	H
J$72FF:	PUSH	HL
	CALL	C.70AF			; setup VDP for VRAM read
	LD	HL,LINWRK+20
	LD	B,16
J$7308:	IN	A,(C)
	AND	7FH
	OR	D
	LD	(HL),A
	INC	HL
	DJNZ	J$7308
	POP	HL
	PUSH	HL
	CALL	C.71B5			; setup VDP for VRAM write
	LD	HL,LINWRK+20
	LD	B,16
	CALL	C.71A4
	POP	HL
	DEC	E
	JR	NZ,J$72F8
	POP	DE
	LD	B,E
	PUSH	IY
	POP	HL
J$7327:	INC	HL
	INC	HL
	INC	HL
	INC	HL
	CALL	C.71B5			; setup VDP for VRAM write
	LD	DE,(LINWRK+0)
	OUT	(C),E
	OUT	(C),D
	DJNZ	J$7327
	RET

;	  Subroutine read vdp register
;	     Inputs  ________________________
;	     Outputs ________________________

I$7339:	LD	A,H
	AND	A
	JR	Z,J$7352
	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	XOR	A
	SUB	L
	DI
	CALL	C.709C			; read VDP status register
	IN	L,(C)
	XOR	A
	CALL	C.709C			; read VDP status register
	EI
	LD	H,0
	RET

J$7352:	LD	DE,RG0SAV
	LD	A,L
	CP	9
	JR	C,J.7364
	LD	DE,RG8SAV-9
	CP	25
	JR	C,J.7364
	LD	DE,RG25SAV-26
J.7364:	ADD	HL,DE
	LD	L,(HL)
	LD	H,0
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7369:	CP	8+1
	JP	C,CHGMOD
	LD	HL,RG25SAV
	LD	B,(HL)
	LD	C,B
	SET	3,B
	RES	4,B
	CP	0CH	; 12 
	JR	Z,J$73AE
	SET	4,B
	LD	HL,MODE
	CP	0BH
	SET	5,(HL)			; screen 11
	JR	Z,J$7388
	RES	5,(HL)
J$7388:	BIT	3,C
	JR	Z,J$73B2
	BIT	4,C
	RET	NZ
	PUSH	BC
	LD	A,0F7H
	LD	B,01H
	LD	DE,0
	LD	L,E
	LD	H,D
	LD	IX,255
	LD	IY,255
	CALL	C$6E36
	LD	A,(VDP.DR)
	LD	C,A
	INC	C
	CALL	C.708A
	JR	J$73B8

J$73AE:	BIT	3,C
	JR	NZ,J$73B9
J$73B2:	PUSH	BC
	LD	A,8
	CALL	CHGMOD
J$73B8:	POP	BC
J$73B9:	LD	C,19H
	JP	WRTVDP

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.73BE:	LD	A,(IDBYT2)
	CP	2			; MSX2+ or higher ?
	SBC	A,A
	RET	NZ			; nope, quit
	LD	A,(RG25SAV)
	AND	18H
	CP	18H
	RET	NZ
	LD	A,(MODE)
	AND	20H			; screen 11
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.73D3:	LD	C,A
	CALL	C.73BE
	LD	A,C
	RET	NZ
	EX	(SP),HL
	LD	(SWPTMP+4),HL
	POP	HL
	INC	B
	DJNZ	J$73F9
	PUSH	AF
	PUSH	DE
	PUSH	HL
	PUSH	IX
	PUSH	IY
	LD	A,0FH
	LD	B,01H
	CALL	C$73FD
	POP	IY
	POP	IX
	POP	HL
	POP	DE
	POP	AF
	LD	B,2
	SCF
J$73F9:	RLA
	RLA
	RLA
	RLA

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$73FD:	PUSH	HL
	LD	HL,(SWPTMP+4)
	EX	(SP),HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7403:	INC	C
	LD	A,(IDBYT2)
	AND	A			; MSX1 ?
	JR	Z,J$7426		; yep,
	PUSH	DE
	LD	A,H
	RLCA
	RLCA
	AND	03H
	LD	E,A
	LD	A,(SCRMOD)
	CP	7
	LD	A,(ACPAGE)
	JR	C,J$741C
	ADD	A,A
J$741C:	ADD	A,A
	ADD	A,E
	POP	DE
	DI
	OUT	(C),A
	LD	A,128+14
	OUT	(C),A
J$7426:	DI
	OUT	(C),L
	LD	A,H
	AND	3FH
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.742D:	PUSH	HL
	PUSH	DE
	PUSH	IX
	POP	DE
	PUSH	IY
	POP	HL
	CALL	C.7441
	PUSH	HL
	POP	IY
	PUSH	DE
	POP	IX
	POP	DE
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7441:	LD	A,(MODE)
	AND	10H			; 212 lines mode ?
	RET	NZ			; nope, quit
	LD	A,D
	ADD	A,A
	JR	NC,J$7450
	LD	DE,0
	JR	J.745C

J$7450:	LD	A,(SCRMOD)
	RRCA
	AND	01H
	CP	D
	JR	NC,J.745C
	LD	E,0FFH
	LD	D,A
J.745C:	LD	A,H
	ADD	A,A
	JR	NC,J$7464
	LD	HL,0
	RET

J$7464:	JR	NZ,J$746A
	LD	A,L
	CP	0D4H
	RET	C
J$746A:	LD	HL,211
	RET

J$746E:	XOR	A
	LD	IX,CLS
	JP	J.74EE

J$7476:	LD	BC,M58FC		; line handler
	JR	J.7483

J$747B:	LD	BC,M5912		; line box handler
	JR	J.7483

J$7480:	LD	BC,M58C1		; line boxfill handler
J.7483:	POP	AF
	LD	(ATRBYT),A
	PUSH	BC
	LD	(GXPOS),DE
	LD	(GYPOS),HL
	PUSH	IX
	POP	BC
	PUSH	IY
	POP	DE
	POP	IX
	JP	J.74EE

J$749A:	POP	AF
	LD	(ATRBYT),A
	LD	C,E
	LD	B,D
	EX	DE,HL
	LD	IX,M57F1+4
	JP	J.74EE			; PSET handler

J$74A8:	LD	C,E
	LD	B,D
	EX	DE,HL
	CALL	SCALXY
	LD	HL,-1
	RET	NC
	CALL	MAPXYC
	CALL	READC
	LD	L,A
	LD	H,0
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$74BC:	LD	(BRDATR),A
	LD	A,B
	LD	(ATRBYT),A
	LD	C,E
	LD	B,D
	EX	DE,HL
	LD	A,(SCRMOD)
	CP	5
	JP	C,J$74D5
	LD	IX,S266E
	JP	EXTROM			; PAINT handler (subrom)

J$74D5:	LD	IX,M59E3		; PAINT handler
	JP	J.74EE

;	  Subroutine circle
;	     Inputs  A = color
;	     Outputs ________________________

I$74DC:	EX	DE,HL
	LD	HL,LINWRK+3
	LD	(HL),0
	DEC	HL
	LD	(HL),A
	DEC	HL
	LD	(HL),0FH
	DEC	HL
	LD	(HL),","		; ,<int constant>
	LD	IX,M5B19		; CIRCLE handler
J.74EE:	CALL	CALBAS
	EI
	RET

;	  Subroutine print tab
;	     Inputs  ________________________
;	     Outputs ________________________

C$74F3:	LD	A,9
	RST	18H
	RET

;	  Subroutine print new line
;	     Inputs  ________________________
;	     Outputs ________________________

C$74F7:	LD	A,13
	RST	18H
	LD	A,10
	RST	18H
	RET

;	  Subroutine print string
;	     Inputs  ________________________
;	     Outputs ________________________

C.74FE:	LD	B,(HL)
	LD	A,B
	AND	A
	RET	Z
J$7502:	INC	HL
	LD	A,(HL)
	RST	18H
	DJNZ	J$7502
	RET

;	  Subroutine print integer
;	     Inputs  ________________________
;	     Outputs ________________________

C$7508:	CALL	C.7BD1			; integer to text
	JR	J$7510

;	  Subroutine print float
;	     Inputs  ________________________
;	     Outputs ________________________

C$750D:	CALL	C.7C2B			; float to text
J$7510:	CALL	C.74FE			; print string
	LD	A," "
	RST	18H
	RET

I$7517:	CALL	C.74FE			; print string
J.751A:	CALL	QINLIN
	JP	C,J.4DFA
	EX	DE,HL
	INC	DE
	CALL	C.7D18
	LD	A,(DE)
	AND	A
	RET	Z
	LD	HL,I$7530
	CALL	C.74FE			; print string
	JR	J.751A

I$7530:	DEFB	18
	DEFB	"?Redo from start",13,10

I$7543:	CALL	C.74FE			; print string
I$7546:	CALL	QINLIN
	JP	C,J.4DFA
	INC	H
	LD	E,L
	LD	D,H
	INC	DE
	LD	BC,256
	LDDR
	INC	HL
	LD	B,0FFH
J$7558:	INC	B
	INC	DE
	LD	A,(DE)
	AND	A
	JR	NZ,J$7558
	LD	(HL),B
	RET

I$7560:	CALL	C.75BE
J$7563:	LD	A,(HL)
	INC	HL
	CP	" "
	JR	Z,J$7563
	LD	DE,BUF+1
	LD	B,0
	CP	'"'
	JR	Z,J.7593
	DEC	HL
J$7573:	LD	A,(HL)
	AND	A
	JR	Z,J.758B
	CP	":"
	JR	Z,J.758B
	CP	","
	JR	Z,J.758B
	LD	(DE),A
	INC	DE
	INC	HL
	INC	B
	JR	J$7573

J.7585:	INC	HL
	LD	A,(HL)
	CP	" "
	JR	Z,J.7585
J.758B:	LD	(DATPTR),HL
	LD	HL,BUF
	LD	(HL),B
	RET

J.7593:	LD	A,(HL)
	AND	A
	JR	Z,J.758B
	CP	'"'
	JR	Z,J.7585
	LD	(DE),A
	INC	DE
	INC	HL
J$759E:	INC	B
	JR	J.7593

I$75A1:	CALL	C.75BE
	EX	DE,HL
	CALL	C.7D18
	LD	(DATPTR),DE
	LD	A,(DE)
	AND	A			; end of line ?
	RET	Z			; yep, quit
	CP	":"			; end of statement ?
	RET	Z			; yep, quit
	CP	","			; next data item ?
	RET	Z			; yep, quit
	LD	HL,(DATLIN)
	LD	(CURLIN),HL
	JP	J.4E16			; BASIC error: syntax error

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.75BE:	LD	HL,(DATPTR)
	LD	A,(HL)
	CP	","
	JR	NZ,J.75DC
	INC	HL
	RET

J$75C8:	XOR	A
	LD	B,0FFH
	CPIR
J$75CD:	LD	A,(HL)
	INC	HL
	OR	(HL)
	JP	Z,J$4E07		; BASIC error: out of data
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(DATLIN),DE
	INC	HL
J.75DC:	LD	B,0
J.75DE:	LD	A,(HL)
	INC	HL
	AND	A
	JR	Z,J$75CD
	CP	84H
	JR	NZ,J$75EA
	INC	B
	DEC	B
	RET	Z
J$75EA:	CP	'"'
	JR	NZ,J$75F2
	INC	B
	DJNZ	J.75DC
	INC	B
J$75F2:	CP	0FFH
	INC	HL
	JR	Z,J.75DE
	DEC	HL
	CP	8FH
	JR	Z,J$75C8
	CP	20H	; " "
	JR	NC,J.75DE
	CP	0BH	; 11 
	JR	C,J.75DE
	CP	0FH	; 15 
	LD	C,01H
	JR	Z,J.761C
	INC	C
	JR	C,J.761C
	CP	1BH
	JR	C,J.75DE
	SUB	1CH
	JR	Z,J.761C
	DEC	A
	LD	C,04H
	JR	Z,J.761C
	LD	C,08H
J.761C:	LD	A,L
	ADD	A,C
	LD	L,A
	JR	NC,J.75DE
	INC	H
	JR	J.75DE

;	  Subroutine multiply
;	     Inputs  ________________________
;	     Outputs ________________________

C.7624:	LD	A,40H
	DEFB	0CBH,037H		; SLL A (Z80), TST A (R800)
	CP	81H
	JR	Z,J$7631		; Z80,
	LD	C,E
	LD	B,D
	DEFB	0EDH,0C3H		; MULUW HL,BC
	RET

J$7631:	LD	C,L
	LD	B,H
	LD	HL,0
	LD	A,16
J$7638:	ADD	HL,HL
	EX	DE,HL
	ADD	HL,HL
	EX	DE,HL
	JR	NC,J$763F
	ADD	HL,BC
J$763F:	DEC	A
	JR	NZ,J$7638
	RET

;	  Subroutine divide
;	     Inputs  ________________________
;	     Outputs ________________________

C.7643:	PUSH	DE
	PUSH	HL
	BIT	7,D
	JR	NZ,J$764F
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
J$764F:	LD	C,E
J$7650:	LD	B,D
	BIT	7,H
	JR	Z,J$765B
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
J$765B:	EX	DE,HL
	XOR	A
	LD	L,A
	LD	H,A
	LD	A,E
	LD	E,16
	RLA
	RL	D
J$7665:	ADC	HL,HL
	PUSH	HL
	ADD	HL,BC
	JR	NC,J$766E
	INC	SP
	INC	SP
	DEFB	030H			; pseudo JR NC,xx (skip next instruction)
J$766E:	POP	HL
	RLA
	RL	D
	DEC	E
	JR	NZ,J$7665
	LD	E,A
	EX	DE,HL
	POP	AF
	AND	A
	JP	P,J$7684
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
	LD	A,80H
J$7684:	POP	BC
	XOR	B
	RET	P
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	RET

;	  Subroutine RND handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$768E:	LD	A,B
	AND	A
	JR	Z,J$76C9
	BIT	7,H
	JR	Z,J$769F
	LD	(SWPTMP+2),HL
	LD	H,B
	LD	L,"5"
	LD	(SWPTMP+0),HL
J$769F:	LD	HL,(SWPTMP+0)
	LD	E,L
	LD	D,H
	ADD	HL,HL
	LD	C,L
	LD	B,H
	JR	NC,J$76AA
	INC	BC
J$76AA:	ADD	HL,DE
	LD	(SWPTMP+0),HL
	LD	HL,(SWPTMP+2)
	LD	E,L
	LD	D,H
	ADC	HL,HL
	ADD	HL,DE
	ADD	HL,BC
	LD	(SWPTMP+2),HL
J$76BA:	LD	A,L
	OR	H
	LD	B,A
	RET	Z
	LD	B,80H
J$76C0:	BIT	7,H
	RES	7,H
	RET	NZ
	ADD	HL,HL
	DEC	B
	JR	J$76C0

J$76C9:	LD	HL,(SWPTMP+2)
	JR	J$76BA

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.76CE:	CALL	C.7643			; divide
	EX	DE,HL
	RET

;	  Subroutine subtract floats
;	     Inputs  ________________________
;	     Outputs ________________________

C.76D3:	LD	A,D
	XOR	80H
	LD	D,A

;	  Subroutine add floats
;	     Inputs  ________________________
;	     Outputs ________________________

C.76D7:	LD	A,C
	AND	A
	RET	Z
	LD	A,B
	AND	A
	JP	Z,J$7745
	SUB	C
	JR	NC,J$76E6
	NEG
	EX	DE,HL
	LD	B,C
J$76E6:	CP	11H
	RET	NC
	LD	C,A
	LD	A,H
	XOR	D
	ADD	A,A
	LD	A,H
	PUSH	AF
	SET	7,H
	SET	7,D
	INC	C
	DEC	C
	JR	Z,J.7701
J$76F7:	SRL	D
	RR	E
	DEC	C
	JR	NZ,J$76F7
	JR	NC,J.7701
	INC	DE
J.7701:	POP	AF
	JR	C,J$771C
	ADD	HL,DE
	JR	NC,J.770E
	INC	B
	JR	Z,J.7715
	RR	H
	RR	L
J.770E:	RES	7,H
J$7710:	AND	A
	RET	P
	SET	7,H
	RET

J.7715:	LD	B,0FFH
	LD	HL,7FFFH
	JR	J$7710

J$771C:	AND	A
	SBC	HL,DE
	JR	NC,J$7728
	EX	DE,HL
	LD	HL,1
	SBC	HL,DE
	CPL
J$7728:	LD	C,A
J.7729:	LD	A,H
	AND	A
	JR	NZ,J.773C
	OR	L
	JR	Z,J.7739
	LD	H,L
	LD	L,0
	LD	A,B
	SUB	08H	; 8 
	LD	B,A
	JR	NC,J.773C
J.7739:	LD	B,0
	RET

J.773C:	LD	A,C
J$773D:	BIT	7,H
	JR	NZ,J.770E
	ADD	HL,HL
	DJNZ	J$773D
	RET

J$7745:	LD	B,C
	EX	DE,HL
	RET

;	  Subroutine multipy floats
;	     Inputs  ________________________
;	     Outputs ________________________

C.7748:	LD	A,B
	AND	A
	RET	Z
	LD	A,C
	AND	A
	JR	Z,J.7739
	ADD	A,B
	LD	B,A
	RRA
	XOR	B
	LD	A,B
	JP	P,J.7823
	ADD	A,80H
	LD	B,A
	RET	Z
	LD	A,H
	XOR	D
	LD	C,A
	PUSH	BC
	SET	7,H
	SET	7,D
	LD	A,40H
	DEFB	0CBH,037H		; SLL A (Z80), TST A (R800)
	CP	81H
	JR	Z,J$7774		; Z80,
	LD	C,E
	LD	B,D
	DEFB	0EDH,0C3H		; MULUW HL,BC
	LD	A,H
	EX	DE,HL
	JP	J$781A

J$7774:	LD	C,L
	LD	A,H
	LD	HL,0
	RRA
	RR	C
	JR	NC,J$777F
	ADD	HL,DE
J$777F:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$7789
	ADD	HL,DE
J$7789:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$7793
	ADD	HL,DE
J$7793:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$779D
	ADD	HL,DE
J$779D:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77A7
	ADD	HL,DE
J$77A7:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77B1
	ADD	HL,DE
J$77B1:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77BB
	ADD	HL,DE
J$77BB:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77C5
	ADD	HL,DE
J$77C5:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77CF
	ADD	HL,DE
J$77CF:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77D9
	ADD	HL,DE
J$77D9:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77E3
	ADD	HL,DE
J$77E3:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77ED
	ADD	HL,DE
J$77ED:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$77F7
	ADD	HL,DE
J$77F7:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$7801
	ADD	HL,DE
J$7801:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$780B
	ADD	HL,DE
J$780B:	RR	H
	RR	L
	RRA
	RR	C
	JR	NC,J$7815
	ADD	HL,DE
J$7815:	RR	H
	RR	L
	RRA
J$781A:	POP	BC
	ADD	A,A
	JP	NC,J.773C
	INC	HL
	JP	J.773C

J.7823:	AND	A
	JP	P,J.7739
	LD	A,H
	XOR	D
	JP	J.7715

;	  Subroutine divide floats
;	     Inputs  ________________________
;	     Outputs ________________________

C.782C:	LD	A,C
	AND	A
	LD	A,H
	JP	Z,J.7715
	LD	A,B
	AND	A
	RET	Z
	SUB	C
	LD	B,A
	RRA
	XOR	B
	LD	A,B
	JP	M,J.7823
	ADD	A,80H
	LD	B,A
	RET	Z
	LD	A,H
	XOR	D
	INC	B
	JP	Z,J.7715
	LD	C,A
	PUSH	BC
	SET	7,H
	SET	7,D
	XOR	A
	LD	C,A
	LD	B,16
	JR	J$7857

J$7853:	ADC	HL,HL
	JR	C,J$7873
J$7857:	SBC	HL,DE
	JR	NC,J$785C
	ADD	HL,DE
J$785C:	CCF
J$785D:	RL	C
	RLA
	DJNZ	J$7853
	SRL	D
	RR	E
	AND	A
	SBC	HL,DE
	LD	L,C
	LD	H,A
	POP	BC
	JP	C,J.7729
	INC	HL
	JP	J.7729

J$7873:	OR	A
	SBC	HL,DE
	JR	J$785D

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7878:	LD	A,E
	OR	D
	JP	Z,C.7924
	BIT	7,D
	PUSH	AF
	JP	P,J$7889
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
J$7889:	PUSH	DE
	LD	C,B
	EX	DE,HL
	CALL	C.7924
J$788F:	EX	(SP),HL
	SRL	H
	RR	L
	EX	(SP),HL
	JR	NC,J$789F
	PUSH	DE
	PUSH	BC
	CALL	C.7748			; multipy floats
	POP	DE
	LD	C,E
	POP	DE
J$789F:	EX	(SP),HL
	LD	A,L
	OR	H
	EX	(SP),HL
	JR	Z,J$78B4
	PUSH	HL
	PUSH	BC
	LD	B,C
	LD	H,D
	LD	L,E
	CALL	C.7748			; multipy floats
	LD	C,B
	EX	DE,HL
	POP	HL
	LD	B,H
	POP	HL
	JR	J$788F

J$78B4:	POP	AF
	POP	AF
	RET	P

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$78B7:	LD	C,B
	EX	DE,HL
	CALL	C.7924
	JP	C.782C			; divide floats

;	  Subroutine ^
;	     Inputs  ________________________
;	     Outputs ________________________

I$78BF:	PUSH	DE
	PUSH	BC
	CALL	C.7B01			; LOG handler
	POP	DE
	LD	C,E
	POP	DE
	CALL	C.7748			; multipy floats
	JP	J.7AA8			; EXP handler

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$78CD:	BIT	7,H
	PUSH	AF
	RES	7,H
	CALL	C.78DF			; convert integer to float
	POP	AF
	RET	Z
	LD	C,90H
	LD	DE,0
	JP	C.76D7			; add floats

;	  Subroutine convert integer to float
;	     Inputs  HL = integer
;	     Outputs B:HL = float

C.78DF:	LD	A,L
	OR	H
	JR	Z,J$78FF
	BIT	7,H
	PUSH	AF
	JR	Z,J$78EE
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
J$78EE:	LD	B,90H
J$78F0:	BIT	7,H
	JR	NZ,J$78F8
	ADD	HL,HL
	DEC	B
	JR	J$78F0

J$78F8:	RES	7,H
	POP	AF
	RET	Z
	SET	7,H
	RET

J$78FF:	LD	B,A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7901:	LD	A,B
	AND	A			; B=0 ?
	JR	Z,J.7926		; yep,
	DEC	B			; B=1 ?
	JP	P,J.7926		; yep,
	BIT	7,H
	PUSH	AF			; save sign
	SET	7,H
	LD	DE,0
J$7911:	ADD	HL,HL
	RL	E
	RL	D
	DEC	B
	JP	M,J$7911
	EX	DE,HL
	POP	AF			; sign set ?
	RET	Z			; nope, quit
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A			; yep, negate
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7924:	LD	B,81H
J.7926:	LD	HL,0
	RET

C.792A:	CALL	C.7966
	LD	HL,0
	RET	NZ
	DEC	HL
	RET

C.7933:	CALL	C.7966
	LD	HL,0
	RET	Z
	DEC	HL
	RET

C.793C:	CALL	C.7966
	LD	HL,0
	RET	C
	RET	Z
	DEC	HL
	RET

C.7946:	CALL	C.7966
	LD	HL,0
	RET	C
	DEC	HL
	RET

C.794F:	CALL	C.7966
	LD	HL,0
	RET	NC
	DEC	HL
	RET

C.7958:	CALL	C.7966
	LD	HL,-1
	RET	C
	RET	Z
	INC	HL
	RET

C.7962:	LD	HL,-1
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7966:	LD	A,C
	AND	A
	JR	Z,J$7986
	LD	A,B
	AND	A
	LD	A,D
	JR	Z,J.7981
	XOR	H
	LD	A,D
	JP	M,J.7981
	LD	A,C
	CP	B
	JR	NZ,J.797F
	LD	A,D
	CP	H
	JR	NZ,J.797F
	LD	A,E
	SUB	L
	RET	Z
J.797F:	RRA
	XOR	D
J.7981:	CPL
	OR	01H
	RLA
	RET

J$7986:	LD	A,B
	AND	A
	RET	Z
	LD	A,H
	RLA
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$798C:	BIT	7,H
	PUSH	AF
	RES	7,H
	CALL	C.7999
	POP	AF
	RET	Z
	SET	7,H
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7999:	LD	A,B
	AND	A
	RET	Z
	CP	91H
	RET	NC
	SUB	81H
	JR	C,J$79D7
	LD	DE,8000H
	JR	Z,J$79AF
J$79A8:	SRA	D
	RR	E
	DEC	A
	JR	NZ,J$79A8
J$79AF:	BIT	7,H
	JR	NZ,J$79BA
	LD	A,H
	AND	D
	LD	H,A
	LD	A,L
	AND	E
	LD	L,A
	RET

J$79BA:	PUSH	HL
	LD	A,H
	AND	D
	LD	H,A
	LD	A,L
	AND	E
	LD	L,A
	EX	(SP),HL
	LD	A,D
	CPL
	AND	H
	JR	NZ,J.79CE
	LD	A,E
	CPL
	AND	L
	JR	NZ,J.79CE
	POP	HL
	RET

J.79CE:	POP	HL
	LD	C,81H
	LD	DE,8000H
	JP	C.76D7			; add floats

J$79D7:	BIT	7,H
	LD	B,0
	RET	Z
	LD	B,81H
	LD	HL,8000H
	RET

;	  Subroutine COS handler
;	     Inputs  ________________________
;	     Outputs ________________________

C.79E2:	LD	C,81H
	LD	DE,4910H
	CALL	C.76D7			; add floats

;	  Subroutine SIN handler
;	     Inputs  ________________________
;	     Outputs ________________________

C.79EA:	LD	A,B
	CP	77H	; "w"
	RET	C
	BIT	7,H
	JR	Z,C.79FC
	RES	7,H
	CALL	C.79FC
J.79F7:	LD	A,H
	XOR	80H
	LD	H,A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.79FC:	LD	C,7EH
	LD	DE,22FAH
	CALL	C.7748			; multipy floats
	PUSH	HL
	PUSH	BC
	CALL	C.7999
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	CALL	C.76D3			; subtract floats
	LD	C,7FH
	LD	DE,0
	CALL	C.7966
	JR	C,J$7A31
	LD	C,80H
	LD	DE,0C000H
	CALL	C.76D7			; add floats
	SET	7,H
	LD	C,7FH
	LD	DE,0
	CALL	C.76D7			; add floats
	LD	A,H
	XOR	80H
	LD	H,A
J$7A31:	BIT	7,H
	PUSH	AF
	RES	7,H
	LD	IX,I$7A53
	CALL	C.7B88
	POP	AF
	RET	Z
	JR	J.79F7

;	  Subroutine TAN handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7A41:	PUSH	HL
	PUSH	BC
	CALL	C.79E2			; COS handler
	LD	A,B
	POP	BC
	EX	(SP),HL
	PUSH	AF
	CALL	C.79EA			; SIN handler
	POP	AF
	LD	C,A
	POP	DE
	JP	C.782C			; divide floats

I$7A53:	DEFB	5
	DEFB	086H,01EH,0D8H
	DEFB	087H,099H,026H
	DEFB	087H,023H,034H
	DEFB	086H,0A5H,05EH
	DEFB	083H,049H,010H

;	  Subroutine ATN handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7A63:	BIT	7,H
	JR	Z,C.7A6E
	RES	7,H
	CALL	C.7A6E
	JR	J.79F7

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A6E:	LD	A,B
	CP	81H
	JR	C,C.7A85
	CALL	C$78B7
	CALL	C.7A85
	LD	A,H
	XOR	80H
	LD	H,A
	LD	C,81H
	LD	DE,4910H
	JP	C.76D7			; add floats

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7A85:	LD	IX,I$7A8C
	JP	C.7B88

I$7A8C:	DEFB	9
	DEFB	078H,03BH,0D7H
	DEFB	07BH,084H,06EH
	DEFB	07CH,02FH,0C2H
	DEFB	07DH,09AH,031H
	DEFB	07DH,05AH,03EH
	DEFB	07EH,091H,080H
	DEFB	07EH,04CH,0BCH
	DEFB	07FH,0AAH,0AAH
	DEFB	081H,000H,000H

;	  Subroutine EXP handler
;	     Inputs  ________________________
;	     Outputs ________________________

J.7AA8:	LD	C,81H
	LD	DE,38AAH
	CALL	C.7748			; multipy floats
	LD	A,B
	CP	88H
	JR	NC,J.7AE1
	CP	68H
	JP	C,C.7924
	PUSH	HL
	PUSH	BC
	CALL	C.7999
	PUSH	HL
	PUSH	BC
	CALL	C.7901			; covert float to integer
	LD	A,L
	ADD	A,81H
	POP	HL
	POP	DE
	POP	BC
	LD	C,H
	POP	HL
	JR	Z,J.7AE1
	PUSH	AF
	CALL	C.76D3			; subtract floats
	LD	IX,I$7AEB
	CALL	C.7B99
	POP	AF
	LD	C,A
	LD	DE,0
	JP	C.7748			; multipy floats

J.7AE1:	BIT	7,H
	LD	B,0
	RET	NZ
	DEC	B
	LD	HL,7FFFH
	RET

I$7AEB:	DEFB	7
	DEFB	074H,059H,088H
	DEFB	077H,026H,098H
	DEFB	07AH,01EH,01EH
	DEFB	07CH,063H,050H
	DEFB	07EH,075H,0FEH
	DEFB	080H,031H,072H
	DEFB	081H,000H,000H

;	  Subroutine LOG handler
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B01:	BIT	7,H
	RET	NZ
	LD	A,B
	AND	A
	RET	Z
	LD	C,B
	LD	D,H
	LD	E,L
	LD	A,80H
	LD	B,A
	XOR	C
	PUSH	AF
	PUSH	HL
	PUSH	BC
	LD	IX,I$7B46
	CALL	C.7B99
	POP	AF
	POP	DE
	PUSH	HL
	PUSH	BC
	LD	B,A
	EX	DE,HL
	LD	IX,I$7B53
	CALL	C.7B99
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	CALL	C.782C			; divide floats
	POP	AF
	PUSH	HL
	PUSH	BC
	RLCA
	RRCA
	LD	L,A
	SBC	A,A
	LD	H,A
	CALL	C.78DF			; convert integer to float
	POP	AF
	LD	C,A
	POP	DE
	CALL	C.76D7			; add floats
	LD	C,80H
	LD	DE,3172H
	JP	C.7748			; multipy floats

I$7B46:	DEFB	4
	DEFB	083H,019H,0F8H
	DEFB	083H,043H,063H
	DEFB	084H,08DH,0CDH
	DEFB	082H,083H,080H
	
I$7B53:	DEFB	4
	DEFB	081H,000H,000H
	DEFB	083H,04DH,0B1H
	DEFB	083H,011H,072H
	DEFB	07FH,035H,005H

;	  Subroutine SQR handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7B60:	LD	A,B
	AND	A
	RET	Z
	RES	7,H
	RRA
	ADC	A,40H
	LD	C,A
	LD	D,H
	LD	E,L
	LD	A,3
J$7B6D:	PUSH	AF
	PUSH	HL
	PUSH	BC
	PUSH	DE
	PUSH	BC
	CALL	C.782C			; divide floats
	POP	DE
	LD	C,E
	POP	DE
	CALL	C.76D7			; add floats
	DEC	B
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	POP	AF
	DEC	A
	JR	NZ,J$7B6D
	LD	B,C
	EX	DE,HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B88:	PUSH	HL
	PUSH	BC
	LD	C,B
	LD	D,H
	LD	E,L
	CALL	C.7748			; multipy floats
	CALL	C.7B99
	POP	AF
	LD	C,A
	POP	DE
	JP	C.7748			; multipy floats

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7B99:	LD	A,(IX+0)
	INC	IX
	PUSH	AF
	PUSH	HL
	PUSH	BC
	LD	B,(IX+0)
	LD	H,(IX+1)
	LD	L,(IX+2)
	INC	IX
	INC	IX
	INC	IX
J$7BB0:	POP	AF
	LD	C,A
	POP	DE
	POP	AF
	DEC	A
	RET	Z
	PUSH	AF
	PUSH	DE
	LD	A,C
	PUSH	AF
	CALL	C.7748			; multipy floats
	LD	C,(IX+0)
	LD	D,(IX+1)
	LD	E,(IX+2)
	CALL	C.76D7			; add floats
	INC	IX
	INC	IX
	INC	IX
	JR	J$7BB0

;	  Subroutine integer to text
;	     Inputs  ________________________
;	     Outputs ________________________

C.7BD1:	LD	IX,FBUFFR+1
	BIT	7,H
	LD	A," "
	JR	Z,J$7BE6
	XOR	A
	SUB	L
	LD	L,A
	SBC	A,A
	SUB	H
	LD	H,A
	JP	M,J$7BF9
	LD	A,"-"
J$7BE6:	LD	(IX+0),A
	INC	IX
	CALL	C.7C0E
J$7BEE:	PUSH	IX
	POP	HL
	LD	A,L
	SUB	LOW (FBUFFR+1)
	LD	HL,FBUFFR+0
	LD	(HL),A
	RET

J$7BF9:	LD	DE,FBUFFR+6
	LD	HL,I$7C07+6
	LD	BC,7
	LDDR
	INC	DE
	EX	DE,HL
	RET

I$7C07:	DEFB	06H,2DH,33H,32H,37H,36H,38H

C.7C0E:	INC	H
	DEC	H
	JR	NZ,J$7C17
	LD	A,L
	CP	9+1
	JR	C,J$7C22
J$7C17:	LD	DE,10
	CALL	C.7643			; divide
	PUSH	DE
	CALL	C.7C0E
	POP	HL
J$7C22:	LD	A,L
	ADD	A,"0"
	LD	(IX+0),A
	INC	IX
	RET

;	  Subroutine float to text
;	     Inputs  ________________________
;	     Outputs ________________________

C.7C2B:	LD	IX,FBUFFR+1
	CALL	C$7C42
	JP	J$7BEE

J$7C35:	LD	(IX+0)," "
	INC	IX
	LD	(IX+0),"0"
	INC	IX
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7C42:	LD	A,B
	AND	A
	JR	Z,J$7C35
	BIT	7,H
	LD	A," "
	JR	Z,J$7C50
	RES	7,H
	LD	A,"-"
J$7C50:	LD	(IX+0),A
	INC	IX
	XOR	A
J.7C56:	PUSH	AF
	LD	C,8AH
	LD	DE,C.79FC
	CALL	C.7966
	JR	NC,J$7C6D
	LD	C,84H
	LD	DE,2000H
	CALL	C.7748			; multipy floats
	POP	AF
	DEC	A
	JR	J.7C56

J$7C6D:	LD	C,8EH
	LD	DE,1C3EH
	CALL	C.7966
	JR	C,J$7C83
	LD	C,84H
	LD	DE,2000H
	CALL	C.782C			; divide floats
	POP	AF
	INC	A
	JR	J.7C56

J$7C83:	LD	C,80H
	LD	DE,0
	CALL	C.76D7			; add floats
	CALL	C.7901			; covert float to integer
	POP	AF
	ADD	A,05H	; 5 
	CP	06H	; 6 
	JR	NC,J$7CE3
	DEC	A
	JP	P,C.7CA7
	LD	(IX+0),"."
	INC	IX
	LD	(IX+0),"0"
	INC	IX
	LD	A,0FFH

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7CA7:	LD	B,A
	LD	DE,1000
	CALL	C.7CC0
	RET	NC
	LD	DE,100
	CALL	C.7CC0
	RET	NC
	LD	DE,10
	CALL	C.7CC0
	RET	NC
	LD	DE,1

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7CC0:	INC	B
	DJNZ	J$7CCB
	LD	(IX+0),"."
	INC	IX
	LD	B,0FFH
J$7CCB:	LD	A,"0"-1
J$7CCD:	INC	A
	AND	A
	SBC	HL,DE
	JR	NC,J$7CCD
	ADD	HL,DE
	LD	(IX+0),A
	INC	IX
	DEC	B
	JR	Z,J$7CDE
	SCF
	RET	P
J$7CDE:	LD	A,L
	OR	H
	RET	Z
	SCF
	RET

J$7CE3:	PUSH	AF
	LD	A,01H
	CALL	C.7CA7
	LD	(IX+0),"E"
	INC	IX
	POP	AF
	SUB	2
	LD	L,A
	LD	A,"+"
	JP	P,J$7CFE
	LD	A,L
	NEG
	LD	L,A
	LD	A,"-"
J$7CFE:	LD	(IX+0),A
	INC	IX
	LD	A,L
	LD	B,"0"-1
J$7D06:	INC	B
	SUB	10
	JR	NC,J$7D06
	ADD	A,'0'+10
	LD	(IX+0),B
	INC	IX
	LD	(IX+0),A
	INC	IX
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7D18:	LD	B,0
	CALL	C.7D34
	CP	"-"
	JR	NZ,J$7D28
	INC	DE
	CALL	C.7D18
	JP	J.79F7

J$7D28:	CP	"&"
	JR	NZ,J$7D8D
	CALL	C$7D3B
	PUSH	DE
	CALL	C.78DF			; convert integer to float
	POP	DE

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7D34:	LD	A,(DE)
	CP	" "
	RET	NZ
	INC	DE
	JR	C.7D34

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7D3B:	LD	HL,0
	INC	DE
	CALL	C.7E38
	INC	DE
	CP	"B"
	JR	Z,J.7D7E
	CP	"O"
	JR	Z,J.7D6D
	CP	"H"
	DEC	DE
	RET	NZ
	INC	DE
J$7D50:	CALL	C.7E38
	AND	A
	RET	Z
	SUB	"0"
	RET	C
	CP	9+1
	JR	C,J$7D64
	CP	11H
	RET	C
	CP	17H
	RET	NC
	SUB	07H
J$7D64:	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	A,L
	LD	L,A
	INC	DE
	JR	J$7D50

J.7D6D:	LD	A,(DE)
	AND	A
	RET	Z
	SUB	"0"
	RET	C
	CP	7+1
	RET	NC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	A,L
	LD	L,A
	INC	DE
	JR	J.7D6D

J.7D7E:	LD	A,(DE)
	AND	A
	RET	Z
	SUB	"0"
	RET	C
	CP	1+1
	RET	NC
	ADD	HL,HL
	ADD	A,L
	LD	L,A
	INC	DE
	JR	J.7D7E

J$7D8D:	LD	C,01H
	DEC	DE
J.7D90:	INC	DE
	CALL	C.7D34
	CP	"0"
	JR	C,J.7DC4
	CP	"9"+1
	JR	NC,J.7DC4
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	C,84H
	LD	DE,2000H
	CALL	C.7748			; multipy floats
	POP	AF
	SUB	"0"
	JR	Z,J$7DBB
	LD	C,88H
J$7DAE:	DEC	C
	ADD	A,A
	JP	P,J$7DAE
	AND	7FH
	LD	D,A
	LD	E,0
	CALL	C.76D7			; add floats
J$7DBB:	POP	DE
	LD	C,E
	POP	DE
	DEC	C
	JR	NZ,J.7D90
	INC	C
	JR	J.7D90

J.7DC4:	CP	"."
	JR	NZ,J$7DCC
	DEC	C
	JR	Z,J.7D90
	RET

J$7DCC:	DEC	C
	JR	Z,J$7DD0
	INC	C
J$7DD0:	CALL	C.7E39			; to upper
	CP	"E"
	JR	Z,J$7DDB
	CP	"D"
	JR	NZ,J$7DF5
J$7DDB:	INC	DE
	CALL	C.7D34
	CP	"+"
	JR	Z,J$7DEF
	CP	"-"
	JR	NZ,J$7DF0
	INC	DE
	CALL	C.7E1C
	NEG
	JR	J$7DF3

J$7DEF:	INC	DE
J$7DF0:	CALL	C.7E1C
J$7DF3:	ADD	A,C
	LD	C,A
J$7DF5:	LD	A,C
	AND	A
	RET	Z
	PUSH	DE
	PUSH	AF
	JP	P,J$7DFF
	NEG
J$7DFF:	LD	E,A
	LD	D,0
	PUSH	HL
	PUSH	BC
	LD	B,84H
	LD	HL,2000H
	CALL	C.7878
	LD	C,B
	EX	DE,HL
	POP	AF
	LD	B,A
	POP	HL
	POP	AF
	PUSH	AF
	CALL	P,C.7748		; multipy floats
	POP	AF
	CALL	M,C.782C		; divide floats
	POP	DE
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7E1C:	PUSH	HL
	LD	L,0
J$7E1F:	CALL	C.7D34
	CP	"9"+1
	JR	NC,J.7E35
	SUB	"0"
	JR	C,J.7E35
	LD	H,A
	LD	A,L
	ADD	A,A
	ADD	A,A
	ADD	A,L
	ADD	A,A
	ADD	A,H
	LD	L,A
	INC	DE
	JR	J$7E1F

J.7E35:	LD	A,L
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C.7E38:	LD	A,(DE)

;	  Subroutine to upper
;	     Inputs  ________________________
;	     Outputs ________________________

C.7E39:	CP	"a"
	RET	C
	CP	"z"+1
	RET	NC
	AND	0DFH
	RET

;	  Subroutine left of string
;	     Inputs  ________________________
;	     Outputs ________________________

I$7E42:	CP	(HL)
	JR	C,J$7E46
	LD	A,(HL)
J$7E46:	INC	HL
	JR	J.7E70

;	  Subroutine right of string
;	     Inputs  ________________________
;	     Outputs ________________________

I$7E49:	CP	(HL)
	JR	C,J$7E4D
	LD	A,(HL)
J$7E4D:	PUSH	AF
	LD	E,(HL)
	NEG
	ADD	A,E
	INC	A
	LD	E,A
	LD	D,0
	ADD	HL,DE
	POP	AF
	JR	J.7E70

;	  Subroutine part of string
;	     Inputs  ________________________
;	     Outputs ________________________

C$7E5A:	LD	C,B
	PUSH	AF
	ADD	A,C
	JR	C,J$7E63
	DEC	A
	CP	(HL)
	JR	C,J$7E6C
J$7E63:	POP	AF
	LD	A,(HL)
	SUB	C
	JR	NC,J$7E6A
	LD	A,0FFH
J$7E6A:	INC	A
	PUSH	AF
J$7E6C:	LD	B,0
	ADD	HL,BC
	POP	AF
J.7E70:	LD	DE,BUF
	LD	(DE),A
	AND	A
	JR	Z,J$7E7D
	INC	DE
	LD	C,A
	LD	B,0
	LDIR
J$7E7D:	LD	HL,BUF
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7E81:	EX	DE,HL
	CP	(HL)
	JR	Z,J$7E86
	RET	NC
J$7E86:	LD	C,A
	LD	A,(DE)
	CP	B
	JR	NC,J$7E8C
	LD	B,A
J$7E8C:	LD	A,C
	DEC	A
	ADD	A,B
	JR	C,J$7E96
	CP	(HL)
	JR	C,J.7E9A
	JR	Z,J.7E9A
J$7E96:	LD	A,(HL)
	SUB	C
	INC	A
	LD	B,A
J.7E9A:	LD	A,L
	ADD	A,C
	LD	L,A
	JR	NZ,J$7EA0
	INC	H
J$7EA0:	EX	DE,HL
	INC	HL
	LD	C,B
	LD	B,0
	LDIR
	RET

;	  Subroutine chr handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7EA8:	LD	HL,BUF+1
	LD	(HL),A
	DEC	HL
	LD	(HL),01H
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7EB0:	LD	DE,BUF+1
	PUSH	DE
	LD	A,(HL)
	AND	A
	JR	Z,J$7EBE
	LD	C,A
	XOR	A
	LD	B,A
	INC	HL
	LDIR
J$7EBE:	LD	(DE),A
	POP	DE
	JP	C.7D18

;	  Subroutine hex handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7EC3:	LD	C,4
	DEFB	011H

;	  Subroutine oct handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7EC6:	LD	C,3
	DEFB	011H

;	  Subroutine bin handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7EC9:	LD	C,1
	LD	DE,FBUFFR+16
J$7ECE:	LD	B,C
	XOR	A
J$7ED0:	SRL	H
	RR	L
	RRA
	DJNZ	J$7ED0
	LD	B,C
J$7ED8:	RLCA
	DJNZ	J$7ED8
	CP	9+1
	JR	C,J$7EE1
	ADD	A,7
J$7EE1:	ADD	A,"0"
	LD	(DE),A
	DEC	DE
	LD	A,L
	OR	H
	JR	NZ,J$7ECE
	LD	A,0D5H
	SUB	E
	LD	(DE),A
	EX	DE,HL
	RET

;	  Subroutine spaces handler
;	     Inputs  ________________________
;	     Outputs ________________________

I$7EEF:	LD	B,A
	LD	A," "

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7EF2:	LD	HL,BUF
	LD	(HL),B
	INC	B
	DEC	B
	RET	Z
	PUSH	HL
	INC	HL
J$7EFB:	LD	(HL),A
	INC	HL
	DJNZ	J$7EFB
	POP	HL
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7F01:	CALL	CHSNS
	LD	HL,BUF
	LD	A,0
	JR	Z,J$7F13
	CALL	CHGET
	INC	HL
	LD	(HL),A
	DEC	HL
	LD	A,1
J$7F13:	LD	(HL),A
	RET

;	  Subroutine __________________________
;	     Inputs  ________________________
;	     Outputs ________________________

C$7F15:	LD	C,A
	LD	A,(DE)
	SUB	C
	SUB	(HL)
	ADD	A,2
	LD	B,A
	LD	A,C
	DEC	A
	ADD	A,E
	LD	E,A
	JR	NC,J.7F23
	INC	D
J.7F23:	PUSH	BC
	PUSH	HL
	LD	B,(HL)
	INC	HL
	INC	DE
	PUSH	DE
J$7F29:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J$7F37
	INC	DE
	INC	HL
	DJNZ	J$7F29
	POP	AF
	POP	AF
	POP	AF
	LD	L,C
	LD	H,B
	RET

J$7F37:	POP	DE
	POP	HL
	POP	BC
	INC	C
	DJNZ	J.7F23
	LD	L,B
	LD	H,B
	RET

;	  Subroutine copy string to NULBUF
;	     Inputs  HL = pointer to string
;	     Outputs ________________________

C$7F40:	LD	DE,(NULBUF)
	LD	C,(HL)			; size of string
	LD	B,0
	INC	BC			; include size byte
	LDIR
	RET

;	  Subroutine string1 > string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C.7F4B:	CALL	C.7F7B			; compare strings
	LD	HL,0
	RET	C
	RET	Z
	DEC	HL
	RET

;	  Subroutine string1 = string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C.7F55:	CALL	C.7F74			; compare strings, assume true
	RET	Z			; equal, quit
	INC	HL			; false
	RET

;	  Subroutine string1 >= string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C.7F5B:	CALL	C.7F74			; compare strings, assume true
	RET	NC
	INC	HL
	RET

;	  Subroutine string1 < string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C.7F61:	CALL	C.7F74			; compare strings, assume true
	RET	C
	INC	HL
	RET

;	  Subroutine string1 <> string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C.7F67:	CALL	C.7F74			; compare strings, assume true
	RET	NZ			; not equal, quit
	INC	HL			; false
	RET

;	  Subroutine string1 <= string 2
;	     Inputs  NULBUF = string 1, HL = string2
;	     Outputs ________________________

C.7F6D:	CALL	C.7F74			; compare strings, assume true
	RET	C
	RET	Z
	INC	HL			; false
	RET

;	  Subroutine compare strings, assume true
;	     Inputs  ________________________
;	     Outputs ________________________

C.7F74:	CALL	C.7F7B			; compare strings
C.7F77:	LD	HL,-1
	RET

;	  Subroutine compare strings
;	     Inputs  NULBUF = first string, HL = second string
;	     Outputs ________________________

C.7F7B:	LD	B,(HL)			; size second string
	INC	HL
	LD	DE,(NULBUF)
	LD	A,(DE)
	LD	C,A			; size first string
	INC	DE
J$7F84:	LD	A,C
	OR	B			; at the end of both strings ?
	RET	Z			; yep, quit with Zx set
	LD	A,C
	SUB	1			; at the end of first string ?
	RET	C			; yep, quit with Cx set, Zx reset
	LD	A,B
	SUB	1			; at the end of second string
	CCF
	RET	NC			; yep, quit with Cx reset, Zx reset
	DEC	B
	DEC	C
	LD	A,(DE)
	CP	(HL)			; compare character
	INC	DE
	INC	HL
	JR	Z,J$7F84		; equal, next character
	RET

;	  Subroutine concat strings
;	     Inputs  NULBUF = string1, HL = string2
;	     Outputs BUF = result string

C$7F99:	LD	DE,BUF
	LD	BC,(NULBUF)
	AND	A
	PUSH	HL
	SBC	HL,DE			; string2 in BUF ?
	POP	HL
	JR	Z,J$7FD2		; yep,
	LD	A,(BC)			; size of string1
	ADD	A,(HL)			; size of string2
	JR	NC,J$7FAD
	LD	A,255			; concat string to 255 characters
J$7FAD:	LD	(DE),A			; result string size
	INC	DE
	PUSH	HL
	LD	A,(BC)			; size of string1
	PUSH	AF
	AND	A			; empty string1 ?
	JR	Z,J$7FBD		; yep, skip copy string1
	INC	BC
	LD	L,C
	LD	H,B
	LD	C,A
	LD	B,0
	LDIR				; copy string1
J$7FBD:	POP	AF			; size of string1
	POP	HL			; string2
	LD	B,A
	LD	A,(HL)			; size string2
	JR	NC,J.7FC5		; string2 not limited
	LD	A,B
J$7FC4:	CPL
J.7FC5:	AND	A			; empty string2 ?
	JR	Z,J$7FCE		; yep, skip copy string2
	INC	HL
	LD	C,A
	LD	B,0
	LDIR				; copy string2
J$7FCE:	LD	HL,BUF			; string in BUF
	RET

J$7FD2:	PUSH	BC
	PUSH	HL
	LD	E,C
	LD	D,B
	LD	A,(DE)
	CP	(HL)
	JR	NC,J$7FDB
	LD	A,(HL)
J$7FDB:	LD	B,A
	INC	B
J$7FDD:	LD	C,(HL)
	LD	A,(DE)
	LD	(HL),A
	LD	A,C
	LD	(DE),A
	INC	DE
	INC	HL
	DJNZ	J$7FDD
	POP	BC
	LD	A,(BC)
	LD	L,A
	LD	H,0
	INC	HL
	ADD	HL,BC
	EX	DE,HL
	POP	HL
	ADD	A,(HL)
	JR	C,J$7FF6
	LD	(BC),A
	LD	A,(HL)
	JR	J.7FC5

J$7FF6:	LD	A,(BC)
	PUSH	AF
	LD	A,0FFH
	LD	(BC),A
	POP	AF
	JR	J$7FC4

	DEFS	08000H-$,0FFH

	END
