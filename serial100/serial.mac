; SERIAL.MAC
;
; MSX-SERIAL first generation (as used in the NAI-2001 serial interface)
;   looks like the newest version known
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker
;
; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders
;

        .Z80
        ASEG

        org     04000H

        INCLUDE SERIAL.INC

RDSLT   EQU     000CH
WRSLT   EQU     0014H
CALSLT	equ	001CH
CHSNS   EQU     009CH
CHGET   EQU     009FH
CHPUT   EQU     00A2H
LPTOUT  EQU     00A5H
BREAKX  EQU     00B7H

SNERR   EQU     4055H                   ; syntax error
TMERR   EQU     406DH                   ; type mismatch error
FNDLIN  EQU     4295H                   ; search linenumber from start of program
CHRGTR  EQU     4666H                   ; get next BASIC character
FCERR   EQU     475AH                   ; illegal function call error
LINGET  EQU     4769H                   ; collect linenumber
USERR   EQU     481CH                   ; undefined line number error
FRMEVL  EQU     4C64H                   ; evaluate expression
DOCNVF  EQU     517AH                   ; convert to DAC to new type
GETBYT  EQU     521CH                   ; evaluate byte operand
GETUIN  EQU     542FH                   ; evaluate address operand
PTRGET  EQU     5EA4H                   ; locate variable
ONTRP   EQU     631BH                   ; enable trap
OFFTRP  EQU     632BH                   ; disable trap
STPTRP  EQU     6331H                   ; stop trap
FRESTR  EQU     67D0H                   ; free temporary string
DERNMF  EQU     6E6BH                   ; bad filename error
DERFAO  EQU     6E6EH                   ; file already open error
DERFNO  EQU     6E77H                   ; file not open error
DERIER  EQU     6E80H                   ; internal error
DERSOO  EQU     6E86H                   ; sequential I/O only error
DIOERR  EQU     73B2H                   ; device I/O error

BUF     EQU     0F55EH

SERTMP  EQU     BUF                     ; temporary storage area

VALTYP  EQU     0F663H
DAC     EQU     0F7F6H
NULBUF  EQU     0F862H
PTRFIL  EQU     0F864H
FNKSTR  EQU     0F87FH

TOCNT   EQU     0FB03H                  ; timeout value
RSFCB   EQU     0FB04H                  ; saved channel
RSIQLN  EQU     0FB06H                  ; buffersize
MEXBIH  EQU     0FB07H                  ; Save for EXTBIO
OLDSTT  EQU     0FB0CH                  ; Save for H.NEWS
OLDINT  EQU     0FB11H                  ; Save for H.KEYI
DEVNUM  EQU     0FB16H                  ; msx serial devicenumber/trap number
DATCNT  EQU     0FB17H                  ; number of bytes in receive buffer
                                        ; get offset in receive buffer
                                        ; put offset in receive buffer
ERRORS  EQU     0FB1AH                  ; receive byte error status
FLAGS   EQU     0FB1BH                  ; b7 = SI/SO receive, b6 = ?, b5 = CR on send, b4 = ?, b3 = channel open, b2 = XON/XOFF receive, b1 = sending suspended, b0 = SI/SO send
ESTBLS  EQU     0FB1CH                  ; b7,b6,b5, b4 = SI/SO handshake, b3 = auto LF on receive, b2 = auto LF on send, b1 = RTS/CTS handshake, b0 = XON/XOFF handshake
COMMSK  EQU     0FB1DH                  ; mask byte (for unused bits)
LSTCOM  EQU     0FB1EH                  ; last command byte
LSTMOD  EQU     0FB1FH                  ; last mode byte

HOKVLD  EQU     0FB20H                  ; EXTBIO valid
ONGSBF  EQU     0FBD8H
TRPTBL  EQU     0FC4CH
INTFLG  EQU     0FC9BH
ESCCNT  EQU     0FCA7H
CSRSR   EQU     0FCA9H
EXPTBL  EQU     0FCC1H
PROCNM  EQU     0FD89H
H.KEYI  EQU     0FD9AH
H.NEWS  EQU     0FF3EH
EXTBIO  EQU     0FFCAH                  ; extended BIOS entry
DISINT  EQU     0FFCFH

        DEFB    "AB"
        DEFW    C4075                   ; initialization handler
        DEFW    C4150                   ; CALL statement handler
        DEFW    C41EC                   ; device handler
        DEFW    0                       ; ROM basic program
        DEFS    6,0                     ; reserved


; BIOS table for RS232

;     Device information byte indicates following options are installed or not:
;       bits #  76543210
;               ||||||||
;               |||||||+----- reserved
;               |||||||
;               ||||||+------ TXREADY interrupt
;               ||||||
;               |||||+------- sync/break character detected
;               |||||
;               ||||+-------- timer interrupt
;               ||||
;               |||+--------- carrier detect
;               |||
;               ||+---------- ring indicator
;               ||
;               |+----------- reserved
;               |
;               +------------ reserved


I4010:  DEFB    010H                    ; RS232 has CD detect
        DEFB    0                       ; RS232 version 1
        DEFB    0                       ; RS232 reserved byte
        JP      J4040                   ; RS232.INIT
        JP      C4260                   ; RS232.OPEN
        JP      C51BE                   ; RS232.STAT
        JP      C42D0                   ; RS232.GETCHR
        JP      C5003                   ; RS232.SNDCHR
        JP      C429B                   ; RS232.CLOSE
        JP      J406A                   ; RS232.EOF
        JP      C4322                   ; RS232.LOC
        JP      C434D                   ; RS232.LOF
        JP      C438A                   ; RS232.BACKUP
        JP      C5143                   ; RS232.SNDBRK
        JP      C51A6                   ; RS232.DTR
        RET                             ; reserved entry
        RET
        RET
        RET                             ; reserved entry
        RET
        RET
        RET                             ; reserved entry
        RET
        RET

;         Subroutine RS232.INIT
;            Inputs  ________________________
;            Outputs ________________________

J4040:  EI
        PUSH    BC
        PUSH    DE
        PUSH    HL
        LD      IY,-13
        ADD     IY,SP
        LD      SP,IY                   ; allocate space on stack
        PUSH    IY
        POP     DE                      ; pointer to space on stack
        LD      C,13
J4051:  CALL    C44CC                   ; read byte from slot
        LD      (DE),A
        INC     DE
        DEC     C
        JR      NZ,J4051
        CALL    C4D0B                   ; initialize RS232
        PUSH    AF
        LD      IY,13+2
        ADD     IY,SP
        POP     AF
        LD      SP,IY                   ; deallocate space on stack
        POP     HL
        POP     DE
        POP     BC
        RET

;         Subroutine RS232.EOF
;            Inputs  ________________________
;            Outputs ________________________

J406A:  LD      HL,0                    ; assume not eof
        CALL    C4E92                   ; get number of bytes in receive buffer (include backup byte)
        RET     Z                       ; none, quit (eof=false)
        CALL    C436A                   ; determine eof
        RET

;         Subroutine MSX-Serial extension INIT
;            Inputs  ________________________
;            Outputs ________________________

C4075:  CALL    C4E7E                   ; disable RS232 interrupts
        LD      IY,I4143                ; RS232 defaults
        CALL    C4D0B                   ; initialize RS232
        CALL    C4131                   ; clear flags and receive buffer
        DI
        LD      DE,OLDINT
        LD      HL,H.KEYI
        LD      BC,5
        LDIR                            ; store old interrupt handler
        LD      DE,OLDSTT
        LD      HL,H.NEWS
        LD      BC,5
        LDIR                            ; store old new statement handler
        CALL    C4E5F                   ; get my slotid
        LD      (H.KEYI+1),A
        LD      (H.NEWS+1),A
        LD      A,0F7H
        LD      (H.KEYI+0),A
        LD      (H.NEWS+0),A
        LD      HL,I4E8C
        LD      (H.KEYI+2),HL
        LD      HL,I4C0F
        LD      (H.NEWS+2),HL
        LD      A,0C9H
        LD      (H.KEYI+4),A
        LD      (H.NEWS+4),A            ; install interrupt and new statement handler
        EI
        LD      HL,HOKVLD
        BIT     0,(HL)                  ; EXTBIO intialized ?
        JR      NZ,J40D2                ; yep, skip
        SET     0,(HL)
        LD      HL,EXTBIO
        LD      B,5
J40CD:  LD      (HL),0C9H
        INC     HL
        DJNZ    J40CD                   ; initialize EXTBIO
J40D2:  XOR     A
        LD      DE,0801H                ; device=MSX serial, function=return number of channels
        CALL    EXTBIO
        LD      HL,DEVNUM
        LD      (HL),A                  ; store MSX serial channel number
        XOR     A
        LD      DE,0001H                ; device=broadcast, function=return number of trap entries used
        CALL    EXTBIO
        ADD     A,A
        ADD     A,A
        ADD     A,A
        ADD     A,A                     ; trap number in b7-b4
        OR      (HL)
        LD      (HL),A                  ; store with channel number (b3-b0)
        LD      DE,MEXBIH
        DI
        LD      HL,EXTBIO
        LD      BC,5
        LDIR                            ; store old EXTBIO
        CALL    C4E5F                   ; get my slotid
        LD      (EXTBIO+1),A
        LD      A,0F7H
        LD      (EXTBIO+0),A
        LD      HL,I43DF
        LD      (EXTBIO+2),HL
        LD      A,0C9H
        LD      (EXTBIO+4),A            ; install new EXTBIO handler
        LD      BC,L4119
        LD      HL,I4119
        LD      DE,DISINT
        LDIR                            ; install DISINT and ENAINT handler
        EI
        RET

;         Subroutine DISINT
;            Inputs  ________________________
;            Outputs ________________________

I4119:  PUSH    DE
        LD      E,2                     ; function=disable interrupt
        JR      J4121

;         Subroutine ENAINT
;            Inputs  ________________________
;            Outputs ________________________

?411E:  PUSH    DE
        LD      E,3                     ; function=enable interrupt
J4121:  LD      D,0                     ; device=broadcast
        PUSH    IX
        PUSH    IY
        CALL    EXTBIO
        EI
        POP     IY
        POP     IX
        POP     DE
        RET

L4119   equ     $-I4119

;         Subroutine clear flags and receive buffer
;            Inputs  ________________________
;            Outputs ________________________

C4131:  XOR     A
        LD      (FLAGS),A

;         Subroutine clear receive buffer
;            Inputs  ________________________
;            Outputs ________________________

C4135:  PUSH    HL
        LD      HL,DATCNT
        XOR     A
        LD      (HL),A                  ; number of bytes in receive buffer=0
        INC     HL
        LD      (HL),A                  ; get offset in receive buffer=0
        INC     HL
        LD      (HL),A                  ; put offset in receive buffer=0
        INC     HL
        LD      (HL),A                  ; clear receive byte error status
        POP     HL
        RET

; RS232 default settings

I4143:  DEFB    "8N1XHNNN"
        DEFW    1200
        DEFW    1200
        DEFB    0

;         Subroutine MSX-Serial extension STATEMENT handler
;            Inputs  ________________________
;            Outputs ________________________

C4150:  EI
        PUSH    HL
        POP     IX                      ; store BASIC pointer
        LD      DE,I41AD                ; CALL statement table
        CALL    C415D                   ; find statement
        RET     C                       ; not found, quit
        PUSH    DE
        RET                             ; execute statement handler

;         Subroutine find statement
;            Inputs  ________________________
;            Outputs ________________________

C415D:  PUSH    BC                      ; store ?
        PUSH    HL                      ; store BASIC pointer
        LD      HL,PROCNM
        LD      A,(HL)
        CP      "C"                     ; starts with COM ?
        JR      NZ,J418C                ; nope, quit with not found
        INC     HL
        LD      A,(HL)
        CP      "O"                     ; starts with COM ?
        JR      NZ,J418C                ; nope, quit with not found
        INC     HL
        LD      A,(HL)
        CP      "M"                     ; starts with COM ?
        JR      NZ,J418C                ; nope, quit with not found
J4173:  LD      HL,PROCNM+3
        LD      A,(DE)
        INC     A                       ; end of table ?
        JR      Z,J418C                 ; yep, quit with not found
        CALL    C4190                   ; compare with name in table
        JR      Z,J4184                 ; found, return found and statement handler
        INC     DE
        INC     DE
        INC     DE                      ; skip to next entry
        JR      J4173                   ; try next

J4184:  EX      DE,HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; statement handler
        AND     A                       ; statement found
        JR      J418D                   ; quit

J418C:  SCF                             ; statement not found
J418D:  POP     HL                      ; restore BASIC pointer
        POP     BC                      ; restore ?
        RET

;         Subroutine compare with name in table
;            Inputs  ________________________
;            Outputs ________________________

C4190:  LD      A,(DE)
        LD      C,A
        LD      A,(HL)
J4193:  CP      C                       ; same ?
        JR      NZ,J419C                ; nope,
        AND     A                       ; end of name ?
        RET     Z                       ; yep, quit with found
        INC     DE
        INC     HL
        JR      C4190

J419C:  LD      A,(DE)
        AND     A                       ; end of name ?
        JR      Z,J41A3                 ; yep,
        INC     DE
        JR      J419C                   ; continue

J41A3:  LD      A,(HL)
        AND     A                       ; end of name ?
        JR      Z,J41AA                 ; yep,
        INC     HL
        JR      J41A3                   ; continue

J41AA:  LD      A,L
        OR      H
        RET

I41AD:  DEFB    "INI",0
        DEFW    C4599
        DEFB    "DTR",0
        DEFW    C465C
        DEFB    "STAT",0
        DEFW    C467A
        DEFB    "BREAK",0
        DEFW    C469E
        DEFB    "TERM",0
        DEFW    C46E3
        DEFB    0
        DEFW    C4B66
        DEFB    "ON",0
        DEFW    C4BBE
        DEFB    "OFF",0
        DEFW    C4BA0
        DEFB    "STOP",0
        DEFW    C4BDC

        IF      COMHELP EQ 1
        DEFB    "HELP",0
        DEFW    C496F
        ENDIF

        db      -1

;         Subroutine MSX-Serial extension DEVICE handler
;            Inputs  ________________________
;            Outputs ________________________

C41EC:  EI
        CP      0FFH                    ; device inquire ?
        JP      NZ,J4229                ; nope,
        LD      HL,PROCNM
        LD      A,(HL)
        CP      "C"
        JR      NZ,J4227
        INC     HL
        LD      A,(HL)
        CP      "O"
        JR      NZ,J4227
        INC     HL
        LD      A,(HL)
        CP      "M"
        JR      NZ,J4227
        INC     HL
        LD      A,(HL)
        AND     A                       ; channel number specified ?
        JR      NZ,J420E                ; yep,
        DEC     HL
        LD      A,"0"                   ; channel 0
J420E:  SUB     "0"                     ; valid channel number ?
        JR      C,J4227                 ; nope, quit with device not recognized
        CP      9+1                     ; valid channel number ?
        JR      NC,J4227                ; nope, quit with device not recognized
        PUSH    BC
        PUSH    AF
        LD      A,(DEVNUM)
        AND     0FH
        LD      B,A                     ; this interface channel number
        POP     AF
        CP      B                       ; channel handled by this interface ?
        POP     BC
        JR      NZ,J4227                ; nope, quit with device not recognized
        INC     HL
        LD      A,(HL)
        AND     A                       ; end of devicename ?
        RET     Z                       ; yep, quit with device recognized, device relative number=0
J4227:  SCF
        RET

J4229:  PUSH    HL
        PUSH    AF
        LD      HL,I423A
        ADD     A,L
        LD      L,A
        JR      NC,J4233
        INC     H
J4233:  LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A
        POP     AF
        EX      (SP),HL
        RET

;         Subroutine BASIC device function table
;            Inputs  ________________________
;            Outputs ________________________

I423A:  DEFW    C424E                   ; function open
        DEFW    C429B                   ; function close, RS232.CLOSE
        DEFW    J4485                   ; function random i/o, sequential i/o only error
        DEFW    C42BD                   ; function sequential output
        DEFW    C42C9                   ; function sequential input
        DEFW    C4314                   ; function loc
        DEFW    C4347                   ; function lof
        DEFW    C4361                   ; function eof
        DEFW    J44A3                   ; function fpos,illegal function call
        DEFW    C438A                   ; function backup, RS232.BACKUP

;         Subroutine BASIC device, function open
;            Inputs  ________________________
;            Outputs ________________________

C424E:  LD      C,127                   ; receive buffer size
        CALL    C4260                   ; RS232.OPEN
        JR      C,J4259                 ; error,
        LD      (PTRFIL),HL
        RET

J4259:  DEC     A
        JP      Z,J4479                 ; bad filename error
        JP      J448B                   ; file already open error

;         Subroutine RS232.OPEN
;            Inputs  HL = pointer to FCB, E = mode, C = receive buffer size
;            Outputs ________________________

C4260:  OR      A
        LD      A,(FLAGS)
        BIT     3,A                     ; already open ?
        LD      A,2
        SCF
        RET     NZ                      ; yep, quit with error
        LD      A,E
        CP      8                       ; mode is append ?
        LD      A,1
        SCF
        RET     Z                       ; yep, quit with error
        PUSH    BC
        PUSH    DE
        PUSH    HL
        LD      (RSFCB),HL
        LD      A,C
        LD      (RSIQLN),A              ; receive buffer size
        LD      (HL),E                  ; store mode in FCB
        XOR     A
        INC     HL
        INC     HL
        LD      (HL),A
        INC     HL
        LD      (HL),A
        INC     HL
        INC     HL
        INC     HL
        LD      (HL),A
        CALL    C4131                   ; clear flags and receive buffer
        LD      HL,FLAGS
        SET     3,(HL)                  ; set open flag
        DI
        CALL    C4E85                   ; enable RS232 interrupts
        CALL    C5189                   ; enable RTS
        EI
        OR      A                       ; clear Cx
        POP     HL
        POP     DE
        POP     BC
        RET

;         Subroutine RS232.CLOSE
;            Inputs  ________________________
;            Outputs ________________________

C429B:  PUSH    HL
        LD      HL,(RSFCB)
        LD      A,(HL)                  ; mode
        CP      2                       ; output ?
        SCF
        CCF
        JR      NZ,J42AB                ; nope,
        LD      A,1AH
        CALL    C5003                   ; RS232.SNDCHR
J42AB:  DI
        CALL    C51E4                   ; wait for empty transmitter
        CALL    C5191                   ; disable RTS if RTS/CTS handshake
        CALL    C4E7E                   ; disable RS232 interrupts
        EI
        LD      HL,FLAGS
        RES     3,(HL)                  ; reset open flag
        POP     HL
        RET

;         Subroutine BASIC device, function sequential output
;            Inputs  ________________________
;            Outputs ________________________

C42BD:  LD      A,C
        CALL    C5003                   ; RS232.SNDCHR
        EI
        JP      C,J44AF                 ; device I/O error
        JP      Z,J44AF                 ; device I/O error
        RET

;         Subroutine BASIC device, function sequential input
;            Inputs  ________________________
;            Outputs ________________________

C42C9:  CALL    C42D0                   ; RS232.GETCHR
        JP      M,J44AF                 ; error, device I/O error
        RET

;         Subroutine RS232.GETCHR
;            Inputs  ________________________
;            Outputs ________________________

C42D0:  PUSH    HL
        PUSH    BC
        CALL    C43A2                   ; get pointer to backup byte
        LD      C,(HL)                  ; backup byte
        LD      (HL),0                  ; clear backup byte
        DEC     HL
        LD      A,(HL)                  ; backup byte error status
        LD      (ERRORS),A              ; update receive byte error status
        LD      (HL),0                  ; clear backup error status
        INC     HL
        AND     A                       ; any errors ?
        JR      NZ,J430A                ; yep, return byte with error flag set
        LD      A,C
        AND     A                       ; valid backup byte ?
        JR      NZ,J42F6                ; yep, skip
        CALL    C4EA6                   ; wait for received byte
        EI
        LD      C,A                     ; store received byte
        JP      M,J430A                 ; error, quit with error flag
        CALL    C50D1                   ; update error flags
        JR      C,J430A                 ; aborted by ctrl-stop, quit with error flag
        JR      Z,J430A                 ; timeout, quit with error flag
J42F6:  PUSH    HL
        LD      HL,(RSFCB)
        LD      A,(HL)                  ; mode
        POP     HL
        CP      4                       ; raw ?
        JR      Z,J430E                 ; yep, quit
        LD      A,C
        CP      1AH                     ; EOF ?
        JR      NZ,J430E                ; nope, quit
        LD      (HL),A                  ; backup byte
        AND     A                       ; clear sign flag (no error)
        SCF                             ; set Cx (EOF)
        JR      J4311

J430A:  OR      80H                     ; set sign flag (error)
        JR      J4310

J430E:  XOR     A                       ; clear Cx (no EOF)
        INC     A                       ; clear sign flag (no error)
J4310:  LD      A,C
J4311:  POP     BC
        POP     HL
        RET

;         Subroutine BASIC device, function loc
;            Inputs  ________________________
;            Outputs ________________________

C4314:  PUSH    HL
        CALL    C4322                   ; RS232.LOC
J4318:  LD      (DAC+2),HL
        LD      HL,VALTYP
        LD      (HL),2
        POP     HL
        RET

;         Subroutine RS232.LOC
;            Inputs  ________________________
;            Outputs ________________________

C4322:  PUSH    AF
        EI
        LD      HL,(RSFCB)
        LD      A,(HL)                  ; mode
        CP      1                       ; input ?
        JR      NZ,J433F                ; nope,
        CALL    C439A                   ; get backup byte
        JR      Z,J4337                 ; no backup byte,
        SUB     1AH                     ; EOF ?
        JR      Z,J4342                 ; yep, return 0
        LD      A,1                     ; 1 extra
J4337:  PUSH    BC
        CALL    C43A9                   ; get number of characters in receiver buffer (with EOF check)
        ADD     A,B                     ; + extra
        POP     BC
        JR      J4342                   ; return

J433F:  CALL    C4E92                   ; get number of bytes in receive buffer (include backup byte)
J4342:  LD      L,A
        LD      H,0
        POP     AF
        RET

;         Subroutine BASIC device, function lof
;            Inputs  ________________________
;            Outputs ________________________

C4347:  PUSH    HL
        CALL    C434D                   ; RS232.LOF
J434B:  JR      J4318                   ; put result in DAC and quit

;         Subroutine RS232.LOF
;            Inputs  ________________________
;            Outputs ________________________

C434D:  PUSH    AF
        EI
        CALL    C4322                   ; RS232.LOC
        PUSH    DE
        EX      DE,HL
        LD      A,(RSIQLN)
        LD      L,A
        LD      H,0                     ; receive buffer size
        AND     A
        SBC     HL,DE
        INC     HL
        POP     DE
        POP     AF
        RET

;         Subroutine BASIC device, function eof
;            Inputs  ________________________
;            Outputs ________________________

C4361:  PUSH    HL
        CALL    C436A                   ; determine eof
        JP      M,J44AF                 ; error, device I/O error
        JR      J434B                   ; put result in DAC and quit

;         Subroutine determine eof
;            Inputs  ________________________
;            Outputs ________________________

C436A:  PUSH    BC
        LD      B,A
        EI
        CALL    C42D0                   ; RS232.GETCHR (receive byte)
        JP      M,J4387                 ; error, quit with error
        PUSH    BC
        LD      C,A
        CALL    C438A                   ; RS232.BACKUP (backup byte)
        POP     BC
        CP      1AH                     ; eof ?
        JR      Z,J4383                 ; yep, quit with eof=true
        XOR     A
        LD      L,A
        LD      H,A                     ; eof=false
        INC     A                       ; clear error flag
        JR      J4387

J4383:  LD      HL,-1
        SCF
J4387:  LD      A,B
        POP     BC
        RET

;         Subroutine RS232.BACKUP
;            Inputs  ________________________
;            Outputs ________________________

C438A:  PUSH    HL
        CALL    C43A2                   ; get pointer to backup byte
        LD      (HL),C                  ; store backup byte
        PUSH    AF
        DEC     HL
        LD      A,(ERRORS)              ; receive byte error status
        AND     38H                     ; clear b7,b6 (timeout),b2 (aborted),b1,b0
        LD      (HL),A
        POP     AF
        POP     HL
        RET

;         Subroutine get backup byte
;            Inputs  ________________________
;            Outputs ________________________

C439A:  PUSH    HL
        CALL    C43A2                   ; get pointer to backup byte
        LD      A,(HL)                  ; backup byte
        POP     HL
        AND     A                       ; valid backup byte
        RET

;         Subroutine get pointer to backup byte
;            Inputs  ________________________
;            Outputs ________________________

C43A2:  LD      HL,(RSFCB)
        INC     HL
        INC     HL
        INC     HL
        RET

;         Subroutine get number of characters in receiver buffer (with EOF check)
;            Inputs  ________________________
;            Outputs ________________________

C43A9:  PUSH    AF
        PUSH    HL
        LD      B,0                     ; offset = 0
        CALL    C4EA1                   ; get number of characters in receive buffer
        JR      Z,J43BF                 ; none, quit
        LD      C,A                     ; store number of characters
J43B3:  CALL    C43C2                   ; get pointer in receive buffer
        LD      A,(HL)                  ; received byte
        CP      1AH                     ; EOF ?
        JR      Z,J43BF                 ; yep, quit
        INC     B                       ; update offset
        DEC     C                       ; update number of characters
        JR      NZ,J43B3                ; next
J43BF:  POP     HL
        POP     AF
        RET

;         Subroutine get pointer in receive buffer
;            Inputs  B = offset
;            Outputs ________________________

C43C2:  PUSH    DE
        LD      A,(DATCNT+1)            ; get offset in receive buffer
        LD      HL,RSIQLN
        ADD     A,B
        JR      C,J43CF
        CP      (HL)
        JR      C,J43D0
J43CF:  SUB     (HL)
J43D0:  LD      HL,(RSFCB)
        LD      E,LOW 9
        LD      D,HIGH 9
        ADD     HL,DE                   ; pointer to buffer
        LD      E,A
        LD      D,0
        ADD     HL,DE
        ADD     HL,DE
        POP     DE
        RET

;         Subroutine EXTBIO handler
;            Inputs  ________________________
;            Outputs ________________________

I43DF:  EI
        PUSH    AF
        LD      A,D
        INC     A                       ; device = system exclusive ?
        JP      Z,J4436                 ; yep,
        DEC     A                       ; device = broadcast ?
        JP      NZ,J4449                ; nope,

; EXTBIO broadcast

        LD      A,E
        AND     A                       ; function = build device name table ?
        JR      Z,J43FA                 ; yep, handle
        DEC     A                       ; function = return number of trap entries used ?
        JR      Z,J4407                 ; yep, handle
        DEC     A                       ; function = disable interrupt ?
        JR      Z,J440D                 ; yep, handle
        DEC     A                       ; function = enable interrupt ?
        JR      Z,J4421                 ; yep, handle
        JP      J4464                   ; continue with EXTBIO chain

; build device name table

J43FA:  LD      A,8                     ; MSX-serial device
        CALL    C44B6                   ; write byte to slot
        LD      A,0
        CALL    C44B6                   ; write byte to slot
        JP      J4464                   ; continue with EXTBIO chain

; return number of trap entries used

J4407:  POP     AF
        INC     A                       ; use 1 trap entry
        PUSH    AF
        JP      J4464                   ; continue with EXTBIO chain

; disable interrupt

J440D:  CALL    C4C50                   ; RS232 port open ?
        JR      Z,J441E                 ; nope, skip
        PUSH    BC
        CALL    C4FCF                   ; signal sender to stop sending
        EI
        NOP
        POP     BC
        DI
        CALL    C4E7E                   ; disable RS232 interrupts
        EI
J441E:  JP      J4464                   ; continue with EXTBIO chain

; enable interrupt

J4421:  CALL    C4C50                   ; RS232 port open ?
        JR      Z,J4433                 ; nope, skip
        DI
        CALL    C4E85                   ; enable RS232 interrupts
        CALL    C5189                   ; enable RTS
        PUSH    BC
        CALL    C4FB5                   ; signal sender to resume sending
        POP     BC
        EI
J4433:  JP      J4464                   ; continue with EXTBIO chain

; EXTBIO system exclusive

J4436:  LD      A,E
        AND     A                       ; function = build BIOS table ?
        JR      NZ,J4447                ; nope,

; build BIOS table

        CALL    C4468                   ; write slotid and pointer to BIOS jumptable
        LD      A,0                     ; reserved byte
        CALL    C44B6                   ; write byte to slot
        LD      A,0                     ; reserved byte
        CALL    C44B6                   ; write byte to slot
J4447:  JR      J4464                   ; continue with EXTBIO chain

J4449:  CP      8                       ; MSX-serial device ?
        JR      NZ,J4464                ; nope, continue with EXTBIO chain
        LD      A,E
        AND     A                       ; function = build BIOS table ?
        JR      Z,J4457                 ; yep, handle
        CP      1                       ; function = return number of channels ?
        JR      Z,J4461                 ; yep, handle
        JR      J4464                   ; continue with EXTBIO chain

; build BIOS table

J4457:  CALL    C4468                   ; write slotid and pointer to BIOS jumptable
        LD      A,0                     ; reserved byte
        CALL    C44B6                   ; write byte to slot
        JR      J4464                   ; continue with EXTBIO chain

; return number of channels

J4461:  POP     AF
        INC     A                       ; has 1 channel
        PUSH    AF
J4464:  POP     AF
        JP      MEXBIH                  ; continue with EXTBIO chain

;         Subroutine write slotid and pointer to BIOS jumptable
;            Inputs  ________________________
;            Outputs ________________________

C4468:  CALL    C4E5F                   ; get my slotid
        CALL    C44B6                   ; write byte to slot
        LD      A,LOW I4010
        CALL    C44B6                   ; write byte to slot
        LD      A,HIGH I4010
        CALL    C44B6                   ; write byte to slot
        RET

J4479:  LD      IX,DERNMF
        JR      J44B3

?447F:  LD      IX,DERIER
        JR      J44B3

J4485:  LD      IX,DERSOO
        JR      J44B3

J448B:  LD      IX,DERFAO
        JR      J44B3

J4491:  LD      IX,DERFNO
        JR      J44B3

J4497:  LD      IX,USERR
        JR      J44B3

J449D:  LD      IX,SNERR
        JR      J44B3

J44A3:  LD      IX,FCERR
        JR      J44B3

J44A9:  LD      IX,TMERR
        JR      J44B3

J44AF:  LD      IX,DIOERR
J44B3:  JP      C4588                   ; call mainrom and enable interrupts

;         Subroutine write byte to slot
;            Inputs  ________________________
;            Outputs ________________________

C44B6:  PUSH    AF
        PUSH    BC
        PUSH    DE
        PUSH    IX
        LD      E,A
        LD      A,B
        LD      IX,WRSLT
        CALL    C458D
        EI
        INC     HL
        POP     IX
        POP     DE
        POP     BC
        POP     AF
        RET

;         Subroutine read byte from slot
;            Inputs  ________________________
;            Outputs ________________________

C44CC:  PUSH    BC
        PUSH    DE
        PUSH    IX
        LD      A,B
        LD      IX,RDSLT
        CALL    C458D
        EI
        INC     HL
        POP     IX
        POP     DE
        POP     BC
        RET

;         Subroutine check if ctrl-stop pressed
;            Inputs  ________________________
;            Outputs ________________________

C44DF:  PUSH    IX
        LD      IX,BREAKX
        CALL    C458D
        POP     IX
        RET

;         Subroutine echo to screen/printer (literal)
;            Inputs  ________________________
;            Outputs ________________________

C44EB:  PUSH    BC
        LD      B,A
        LD      A,(SERTMP+3)
        AND     A                       ; literal mode ?
        JR      Z,J4511                 ; nope,
        LD      A,B
        CP      20H                     ; control character ?
        JR      NC,J4511
        LD      A,"^"
        CALL    C4513                   ; echo to screen/printer
        LD      A,B
        ADD     A,40H
        CALL    C4513                   ; echo to screen/printer
        LD      A,B
        CP      0AH                     ; LF ?
        POP     BC
        RET     NZ                      ; nope, quit
        LD      A,0DH                   ; CR
        CALL    C4513                   ; echo to screen/printer
        LD      A,0AH                   ; LF
        JR      C4513                   ; echo to screen/printer

J4511:  LD      A,B
        POP     BC

;         Subroutine echo to screen/printer
;            Inputs  ________________________
;            Outputs ________________________

C4513:  PUSH    AF
        CALL    CHPUT
        EI
        LD      A,(SERTMP+5)
        AND     A                       ; printer echo ?
        JR      Z,J4524                 ; nope, quit
        POP     AF
        PUSH    AF
        CALL    LPTOUT
        EI
J4524:  POP     AF
        RET

;         Subroutine check for BASIC character
;            Inputs  ________________________
;            Outputs ________________________

C4526:  LD      A,(HL)
        EX      (SP),HL
        CP      (HL)
        JP      NZ,J449D                ; syntax error
        INC     HL
        EX      (SP),HL

;         Subroutine get next BASIC character
;            Inputs  ________________________
;            Outputs ________________________

C452E:  PUSH    IX
        LD      IX,CHRGTR               ; get next BASIC character
        EXX
        PUSH    HL
        EXX
        CALL    C4588                   ; call mainrom and enable interrupts
        EXX
        POP     HL
        EXX
        POP     IX
        RET

;         Subroutine evaluate expression
;            Inputs  ________________________
;            Outputs ________________________

C4540:  PUSH    IX
        LD      IX,FRMEVL               ; evaluate expression
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     IX
        RET

;         Subroutine evaluate address operand
;            Inputs  ________________________
;            Outputs ________________________

C454C:  PUSH    IX
        LD      IX,GETUIN               ; evaluate address operand
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     IX
        RET

;         Subroutine evaluate byte operand
;            Inputs  ________________________
;            Outputs ________________________

C4558:  PUSH    IX
        LD      IX,GETBYT               ; evaluate byte operand
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     IX
        RET

;         Subroutine locate variable
;            Inputs  ________________________
;            Outputs ________________________

C4564:  PUSH    IX
        LD      IX,PTRGET               ; locate variable
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     IX
        RET

;         Subroutine free temporary string
;            Inputs  ________________________
;            Outputs ________________________

C4570:  PUSH    IX
        LD      IX,FRESTR               ; free temporary string with type check
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     IX
        RET

;         Subroutine convert to DAC to new type
;            Inputs  ________________________
;            Outputs ________________________

C457C:  PUSH    IX
        LD      IX,DOCNVF               ; convert to DAC to new type
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     IX
        RET

;         Subroutine call mainrom and enable interrupts
;            Inputs  ________________________
;            Outputs ________________________

C4588:  CALL    C458D
        EI
        RET

;         Subroutine call mainrom
;            Inputs  ________________________
;            Outputs ________________________

C458D:  PUSH    IY
        LD      IY,(EXPTBL+0-1)
        CALL    CALSLT
        POP     IY
        RET

;         Subroutine CALL COMINI statement
;            Inputs  ________________________
;            Outputs ________________________

C4599:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4C50                   ; RS232 port open ?
        DI
        CALL    C4E7E                   ; disable RS232 interrupts
        EI
        LD      A,(LSTCOM)              ; last command byte
        LD      (SERTMP+2),A            ; store last command byte
        LD      IY,SERTMP+9
        PUSH    BC
        PUSH    DE
        PUSH    HL
        LD      BC,13
        PUSH    IY
        POP     DE
        LD      HL,I4143
        LDIR                            ; copy RS232 defaults
        POP     HL
        POP     DE
        POP     BC
        LD      A,B
        AND     C
        INC     A                       ; string specified ?
        JR      NZ,J45D9                ; yep,
        LD      A,D                     ; last BASIC character
        AND     A                       ; end of line ?
        JP      Z,J4645                 ; yep,
        CP      ":"                     ; next statement ?
        JP      Z,J4645                 ; yep,
        CP      ")"                     ; end of statement parameters ?
        JP      Z,J4642                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ','
        JR      J45FF

J45D9:  PUSH    HL
        EXX
        PUSH    HL
        EXX
        POP     HL
        LD      A,B
        AND     A                       ; empty string ?
        JR      Z,J45F2                 ; yep, skip
        PUSH    IY
        POP     DE
J45E5:  LD      A,(HL)
        CP      " "                     ; space ?
        JR      Z,J45EE                 ; yep, skip
        CALL    C4D02                   ; to uppercase
        LD      (DE),A
J45EE:  INC     DE
        INC     HL
        DJNZ    J45E5
J45F2:  POP     HL
        DEC     HL
        CALL    C452E                   ; get next BASIC character
        CP      ")"                     ; end of statement parameters ?
        JR      Z,J4642                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ','
J45FF:  CP      ","
        JR      Z,J4619
        CALL    C454C                   ; evaluate address operand
        LD      (IY+8),E
        LD      (IY+9),D                ; store receiver baudrate
        LD      A,(HL)
        CP      ")"
        JR      NZ,J4619
        LD      (IY+10),E
        LD      (IY+11),D               ; store transmitter baudrate
        JR      J4642

J4619:  CALL    C4526                   ; check for BASIC character
        DEFB    ','
        CP      ","
        JR      Z,J462F
        CALL    C454C                   ; evaluate address operand
        LD      (IY+10),E
        LD      (IY+11),D               ; store transmitter baudrate
        LD      A,(HL)
        CP      ")"
        JR      Z,J4642
J462F:  CALL    C4526                   ; check for BASIC character
        DEFB    ','
        CP      ")"
        JR      Z,J4642
        CALL    C4558                   ; evaluate byte operand
        LD      (IY+12),A               ; store timeout
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
        DEC     HL
J4642:  CALL    C452E                   ; get next BASIC character
J4645:  EI
        CALL    C4D0B                   ; initialize RS232
        JP      C,J44A3                 ; error, illegal function call
        CALL    C4C50                   ; RS232 port open ?
        CALL    NZ,C4E85                ; yep, enable RS232 interrupts
        LD      A,(SERTMP+2)
        BIT     5,A                     ; was RTS enabled ?
        CALL    NZ,C5189                ; yep, enable RTS
        AND     A                       ; statement handled
        RET

;         Subroutine CALL COMDTR statement
;            Inputs  ________________________
;            Outputs ________________________

C465C:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        CALL    C4526                   ; check for BASIC character
        DEFB    ','
        CALL    C4C50                   ; RS232 port open ?
        JP      Z,J4491                 ; nope, file not open error
        CALL    C454C                   ; evaluate address operand
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
        LD      A,D
        OR      E                       ; convert to byte (0 or <>0)
        CALL    C51A6                   ; RS232.DTR
        EI
        RET

;         Subroutine CALL COMSTAT statement
;            Inputs  ________________________
;            Outputs ________________________

C467A:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        CALL    C4526                   ; check for BASIC character
        DEFB    ','
        CALL    C4C50                   ; RS232 port open ?
        JP      Z,J4491                 ; nope, file not open error
        CALL    C4564                   ; locate variable
        PUSH    HL                      ; store BASIC pointer
        CALL    C51BE                   ; RS232.STAT
        LD      (DAC+2),HL              ; store result in DAC
        POP     HL                      ; restore BASIC pointer
        CALL    C4CC9                   ; copy DAC to variable
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
        AND     A                       ; statement handled
        RET

;         Subroutine CALL COMBREAK statement
;            Inputs  ________________________
;            Outputs ________________________

C469E:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        CALL    C4C50                   ; RS232 port open ?
        JP      Z,J4491                 ; nope, file not open error
        LD      A,D                     ; last BASIC character
        CP      ","                     ; parameter seperator ?
        JR      Z,J46BF                 ; yep,
        AND     A                       ; end of line ?
        JR      Z,J46BA                 ; yep,
        CP      ":"                     ; next statement ?
        JR      Z,J46BA                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J46BA:  LD      DE,10
        JR      J46C9

J46BF:  CALL    C452E                   ; get next BASIC character
        CALL    C454C                   ; evaluate address operand
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J46C9:  PUSH    HL
        LD      HL,2
        AND     A
        SBC     HL,DE
        JP      NC,J44A3                ; illegal function call
        POP     HL
        CALL    C5143                   ; RS232.SNDBRK
        EI
        LD      A,0
        INC     A                       ; clear Cx, clear Zx
        CALL    C50D1                   ; update error flags
        JP      C,J44AF                 ; aborted, device I/O error
        AND     A                       ; statement handled
        RET

;         Subroutine CALL COMTERM statement
;            Inputs  ________________________
;            Outputs ________________________
;            Remark  BUGFIX: _COMTERM in basic program, something with cursor

C46E3:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        LD      A,D                     ; last BASIC character
        AND     A                       ; end of line ?
        JR      Z,J46F5                 ; yep,
        CP      ':'                     ; next statement ?
        JR      Z,J46F5                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J46F5:  LD      (SERTMP+7),HL           ; store BASIC pointer
        CALL    C4C50                   ; RS232 port open ?
        JP      NZ,J448B                ; yep, file already open error
        XOR     A
        LD      (SERTMP+0),A            ; clear received ESC byte
        LD      (SERTMP+5),A            ; printer echo = off
        LD      (SERTMP+3),A            ; literal mode = off
        LD      (SERTMP+4),A            ; duplex mode = full
        LD      HL,FNKSTR+5*16
        LD      DE,SERTMP+16
        LD      BC,48
        PUSH    BC
        PUSH    HL
        LDIR                            ; save F5-F7 definition
        POP     HL
        POP     BC
        LD      B,C
        PUSH    HL
J471C:  LD      (HL),0
        INC     HL
        DJNZ    J471C                   ; clear F5-F7 definition
        POP     DE
        LD      HL,I4906
        LD      BC,5
        PUSH    BC
        LDIR                            ; redefine F5
        POP     BC
        LD      DE,FNKSTR+6*16
        PUSH    BC
        LDIR                            ; redefine F6
        POP     BC
        LD      DE,FNKSTR+7*16
        PUSH    BC
        LDIR                            ; redefine F7
        POP     BC
        XOR     A
        LD      (SERTMP+9),A            ; cursor currently off
        LD      A,(CSRSR)
        LD      (SERTMP+6),A            ; save current cursor status
        CALL    C4927                   ; cursor on
        LD      HL,(NULBUF)             ; BASIC channel
        LD      E,4                     ; raw mode
        LD      C,120                   ; buffer size = 120
        CALL    C4260                   ; RS232.OPEN

; COMTERM main loop

J4751:  EI
        CALL    C4322                   ; RS232.LOC
        LD      A,L
        OR      H                       ; receive buffer empty ?
        JR      Z,J4786                 ; yep, handle keyboard input
        CALL    C4915                   ; wait for received byte
        JR      C,J47B5                 ; EOF, quit COMTERM
        LD      C,A                     ; store received byte
        CALL    C4944                   ; cursor off
        LD      A,(SERTMP+0)
        AND     A                       ; previous received byte was ESC ?
        JR      NZ,J4778                ; yep,
        LD      A,C                     ; received byte
        CP      1BH                     ; ESC ?
        JR      NZ,J4773
        LD      A,1
        LD      (SERTMP+0),A            ; set received ESC flag
        LD      A,C
J4773:  CALL    C44EB                   ; echo to screen/printer (literal)
        JR      J4789                   ; handle keyboard input

J4778:  XOR     A
        LD      (SERTMP+0),A            ; clear received ESC flag
        LD      A,C                     ; received byte
        CP      1BH                     ; second ESC ?
        JR      NZ,J4773                ; nope, continue normally
        CALL    C44EB                   ; echo to screen/printer (literal)
        JR      J47D8                   ; enter hexadecimal transfer mode

J4786:  CALL    C4927                   ; cursor on
J4789:  CALL    C4964                   ; STOP or CTRL-STOP pressed ?
        CALL    NZ,C491F                ; yep, send long break
        CALL    C44DF                   ; check if ctrl-stop pressed
        JR      C,J47B5                 ; yep, quit COMTERM
        CALL    CHSNS                   ; keyboard input ?
        EI
        JR      Z,J4751                 ; nope, main loop
        CALL    CHGET                   ; get keyboard input
        EI
        CP      0A0H                    ; F5-F7 pressed ?
        JP      Z,J48E5                 ; yep, handle
        CALL    C491A                   ; send byte
        LD      C,A
        LD      A,(SERTMP+4)
        AND     A                       ; full duplex mode ?
        JP      Z,J4751                 ; yep, main loop
        LD      A,C
        CALL    C44EB                   ; echo to screen/printer (literal)
        JP      J4751                   ; main loop

; quit COMTERM

J47B5:  CALL    C429B                   ; RS232.CLOSE
        LD      HL,SERTMP+16
        LD      DE,FNKSTR+5*16
        LD      BC,48
        LDIR                            ; restore F5-F7 definition
        LD      HL,(SERTMP+7)           ; restore BASIC pointer
        LD      A,(SERTMP+6)
        AND     A                       ; saved cursor status
        PUSH    AF
        CALL    Z,C4944                 ; was off, cursor off
        POP     AF
        CALL    NZ,C4927                ; was on, cursor on
        XOR     A
        DI
        LD      (INTFLG),A              ; clear STOP/CTRL-STOP
        RET

; hexdecimal transfer mode

J47D8:  LD      A,(SERTMP+3)
        AND     A                       ; literal mode ?
        JP      NZ,J4751                ; yep, main loop
        CALL    C4944                   ; cursor off
        LD      A,0FFH
        LD      (SERTMP+1),A            ; show no progress char

; intel hexfile transfer main loop

J47E7:  CALL    C4915                   ; wait for received byte
        JP      C,J47B5                 ; EOF, quit COMTERM
        CP      ":"
        JR      NZ,J47E7                ; nope, intel hexfile transfer main loop
        CALL    C48B3                   ; receive byte in hexadecimal characters (number of bytes)
        JP      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        AND     A                       ; number of bytes = 0 ?
        JR      Z,J4841                 ; yep,
        LD      B,A                     ; number of bytes
        LD      E,A                     ; checksum
        CALL    C48A8                   ; receive word in hexadecimal characters (address)
        JP      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        CALL    C48B3                   ; receive byte in hexadecimal characters (record type)
        JP      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        ADD     A,L
        ADD     A,H
        ADD     A,E
        LD      E,A                     ; update checksum
J480C:  CALL    C48B3                   ; receive byte in hexadecimal characters
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        LD      (HL),A
        ADD     A,E
        LD      E,A                     ; update checksum
        INC     HL
        DJNZ    J480C                   ; next byte
        CALL    C48B3                   ; receive byte in hexadecimal characters
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        ADD     A,E                     ; update checksum
        JR      NZ,J486A                ; bad checksum, send bad and return to intel hexfile transfer mainloop
        LD      A,"G"                   ; good
        CALL    C491A                   ; send byte
        LD      A,(SERTMP+1)
        AND     A                       ; show progress char ?
        JR      Z,J4835                 ; yep, now remove progress char
        INC     A
        LD      (SERTMP+1),A            ; show progress char
        LD      A,"*"                   ; progress char
        CALL    C44EB                   ; echo to screen/printer (literal)
        JR      J483E                   ; ? main loop

J4835:  DEC     A
        LD      (SERTMP+1),A            ; do not show progress char
        LD      A,7FH                   ; DEL (remove progress char)
        CALL    C44EB                   ; echo to screen/printer (literal)
J483E:  JP      J47E7                   ; intel hexfile transfer main loop

J4841:  CALL    C48A8                   ; receive word in hexadecimal characters (start address)
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        LD      A,H
        OR      L                       ; start address = 0 ?
        JR      NZ,J4872                ; nope, start
        CALL    C48B3                   ; receive byte in hexadecimal characters (record type)
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        CP      01H                     ; must be 01H (end of hex file)
        JR      NZ,J486A                ; nope, send bad and return to mainloop
        CALL    C48B3                   ; receive byte in hexadecimal characters
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        CP      0FFH                    ; must be FFH (data)
        JR      NZ,J486A                ; nope, send bad and return to intel hexfile transfer mainloop
J485C:  LD      A,"G"                   ; good
        CALL    C491A                   ; send byte
        CALL    C495B                   ; echo CR/LF to screen/printer (literal)
        CALL    C4927                   ; cursor on
        JP      J4751                   ; main loop

J486A:  LD      A,"B"                   ; bad
        CALL    C491A                   ; send byte
        JP      J47E7                   ; intel hexfile transfer main loop

J4872:  CALL    C48B3                   ; receive byte in hexadecimal characters
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        CP      01H                     ; must be 01H
        JR      NZ,J486A                ; nope, send bad and return to intel hexfile transfer mainloop
        ADD     A,L
        ADD     A,H
        LD      E,A                     ; update checksum
        CALL    C48B3                   ; receive byte in hexadecimal characters
        JR      C,J486A                 ; no hexadecimal character, send bad and return to intel hexfile transfer mainloop
        ADD     A,E                     ; update checksum
        JR      NZ,J486A                ; checksum is bad, send bad and return to intel hexfile transfer mainloop
        CALL    C4915                   ; wait for received byte
        JP      C,J47B5                 ; EOF, quit COMTERM
        CP      0AH                     ; LF ?
        JR      NZ,J485C                ; nope, send good and return to mainloop
        LD      A,"G"                   ; good
        CALL    C491A                   ; send byte
        CALL    C495B                   ; echo CR/LF to screen/printer (literal)
        PUSH    IX
        PUSH    HL                      ; start address
        LD      HL,I48A0
        EX      (SP),HL
        JP      (HL)                    ; call start address

I48A0:  POP     IX
        CALL    C4927                   ; cursor on
        JP      J4751                   ; main loop

;         Subroutine receive word in hexadecimal characters
;            Inputs  ________________________
;            Outputs Cx set if no hexadecimal character, HL = address

C48A8:  CALL    C48B3                   ; receive byte in hexadecimal characters
        RET     C                       ; no hexadecimal character, quit
        LD      H,A
        CALL    C48B3                   ; receive byte in hexadecimal characters
        RET     C                       ; no hexadecimal character, quit
        LD      L,A
        RET

;         Subroutine receive byte in hexadecimal characters
;            Inputs  ________________________
;            Outputs Cx set if no hexadecimal character, A = byte

C48B3:  PUSH    BC
        CALL    C4915                   ; wait for received byte
        JR      C,J48CE                 ; EOF,
        CALL    C48D0                   ; is hexadecimal character ?
        JR      C,J48CE                 ; nope, quit
        ADD     A,A
        ADD     A,A
        ADD     A,A
        ADD     A,A
        LD      B,A
        CALL    C4915                   ; wait for received byte
        JR      C,J48CE                 ; EOF,
        CALL    C48D0                   ; is hexadecimal character ?
        JR      C,J48CE                 ; nope, quit
        ADD     A,B
J48CE:  POP     BC
        RET

;         Subroutine is hexadecimal character ?
;            Inputs  ________________________
;            Outputs Cx set if no hexadecimal character

C48D0:  CALL    C4D02                   ; to uppercase
        SUB     "0"
        RET     C
        CP      9+1
        JR      C,J48E3
        SUB     "A"-"0"
        RET     C
        CP      "F"-"A"+1
        CCF
        RET     C
        ADD     A,10
J48E3:  AND     A
        RET

; handle F5-F7

J48E5:  CALL    CHGET
        EI
        SUB     06H                     ; F5 ?
        JR      Z,J48F8                 ; yep, toggle literal mode
        DEC     A                       ; F6 ?
        JR      Z,J48FD                 ; yep, toggle duplex mode
        DEC     A                       ; F7 ?
        JR      NZ,J4903                ; nope,
        LD      HL,SERTMP+5
        JR      J4900                   ; toggle printer echo

J48F8:  LD      HL,SERTMP+3
        JR      J4900

J48FD:  LD      HL,SERTMP+4
J4900:  LD      A,(HL)
        CPL
        LD      (HL),A
J4903:  JP      J4751                   ; main loop

; functionkey definitions F5-F7

I4906:  DEFB    0A0H,006H,000H,06CH,069H
        DEFB    0A0H,007H,000H,068H,066H
        DEFB    0A0H,008H,000H,070H,065H

;         Subroutine wait for received byte
;            Inputs  ________________________
;            Outputs ________________________

C4915:  CALL    C4EA6                   ; wait for received byte
        EI
        RET

;         Subroutine send byte
;            Inputs  ________________________
;            Outputs ________________________

C491A:  CALL    C5003                   ; RS232.SNDCHR
        EI
        RET

;         Subroutine send long break
;            Inputs  ________________________
;            Outputs ________________________

C491F:  LD      DE,100
        CALL    C5143                   ; RS232.SNDBRK
        EI
        RET

;         Subroutine cursor on
;            Inputs  ________________________
;            Outputs ________________________

C4927:  LD      A,(ESCCNT)
        OR      A                       ; in ESC sequence ?
        RET     NZ                      ; yep, quit
        LD      A,(SERTMP+9)
        OR      A                       ; cursor on ?
        RET     NZ                      ; yep, quit
        CPL
        LD      (SERTMP+9),A            ; cursor on
        LD      A,1BH
        CALL    CHPUT
        LD      A,"y"
J493C:  CALL    CHPUT
        LD      A,"5"
J4941:  JP      CHPUT

;         Subroutine cursor off
;            Inputs  ________________________
;            Outputs ________________________

C4944:  LD      A,(ESCCNT)
        OR      A                       ; in ESC sequence ?
        RET     NZ                      ; yep, quit
        LD      A,(SERTMP+9)
        OR      A                       ; cursor off ?
        RET     Z                       ; yep, quit
        CPL
        LD      (SERTMP+9),A            ; cursor off
        LD      A,1BH
        CALL    CHPUT
        LD      A,"x"
        JR      J493C

;         Subroutine echo CR/LF to screen/printer (literal)
;            Inputs  ________________________
;            Outputs ________________________

C495B:  LD      A,0DH                   ; CR
        CALL    C44EB                   ; echo to screen/printer (literal)
        LD      A,0AH                   ; LF
        JR      J4941                   ; echo to screen/printer (literal)

;         Subroutine STOP or CTRL-STOP pressed ?
;            Inputs  ________________________
;            Outputs ________________________

C4964:  LD      A,(INTFLG)
        AND     A                       ; STOP or CTRL-STOP pressed ?
        RET     Z                       ; nope, quit
        XOR     A
        LD      (INTFLG),A              ; clear
        INC     A
        RET

        IF      COMHELP EQ 1

;         Subroutine CALL COMHELP statement
;            Inputs  ________________________
;            Outputs ________________________

C496F:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        LD      A,D                     ; last BASIC character
        AND     A                       ; end of line ?
        JR      Z,J4981                 ; yep,
        CP      ":"                     ; next statement ?
        JR      Z,J4981                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J4981:  XOR     A
        LD      (SERTMP+3),A            ; literal mode = off
        LD      (SERTMP+5),A            ; printer echo = off
        LD      (SERTMP+4),A            ; duplex mode = full
        PUSH    HL
        CALL    C495B                   ; echo CR/LF to screen/printer (literal)
        LD      HL,I49C8
J4992:  LD      A,(HL)
        INC     HL
        INC     A
        JR      Z,J49C5
        DEC     A
        JR      Z,J49A7
        CALL    C44EB                   ; echo to screen/printer (literal)
        LD      A,(INTFLG)
        AND     A                       ; STOP or CTRL-STOP pressed ?
        JR      Z,J4992                 ; nope,
        CP      03H                     ; CTRL-STOP pressed ?
        JR      Z,J49C5                 ; yep,
J49A7:  PUSH    HL
        LD      HL,INTFLG
        LD      (HL),0                  ; clear STOP/CTRL-STOP
        CALL    C4927                   ; cursor on
J49B0:  EI
        LD      A,(HL)
        AND     A
        JR      Z,J49B0
        PUSH    AF
        CALL    C4944                   ; cursor off
        POP     AF
        POP     HL
        CP      03H
        JR      Z,J49C5
        XOR     A
        LD      (INTFLG),A              ; clear STOP/CTRL-STOP
        JR      J4992

J49C5:  POP     HL
        AND     A                       ; statement handled
        RET

I49C8:  DEFB    "Initialize statement options",13,10
        DEFB    13,10
        DEFB    'CALL COMINI ("',13,10
        DEFB    "<device# {0,1,2...9}>:",13,10
        DEFB    "<character length {5,6,7,8}>",13,10
        DEFB    "<parity {E,O,I,N}>",13,10
        DEFB    "<stop bits {1,2,3}>",13,10
        DEFB    "<XON/XOFF {X,N}>",13,10
        DEFB    "<CTS hand-shake {H,N}>",13,10
        DEFB    "<auto LF on receive {A,N}>",13,10
        DEFB    "<auto LF on transmit {A,N}>",13,10
        DEFB    '<SI/SO {S,N}>"',13,10
        DEFB    ",<receiver baud rate>",13,10
        DEFB    ",<transmitter baud rate>",13,10
        DEFB    ",<time out count>",13,10
        DEFB    "                          )",13,10
        DEFB    "Default:",13,10
        DEFB    ' CALL COMINI("0:8N1XHNNN"',13,10
        DEFB    "      ,1200,1200,0)",13,10
        DEFB    -1

        ENDIF

;         Subroutine CALL COM statement
;            Inputs  ________________________
;            Outputs ________________________

C4B66:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        CALL    C4C43                   ; get MSX-serial trap number
        JP      C,J44A3                 ; invalid trap number, illegal function call
J4B72:  CALL    C4526                   ; check for BASIC character
        DEFB    ','
J4B76:  CALL    C4526                   ; check for BASIC character
        DEFB    08DH                    ; GOSUB token
J4B7A:  LD      IX,LINGET               ; collect linenumber
        CALL    C4588                   ; call mainrom and enable interrupts
        PUSH    HL
        LD      A,E
        OR      D
        JR      Z,J4B92
        LD      IX,FNDLIN               ; search linenumber from start of program
        CALL    C4588                   ; call mainrom and enable interrupts
J4B8D:  JP      NC,J4497                ; not found, undefined line number error
        LD      E,C
        LD      D,B
J4B92:  CALL    C4C30                   ; get MSX-serial trap entry
J4B95:  INC     HL
        LD      (HL),E
        INC     HL
        LD      (HL),D                  ; store trap handler
        POP     HL
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
        AND     A                       ; statement handled
        RET

;         Subroutine CALL COMOFF statement
;            Inputs  ________________________
;            Outputs ________________________

C4BA0:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        LD      A,D                     ; last BASIC character
        AND     A                       ; end of line ?
        JR      Z,J4BB2                 ; yep,
        CP      ":"                     ; next statement ?
        JR      Z,J4BB2                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J4BB2:  CALL    C4C43                   ; get MSX-serial trap number
        JP      C,J44A3                 ; invalid trap number, illegal function call
        LD      IX,OFFTRP
        JR      J4C05                   ; disable MSX-serial trap

;         Subroutine CALL COMON statement
;            Inputs  ________________________
;            Outputs ________________________

C4BBE:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        LD      A,D                     ; last BASIC character
        AND     A                       ; end of line ?
        JR      Z,J4BD0                 ; yep,
        CP      ":"                     ; next statement ?
        JR      Z,J4BD0                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J4BD0:  CALL    C4C43                   ; get MSX-serial trap number
        JP      C,J44A3                 ; invalid trap number, illegal function call
        LD      IX,ONTRP
        JR      J4BF8                   ; enable MSX-serial trap

;         Subroutine CALL COMSTOP statement
;            Inputs  ________________________
;            Outputs ________________________

C4BDC:  CALL    C4C56                   ; evaluate optional device name, quit if not handled
        CALL    C4CBF                   ; check for no filename specified
        LD      A,D                     ; last BASIC character
        AND     A                       ; end of line ?
        JR      Z,J4BEE                 ; yep,
        CP      ":"                     ; next statement ?
        JR      Z,J4BEE                 ; yep,
        CALL    C4526                   ; check for BASIC character
        DEFB    ')'
J4BEE:  CALL    C4C43                   ; get MSX-serial trap number
        JP      C,J44A3                 ; invalid trap number, illegal function call
        LD      IX,STPTRP               ; pause MSX-serial trap
J4BF8:  PUSH    HL
        PUSH    AF
        CALL    C4C30                   ; get MSX-serial trap entry
        LD      A,(HL)
        AND     01H                     ; trap enabled ?
        CALL    Z,C4135                 ; nope, clear receive buffer
        POP     AF
        POP     HL
J4C05:  PUSH    HL
        CALL    C4C30                   ; get MSX-serial trap entry
        CALL    C4588                   ; call mainrom and enable interrupts
        POP     HL
        AND     A                       ; statement handled
        RET

;         Subroutine new statement handler
;            Inputs  ________________________
;            Outputs ________________________

I4C0F:  EI
        CALL    C4E92                   ; get number of bytes in receive buffer (include backup byte)3                       
        PUSH    HL
        CALL    NZ,C4C1B                ; there are, raise MSX-serial trap
        POP     HL
        JP      OLDSTT                  ; next new statement handler

;         Subroutine raise MSX-serial trap
;            Inputs  ________________________
;            Outputs ________________________

C4C1B:  CALL    C4C30                   ; get MSX-serial trap entry
        LD      A,(HL)
        AND     01H                     ; trap enabled ?
        RET     Z                       ; nope, quit
        LD      A,(HL)
        OR      04H
        CP      (HL)                    ; trap already raised ?
        RET     Z                       ; yep, quit
        CP      05H                     ; trap paused ?
        RET     NZ                      ; yep, quit
        LD      (HL),A
        LD      HL,ONGSBF
        INC     (HL)                    ; increase trap counter
        RET

;         Subroutine get MSX-serial trap entry
;            Inputs  ________________________
;            Outputs ________________________

C4C30:  CALL    C4C43                   ; get MSX-serial trap number
        JP      C,J44A3                 ; invalid trap number, illegal function call
        PUSH    BC
        LD      C,A
        ADD     A,A
        ADD     A,C
        LD      C,A
        LD      B,0
        LD      HL,TRPTBL+18*3
        ADD     HL,BC
        POP     BC
        RET

;         Subroutine get MSX-serial trap number
;            Inputs  ________________________
;            Outputs ________________________

C4C43:  LD      A,(DEVNUM)
        AND     0F0H
        RRCA
        RRCA
        RRCA
        RRCA                            ; get my trap number
        CP      6
        CCF                             ; valid trap number ?
        RET

;         Subroutine RS232 port open ?
;            Inputs  ________________________
;            Outputs ________________________

C4C50:  LD      A,(FLAGS)
        BIT     3,A
        RET

;         Subroutine evaluate optional device name, quit if not handled
;            Inputs  ________________________
;            Outputs ________________________

C4C56:  DEC     HL
        CALL    C452E                   ; get next BASIC character
        LD      D,A                     ; store last BASIC character
        JR      NZ,J4C64                ; not end of statement,
J4C5D:  XOR     A                       ; COM0
        LD      BC,-1                   ; no string
        PUSH    HL
        JR      J4CA2

J4C64:  CP      "("
        JP      Z,J4C6F
        CP      ","
        JR      Z,J4C5D
        JR      J4C77

J4C6F:  CALL    C452E                   ; get next BASIC character
        LD      D,A                     ; store last BASIC character
        CP      ","
        JR      Z,J4C5D
J4C77:  CALL    C4540                   ; evaluate expression
        PUSH    HL
        CALL    C4570                   ; free temporary string
        LD      C,0
        LD      B,(HL)                  ; size of string
        INC     HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A                     ; pointer to string
        LD      A,B
        AND     A                       ; empty string ?
        JR      Z,J4CA2                 ; yep, COM0
        INC     HL
        LD      A,(HL)
        CP      ":"                     ; device seperator ?
        JR      Z,J4C94                 ; yep,
        DEC     HL
        XOR     A                       ; COM0
        JR      J4CA2

J4C94:  DEC     HL
        LD      A,(HL)
        SUB     "0"
        JR      C,J4CBC
        CP      9+1
        JR      NC,J4CBC
        INC     HL
        INC     HL
        DEC     B
        DEC     B
J4CA2:  LD      E,A
        LD      A,(DEVNUM)
        AND     0FH                     ; my channel number
        PUSH    HL
        EXX
        POP     HL
        EXX
        POP     HL
        PUSH    AF
        DEC     HL
        CALL    C452E                   ; get next BASIC character
        LD      D,A                     ; store last BASIC character
        POP     AF
        CP      E                       ; channel specified handled by me ?
        RET     Z                       ; yep, quit
J4CB6:  POP     HL                      ; discard return address
        PUSH    IX
        POP     HL                      ; restore BASIC pointer
        SCF                             ; statement not handled
        RET

J4CBC:  POP     HL
        JR      J4CB6

;         Subroutine check for no filename specified
;            Inputs  ________________________
;            Outputs ________________________

C4CBF:  LD      A,B
        OR      C                       ; empty string ?
        RET     Z                       ; yep, quit
        LD      A,B
        AND     C
        INC     A                       ; no string ?
        RET     Z                       ; yep, quit
        JP      J44A3                   ; illegal function call

;         Subroutine copy DAC to variable
;            Inputs  ________________________
;            Outputs ________________________

C4CC9:  PUSH    HL
        LD      HL,VALTYP
        LD      A,(HL)
        CP      2                       ; variable is integer ?
        JR      Z,J4CF7                 ; yep, copy DAC to variable
        CP      4                       ; variable is single float ?
        JR      Z,J4CE7                 ; yep, copy to variable
        CP      8                       ; variable is double float ?
        JP      NZ,J44A9                ; nope, type mismatch error
        LD      (HL),2                  ; DAC = integer
        PUSH    DE
        LD      A,8                     ; double float
        CALL    C457C                   ; convert to DAC to new type
        LD      C,8                     ; double float = 8 bytes
        JR      J4CF1                   ; copy DAC to variable

J4CE7:  LD      (HL),2                  ; DAC = integer
        PUSH    DE
        LD      A,4                     ; single float
        CALL    C457C                   ; convert to DAC to new type
        LD      C,4                     ; single float = 4 bytes
J4CF1:  POP     DE
        LD      HL,DAC
        JR      J4CFC                   ; copy DAC to variable

J4CF7:  LD      HL,DAC+2
        LD      C,2
J4CFC:  LD      B,0
        LDIR
        POP     HL
        RET

;         Subroutine to uppercase
;            Inputs  ________________________
;            Outputs ________________________

C4D02:  CP      "a"
        RET     C
        CP      "z"+1
        RET     NC
        SUB     20H
        RET

;         Subroutine initialize RS232
;            Inputs  ________________________
;            Outputs ________________________

C4D0B:  LD      A,(IY+0)
        SUB     "5"
        CP      "8"-"5"+1
        JR      NC,J4D2C
        LD      B,A                     ; data bits in i8251 mode byte
        LD      D,A                     ; store data bits
        CALL    C4DE0                   ; set data mask
        LD      A,(IY+1)
        CP      "E"
        JR      Z,J4D2E
        CP      "O"
        JR      Z,J4D30
        CP      "I"
        JR      Z,J4D34
        CP      "N"
        JR      Z,J4D3B
J4D2C:  SCF
        RET

J4D2E:  SET     3,B                     ; even parity
J4D30:  SET     2,B                     ; enable parity
        JR      J4D3B

J4D34:  LD      A,B
        CP      3                       ; 8 data bits ?
        JP      Z,J4D2C                 ; yep, quit with error
        INC     B                       ; increase data bits
J4D3B:  RLC     B
        RLC     B
        LD      A,(IY+2)
        SUB     "1"
        CP      "3"-"1"+1
        JP      NC,J4D2C
        INC     A
        RRCA
        RRCA                            ; i8251 stop bits
        OR      B
        LD      B,A
        LD      C,0                     ; reset ? flags
        LD      A,(IY+3)
        CP      "X"
        JR      NZ,J4D5B
        SET     0,C                     ; XON/XOFF handshake
        JR      J4D60

J4D5B:  CP      "N"
        JP      NZ,J4D2C
J4D60:  LD      A,(IY+4)
        CP      "H"
        JR      NZ,J4D6B
        SET     1,C                     ; RTS/CTS handshake
        JR      J4D70

J4D6B:  CP      "N"
        JP      NZ,J4D2C
J4D70:  LD      A,(IY+5)
        CP      "A"
        JR      NZ,J4D7B
        SET     3,C                     ; auto LF on receive
        JR      J4D80

J4D7B:  CP      "N"
        JP      NZ,J4D2C
J4D80:  LD      A,(IY+6)
        CP      "A"
        JR      NZ,J4D8B
        SET     2,C                     ; auto LF on send
        JR      J4D90

J4D8B:  CP      "N"
        JP      NZ,J4D2C
J4D90:  LD      A,(IY+7)
        CP      "S"
        JR      NZ,J4DA1
        LD      A,D
        CP      2                       ; 7 bits ?
        JP      NZ,J4D2C                ; nope,
        SET     4,C                     ; SI/SO handshake
        JR      J4DA6

J4DA1:  CP      "N"
        JP      NZ,J4D2C
J4DA6:  LD      A,C
        LD      (ESTBLS),A              ; mode flags
        LD      A,2
        OR      B
        LD      (LSTMOD),A              ; store mode byte
        CALL    C50E3                   ; initialize i8251
        LD      E,(IY+8)
        LD      D,(IY+9)                ; receive baudrate/counter value
        CALL    C4DF4                   ; validate and get i8253 counter value
        JP      C,J4D2C
        LD      C,0                     ; counter = 0 (receive)
        CALL    C5248                   ; initialize i8253 counter
        LD      E,(IY+10)
        LD      D,(IY+11)               ; send baudrate/counter value
        CALL    C4DF4                   ; validate and get i8253 counter value
        JP      C,J4D2C
        LD      C,1                     ; counter = 1 (send)
        CALL    C5248                   ; initialize i8253 counter
        LD      A,(IY+12)               ; timeout value
        LD      (TOCNT),A
        CALL    C51A9                   ; enable DTR
        OR      A                       ; clear Cx
        RET

;         Subroutine set data mask
;            Inputs  ________________________
;            Outputs ________________________

C4DE0:  PUSH    AF
        PUSH    BC
        XOR     03H                     ; 8 data bits ?
        LD      C,0FFH
        JR      Z,J4DED                 ; yep, use 0FFH mask
        LD      B,A
J4DE9:  SRL     C
        DJNZ    J4DE9
J4DED:  LD      A,C
        LD      (COMMSK),A              ; data mask
        POP     BC
        POP     AF
        RET

;         Subroutine validate and get i8253 counter value
;            Inputs  ________________________
;            Outputs ________________________

C4DF4:  PUSH    HL
        BIT     7,D                     ; baudrate ?
        JR      Z,J4E06                 ; yep,
        LD      A,E
        AND     D
        INC     A                       ; -1 ?
        JR      Z,J4E22                 ; yep, quit with error
        LD      HL,0
        SBC     HL,DE
        EX      DE,HL                   ; absolute i8253 counter value
        JR      J4E21                   ; return counter value

J4E06:  LD      HL,I4E25                ; baudrate table
J4E09:  LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; baudrate
        INC     HL
        LD      A,B
        OR      C                       ; end of table ?
        JR      Z,J4E22                 ; yep, quit with error
        PUSH    HL
        LD      L,E
        LD      H,D
        AND     A
        SBC     HL,BC                   ; same as request baudrate ?
        POP     HL
        JR      Z,J4E1E                 ; yep, return counter value
        INC     HL
        INC     HL
        JR      J4E09                   ; next entry

J4E1E:  LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; counter value
J4E21:  SCF
J4E22:  CCF
        POP     HL
        RET

I4E25:  DEFW    50,00900h
        DEFW    75,00600h
        DEFW    110,00417h
        DEFW    300,00180h
        DEFW    600,000C0h
        DEFW    1200,00060h
        DEFW    1800,00040h
        DEFW    2000,0003Ah
        DEFW    2400,00030h
        DEFW    3600,00020h
        DEFW    4800,00018h
        DEFW    7200,00010h
        DEFW    9600,0000Ch
        DEFW    19200,00006h
        DEFW    0

;         Subroutine get my slotid
;            Inputs  ________________________
;            Outputs ________________________
;            Remark  BUGFIX: EXPTBL, use only b7

C4E5F:  PUSH    BC
        PUSH    HL
        IN      A,(0A8H)
        RRCA
        RRCA
        AND     03H                     ; primairy slot in page 1
        LD      C,A
        LD      B,0
        LD      HL,EXPTBL
        ADD     HL,BC
        LD      A,(HL)
        AND     80H                     ; expanded slot flag
        OR      C
        LD      C,A
        INC     HL
        INC     HL
        INC     HL
        INC     HL
        LD      A,(HL)
        AND     0CH                     ; secundairy slot in page 1
        OR      C
        POP     HL
        POP     BC
        RET

;         Subroutine disable RS232 interrupts
;            Inputs  ________________________
;            Outputs ________________________

C4E7E:  PUSH    AF
        LD      A,0FFH
        OUT     (82H),A
        POP     AF
        RET

;         Subroutine enable RS232 interrupts
;            Inputs  ________________________
;            Outputs ________________________

C4E85:  PUSH    AF
        LD      A,0FEH
        OUT     (82H),A
        POP     AF
        RET

;         Subroutine interrupt handler
;            Inputs  ________________________
;            Outputs ________________________

I4E8C:  CALL    C4EF2                   ; rs232 interrupt handler
        JP      OLDINT                  ; next interrupt handler

;         Subroutine get number of bytes in receive buffer (include backup byte)
;            Inputs  ________________________
;            Outputs ________________________

C4E92:  CALL    C4EA1                   ; get number of characters in receive buffer
        PUSH    BC
        LD      B,A                     ; store number of bytes
        CALL    C439A                   ; get backup byte
        JR      Z,J4E9E                 ; no backup byte, return number of bytes
        LD      A,1                     ; 1 extra
J4E9E:  ADD     A,B
        POP     BC
        RET

;         Subroutine get number of characters in receive buffer
;            Inputs  ________________________
;            Outputs ________________________

C4EA1:  LD      A,(DATCNT)
        AND     A
        RET

;         Subroutine wait for received byte
;            Inputs  ________________________
;            Outputs ________________________

C4EA6:  PUSH    HL
        PUSH    DE
        PUSH    BC
        LD      HL,DATCNT
J4EAC:  EI
        CALL    C44DF                   ; check if ctrl-stop pressed
        JR      C,J4EEA                 ; yep,
        LD      A,(HL)                  ; number of bytes in receive buffer
        AND     A                       ; none ?
        JR      NZ,J4EC2                ; nope,
        CALL    C5189                   ; enable RTS
        CALL    C4FB5                   ; signal sender to resume sending
        JR      C,J4EEA                 ; aborted by ctrl-stop, quit
        JR      Z,J4EEA                 ; timeout, quit
        JR      J4EAC                   ; again

J4EC2:  CP      3                       ; >=3 ?
        JR      NC,J4ED1                ; yep,
        CALL    C5189                   ; enable RTS
        CALL    C4FB5                   ; signal sender to resume sending
        EI
        JR      C,J4EEA                 ; aborted by ctrl-stop, quit
        JR      Z,J4EEA                 ; timeout, quit
J4ED1:  DI
        DEC     (HL)                    ; update number of bytes in receive buffer
        CALL    C4F9A                   ; get pointer in receive buffer (get pointer)
        LD      C,(HL)                  ; received byte
        LD      B,80H                   ; assume error
        INC     HL
        LD      A,(HL)                  ; received byte error status
        LD      (ERRORS),A              ; update received byte error status
        AND     A                       ; any errors ?
        JR      Z,J4EE2                 ; nope, reset sign flag, clear Cx, Clear Zx and quit
        INC     B                       ; set sign flag (error)
J4EE2:  LD      A,C
        OR      A
        DEC     B
J4EE5:  EI
        POP     BC
        POP     DE
        POP     HL
        RET

J4EEA:  PUSH    AF
        POP     BC
        RES     7,C
        PUSH    BC
        POP     AF                      ; clear sign flag (no error)
        JR      J4EE5                   ; quit

;         Subroutine rs232 interrupt handler
;            Inputs  ________________________
;            Outputs ________________________
;            Remark  BUGFIX: check if RS232 open

C4EF2:  LD      A,(FLAGS)
        BIT     3,A                     ; RS232 open ?
        RET     Z                       ; nope, quit
        IN      A,(81H)
        AND     02H                     ; received byte ?
        RET     Z                       ; nope, quit
        IN      A,(80H)                 ; get received byte
        LD      HL,COMMSK
        AND     (HL)                    ; mask off bits
        LD      C,A                     ; store received byte
        CALL    C5175                   ; get error bits and reset
        LD      B,A                     ; error bits
        AND     A                       ; error ?
        JR      NZ,J4F25                ; yep,
        LD      HL,FLAGS
        LD      A,C                     ; received byte
        CP      11H                     ; XON ?
        JR      Z,J4F1B                 ; yep,
        CP      13H                     ; XOFF ?
        JR      NZ,J4F36                ; nope,
        SET     2,(HL)                  ; set XOFF flag
        JR      J4F1D

J4F1B:  RES     2,(HL)                  ; reset XOFF flag
J4F1D:  LD      A,(ESTBLS)              ; mode flags
        BIT     0,A                     ; XON/XOFF handshake ?
        RET     NZ                      ; yep, quit
        JR      J4F36

J4F25:  AND     20H                     ; framing error ?
        JR      Z,J4F4E                 ; nope, try put in receive buffer
        LD      A,C                     ; received byte
        AND     A                       ; zero byte ?
        JR      NZ,J4F4E                ; nope, try put in receive buffer
        LD      HL,FLAGS
        SET     4,(HL)                  ; break detected
        LD      B,0
        JR      J4F4E                   ; try put in receive buffer

J4F36:  LD      A,(ESTBLS)
        BIT     4,A                     ; SI/SO handshake ?
        JR      Z,J4F4E                 ; nope, try put in receive buffer
        LD      HL,FLAGS
        LD      A,C                     ; received byte
        SUB     0FH                     ; SI ?
        JR      NZ,J4F48                ; nope,
        RES     7,(HL)                  ; reset SO received flag
        RET

J4F48:  INC     A                       ; SO ?
        JR      NZ,J4F4E                ; nope, try put in receive buffer
        SET     7,(HL)                  ; set SO received flag
        RET

J4F4E:  LD      HL,DATCNT
        LD      A,(RSIQLN)
        CP      (HL)                    ; receive buffer full ?
        RET     Z                       ; yep, quit
        INC     (HL)                    ; update number of bytes in receive buffer
        INC     HL
        PUSH    BC
        CALL    C4F9A                   ; get pointer in receive buffer (put pointer)
        POP     BC
        LD      A,(ESTBLS)              ; mode flags
        BIT     4,A                     ; SI/SO handshake ?
        LD      A,C                     ; received byte
        JR      Z,J4F73                 ; nope,
        CP      20H
        JR      C,J4F73
        LD      A,(FLAGS)
        BIT     7,A                     ; SO received flag ?
        LD      A,C
        JR      Z,J4F73                 ; nope,
        OR      80H                     ; set high bit
J4F73:  LD      (HL),A                  ; put receive byte in receive buffer
        PUSH    HL
        LD      HL,DATCNT
        LD      A,(RSIQLN)
        SUB     (HL)
        POP     HL
        JR      NZ,J4F81
        SET     7,B
J4F81:  CP      16
        CALL    C,C4FCF                 ; signal sender to stop sending
        LD      A,B
        INC     HL
        LD      (HL),A                  ; put receive status in receive buffer
        DEC     HL
        AND     A                       ; any errors ?
        RET     NZ                      ; yep, quit
        LD      A,(ESTBLS)              ; mode flags
        BIT     3,A                     ; auto LF on receive ?
        RET     Z                       ; nope, quit
        LD      A,(HL)
        CP      0DH                     ; CR ?
        RET     NZ                      ; nope, quit
        LD      C,0AH                   ; LF
        JR      J4F4E                   ; try put in receive buffer

;         Subroutine get pointer in receive buffer
;            Inputs  ________________________
;            Outputs ________________________

C4F9A:  INC     HL
        LD      A,(HL)
        LD      C,A
        INC     A
        PUSH    HL
        LD      HL,RSIQLN
        CP      (HL)
        POP     HL
        JR      C,J4FA7
        XOR     A
J4FA7:  LD      (HL),A
        EX      DE,HL
        LD      HL,(RSFCB)
        LD      B,0
        ADD     HL,BC
        ADD     HL,BC
        LD      BC,9
        ADD     HL,BC
        RET

;         Subroutine signal sender to resume sending
;            Inputs  ________________________
;            Outputs ________________________

C4FB5:  DI
        LD      A,(FLAGS)
        BIT     1,A                     ; sending suspended ?
        JR      NZ,J4FC0                ; yep, resume
        XOR     A
        INC     A
        RET

J4FC0:  LD      C,11H                   ; XON
        CALL    C4FEB                   ; send XON/XOFF (if XON/XOFF handshake is enabled)
        RET     C                       ; aborted by ctrl-stop, quit
        RET     Z                       ; timeout, quit
        PUSH    HL
        LD      HL,FLAGS
        RES     1,(HL)                  ; reset sending suspended flag
        POP     HL
        RET

;         Subroutine signal sender to stop sending
;            Inputs  ________________________
;            Outputs ________________________

C4FCF:  DI
        XOR     A                       ; clear Cx
        INC     A                       ; 
        LD      A,(FLAGS)
        BIT     1,A                     ; sending suspended ?
        RET     NZ                      ; yep, quit
        PUSH    HL
        LD      HL,FLAGS
        SET     1,(HL)                  ; set sending suspended flag
        POP     HL
        LD      C,13H                   ; XOFF
        CALL    C4FEB                   ; send XON/XOFF (if XON/XOFF handshake is enabled)
        CALL    C51E4                   ; wait for empty transmitter
        CALL    C5191                   ; disable RTS if RTS/CTS handshake
        RET

;         Subroutine send XON/XOFF (if XON/XOFF handshake is enabled)
;            Inputs  ________________________
;            Outputs ________________________

C4FEB:  LD      A,(ESTBLS)              ; mode flags
        BIT     0,A                     ; XON/XOFF handshake ?
        JR      NZ,J4FF5                ; yep,
        XOR     A
        INC     A                       ; clear Cx, clear Zx
        RET

J4FF5:  CALL    C51E4                   ; wait for empty transmitter
        PUSH    DE
        CALL    C51F3                   ; clear to send (RTS/CTS) ?
        POP     DE
        RET     C                       ; aborted by ctrl-stop, quit
        RET     Z                       ; timeout, quit
        LD      A,C
        OUT     (80H),A                 ; send byte
        RET

;         Subroutine RS232.SNDCHR
;            Inputs  ________________________
;            Outputs ________________________

C5003:  PUSH    BC
        LD      C,A                     ; store byte
        CALL    C500B                   ; send byte (with auto LF, SI/SO, XON/XOFF, CTS/RTS)
        LD      A,C                     ; restore byte
        POP     BC
        RET

;         Subroutine send byte (with auto LF, SI/SO, XON/XOFF, CTS/RTS)
;            Inputs  ________________________
;            Outputs ________________________

C500B:  EI
        PUSH    BC
        LD      C,A                     ; store byte
        LD      A,(ESTBLS)              ; mode flags
        BIT     4,A                     ; SI/SO handshake ?
        JR      Z,J504D                 ; nope,
        LD      A,C
        CP      20H                     ; control character ?
        JR      C,J504D                 ; yep,
        LD      A,(FLAGS)
        BIT     0,A                     ; in SO ?
        JR      NZ,J5037                ; yep,
        BIT     7,C                     ; high bit set ?
        JR      Z,J504D                 ; nope,
        LD      A,0EH                   ; SO
        CALL    C504F                   ; send byte (with auto LF, XON/XOFF, CTS/RTS)
        JR      C,J5098                 ; aborted by ctrl-stop, update error flags and quit
        JR      Z,J5098                 ; timeout, update error flags and quit
        PUSH    HL
        LD      HL,FLAGS
        SET     0,(HL)                  ; set in SO flag
        POP     HL
        JR      J504B

J5037:  BIT     7,C                     ; high bit set ?
        JR      NZ,J504B                ; yep,
        LD      A,0FH                   ; SI
        CALL    C504F                   ; send byte (with auto LF, XON/XOFF, CTS/RTS)
        JR      C,J5098                 ; aborted by ctrl-stop, update error flags and quit
        JR      Z,J5098                 ; timeout, update error flags and quit
        PUSH    HL
        LD      HL,FLAGS
        RES     0,(HL)                  ; reset in SO flag
        POP     HL
J504B:  RES     7,C                     ; reset high bit
J504D:  LD      A,C
        POP     BC

;         Subroutine send byte (with auto LF, XON/XOFF, CTS/RTS)
;            Inputs  ________________________
;            Outputs ________________________

C504F:  PUSH    HL
        LD      HL,ESTBLS               ; mode flags
        BIT     2,(HL)                  ; auto LF on send ?
        POP     HL
        JR      Z,J506E                 ; nope, skip
        CP      0AH                     ; LF ?
        JR      NZ,J506E
        LD      A,(FLAGS)
        BIT     5,A                     ; CR on send detected ?
        LD      A,0AH                   ; LF
        JR      Z,J506E                 ; nope,
        PUSH    HL
        LD      HL,FLAGS
        RES     5,(HL)                  ; clear CR on send flag
        POP     HL
        AND     A                       ; clear Cx
        RET

J506E:  PUSH    BC
        LD      C,A                     ; store byte
        PUSH    DE
        CALL    C509E                   ; clear to send (XON/XOFF) ?
        POP     DE
        JR      C,J5098                 ; aborted by ctrl-stop, update error flags and quit
        JR      Z,J5098                 ; timeout, update error flags and quit
        CALL    C51E4                   ; wait for empty transmitter
        CALL    C51F3                   ; clear to send (RTS/CTS) ?
        JR      C,J5098                 ; aborted by ctrl-stop, update error flags and quit
        JR      Z,J5098                 ; timeout, update error flags and quit
        LD      A,C
        OUT     (80H),A                 ; send byte
        EI
        PUSH    HL
        LD      HL,FLAGS
        CP      0DH                     ; CR ?
        JR      NZ,J5093                ; nope,
        SET     5,(HL)                  ; set CR send flag
        JR      J5095

J5093:  RES     5,(HL)                  ; reset CR send flag
J5095:  POP     HL
        XOR     A
        INC     A                       ; clear Cx (not aborted), clear Zx (no timeout)
J5098:  CALL    C50D1                   ; update error flags
        LD      A,C                     ; send byte
        POP     BC
        RET

;         Subroutine clear to send (XON/XOFF) ?
;            Inputs  ________________________
;            Outputs ________________________

C509E:  LD      A,(ESTBLS)              ; mode flags
        BIT     0,A                     ; XON/XOFF handshake ?
        JR      Z,J50CE                 ; nope,
        LD      A,(TOCNT)
        LD      D,A                     ; timeout value
J50A9:  LD      E,100
J50AB:  CALL    C5237                   ; initialize i8253 counter 2
J50AE:  EI
        CALL    C44DF                   ; check if ctrl-stop pressed
        DI
        RET     C                       ; yep, quit
        LD      A,(FLAGS)
        BIT     2,A                     ; XOFF ?
        JR      Z,J50CE                 ; yep, quit
        LD      A,(TOCNT)
        AND     A                       ; timeout value = 0 ?
        JR      Z,J50AE                 ; yep, endless wait
        CALL    C5243                   ; counter 2 finished ?
        JR      NC,J50AE                ; nope, again
        AND     A                       ; clear Cx
        DEC     E
        JR      NZ,J50AB
        DEC     D
        JR      NZ,J50A9
        RET

J50CE:  XOR     A                       ; clear Cx
        INC     A                       ; clear Zx
        RET

;         Subroutine update error flags
;            Inputs  ________________________
;            Outputs ________________________

C50D1:  PUSH    HL
        LD      HL,ERRORS
        LD      (HL),0                  ; clear received byte error status
        JR      C,J50DF                 ; aborted by ctrl-stop,
        JR      NZ,J50E1                ; no timeout, quit
        SET     6,(HL)                  ; set timeout flag
        JR      J50E1

J50DF:  SET     2,(HL)                  ; set abort flag
J50E1:  POP     HL
        RET

;         Subroutine initialize i8251
;            Inputs  ________________________
;            Outputs ________________________
;            Remark  R800 compatible

C50E3:  XOR     A
        OUT     (81H),A
        PUSH    AF

        IF      R800 EQ 1
        PUSH    BC
        LD      C,1
        OUT     (0E6H),A
J50EC:  IN      A,(0E7H)
        CP      C
        JR      C,J50EC
        POP     BC
        ENDIF

        POP     AF
        OUT     (81H),A
        PUSH    AF

        IF      R800 EQ 1
        PUSH    BC
        LD      C,1
        OUT     (0E6H),A
J50FB:  IN      A,(0E7H)
        CP      C
        JR      C,J50FB
        POP     BC
        ENDIF

        POP     AF
        OUT     (81H),A
        PUSH    AF

        IF      R800 EQ 1
        PUSH    BC
        LD      C,1
        OUT     (0E6H),A
J510A:  IN      A,(0E7H)
        CP      C
        JR      C,J510A
        POP     BC
        ENDIF

        POP     AF
        LD      A,40H
        OUT     (81H),A
        PUSH    AF

        IF      R800 EQ 1
        PUSH    BC
        LD      C,1
        OUT     (0E6H),A
J511B:  IN      A,(0E7H)
        CP      C
        JR      C,J511B
        POP     BC
        ENDIF

        POP     AF
        LD      A,(LSTMOD)              ; last mode byte
        OUT     (81H),A                 ; write i8251 mode
        PUSH    AF

        IF      R800 EQ 1
        PUSH    BC
        LD      C,1
        OUT     (0E6H),A
J512D:  IN      A,(0E7H)
        CP      C
        JR      C,J512D
        POP     BC
        ENDIF

        POP     AF
        IN      A,(80H)                 ; get received byte
        CALL    C5175                   ; get error bits and reset
        LD      A,07H                   ; enable receive, enable DTR, enable transmit
        CALL    C5224                   ; write i8251 command byte
        IN      A,(80H)                 ; get received byte
        JP      C5175                   ; get error bits and reset, quit

;         Subroutine RS232.SNDBRK
;            Inputs  DE = number of break bytes
;            Outputs ________________________

C5143:  PUSH    BC
        DI
        CALL    C4E7E                   ; disable RS232 interrupts
        EI
        LD      A,(LSTCOM)              ; last command byte
        OR      08H                     ; enable send break
        LD      B,A                     ; store command byte
J514F:  CALL    C44DF                   ; check if ctrl-stop pressed
        JR      C,J5163                 ; yep,
        CALL    C51E4                   ; wait for empty transmitter
        XOR     A
        OUT     (80H),A                 ; send null byte
        LD      A,B                     ; restore command byte
        CALL    C5224                   ; write i8251 command byte
        DEC     DE
        LD      A,E
        OR      D
        JR      NZ,J514F
J5163:  PUSH    AF
        CALL    C51E4                   ; wait for empty transmitter
        LD      A,B
        AND     0F7H                    ; disable send break
        CALL    C5224                   ; write i8251 command byte
        DI
        CALL    C4E85                   ; enable RS232 interrupts
        EI
        POP     AF
        POP     BC
        RET

;         Subroutine get error bits and reset
;            Inputs  ________________________
;            Outputs ________________________

C5175:  IN      A,(81H)                 ; read status
        AND     38H                     ; only error bits
        PUSH    AF                      ; store error bits
        LD      A,(LSTCOM)              ; last command byte
        PUSH    AF                      ; store last command byte
        OR      10H                     ; error reset
        CALL    C5224                   ; write i8251 command byte
        POP     AF
        LD      (LSTCOM),A              ; restore last command byte
        POP     AF                      ; restore error bits
        RET

;         Subroutine enable RTS
;            Inputs  ________________________
;            Outputs ________________________

C5189:  PUSH    AF
        LD      A,(LSTCOM)              ; last command byte
        SET     5,A                     ; enable RTS
        JR      J51A1

;         Subroutine disable RTS if RTS/CTS handshake
;            Inputs  ________________________
;            Outputs ________________________

C5191:  PUSH    AF
        LD      A,(ESTBLS)              ; mode flags
        BIT     1,A                     ; RTS/CTS handshake ?
        JR      NZ,J519C                ; yep, disable RTS
        POP     AF
        RET

;         Subroutine disable RTS
;            Inputs  ________________________
;            Outputs ________________________

?519B:  PUSH    AF
J519C:  LD      A,(LSTCOM)              ; last command byte
        RES     5,A                     ; disable RTS
J51A1:  CALL    C5224                   ; write i8251 command byte
        POP     AF
        RET

;         Subroutine RS232.DTR
;            Inputs  ________________________
;            Outputs ________________________

C51A6:  AND     A
        JR      Z,J51B2

;         Subroutine DTR=1
;            Inputs  ________________________
;            Outputs ________________________

C51A9:  DI
        PUSH    AF
        LD      A,(LSTCOM)              ; last command byte
        OR      02H                     ; enable DTR
        JR      J51B9

;         Subroutine DTR=0
;            Inputs  ________________________
;            Outputs ________________________

J51B2:  DI
        PUSH    AF
        LD      A,(LSTCOM)              ; last command byte
        AND     0FDH                    ; disable DTR
J51B9:  CALL    C5224                   ; write i8251 command byte
        POP     AF
        RET

;         Subroutine RS232.STAT
;            Inputs  ________________________
;            Outputs ________________________

C51BE:  PUSH    AF
        IN      A,(82H)
        LD      L,0C1H
        XOR     L
        AND     L
        LD      L,A
        IN      A,(81H)
        AND     80H
        JR      Z,J51CE
        SET     3,L
J51CE:  DI
        LD      A,(FLAGS)
        BIT     4,A                     ; break detected ?
        JR      Z,J51DD                 ; nope,
        SET     2,L                     ; break detected
        RES     4,A
        LD      (FLAGS),A               ; clear break detected
J51DD:  EI
        LD      A,(ERRORS)
        LD      H,A                     ; received byte error status
        POP     AF
        RET

;         Subroutine wait for empty transmitter
;            Inputs  ________________________
;            Outputs ________________________

C51E4:  PUSH    AF
J51E5:  EI
        NOP
        NOP
        DI
        IN      A,(81H)
        AND     05H
        CP      05H
        JR      NZ,J51E5
        POP     AF
        RET

;         Subroutine clear to send (RTS/CTS) ?
;            Inputs  ________________________
;            Outputs ________________________

C51F3:  LD      A,(ESTBLS)              ; mode flags
        BIT     1,A                     ; RTS/CTS handshake ?
        JR      Z,J5221                 ; nope, quit
        LD      A,(TOCNT)
        LD      D,A                     ; timeout value
J51FE:  LD      E,100
J5200:  CALL    C5237                   ; initialize i8253 counter 2
J5203:  CALL    C44DF                   ; check if ctrl-stop pressed
        EI
        RET     C                       ; yep, quit
        IN      A,(82H)
        BIT     7,A                     ; CTS ?
        JR      Z,J5221                 ; yep, quit
        LD      A,(TOCNT)
        AND     A                       ; timeout value = 0 ?
        JR      Z,J5203                 ; yep, endless wait
        CALL    C5243                   ; counter 2 finished ?
        JR      NC,J5203                ; nope, again
        AND     A                       ; clear Cx
        DEC     E
        JR      NZ,J5200
        DEC     D
        JR      NZ,J51FE
        RET

J5221:  XOR     A                       ; clear Cx
        INC     A                       ; clear Zx
        RET

;         Subroutine write i8251 command byte
;            Inputs  ________________________
;            Outputs ________________________
;            Remark  R800 compatible

C5224:  OUT     (81H),A
        LD      (LSTCOM),A              ; store command byte
        PUSH    AF

        IF      R800 EQ 1
        PUSH    BC
        LD      C,1
        OUT     (0E6H),A
J522F:  IN      A,(0E7H)
        CP      C
        JR      C,J522F
        POP     BC
        ENDIF

        POP     AF
        RET

;         Subroutine initialize i8253 counter 2
;            Inputs  ________________________
;            Outputs ________________________

C5237:  PUSH    AF
        PUSH    BC
        PUSH    DE
        LD      A,0B0H
        LD      C,86H
        LD      DE,4800H
        JR      J5255

;         Subroutine counter 2 finished ?
;            Inputs  ________________________
;            Outputs ________________________

C5243:  IN      A,(82H)
        RLCA
        RLCA
        RET

;         Subroutine initialize i8253 counter
;            Inputs  C = counter, DE = counter value
;            Outputs ________________________

C5248:  PUSH    AF
        PUSH    BC
        PUSH    DE
        LD      A,C
        LD      B,C
        ADD     A,84H
        LD      C,A
        LD      A,B
        RRCA
        RRCA
        OR      36H
J5255:  OUT     (87H),A
        OUT     (C),E
        OUT     (C),D
        POP     DE
        POP     BC
        POP     AF
        RET

        DEFS    06000H-$,000H

        END
