; BISTRS.MAC

; BASIC STRING functions, MSX 1 version (version 1.0)

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders


        .Z80
        ASEG
        ORG     65C8H


        INCLUDE MSX.INC


CGTABL          EQU     0004H
RDSLT           EQU     000CH
CALSLT          EQU     001CH
ENASLT          EQU     0024H
INITIO          EQU     003BH
INIFNK          EQU     003EH
WRTVDP          EQU     0047H
WRTVRM          EQU     004DH
RDVRM           EQU     004AH
FILVRM          EQU     0056H
LDIRMV          EQU     0059H
LDIRVM          EQU     005CH
CHGMOD          EQU     005FH
CHGCLR          EQU     0062H
CLRSPR          EQU     0069H
INITXT          EQU     006CH
INIT32          EQU     006FH
SETTXT          EQU     0078H
SETGRP          EQU     007EH
SETMLT          EQU     0081H
CALPAT          EQU     0084H
CALATR          EQU     0087H
GSPSIZ          EQU     008AH
GRPPRT          EQU     008DH
GICINI          EQU     0090H
WRTPSG          EQU     0093H
STRTMS          EQU     0099H
CHSNS           EQU     009CH
CHGET           EQU     009FH
CHPUT           EQU     00A2H
LPTOUT          EQU     00A5H
CNVCHR          EQU     00ABH
PINLIN          EQU     00AEH
INLIN           EQU     00B1H
QINLIN          EQU     00B4H
ISCNTC          EQU     00BAH
CKCNTC          EQU     00BDH
BEEP            EQU     00C0H
CLS             EQU     00C3H
POSIT           EQU     00C6H
FNKSB           EQU     00C9H
ERAFNK          EQU     00CCH
DSPFNK          EQU     00CFH
TOTEXT          EQU     00D2H
GTSTCK          EQU     00D5H
GTTRIG          EQU     00D8H
GTPAD           EQU     00DBH
GTPDL           EQU     00DEH
TAPION          equ     00E1H
TAPIN           equ     00E4H
TAPIOF          equ     00E7H
TAPOON          equ     00EAH
TAPOUT          equ     00EDH
TAPOOF          equ     00F0H
STMOTR          equ     00F3H
LFTQ            EQU     00F6H
PUTQ            EQU     00F9H
LEFTC           EQU     00FFH
TUPC            EQU     0105H
DOWNC           EQU     0108H
TDOWNC          EQU     010BH
SCALXY          EQU     010EH
MAPXYC          EQU     0111H
FETCHC          EQU     0114H
STOREC          EQU     0117H
SETATR          EQU     011AH
READC           EQU     011DH
SETC            EQU     0120H
NSETCX          EQU     0123H
GTASPC          EQU     0126H
PNTINI          EQU     0129H
SCANR           EQU     012CH
SCANL           EQU     012FH
ISFLIO          EQU     014AH
OUTDLP          EQU     014DH
GETVCP          EQU     0150H
GETVC2          EQU     0153H

VARWRK          EQU     0F380H
LOW.            EQU     0F406h
ERRFLG          EQU     0F414H
LPTPOS          EQU     0F415H
PRTFLG          EQU     0F416H
NTMSXP          EQU     0F417H
VLZADR          EQU     0F419H
VLZDAT          EQU     0F41BH
CURLIN          EQU     0F41CH
KBFMIN          EQU     0F41EH
KBUF            EQU     0F41FH
BUFMIN          EQU     0F55DH
BUF             EQU     0F55EH
ENDBUF          EQU     0F660H
TTYPOS          EQU     0F661H
DIMFLG          EQU     0F662H
VALTYP          EQU     0F663H
DORES           EQU     0F664H
DONUM           EQU     0F665H
CONTXT          EQU     0F666H
CONSAV          EQU     0F668H
CONTYP          EQU     0F669H
CONLO           EQU     0F66AH
MEMSIZ          EQU     0F672H
STKTOP          EQU     0F674H
TXTTAB          EQU     0F676H
TEMPPT          EQU     0F678H
TEMPST          EQU     0F67AH
DSCTMP          EQU     0F698H
FRETOP          EQU     0F69BH
TEMP3           EQU     0F69DH
TEMP8           EQU     0F69FH
ENDFOR          EQU     0F6A1H
DATLIN          EQU     0F6A3H
SUBFLG          EQU     0F6A5H
FLGINP          EQU     0F6A6H
TEMP            EQU     0F6A7H
PTRFLG          EQU     0F6A9H
AUTFLG          EQU     0F6AAH
AUTLIN          EQU     0F6ABH
AUTINC          EQU     0F6ADH
SAVTXT          EQU     0F6AFH
SAVSTK          EQU     0F6B1H
ERRLIN          EQU     0F6B3H
DOT             EQU     0F6B5H
ERRTXT          EQU     0F6B7H
ONELIN          EQU     0F6B9H
ONEFLG          EQU     0F6BBH
TEMP2           EQU     0F6BCH
OLDLIN          EQU     0F6BEH
OLDTXT          EQU     0F6C0H
VARTAB          EQU     0F6C2H
ARYTAB          EQU     0F6C4H
STREND          EQU     0F6C6H
DATPTR          EQU     0F6C8H
DEFTBL          EQU     0F6CAH
PRMSTK          EQU     0F6E4H
PRMLEN          EQU     0F6E6H
PARM1           EQU     0F6E8H
PRMPRV          EQU     0F74CH
PRMLN2          EQU     0F74EH
PARM2           EQU     0F750H
PRMFLG          EQU     0F7B4H
ARYTA2          EQU     0F7B5H
NOFUNS          EQU     0F7B7H
TEMP9           EQU     0F7B8H
FUNACT          EQU     0F7BAH
SWPTMP          EQU     0F7BCH
TRCFLG          EQU     0F7C4H
DAC             EQU     0F7F6H
ARG             EQU     0F847H
MAXFIL          EQU     0F85FH
FILTAB          EQU     0F860H
NULBUF          EQU     0F862H
PTRFIL          EQU     0F864H
FILNAM          EQU     0F866H
FILNM2          EQU     0F871H
NLONLY          EQU     0F87CH
SAVEND          EQU     0F87DH
FNKSTR          EQU     0F87FH
CGPNT           EQU     0F91FH
MINDEL          EQU     0F92DH
MAXDEL          EQU     0F92FH
ASPECT          EQU     0F931H
CENCNT          EQU     0F933H
CLINEF          EQU     0F935H
CNPNTS          EQU     0F936H
CPLOTF          EQU     0F938H
CPCNT           EQU     0F939H
CPCNT8          EQU     0F93BH
CRCSUM          EQU     0F93DH
CSTCNT          EQU     0F93FH
CSCLXY          EQU     0F941H
CSAVEA          EQU     0F942H
CSAVEM          EQU     0F944H
CXOFF           EQU     0F945H
CYOFF           EQU     0F947H
LOHMSK          EQU     0F949H
LOHDIR          EQU     0F94AH
LOHADR          EQU     0F94BH
LOHCNT          EQU     0F94DH
SKPCNT          EQU     0F94FH
MOVCNT          EQU     0F951H
PDIREC          EQU     0F953H
LFPROG          EQU     0F954H
RTPROG          EQU     0F955H
MCLTAB          EQU     0F956H
MCLFLG          EQU     0F958H
QUETAB          EQU     0F959H
PRSCNT          EQU     0FB35H
SAVSP           EQU     0FB36H
VOICEN          EQU     0FB38H
SAVVOL          EQU     0FB39H
MCLLEN          EQU     0FB3BH
MCLPTR          EQU     0FB3CH
MUSICF          EQU     0FB3FH
PLYCNT          EQU     0FB40H
BASROM          EQU     0FBB1H
FNKFLG          EQU     0FBCEH
ONGSBF          EQU     0FBD8H
KEYBUF          EQU     0FBF0H
BOTTOM          EQU     0FC48H
HIMEM           EQU     0FC4AH
TRPTBL          EQU     0FC4CH
INTFLG          EQU     0FC9BH
JIFFY           EQU     0FC9EH
INTVAL          EQU     0FCA0H
INTCNT          EQU     0FCA2H
FLBMEM          EQU     0FCAEH
SCRMOD          EQU     0FCAFH
OLDSCR          EQU     0FCB0H
CASPRV          equ     0FCB1H
GXPOS           EQU     0FCB3H
GYPOS           EQU     0FCB5H
GRPACX          EQU     0FCB7H
GRPACY          EQU     0FCB9H
DRWFLG          EQU     0FCBBH
DRWSCL          EQU     0FCBCH
DRWANG          EQU     0FCBDH
RUNBNF          EQU     0FCBEH
SAVENT          EQU     0FCBFH
EXPTBL          EQU     0FCC1H
SLTTBL          EQU     0FCC5H
SLTATR          EQU     0FCC9H
SLTWRK          EQU     0FD09H
PROCNM          EQU     0FD89H
DEVICE          EQU     0FD99H

H.KEYI          EQU     0FD9AH
H.ONGO          EQU     0FDEAH
H.DSKO          EQU     0FDEFH
H.SETS          EQU     0FDF4H
H.NAME          EQU     0FDF9H
H.KILL          EQU     0FDFEH
H.IPL           EQU     0FE03H
H.COPY          EQU     0FE08H
H.CMD           EQU     0FE0DH
H.DSKF          EQU     0FE12H
H.DSKI          EQU     0FE17H
H.ATTR          EQU     0FE1CH
H.LSET          EQU     0FE21H
H.RSET          EQU     0FE26H
H.FIEL          EQU     0FE2BH
H.MKI$          EQU     0FE30H
H.MKS$          EQU     0FE35H
H.MKD$          EQU     0FE3AH
H.CVI           EQU     0FE3FH
H.CVS           EQU     0FE44H
H.CVD           EQU     0FE49H
H.GETP          EQU     0FE4EH
H.SETF          EQU     0FE53H
H.NOFO          EQU     0FE58H
H.NULO          EQU     0FE5DH
H.NTFL          EQU     0FE62H
H.MERG          EQU     0FE67H
H.SAVE          EQU     0FE6CH
H.BINS          EQU     0FE71H
H.BINL          EQU     0FE76H
H.FILE          EQU     0FE7BH
H.DGET          EQU     0FE80H
H.FILO          EQU     0FE85H
H.INDS          EQU     0FE8AH
H.RSLF          EQU     0FE8FH
H.SAVD          EQU     0FE94H
H.LOC           EQU     0FE99H
H.LOF           EQU     0FE9EH
H.EOF           EQU     0FEA3H
H.FPOS          EQU     0FEA8H
H.BAKU          EQU     0FEADH
H.PARD          EQU     0FEB2H
H.NODE          EQU     0FEB7H
H.POSD          EQU     0FEBCH
H.GEND          EQU     0FEC6H
H.RUNC          EQU     0FECBH
H.CLEA          EQU     0FED0H
H.LOPD          EQU     0FED5H
H.STKE          EQU     0FEDAH
H.CRDO          EQU     0FEE9H
H.DSKC          EQU     0FEEEH
H.DOGR          EQU     0FEF3H
H.PRGE          EQU     0FEF8H
H.ERRP          EQU     0FEFDH
H.ERRF          EQU     0FF02H
H.READ          EQU     0FF07H
H.MAIN          EQU     0FF0CH
H.DIRD          EQU     0FF11H
H.FINI          EQU     0FF16H
H.FINE          EQU     0FF1BH
H.CRUN          EQU     0FF20H
H.CRUS          EQU     0FF25H
H.ISRE          EQU     0FF2AH
H.NTFN          EQU     0FF2FH
H.NOTR          EQU     0FF34H
H.SNGF          EQU     0FF39H
H.NEWS          EQU     0FF3EH
H.GONE          EQU     0FF43H
H.CHRG          EQU     0FF48H
H.RETU          EQU     0FF4DH
H.PRTF          EQU     0FF52H
H.COMP          EQU     0FF57H
H.FINP          EQU     0FF5CH
H.TRMN          EQU     0FF61H
H.FRME          EQU     0FF66H
H.NTPL          EQU     0FF6BH
H.EVAL          EQU     0FF70H
H.OKNO          EQU     0FF75H
H.FING          EQU     0FF7AH
H.ISMI          EQU     0FF7FH
H.WIDT          EQU     0FF84H
H.LIST          EQU     0FF89H
H.BUFL          EQU     0FF8EH
H.FRQI          EQU     0FF93H
H.SCNE          EQU     0FF98H
H.FRET          EQU     0FF9DH
H.PTRG          EQU     0FFA2H
H.ERRO          EQU     0FFB1H
H.SCRE          EQU     0FFC0H
H.PLAY          EQU     0FFC5H
EXTBIO          EQU     0FFCAH
D.FFFF          EQU     0FFFFH

        PUBLIC  FRESTR
        PUBLIC  FREDAC
        PUBLIC  STROUI
        PUBLIC  STROUT
        PUBLIC  GETSPA
        PUBLIC  STRINI
        PUBLIC  STRIN1
        PUBLIC  SETSTR
        PUBLIC  PUTNEW
        PUBLIC  PUTTMP
        PUBLIC  STRLIT
        PUBLIC  STRLTI
        PUBLIC  STRLT2
        PUBLIC  STRLT3
        PUBLIC  ASC2
        PUBLIC  STRCPY
        PUBLIC  FRETMS
        PUBLIC  STRPRT
        PUBLIC  FRETMP
        PUBLIC  FRETM2
        PUBLIC  LEFTUS
        PUBLIC  CAT
        PUBLIC  STRCMP
        PUBLIC  J66A7
        PUBLIC  INSTR
        PUBLIC  STRNG$
        PUBLIC  CHR$
        PUBLIC  SPACE$
        PUBLIC  LEFT$
        PUBLIC  RIGHT$
        PUBLIC  MID$
        PUBLIC  MIDS
        PUBLIC  VAL
        PUBLIC  LEN
        PUBLIC  STR$
        PUBLIC  ASC
        PUBLIC  FRE
        PUBLIC  OCT$
        PUBLIC  HEX$
        PUBLIC  BIN$

        EXTRN   MOVRM
        EXTRN   VMOVE
        EXTRN   FIN
        EXTRN   FOUT
        EXTRN   FOUTB
        EXTRN   FOUTO
        EXTRN   FOUTH
        EXTRN   FCERR
        EXTRN   FRMEVL
        EXTRN   FRMPRN
        EXTRN   FRMEQL
        EXTRN   GETBYT
        EXTRN   CONINT
        EXTRN   CHKSTR
        EXTRN   BLTUC
        EXTRN   ERROR
        EXTRN   SNGFLT
        EXTRN   PTRGET
        EXTRN   J3297
        EXTRN   GIVDBL
        EXTRN   TSTOP
        EXTRN   EVAL
        EXTRN   SIGNS
        EXTRN   GETBCD
        EXTRN   CRFIN
        EXTRN   SYNCHR
        EXTRN   CHRGTR
        EXTRN   OUTDO
        EXTRN   DCOMPR
        EXTRN   GETYPR
        EXTRN   CALLF


_RST    MACRO   X
        IFIDN   <X>,<SYNCHR>
        RST     08H
        ENDIF
        IFIDN   <X>,<CHRGTR>
        RST     10H
        ENDIF
        IFIDN   <X>,<OUTDO>
        RST     18H
        ENDIF
        IFIDN   <X>,<DCOMPR>
        RST     20H
        ENDIF
        IFIDN   <X>,<GETYPR>
        RST     28H
        ENDIF
        IFIDN   <X>,<CALLF>
        RST     30H
        ENDIF
        ENDM


; START	SUBTTL	BISTRS

	SUBTTL	BISTRS

STRCMP:
I65C8:  CALL    FRESTR                  ; free temporary string with type check
        LD      A,(HL)                  ; size of string
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; pointer to string
        POP     DE
        PUSH    BC
        PUSH    AF
        CALL    FRETMP                  ; free temporary string (descriptor in DE)
        POP     AF
        LD      D,A
        LD      E,(HL)                  ; size of string
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; pointer to string
        POP     HL
J65DE:  LD      A,E
        OR      D                       ; end of both strings ?
        RET     Z                       ; yep, quit (A=0, equal)
        LD      A,D
        SUB     1                       ; end of first string ?
        RET     C                       ; yep, quit (A=FF, less)
        XOR     A
        CP      E                       ; end of second string ?
        INC     A
        RET     NC                      ; yep, quit (A=1, bigger)
        DEC     D
        DEC     E                       ; adjust counter
        LD      A,(BC)
        INC     BC
        CP      (HL)                    ; equal ?
        INC     HL
        JR      Z,J65DE                 ; yep, next
        CCF
        JP      SIGNS                   ; set compare value

;       Subroutine      OCT$ function
;       Inputs          ________________________
;       Outputs         ________________________

OCT$:
C65F5:  CALL    FOUTO                   ; convert integer to octal text
        JR      J6607

;       Subroutine      HEX$ function
;       Inputs          ________________________
;       Outputs         ________________________

HEX$:
C65FA:  CALL    FOUTH                   ; convert integer to hexadecimal text
        JR      J6607

;       Subroutine      BIN$ function
;       Inputs          ________________________
;       Outputs         ________________________

BIN$:
C65FF:  CALL    FOUTB                   ; convert integer to binary text
        JR      J6607

;       Subroutine      STR$ function
;       Inputs          ________________________
;       Outputs         ________________________

STR$:
C6604:  CALL    FOUT                    ; convert DAC to text, unformatted
J6607:  CALL    STRLIT                  ; analyse string and create temporary stringdescriptor
        CALL    FREDAC                  ; free temporary string in DAC
        LD      BC,J6825
        PUSH    BC                      ; copy string to new temporary string, temporary stringdescriptor to heap and quit

;       Subroutine      copy string to new temporary string
;       Inputs          HL = source string descriptor
;       Outputs         ________________________

STRCPY:
C6611:  LD      A,(HL)                  ; size of string
        INC     HL
        PUSH    HL
        CALL    GETSPA                  ; allocate stringspace
        POP     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; pointer to string
        CALL    C662A                   ; make temporary stringdescriptor
        PUSH    HL
        LD      L,A                     ; size of string
        CALL    C67C7                   ; copy string
        POP     DE
        RET

;       Subroutine      allocate temporary string of 1 char
;       Inputs          ________________________
;       Outputs         DE = pointer to string, HL = descriptor

STRIN1:
C6625:  LD      A,1

;       Subroutine      allocate temporary string
;       Inputs          A = stringsize
;       Outputs         DE = pointer to string, HL = descriptor

STRINI:
C6627:  CALL    GETSPA                  ; allocate stringspace

;       Subroutine      make temporary stringdescriptor
;       Inputs          A = stringsize, DE = pointer to string
;       Outputs         HL = pointer to temporary stringdescriptor

STRAD2:
C662A:  LD      HL,DSCTMP
        PUSH    HL
        LD      (HL),A
        INC     HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        POP     HL
        RET

;       Subroutine      analyse string and create temporary stringdescriptor
;       Inputs          HL = pointer to string to be analysed
;       Outputs         ________________________


STRLIT:
C6635:  DEC     HL

;       Subroutine      analyze string with " as endmarker (1st char is skipped) and create temporary stringdescriptor
;       Inputs          ________________________
;       Outputs         ________________________

STRLTI:
C6636:  LD      B,'"'

;       Subroutine      analyze string with specified endmaker (1st char is skipped) and create temporary stringdescriptor
;       Inputs          ________________________
;       Outputs         ________________________

STRLT3:
C6638:  LD      D,B

;       Subroutine      analyse string with specified endmarkers (1st char is skipped) and create temporary stringdescriptor
;       Inputs          HL = pointer to string to be analysed, B = end character 1, D = end character 2
;       Outputs         ________________________

STRLT2:
C6639:  PUSH    HL
        LD      C,-1
J663C:  INC     HL
        LD      A,(HL)
        INC     C
        OR      A                       ; end of BASIC line/string ?
        JR      Z,J6648                 ; yep,
        CP      D                       ; end character 1 ?
        JR      Z,J6648                 ; yep,
        CP      B                       ; end character 2 ?
        JR      NZ,J663C                ; nope, skip
J6648:  CP      '"'                     ; string marker ?
        CALL    Z,CHRGTR                ; yep, get next BASIC character
        EX      (SP),HL
        INC     HL
        EX      DE,HL
        LD      A,C
        CALL    C662A                   ; make temporary stringdescriptor

;       Subroutine      push temporary descriptor to temporary desciptor heap
;       Inputs          ________________________
;       Outputs         ________________________

PUTNEW:
J6654:  LD      DE,DSCTMP
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction

;       Subroutine      push descriptor to temporary desciptor heap
;       Inputs          DE = desciptor
;       Outputs         ________________________

PUTTMP:
C6658:  PUSH    DE
        LD      HL,(TEMPPT)
        LD      (DAC+2),HL
        LD      A,3
        LD      (VALTYP),A
        CALL    VMOVE                   ; HL = DE (valtyp)
        LD      DE,TEMPST+30+3
        _RST    DCOMPR                  ; temporary descriptor heap full ?
        LD      (TEMPPT),HL
        POP     HL
        LD      A,(HL)
        RET     NZ
        LD      DE,16                   ; ?? LD E,16 should be enough ??
        JP      ERROR                   ; yep, string formula too complex error

;       Subroutine      skip first character, message to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

STROUI:
I6677:  INC     HL

;       Subroutine      message to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

STROUT:
C6678:  CALL    STRLIT                  ; analyse string and create temporary stringdescriptor

;       Subroutine      free string and string to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

STRPRT:
C667B:  CALL    FREDAC                  ; free temporary string in DAC
        CALL    GETBCD                  ; get size and address of string
        INC     D
J6682:  DEC     D
        RET     Z
        LD      A,(BC)
        _RST    OUTDO                   ; char to interpreter output
        CP      0DH                     ; CR ?
        CALL    Z,CRFIN                 ; yep, interpreter output pos = 0
        INC     BC
        JR      J6682

;       Subroutine      allocate stringspace
;       Inputs          A = size of string
;       Outputs         DE = pointer to stringspace

GETSPA:
C668E:  OR      A                       ; because size<>0, Zx is reset (no garbage collect done)
        DEFB    00EH                    ; LD C,xx, trick to skip next instruction
I6690:  POP     AF
        PUSH    AF
        LD      HL,(STKTOP)
        EX      DE,HL                   ; lowest stringspace
        LD      HL,(FRETOP)
        CPL
        LD      C,A
        LD      B,0FFH
        ADD     HL,BC
        INC     HL                      ; lower stringspace - stringsize = new lower
        _RST    DCOMPR                  ; space available at bottom ?
        JR      C,J66A9                 ; nope, try garbage collect
        LD      (FRETOP),HL             ; new lower stringspace
        INC     HL
        EX      DE,HL
J66A7:  POP     AF
        RET

J66A9:  POP     AF                      ; garbage collect already done ?
        LD      DE,14                   ; ?? LD E,14 should be enough ??
        JP      Z,ERROR                 ; yep, out of string space error
        CP      A                       ; Zx set (garbage collect done)
        PUSH    AF
        LD      BC,I6690
        PUSH    BC                      ; do a garbage collect and try allocate again

;       Subroutine      garbage collect
;       Inputs          ________________________
;       Outputs         ________________________

C66B6:  LD      HL,(MEMSIZ)             ; stringheap pointer to top of stringspace
J66B9:  LD      (FRETOP),HL
        LD      HL,0
        PUSH    HL                      ; descriptor current top string
        LD      HL,(STREND)
        PUSH    HL                      ; current top string (strings in BASIC text or variables is excluded)
        LD      HL,TEMPST               ; start with the temporary stringdescriptors
I66C7:  LD      DE,(TEMPPT)
        _RST    DCOMPR                  ; stringdescriptor heap empty ?
        LD      BC,I66C7
        JP      NZ,J6742                ; nope, adjust if new topstring and next descriptor
        LD      HL,PRMPRV
        LD      (TEMP9),HL
        LD      HL,(ARYTAB)
        LD      (ARYTA2),HL             ; stop searching when the array variables are reached
        LD      HL,(VARTAB)             ; start searching in the simple variables
J66E1:  LD      DE,(ARYTA2)
        _RST    DCOMPR                  ; end of searcharea ?
        JR      Z,J66FA                 ; yep,
        LD      A,(HL)                  ; variable type
        INC     HL
        INC     HL
        INC     HL                      ; skip variablename, to variable value
        CP      3                       ; string ?
        JR      NZ,J66F4                ; nope, next variable
        CALL    C6743                   ; adjust if new topstring
        XOR     A
J66F4:  LD      E,A
        LD      D,0
        ADD     HL,DE
        JR      J66E1                   ; next variable

J66FA:  LD      HL,(TEMP9)              ; current FN parameter block
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      A,D
        OR      E                       ; end of FN parameter block list ?
        LD      HL,(ARYTAB)
        JR      Z,J671A                 ; yep, continue with the arrayvariables
        EX      DE,HL
        LD      (TEMP9),HL              ; update current FN parameter block
        INC     HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        EX      DE,HL
        ADD     HL,DE
        LD      (ARYTA2),HL
        EX      DE,HL
        JR      J66E1                   ; search FN parameter block variables

J6719:  POP     BC
J671A:  LD      DE,(STREND)
        _RST    DCOMPR                  ; end of arrayvariables ?
        JP      Z,J6763                 ; yep, move topstring up when possible
        LD      A,(HL)                  ; variable type
        INC     HL
        CALL    MOVRM                   ; load from HL (arrayoffset and variablename)
        PUSH    HL
        ADD     HL,BC                   ; to next variable
        CP      3                       ; string ?
        JR      NZ,J6719                ; nope, next variable
        LD      (TEMP8),HL              ; next variable
        POP     HL
        LD      C,(HL)
        LD      B,0
        ADD     HL,BC
        ADD     HL,BC
        INC     HL                      ; to the first arrayelement
I6737:  EX      DE,HL
        LD      HL,(TEMP8)
        EX      DE,HL
        _RST    DCOMPR                  ; end of this arrayvariable ?
        JR      Z,J671A                 ; yep, next arrayvariable
        LD      BC,I6737                ; adjust if new topstring and next arrayelement
J6742:  PUSH    BC

;       Subroutine      adjust if new topstring
;       Inputs          ________________________
;       Outputs         ________________________

C6743:  XOR     A
        OR      (HL)                    ; empty string ?
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; pointer to string
        INC     HL
        RET     Z                       ; empty string, quit
        LD      B,H
        LD      C,L
        LD      HL,(FRETOP)
        _RST    DCOMPR                  ; string above current top of heap ?
        LD      H,B
        LD      L,C
        RET     C                       ; yep, quit
        POP     HL
        EX      (SP),HL
        _RST    DCOMPR                  ; string below current top string ?
        EX      (SP),HL
        PUSH    HL
        LD      H,B
        LD      L,C
        RET     NC                      ; yep, quit
        POP     BC                      ; return address
        POP     AF
        POP     AF                      ; discharge
        PUSH    HL                      ; new current descriptor topstring +3
        PUSH    DE                      ; new current topstring
        PUSH    BC
        RET

J6763:  POP     DE
        POP     HL
        LD      A,H
        OR      L                       ; topstring found ?
        RET     Z                       ; nope, quit with garabage collect
        DEC     HL
        LD      B,(HL)
        DEC     HL
        LD      C,(HL)                  ; current topstring
        PUSH    HL
        DEC     HL
        LD      L,(HL)                  ; size of string
        LD      H,0
        ADD     HL,BC
        LD      D,B
        LD      E,C                     ; start of string
        DEC     HL
        LD      B,H
        LD      C,L                     ; end of string
        LD      HL,(FRETOP)             ; top of stringspace is new end of string
        CALL    BLTUC                   ; move data
        POP     HL
        LD      (HL),C
        INC     HL
        LD      (HL),B                  ; new address string
        LD      H,B
        LD      L,C
        DEC     HL
        JP      J66B9                   ; new stringheap pointer and continue garbage collect

CAT:
J6787:  PUSH    BC
        PUSH    HL
        LD      HL,(DAC+2)
        EX      (SP),HL
        CALL    EVAL                    ; evaluate factor
        EX      (SP),HL
        CALL    CHKSTR                  ; check if DAC has string
        LD      A,(HL)                  ; size of 1st string
        PUSH    HL
        LD      HL,(DAC+2)
        PUSH    HL
        ADD     A,(HL)                  ; + size of 2nd string
        LD      DE,15                   ; ?? LD E,15 should be enough ??
        JP      C,ERROR                 ; resulting length >255, string too long error
        CALL    STRINI                  ; allocate temporary string for result
        POP     DE
        CALL    FRETMP                  ; free temporary string (descriptor in DE) -> free 2nd string
        EX      (SP),HL
        CALL    FRETM2                  ; free temporary string (descriptor in HL) -> free 1st string
        PUSH    HL
        LD      HL,(DSCTMP+1)
        EX      DE,HL
        CALL    C67BF                   ; copy string (descriptor on stack) -> copy 1st string
        CALL    C67BF                   ; copy string (descriptor on stack) -> copy 2nd string
        LD      HL,TSTOP
        EX      (SP),HL
        PUSH    HL
        JP      PUTNEW                  ; push temporary descriptor to temporary desciptor heap and quit

;       Subroutine      copy string (descriptor on stack)
;       Inputs          string descriptor on stack, DE = destination string
;       Outputs         ________________________
;       Remark          works only if this routine is CALLed

C67BF:  POP     HL
        EX      (SP),HL                 ; get descriptor from stack
        LD      A,(HL)
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        LD      L,A

;       Subroutine      copy string
;       Inputs          L = size of string, BC = source string, DE = destination string
;       Outputs         ________________________

C67C7:  INC     L
J67C8:  DEC     L
        RET     Z
        LD      A,(BC)
        LD      (DE),A
        INC     BC
        INC     DE
        JR      J67C8

;       Subroutine      FRESTR (free temporary string with type check)
;       Inputs          ________________________
;       Outputs         ________________________

FRESTR:
C67D0:  CALL    CHKSTR                  ; check if string

;       Subroutine      free temporary string in DAC
;       Inputs          DAC = string descriptor
;       Outputs         ________________________

FREDAC:
C67D3:  LD      HL,(DAC+2)              ; descriptor

;       Subroutine      free temporary string
;       Inputs          HL = string descriptor
;       Outputs         ________________________

FRETM2:
C67D6:  EX      DE,HL

;       Subroutine      free temporary string
;       Inputs          DE = string descriptor
;       Outputs         HL = string descriptor

FRETMP:
C67D7:  CALL    FRETMS                  ; free descriptor if temporary and on top of heap
        EX      DE,HL
        RET     NZ                      ; no temporary descriptor on top of heap, quit
        PUSH    DE
        LD      D,B
        LD      E,C
        DEC     DE
        LD      C,(HL)                  ; size of string
        LD      HL,(FRETOP)
        _RST    DCOMPR                  ; on top of string heap ?
        JR      NZ,J67EC                ; nope, quit
        LD      B,A
        ADD     HL,BC
        LD      (FRETOP),HL             ; release string from heap
J67EC:  POP     HL
        RET

;       Subroutine      free descriptor if temporary and on top of heap
;       Inputs          DE = descriptor
;       Outputs         ________________________

FRETMS:
C67EE:  CALL    H.FRET
        LD      HL,(TEMPPT)
        DEC     HL
        LD      B,(HL)
        DEC     HL
        LD      C,(HL)                  ; pointer to string
        DEC     HL
        _RST    DCOMPR                  ; desciptor on top of the heap ?
        RET     NZ                      ; nope, quit
        LD      (TEMPPT),HL             ; release descriptor from heap
        RET

;       Subroutine      LEN function
;       Inputs          ________________________
;       Outputs         ________________________

LEN:
C67FF:  LD      BC,SNGFLT
        PUSH    BC                      ; after this, byte to DAC

;       Subroutine      free temporary string and get size
;       Inputs          ________________________
;       Outputs         ________________________

C6803:  CALL    FRESTR                  ; free temporary string with type check
        XOR     A
        LD      D,A
        LD      A,(HL)                  ; size of string
        OR      A                       ; Zx set if empty string
        RET

;       Subroutine      ASC function
;       Inputs          ________________________
;       Outputs         ________________________

ASC:
C680B:  LD      BC,SNGFLT               ; after this, byte to DAC
        PUSH    BC

;       Subroutine      free temporary string and get first character
;       Inputs          ________________________
;       Outputs         ________________________

ASC2:
C680F:  CALL    C6803                   ; free temporary string and get size
        JP      Z,FCERR                 ; empty string, illegal function call
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; pointer to string
        LD      A,(DE)                  ; first character
        RET

;       Subroutine      CHR$ function
;       Inputs          ________________________
;       Outputs         ________________________

CHR$:
C681B:  CALL    STRIN1                  ; allocate temporary string of 1 char
        CALL    CONINT                  ; check for byte value

;       Subroutine      set first character of temporary string and put on heap
;       Inputs          ________________________
;       Outputs         ________________________

SETSTR:
C6821:  LD      HL,(DSCTMP+1)
        LD      (HL),E
J6825:  POP     BC
        JP      PUTNEW                  ; push temporary descriptor to temporary desciptor heap and quit

;       Subroutine      STRING$ function
;       Inputs          ________________________
;       Outputs         ________________________

STRNG$:
J6829:  _RST    CHRGTR                  ; get next BASIC character
        _RST    SYNCHR
        DEFB    "("                     ; check for (
        CALL    GETBYT                  ; evaluate byte operand
        PUSH    DE
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    FRMEVL                  ; evaluate expression
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        EX      (SP),HL
        PUSH    HL
        _RST    GETYPR                  ; get DAC type
        JR      Z,J6841                 ; string,
        CALL    CONINT                  ; check for byte value
        JR      J6844

J6841:  CALL    ASC2                    ; free temporary string and get first character
J6844:  POP     DE                      ; number of characters
        CALL    C684D                   ; create string with characters and quit

;       Subroutine      SPACE$ function
;       Inputs          ________________________
;       Outputs         ________________________

SPACE$:
C6848:  CALL    CONINT                  ; check for byte value
        LD      A," "

;       Subroutine      create string with characters
;       Inputs          ________________________
;       Outputs         ________________________

C684D:  PUSH    AF
        LD      A,E                     ; number of characters
        CALL    STRINI                  ; allocate temporary string
        LD      B,A
        POP     AF
        INC     B
        DEC     B                       ; stringsize zero ?
        JR      Z,J6825                 ; yep, temporary stringdescriptor to heap and quit
        LD      HL,(DSCTMP+1)           ; pointer to temporary string
J685B:  LD      (HL),A
        INC     HL
        DJNZ    J685B                   ; fill string
        JR      J6825                   ; temporary stringdescriptor to heap and quit

;       Subroutine      LEFT$ function
;       Inputs          ________________________
;       Outputs         ________________________

LEFT$:
C6861:  CALL    C68E3
        XOR     A
J6865:  EX      (SP),HL
        LD      C,A
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction
LEFTUS:
C6868:  PUSH    HL
I6869:  PUSH    HL
        LD      A,(HL)
        CP      B
        JR      C,J6870
        LD      A,B
        DEFB    011H                    ; LD DE,xxxx, trick to skip next instruction
J6870:  LD      C,0
        PUSH    BC
        CALL    GETSPA                  ; allocate stringspace
        POP     BC
        POP     HL
        PUSH    HL
        INC     HL
        LD      B,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,B
        LD      B,00H
        ADD     HL,BC
        LD      B,H
        LD      C,L
        CALL    C662A                   ; make temporary stringdescriptor
        LD      L,A
        CALL    C67C7                   ; copy string
        POP     DE
        CALL    FRETMP                  ; free temporary string (descriptor in DE)
        JP      PUTNEW                  ; push temporary descriptor to temporary desciptor heap and quit

;       Subroutine      RIGHT$ function
;       Inputs          ________________________
;       Outputs         ________________________

RIGHT$:
C6891:  CALL    C68E3
        POP     DE
        PUSH    DE
        LD      A,(DE)
        SUB     B
        JR      J6865

;       Subroutine      MID$ function
;       Inputs          ________________________
;       Outputs         ________________________

MID$:
C689A:  EX      DE,HL
        LD      A,(HL)
        CALL    C68E6
        INC     B
        DEC     B
        JP      Z,FCERR                 ; illegal function call
        PUSH    BC
        CALL    C69E4
        POP     AF
        EX      (SP),HL
        LD      BC,I6869
        PUSH    BC
        DEC     A
        CP      (HL)
        LD      B,00H
        RET     NC
        LD      C,A
        LD      A,(HL)
        SUB     C
        CP      E
        LD      B,A
        RET     C
        LD      B,E
        RET

;       Subroutine      VAL function
;       Inputs          ________________________
;       Outputs         ________________________

VAL:
C68BB:  CALL    C6803                   ; free temporary string and get size
        JP      Z,SNGFLT                ; empty string, byte (size) to DAC
        LD      E,A
        INC     HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A
        PUSH    HL
        ADD     HL,DE
        LD      B,(HL)
        LD      (VLZADR),HL
        LD      A,B
        LD      (VLZDAT),A
        LD      (HL),D
        EX      (SP),HL
        PUSH    BC
        DEC     HL
        _RST    CHRGTR                  ; get next BASIC character
        CALL    FIN                     ; convert text to number
        LD      HL,0
        LD      (VLZADR),HL
        POP     BC
        POP     HL
        LD      (HL),B
        RET

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C68E3:  EX      DE,HL
        _RST    SYNCHR
        DEFB    ")"                     ; check for )

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C68E6:  POP     BC
        POP     DE
        PUSH    BC
        LD      B,E
        RET

;       Subroutine      INSTR function
;       Inputs          ________________________
;       Outputs         ________________________

INSTR:
J68EB:  _RST    CHRGTR                  ; get next BASIC character
        CALL    FRMPRN                  ; evaluate ( expression
        _RST    GETYPR                  ; get DAC type
        LD      A,1
        PUSH    AF
        JR      Z,J6906                 ; string,
        POP     AF
        CALL    CONINT                  ; check for byte value
        OR      A
        JP      Z,FCERR                 ; illegal function call
        PUSH    AF
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    FRMEVL                  ; evaluate expression
        CALL    CHKSTR                  ; check if string
J6906:  _RST    SYNCHR
        DEFB    ","                     ; check for ,
        PUSH    HL
        LD      HL,(DAC+2)
        EX      (SP),HL
        CALL    FRMEVL                  ; evaluate expression
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        PUSH    HL
        CALL    FRESTR                  ; free temporary string with type check
        EX      DE,HL
        POP     BC
        POP     HL
        POP     AF
        PUSH    BC
        LD      BC,J3297
        PUSH    BC
        LD      BC,SNGFLT
        PUSH    BC                      ; after this, byte to DAC
        PUSH    AF
        PUSH    DE
        CALL    FRETM2                  ; free temporary string (descriptor in HL)
        POP     DE
        POP     AF
        LD      B,A
        DEC     A
        LD      C,A
        CP      (HL)
        LD      A,0
        RET     NC
        LD      A,(DE)
        OR      A
        LD      A,B
        RET     Z
        LD      A,(HL)
        INC     HL
        LD      B,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,B
        LD      B,0
        ADD     HL,BC
J693E:  SUB     C
        LD      B,A
        PUSH    BC
        PUSH    DE
        EX      (SP),HL
        LD      C,(HL)
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        POP     HL
J6949:  PUSH    HL
        PUSH    DE
        PUSH    BC
J694C:  LD      A,(DE)
        CP      (HL)
        JR      NZ,J6966
        INC     DE
        DEC     C
        JR      Z,J695D
        INC     HL
        DJNZ    J694C
        POP     DE
        POP     DE
        POP     BC
J695A:  POP     DE
        XOR     A
        RET

J695D:  POP     HL
        POP     DE
        POP     DE
        POP     BC
        LD      A,B
        SUB     H
        ADD     A,C
        INC     A
        RET

J6966:  POP     BC
        POP     DE
        POP     HL
        INC     HL
        DJNZ    J6949
        JR      J695A

;       Subroutine      MID$ statement
;       Inputs          ________________________
;       Outputs         ________________________

MIDS:
J696E:  _RST    SYNCHR
        DEFB    "("                     ; check for (
        CALL    PTRGET                  ; locate variable
        CALL    CHKSTR                  ; check if string
        PUSH    HL
        PUSH    DE
        EX      DE,HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      HL,(STREND)
        _RST    DCOMPR
        JR      C,J6993
        LD      HL,(TXTTAB)
        _RST    DCOMPR
        JR      NC,J6993
        POP     HL
        PUSH    HL
        CALL    STRCPY                  ; copy string to new temporary string
        POP     HL
        PUSH    HL
        CALL    VMOVE                   ; HL = DE (valtyp)
J6993:  POP     HL
        EX      (SP),HL
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    GETBYT                  ; evaluate byte operand
        OR      A                       ; startpos 0 ?
        JP      Z,FCERR                 ; yep, illegal function call
        PUSH    AF
        LD      A,(HL)
        CALL    C69E4
        PUSH    DE
        CALL    FRMEQL                  ; evaluate = expression
        PUSH    HL
        CALL    FRESTR                  ; free temporary string with type check
        EX      DE,HL
        POP     HL
        POP     BC
        POP     AF
        LD      B,A
        EX      (SP),HL
        PUSH    HL
        LD      HL,J3297
        EX      (SP),HL
        LD      A,C
        OR      A
        RET     Z
        LD      A,(HL)
        SUB     B
        JP      C,FCERR                 ; illegal function call
        INC     A
        CP      C
        JR      C,J69C3
        LD      A,C
J69C3:  LD      C,B
        DEC     C
        LD      B,00H
        PUSH    DE
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,E
        ADD     HL,BC
        LD      B,A
        POP     DE
        EX      DE,HL
        LD      C,(HL)
        INC     HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A
        EX      DE,HL
        LD      A,C
        OR      A
        RET     Z
J69DB:  LD      A,(DE)
        LD      (HL),A
        INC     DE
        INC     HL
        DEC     C
        RET     Z
        DJNZ    J69DB
        RET

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C69E4:  LD      E,0FFH
        CP      ")"
        JR      Z,J69EF
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    GETBYT                  ; evaluate byte operand
J69EF:  _RST    SYNCHR
        DEFB    ")"                     ; check for )
        RET

;       Subroutine      FRE function
;       Inputs          ________________________
;       Outputs         ________________________

FRE:
C69F2:  LD      HL,(STREND)
        EX      DE,HL
        LD      HL,0
        ADD     HL,SP
        _RST    GETYPR                  ; get DAC type
        JP      NZ,GIVDBL               ; not a string,
        CALL    FREDAC                  ; free temporary string in DAC
        CALL    C66B6                   ; garbage collect
        LD      DE,(STKTOP)
        LD      HL,(FRETOP)
        JP      GIVDBL

; END	SUBTTL	BISTRS

        END

