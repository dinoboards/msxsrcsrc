; BISTRS.MAC

; BASIC STRING functions, MSX 1 version (version 1.0)

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders


        .Z80
        ASEG
        ORG     65C8H


        INCLUDE MSX.INC


VLZADR  EQU     0F419H
VLZDAT  EQU     0F41BH
VALTYP  EQU     0F663H
MEMSIZ  EQU     0F672H
STKTOP  EQU     0F674H
TXTTAB  EQU     0F676H
TEMPPT  EQU     0F678H
TEMPST  EQU     0F67AH
DSCTMP  EQU     0F698H
FRETOP  EQU     0F69BH
TEMP8   EQU     0F69FH
VARTAB  EQU     0F6C2H
ARYTAB  EQU     0F6C4H
STREND  EQU     0F6C6H
PRMPRV  EQU     0F74CH
ARYTA2  EQU     0F7B5H
TEMP9   EQU     0F7B8H
DAC     EQU     0F7F6H

H.FRET  EQU     0FF9DH


        PUBLIC  FRESTR
        PUBLIC  FREDAC
        PUBLIC  STROUI
        PUBLIC  STROUT
        PUBLIC  GETSPA
        PUBLIC  STRINI
        PUBLIC  STRIN1
        PUBLIC  SETSTR
        PUBLIC  PUTNEW
        PUBLIC  PUTTMP
        PUBLIC  STRLIT
        PUBLIC  STRLTI
        PUBLIC  STRLT2
        PUBLIC  STRLT3
        PUBLIC  ASC2
        PUBLIC  STRCPY
        PUBLIC  FRETMS
        PUBLIC  STRPRT
        PUBLIC  FRETMP
        PUBLIC  FRETM2
        PUBLIC  LEFTUS
        PUBLIC  CAT
        PUBLIC  STRCMP
        PUBLIC  PPSWRT
        PUBLIC  INSTR
        PUBLIC  STRNG$
        PUBLIC  CHR$
        PUBLIC  SPACE$
        PUBLIC  LEFT$
        PUBLIC  RIGHT$
        PUBLIC  MID$
        PUBLIC  MIDS
        PUBLIC  VAL
        PUBLIC  LEN
        PUBLIC  STR$
        PUBLIC  ASC
        PUBLIC  FRE
        PUBLIC  OCT$
        PUBLIC  HEX$
        PUBLIC  BIN$

        EXTRN   MOVRM
        EXTRN   VMOVE
        EXTRN   FIN
        EXTRN   FOUT
        EXTRN   FOUTB
        EXTRN   FOUTO
        EXTRN   FOUTH
        EXTRN   FCERR
        EXTRN   FRMEVL
        EXTRN   FRMPRN
        EXTRN   FRMEQL
        EXTRN   GETBYT
        EXTRN   CONINT
        EXTRN   CHKSTR
        EXTRN   BLTUC
        EXTRN   ERROR
        EXTRN   SNGFLT
        EXTRN   PTRGET
        EXTRN   POPHRT
        EXTRN   GIVDBL
        EXTRN   TSTOP
        EXTRN   EVAL
        EXTRN   SIGNS
        EXTRN   GETBCD
        EXTRN   CRFIN
        EXTRN   SYNCHR
        EXTRN   CHRGTR
        EXTRN   OUTDO
        EXTRN   DCOMPR
        EXTRN   GETYPR
        EXTRN   CALLF


_RST    MACRO   X
        IFIDN   <X>,<SYNCHR>
        RST     08H
        ENDIF
        IFIDN   <X>,<CHRGTR>
        RST     10H
        ENDIF
        IFIDN   <X>,<OUTDO>
        RST     18H
        ENDIF
        IFIDN   <X>,<DCOMPR>
        RST     20H
        ENDIF
        IFIDN   <X>,<GETYPR>
        RST     28H
        ENDIF
        IFIDN   <X>,<CALLF>
        RST     30H
        ENDIF
        ENDM

_MSXCP	MACRO	X,Y
	X EQU $
	IF2
	IF	($ NE Y)
	.PRINTX	"ERROR: MSX incompatible, subroutine &X not aligned to &Y"
	ENDIF
	ENDIF
	ENDM


; START	SUBTTL	BISTRS

	SUBTTL	BISTRS

STRCMP:
C65C8:  CALL    FRESTR                  ; check for string and free temporary string descriptor and string (string1)
        LD      A,(HL)                  ; size of string1
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; pointer to string1
        POP     DE			; restore pointer to temporary string descriptor (string2)
        PUSH    BC			; store pointer to string1
        PUSH    AF			; store size of string1
        CALL    FRETMP                  ; free temporary string (descriptor in DE) (string2)
        POP     AF			; restore size of string1
        LD      D,A			; store size of string1
        LD      E,(HL)                  ; size of string2
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; pointer to string2
        POP     HL
J65DE:  LD      A,E
        OR      D                       ; end of both strings ?
        RET     Z                       ; yep, quit (A=0, equal)
        LD      A,D
        SUB     1                       ; end of string1 ?
        RET     C                       ; yep, quit (A=FF, less)
        XOR     A
        CP      E                       ; end of string2 ?
        INC     A
        RET     NC                      ; yep, quit (A=1, bigger)
        DEC     D
        DEC     E                       ; adjust counter
        LD      A,(BC)			; character string2
        INC     BC
        CP      (HL)                    ; equal to character string1 ?
        INC     HL
        JR      Z,J65DE                 ; yep, next
        CCF				; flip Cx
        JP      SIGNS                   ; set compare value

;       Subroutine      OCT$ function
;       Inputs          ________________________
;       Outputs         ________________________

OCT$:
C65F5:  CALL    FOUTO                   ; convert integer to octal text
        JR      J6607

;       Subroutine      HEX$ function
;       Inputs          ________________________
;       Outputs         ________________________

HEX$:
C65FA:  CALL    FOUTH                   ; convert integer to hexadecimal text
        JR      J6607

;       Subroutine      BIN$ function
;       Inputs          ________________________
;       Outputs         ________________________

BIN$:
C65FF:  CALL    FOUTB                   ; convert integer to binary text
        JR      J6607

;       Subroutine      STR$ function
;       Inputs          ________________________
;       Outputs         ________________________

STR$:
C6604:  CALL    FOUT                    ; convert DAC to text, unformatted
J6607:  CALL    STRLIT                  ; get string literal and create temporary string descriptor
        CALL    FREDAC                  ; free temporary string descriptor and string (DAC)
        LD      BC,J6825
        PUSH    BC                      ; copy string to new temporary string, temporary stringdescriptor to heap and quit

;       Subroutine      copy string to new temporary string
;       Inputs          HL = source string descriptor
;       Outputs         ________________________

STRCPY:
C6611:  LD      A,(HL)                  ; size of string
        INC     HL
        PUSH    HL			; store pointer in string descriptor
        CALL    GETSPA                  ; allocate string space
        POP     HL			; restore pointer in string descriptor
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; pointer to string
        CALL    STRAD2                  ; create temporary string descriptor
        PUSH    HL			; store pointer to temporary string descriptor
        LD      L,A                     ; size of string
        CALL    C67C7                   ; copy string
        POP     DE			; restore pointer to temporary string descriptor
        RET

;       Subroutine      allocate temporary string of 1 char
;       Inputs          ________________________
;       Outputs         DE = pointer to string, HL = pointer to temporary string descriptor

STRIN1:
C6625:  LD      A,1

;       Subroutine      allocate temporary string
;       Inputs          A = size of string
;       Outputs         DE = pointer to string, HL = pointer to temporary string descriptor

	_MSXCP	STRINI,6627H

C6627:  CALL    GETSPA                  ; allocate string space

;       Subroutine      create temporary string descriptor
;       Inputs          A = size of string, DE = pointer to string
;       Outputs         HL = pointer to temporary string descriptor

STRAD2:
C662A:  LD      HL,DSCTMP
        PUSH    HL
        LD      (HL),A
        INC     HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        POP     HL
        RET

;       Subroutine      get string literal and create temporary string descriptor
;       Inputs          HL = pointer to string literal-1
;       Outputs         ________________________


STRLIT:
C6635:  DEC     HL

;       Subroutine      get string literal and create temporary string descriptor
;       Inputs          HL = pointer to string literal
;       Outputs         ________________________

STRLTI:
C6636:  LD      B,'"'

;       Subroutine      get string literal (with specified endmarker) and create temporary string descriptor
;       Inputs          ________________________
;       Outputs         ________________________

STRLT3:
C6638:  LD      D,B

;       Subroutine      get string literal (with specified endmarkers) and create temporary string descriptor
;       Inputs          HL = pointer to string to be analysed, B = end character 1, D = end character 2
;       Outputs         ________________________

STRLT2:
C6639:  PUSH    HL			; store pointer to string
        LD      C,-1			; size = -1
J663C:  INC     HL
        LD      A,(HL)
        INC     C
        OR      A                       ; end of BASIC line/string ?
        JR      Z,J6648                 ; yep,
        CP      D                       ; end character 1 ?
        JR      Z,J6648                 ; yep,
        CP      B                       ; end character 2 ?
        JR      NZ,J663C                ; nope, skip
J6648:  CP      '"'                     ; string marker ?
        CALL    Z,CHRGTR                ; yep, get next BASIC character
        EX      (SP),HL			; store pointer in string (restored later), restore pointer to string
        INC     HL
        EX      DE,HL
        LD      A,C			; size of string
        CALL    STRAD2                  ; create temporary string descriptor

;       Subroutine      push temporary sring descriptor to temporary string descriptor heap
;       Inputs          ________________________
;       Outputs         ________________________

PUTNEW:
J6654:  LD      DE,DSCTMP		; string descriptor = temporary string descriptor
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction

;       Subroutine      push string descriptor to temporary string descriptor heap
;       Inputs          DE = pointer to string descriptor
;       Outputs         ________________________

PUTTMP:
C6658:  PUSH    DE			; store pointer to string descriptor
        LD      HL,(TEMPPT)
        LD      (DAC+2),HL
        LD      A,3
        LD      (VALTYP),A		; DAC = new string descriptor
        CALL    VMOVE                   ; HL = DE (valtyp), copy temporary string descriptor to temporary string descriptor heap
        LD      DE,TEMPST+30+3
        _RST    DCOMPR                  ; temporary descriptor heap full ?
        LD      (TEMPPT),HL
        POP     HL			; restore pointer to string descriptor
        LD      A,(HL)			; size of string
        RET     NZ
STERR:
        IF      OPTM EQ 0
        LD      DE,16                   ; ?? LD E,16 should be enough ??
        ELSE
        LD      E,16
        ENDIF

        JP      ERROR                   ; yep, string formula too complex error

;       Subroutine      skip first character, message to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

STROUI:
C6677:  INC     HL

;       Subroutine      message to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

STROUT:
C6678:  CALL    STRLIT                  ; get string literal and create temporary string descriptor

;       Subroutine      free string and string to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

STRPRT:
C667B:  CALL    FREDAC                  ; free temporary string descriptor and string (DAC)
        CALL    GETBCD                  ; get size and pointer to string
        INC     D			; size+1
J6682:  DEC     D
        RET     Z
        LD      A,(BC)
        _RST    OUTDO                   ; char to interpreter output
        CP      0DH                     ; CR ?
        CALL    Z,CRFIN                 ; yep, interpreter output pos = 0
        INC     BC
        JR      J6682

;       Subroutine      allocate string space
;       Inputs          A = size of string
;       Outputs         DE = pointer to string space

	_MSXCP	GETSPA,668EH

C668E:  OR      A                       ; because size<>0, Zx is reset (no garbage collect done)
        DEFB    00EH                    ; LD C,xx, trick to skip next instruction

C6690:  POP     AF			; restore garbage collect flag
        PUSH    AF			; store garbage collect flag
        LD      HL,(STKTOP)		; end of string heap (= top of BASIC stack)
        EX      DE,HL
        LD      HL,(FRETOP)		; string heap pointer

	IF	OPTM EQ 0
        CPL
        LD      C,A
        LD      B,0FFH			; -(size-1)
        ADD     HL,BC
        INC     HL                      ; new string heap pointer

	ELSE

	LD	C,A
	LD	B,0
	SBC	HL,BC                   ; new string heap pointer

	ENDIF

        _RST    DCOMPR                  ; compare end of string heap with new string heap pointer
        JR      C,J66A9                 ; out of string heap space, try garbage collect
        LD      (FRETOP),HL             ; update string heap pointer
        INC     HL
        EX      DE,HL
PPSWRT: POP     AF			; discard garbage collect flag
        RET

J66A9:  POP     AF			; restore garbage collect flag
        IF      OPTM EQ 0
        LD      DE,14                   ; ?? LD E,14 should be enough ??
	ELSE
	LD	E,14
	ENDIF
        JP      Z,ERROR                 ; garbage collect done, out of string space error
        CP      A                       ; Zx set (garbage collect done)
        PUSH    AF			; store garbage collect flag
        LD      BC,C6690
        PUSH    BC                      ; do a garbage collect and try allocate again

;       Subroutine      garbage collect
;       Inputs          ________________________
;       Outputs         ________________________

C66B6:  LD      HL,(MEMSIZ)             ; start of string heap (use as string heap pointer starting point)
J66B9:  LD      (FRETOP),HL		; update string heap pointer
        LD      HL,0
        PUSH    HL                      ; pointer to string descriptor (+3) of top unheaped string = none found
        LD      HL,(STREND)		; end of variable area
        PUSH    HL                      ; pointer to top unheaped string = end of variable area (undefined)
        LD      HL,TEMPST               ; temporary string descriptor pointer = start of temporary string descriptor heap

; loop through temporary string descriptors

C66C7:  LD      DE,(TEMPPT)		; end of temporary string descriptor heap
        _RST    DCOMPR                  ; compare temporary string descriptor pointer with end of temporary string descriptor heap
        LD      BC,C66C7		; continue with next temporary descriptor
        JP      NZ,J6742                ; not end of temporary string descriptor heap, update top of unheaped string if higher

        LD      HL,PRMPRV
        LD      (TEMP9),HL
        LD      HL,(ARYTAB)		; start of array variable area
        LD      (ARYTA2),HL             ; end of variable area = end of simple variable area
        LD      HL,(VARTAB)             ; variable pointer = start of simple variable area

; loop through variables

J66E1:  LD      DE,(ARYTA2)		; end of variable area
        _RST    DCOMPR                  ; compare variable pointer with end of variable area
        JR      Z,J66FA                 ; end of variable area,
        LD      A,(HL)                  ; variable type
        INC     HL
        INC     HL
        INC     HL                      ; skip variable name, to variable value
        CP      3                       ; string ?
        JR      NZ,J66F4                ; nope, offset = variable type, to next variable
        CALL    C6743                   ; update top of unheaped string if higher
        XOR     A			; offset = 0 (pointer already updated)
J66F4:  LD      E,A
        LD      D,0			; offset
        ADD     HL,DE			; update pointer to next variable
        JR      J66E1                   ; next variable

J66FA:  LD      HL,(TEMP9)              ; current FN parameter block
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      A,D
        OR      E                       ; end of FN parameter block list ?
        LD      HL,(ARYTAB)		; start of array variable area
        JR      Z,J671A                 ; yep, continue with the array variables
        EX      DE,HL
        LD      (TEMP9),HL              ; update current FN parameter block
        INC     HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        INC     HL
        EX      DE,HL
        ADD     HL,DE
        LD      (ARYTA2),HL		; update end of variable area
        EX      DE,HL
        JR      J66E1                   ; search FN parameter block variables

J6719:  POP     BC			; discard pointer in array variable

; loop through array variables

J671A:  LD      DE,(STREND)		; end of variable area
        _RST    DCOMPR                  ; end of array variables ?
        JP      Z,J6763                 ; yep, move topstring up when possible
        LD      A,(HL)                  ; variable type
        INC     HL
        CALL    MOVRM                   ; load from HL (array offset and variable name)
        PUSH    HL			; store pointer in array variable
        ADD     HL,BC                   ; pointer to next array variable
        CP      3                       ; string ?
        JR      NZ,J6719                ; nope, next array variable
        LD      (TEMP8),HL              ; store pointer to next array variable
        POP     HL			; restore pointer in array variable
        LD      C,(HL)
        LD      B,0			; array dimension
        ADD     HL,BC
        ADD     HL,BC
        INC     HL                      ; to the first array element
C6737:  EX      DE,HL
        LD      HL,(TEMP8)		; pointer to next array variable
        EX      DE,HL
        _RST    DCOMPR                  ; compare pointer to next array variable with pointer to next variable
        JR      Z,J671A                 ; end of array variable, next array variable
        LD      BC,C6737		; continue with next array element

J6742:  PUSH    BC

;       Subroutine      update top of unheaped string if higher
;       Inputs          HL = pointer to string descriptor
;       Outputs         ________________________

C6743:  XOR     A
        OR      (HL)                    ; empty string ?
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; pointer to string
        INC     HL
        RET     Z                       ; empty string, quit
        LD      B,H
        LD      C,L			; store pointer to next variable
        LD      HL,(FRETOP)		; string heap pointer
        _RST    DCOMPR                  ; compare string heap pointer with pointer to string
        LD      H,B
        LD      L,C			; restore pointer to next variable
        RET     C                       ; string is in string heap, quit
        POP     HL			; return address
        EX      (SP),HL			; store return address, restore pointer to top unheaped string
        _RST    DCOMPR                  ; compare end of variable area with pointer to string
        EX      (SP),HL			; store pointer to top unheaped string, restore return address
        PUSH    HL			; store return address
        LD      H,B
        LD      L,C			; restore pointer to next variable
        RET     NC                      ; string is literal (in BASIC program), quit
        POP     BC                      ; restore return address
        POP     AF			; discard pointer to top unheaped string
        POP     AF                      ; discard pointer to string descriptor (+3) of top unheaped string
        PUSH    HL                      ; store new pointer to string descriptor (+3) of top unheaped string
        PUSH    DE                      ; store new pointer to top unheaped string
        PUSH    BC			; store return addres
        RET

J6763:  POP     DE			; restore
        POP     HL			; restore pointer to next string descriptor
        LD      A,H
        OR      L                       ; topstring found ?
        RET     Z                       ; nope, quit with garabage collect
        DEC     HL
        LD      B,(HL)
        DEC     HL
        LD      C,(HL)                  ; pointer to string
        PUSH    HL			; store pointer to string descriptor +1
        DEC     HL
        LD      L,(HL)                  ; size of string
        LD      H,0
        ADD     HL,BC
        LD      D,B
        LD      E,C                     ; start of string
        DEC     HL
        LD      B,H
        LD      C,L                     ; end of string
        LD      HL,(FRETOP)             ; string heap pointer
        CALL    BLTUC                   ; move data (copy string to bottom of the string heap)
        POP     HL			; restore pointer to string descriptor +1
        LD      (HL),C
        INC     HL
        LD      (HL),B                  ; update pointer to string
        LD      H,B
        LD      L,C
        DEC     HL
        JP      J66B9                   ; update string heap pointer and restart garbage collect

CAT:
J6787:  PUSH    BC
        PUSH    HL
        LD      HL,(DAC+2)
        EX      (SP),HL
        CALL    EVAL                    ; evaluate factor
        EX      (SP),HL
        CALL    CHKSTR                  ; check if DAC has string
        LD      A,(HL)                  ; size of 1st string
        PUSH    HL
        LD      HL,(DAC+2)
        PUSH    HL
        ADD     A,(HL)                  ; + size of 2nd string
        IF      OPTM EQ 0
        LD      DE,15                   ; ?? LD E,15 should be enough ??
	ELSE
	LD	E,15
	ENDIF
        JP      C,ERROR                 ; resulting length >255, string too long error
        CALL    STRINI                  ; allocate temporary string for result
        POP     DE
        CALL    FRETMP                  ; free temporary string (descriptor in DE) -> free 2nd string
        EX      (SP),HL
        CALL    FRETM2                  ; free temporary string (descriptor in HL) -> free 1st string
        PUSH    HL
        LD      HL,(DSCTMP+1)
        EX      DE,HL
        CALL    C67BF                   ; copy string (descriptor on stack) -> copy 1st string
        CALL    C67BF                   ; copy string (descriptor on stack) -> copy 2nd string
        LD      HL,TSTOP
        EX      (SP),HL
        PUSH    HL
        JP      PUTNEW                  ; push temporary descriptor to temporary descriptor heap and quit

;       Subroutine      copy string (descriptor on stack)
;       Inputs          string descriptor on stack, DE = destination string
;       Outputs         ________________________
;       Remark          works only if this routine is CALLed

C67BF:  POP     HL
        EX      (SP),HL                 ; get descriptor from stack
        LD      A,(HL)
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        LD      L,A

;       Subroutine      copy string
;       Inputs          L = size of string, BC = source string, DE = destination string
;       Outputs         ________________________

C67C7:  INC     L
J67C8:  DEC     L
        RET     Z
        LD      A,(BC)
        LD      (DE),A
        INC     BC
        INC     DE
        JR      J67C8

;       Subroutine      FRESTR (check for string and free temporary string descriptor and string)
;       Inputs          ________________________
;       Outputs         ________________________

	_MSXCP	FRESTR,67D0H

C67D0:  CALL    CHKSTR                  ; check if string

;       Subroutine      free temporary string descriptor and string (DAC)
;       Inputs          DAC = pointer to temporary string descriptor
;       Outputs         ________________________

FREDAC:
C67D3:  LD      HL,(DAC+2)              ; pointer to temporary string descriptor

;       Subroutine      free temporary string descriptor and string
;       Inputs          HL = string descriptor
;       Outputs         ________________________

FRETM2:
C67D6:  EX      DE,HL

;       Subroutine      free temporary string descriptor and string
;       Inputs          DE = pointer to temporary string descriptor
;       Outputs         HL = pointer to temporary string descriptor

FRETMP:
C67D7:  CALL    FRETMS                  ; free temporary string descriptor if on top of the heap
        EX      DE,HL
        RET     NZ                      ; not freed, quit
        PUSH    DE			; store pointer to freed temporary string descriptor
        LD      D,B
        LD      E,C			; pointer to string
        DEC     DE
        LD      C,(HL)                  ; size of string
        LD      HL,(FRETOP)		; string heap pointer
        _RST    DCOMPR                  ; on top of string heap ?
        JR      NZ,J67EC                ; nope, quit
        LD      B,A			; 0
        ADD     HL,BC
        LD      (FRETOP),HL             ; update string heap pointer
J67EC:  POP     HL			; restore pointer to freed temporary string desciptor
        RET

;       Subroutine      free temporary string descriptor if on top of the heap
;       Inputs          DE = pointer to string descriptor
;       Outputs         BC = pointer to string, Zx set if freed

FRETMS:
C67EE:  CALL    H.FRET
        LD      HL,(TEMPPT)
        DEC     HL
        LD      B,(HL)
        DEC     HL
        LD      C,(HL)                  ; pointer to string
        DEC     HL
        _RST    DCOMPR                  ; descriptor on top of the heap ?
        RET     NZ                      ; nope, quit
        LD      (TEMPPT),HL             ; release descriptor from heap
        RET

;       Subroutine      LEN function
;       Inputs          ________________________
;       Outputs         ________________________

LEN:
C67FF:  LD      BC,SNGFLT
        PUSH    BC                      ; after this, byte to DAC

;       Subroutine      free temporary string and get size
;       Inputs          ________________________
;       Outputs         ________________________

C6803:  CALL    FRESTR                  ; check for string and free temporary string descriptor and string
        XOR     A
        LD      D,A
        LD      A,(HL)                  ; size of string
        OR      A                       ; Zx set if empty string
        RET

;       Subroutine      ASC function
;       Inputs          ________________________
;       Outputs         ________________________

ASC:
C680B:  LD      BC,SNGFLT               ; after this, byte to DAC
        PUSH    BC

;       Subroutine      free temporary string and get first character
;       Inputs          ________________________
;       Outputs         ________________________

ASC2:
C680F:  CALL    C6803                   ; free temporary string and get size
        JP      Z,FCERR                 ; empty string, illegal function call
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; pointer to string
        LD      A,(DE)                  ; first character
        RET

;       Subroutine      CHR$ function
;       Inputs          ________________________
;       Outputs         ________________________

CHR$:
C681B:  CALL    STRIN1                  ; allocate temporary string of 1 char
        CALL    CONINT                  ; check for byte value

;       Subroutine      set first character of temporary string and put on heap
;       Inputs          ________________________
;       Outputs         ________________________

SETSTR:
C6821:  LD      HL,(DSCTMP+1)
        LD      (HL),E
FINBCK:
J6825:  POP     BC
        JP      PUTNEW                  ; push temporary descriptor to temporary descriptor heap and quit

;       Subroutine      STRING$ function
;       Inputs          ________________________
;       Outputs         ________________________

STRNG$:
J6829:  _RST    CHRGTR                  ; get next BASIC character
        _RST    SYNCHR
        DEFB    "("                     ; check for (
        CALL    GETBYT                  ; evaluate byte operand
        PUSH    DE
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    FRMEVL                  ; evaluate expression
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        EX      (SP),HL
        PUSH    HL
        _RST    GETYPR                  ; get DAC type
        JR      Z,J6841                 ; string,
        CALL    CONINT                  ; check for byte value
        JR      J6844

J6841:  CALL    ASC2                    ; free temporary string and get first character
J6844:  POP     DE                      ; number of characters
        CALL    C684D                   ; create string with characters and quit

;       Subroutine      SPACE$ function
;       Inputs          ________________________
;       Outputs         ________________________

SPACE$:
C6848:  CALL    CONINT                  ; check for byte value
        LD      A," "

;       Subroutine      create string with characters
;       Inputs          ________________________
;       Outputs         ________________________

C684D:  PUSH    AF
        LD      A,E                     ; number of characters
        CALL    STRINI                  ; allocate temporary string
        LD      B,A
        POP     AF
        INC     B
        DEC     B                       ; stringsize zero ?
        JR      Z,J6825                 ; yep, temporary stringdescriptor to heap and quit
        LD      HL,(DSCTMP+1)           ; pointer to temporary string
J685B:  LD      (HL),A
        INC     HL
        DJNZ    J685B                   ; fill string
        JR      J6825                   ; temporary stringdescriptor to heap and quit

;       Subroutine      LEFT$ function
;       Inputs          ________________________
;       Outputs         ________________________

LEFT$:
C6861:  CALL    C68E3
        XOR     A
J6865:  EX      (SP),HL
        LD      C,A
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction
LEFTUS:
C6868:  PUSH    HL
C6869:  PUSH    HL
        LD      A,(HL)			; size of string
        CP      B
        JR      C,J6870
        LD      A,B			; size of string
        DEFB    011H                    ; LD DE,xxxx, trick to skip next instruction
J6870:  LD      C,0
        PUSH    BC
        CALL    GETSPA                  ; allocate stringspace
        POP     BC
        POP     HL
        PUSH    HL
        INC     HL
        LD      B,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,B
        LD      B,0
        ADD     HL,BC
        LD      B,H
        LD      C,L
        CALL    STRAD2                  ; create temporary string descriptor
        LD      L,A
        CALL    C67C7                   ; copy string
        POP     DE
        CALL    FRETMP                  ; free temporary string (descriptor in DE)
        JP      PUTNEW                  ; push temporary descriptor to temporary descriptor heap and quit

;       Subroutine      RIGHT$ function
;       Inputs          ________________________
;       Outputs         ________________________

RIGHT$:
C6891:  CALL    C68E3
        POP     DE
        PUSH    DE
        LD      A,(DE)
        SUB     B
        JR      J6865

;       Subroutine      MID$ function
;       Inputs          ________________________
;       Outputs         ________________________

MID$:
C689A:  EX      DE,HL
        LD      A,(HL)
        CALL    C68E6
        INC     B
        DEC     B
        JP      Z,FCERR                 ; illegal function call
        PUSH    BC
        CALL    C69E4
        POP     AF
        EX      (SP),HL
        LD      BC,C6869
        PUSH    BC
        DEC     A
        CP      (HL)
        LD      B,00H
        RET     NC
        LD      C,A
        LD      A,(HL)
        SUB     C
        CP      E
        LD      B,A
        RET     C
        LD      B,E
        RET

;       Subroutine      VAL function
;       Inputs          ________________________
;       Outputs         ________________________

VAL:
C68BB:  CALL    C6803                   ; free temporary string and get size
        JP      Z,SNGFLT                ; empty string, byte (size) to DAC
        LD      E,A
        INC     HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A
        PUSH    HL
        ADD     HL,DE
        LD      B,(HL)
        LD      (VLZADR),HL
        LD      A,B
        LD      (VLZDAT),A
        LD      (HL),D
        EX      (SP),HL
        PUSH    BC
        DEC     HL
        _RST    CHRGTR                  ; get next BASIC character
        CALL    FIN                     ; convert text to number
        LD      HL,0
        LD      (VLZADR),HL
        POP     BC
        POP     HL
        LD      (HL),B
        RET

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C68E3:  EX      DE,HL
        _RST    SYNCHR
        DEFB    ")"                     ; check for )

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C68E6:  POP     BC
        POP     DE
        PUSH    BC
        LD      B,E
        RET

;       Subroutine      INSTR function
;       Inputs          ________________________
;       Outputs         ________________________

INSTR:
J68EB:  _RST    CHRGTR                  ; get next BASIC character
        CALL    FRMPRN                  ; evaluate ( expression
        _RST    GETYPR                  ; get DAC type
        LD      A,1
        PUSH    AF
        JR      Z,J6906                 ; string,
        POP     AF
        CALL    CONINT                  ; check for byte value
        OR      A
        JP      Z,FCERR                 ; illegal function call
        PUSH    AF
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    FRMEVL                  ; evaluate expression
        CALL    CHKSTR                  ; check if string
J6906:  _RST    SYNCHR
        DEFB    ","                     ; check for ,
        PUSH    HL
        LD      HL,(DAC+2)
        EX      (SP),HL
        CALL    FRMEVL                  ; evaluate expression
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        PUSH    HL
        CALL    FRESTR                  ; check for string and free temporary string descriptor and string
        EX      DE,HL
        POP     BC
        POP     HL
        POP     AF
        PUSH    BC
        LD      BC,POPHRT
        PUSH    BC
        LD      BC,SNGFLT
        PUSH    BC                      ; after this, byte to DAC
        PUSH    AF
        PUSH    DE
        CALL    FRETM2                  ; free temporary string (descriptor in HL)
        POP     DE
        POP     AF
        LD      B,A
        DEC     A
        LD      C,A
        CP      (HL)
        LD      A,0
        RET     NC
        LD      A,(DE)
        OR      A
        LD      A,B
        RET     Z
        LD      A,(HL)
        INC     HL
        LD      B,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,B
        LD      B,0
        ADD     HL,BC
J693E:  SUB     C
        LD      B,A
        PUSH    BC
        PUSH    DE
        EX      (SP),HL
        LD      C,(HL)
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        POP     HL
J6949:  PUSH    HL
        PUSH    DE
        PUSH    BC
J694C:  LD      A,(DE)
        CP      (HL)
        JR      NZ,J6966
        INC     DE
        DEC     C
        JR      Z,J695D
        INC     HL
        DJNZ    J694C
        POP     DE
        POP     DE
        POP     BC
J695A:  POP     DE
        XOR     A
        RET

J695D:  POP     HL
        POP     DE
        POP     DE
        POP     BC
        LD      A,B
        SUB     H
        ADD     A,C
        INC     A
        RET

J6966:  POP     BC
        POP     DE
        POP     HL
        INC     HL
        DJNZ    J6949
        JR      J695A

;       Subroutine      MID$ statement
;       Inputs          ________________________
;       Outputs         ________________________

MIDS:
J696E:  _RST    SYNCHR
        DEFB    "("                     ; check for (
        CALL    PTRGET                  ; locate variable
        CALL    CHKSTR                  ; check if string
        PUSH    HL
        PUSH    DE
        EX      DE,HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      HL,(STREND)		; end of variable area
        _RST    DCOMPR
        JR      C,J6993
        LD      HL,(TXTTAB)
        _RST    DCOMPR
        JR      NC,J6993
        POP     HL
        PUSH    HL
        CALL    STRCPY                  ; copy string to new temporary string
        POP     HL
        PUSH    HL
        CALL    VMOVE                   ; HL = DE (valtyp)
J6993:  POP     HL
        EX      (SP),HL
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    GETBYT                  ; evaluate byte operand
        OR      A                       ; startpos 0 ?
        JP      Z,FCERR                 ; yep, illegal function call
        PUSH    AF
        LD      A,(HL)
        CALL    C69E4
        PUSH    DE
        CALL    FRMEQL                  ; evaluate = expression
        PUSH    HL
        CALL    FRESTR                  ; check for string and free temporary string descriptor and string
        EX      DE,HL
        POP     HL
        POP     BC
        POP     AF
        LD      B,A
        EX      (SP),HL
        PUSH    HL
        LD      HL,POPHRT
        EX      (SP),HL
        LD      A,C
        OR      A
        RET     Z
        LD      A,(HL)
        SUB     B
        JP      C,FCERR                 ; illegal function call
        INC     A
        CP      C
        JR      C,J69C3
        LD      A,C
J69C3:  LD      C,B
        DEC     C
        LD      B,00H
        PUSH    DE
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,E
        ADD     HL,BC
        LD      B,A
        POP     DE
        EX      DE,HL
        LD      C,(HL)
        INC     HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A
        EX      DE,HL
        LD      A,C
        OR      A
        RET     Z
J69DB:  LD      A,(DE)
        LD      (HL),A
        INC     DE
        INC     HL
        DEC     C
        RET     Z
        DJNZ    J69DB
        RET

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C69E4:  LD      E,0FFH
        CP      ")"
        JR      Z,J69EF
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    GETBYT                  ; evaluate byte operand
J69EF:  _RST    SYNCHR
        DEFB    ")"                     ; check for )
        RET

;       Subroutine      FRE function
;       Inputs          ________________________
;       Outputs         ________________________

FRE:
C69F2:  LD      HL,(STREND)
        EX      DE,HL			; end of variable area
        LD      HL,0
        ADD     HL,SP			; Z80 stack pointer
        _RST    GETYPR                  ; get DAC type
        JP      NZ,GIVDBL               ; not a string, subtract and convert to double float (number of bytes of free BASIC memory)
        CALL    FREDAC                  ; free temporary string descriptor and string (DAC)
        CALL    C66B6                   ; garbage collect
        LD      DE,(STKTOP)		; end of string heap (= top of BASIC stack)
        LD      HL,(FRETOP)		; string heap pointer
        JP      GIVDBL			; subtract and convert to double float (number of bytes of free string heap space)

; END	SUBTTL	BISTRS

        END

